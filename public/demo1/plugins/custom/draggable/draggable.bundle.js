/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@shopify/draggable/lib/draggable.bundle.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@shopify/draggable/lib/draggable.bundle.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(true)\r\n\t\tmodule.exports = factory();\r\n\telse {}\r\n})(window, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __nested_webpack_require_571__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId]) {\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_571__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__nested_webpack_require_571__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__nested_webpack_require_571__.c = installedModules;\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__nested_webpack_require_571__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__nested_webpack_require_571__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// define __esModule on exports\r\n/******/ \t__nested_webpack_require_571__.r = function(exports) {\r\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\r\n/******/ \t\t}\r\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\r\n/******/ \t};\r\n/******/\r\n/******/ \t// create a fake namespace object\r\n/******/ \t// mode & 1: value is a module id, require it\r\n/******/ \t// mode & 2: merge all properties of value into the ns\r\n/******/ \t// mode & 4: return value when already ns object\r\n/******/ \t// mode & 8|1: behave like require\r\n/******/ \t__nested_webpack_require_571__.t = function(value, mode) {\r\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_571__(value);\r\n/******/ \t\tif(mode & 8) return value;\r\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\r\n/******/ \t\tvar ns = Object.create(null);\r\n/******/ \t\t__nested_webpack_require_571__.r(ns);\r\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\r\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_571__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\r\n/******/ \t\treturn ns;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__nested_webpack_require_571__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__nested_webpack_require_571__.d(getter, 'a', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__nested_webpack_require_571__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__nested_webpack_require_571__.p = \"\";\r\n/******/\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __nested_webpack_require_571__(__nested_webpack_require_571__.s = 72);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __nested_webpack_require_4119__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_4119__(66);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractPlugin2.default;\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports, __nested_webpack_require_4550__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractEvent = __nested_webpack_require_4550__(70);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractEvent2.default;\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports, __nested_webpack_require_4977__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_4977__(57);\r\n\r\nObject.defineProperty(exports, 'closest', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_closest).default;\r\n  }\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_4977__(55);\r\n\r\nObject.defineProperty(exports, 'requestNextAnimationFrame', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_requestNextAnimationFrame).default;\r\n  }\r\n});\r\n\r\nvar _distance = __nested_webpack_require_4977__(53);\r\n\r\nObject.defineProperty(exports, 'distance', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_distance).default;\r\n  }\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_4977__(51);\r\n\r\nObject.defineProperty(exports, 'touchCoords', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_touchCoords).default;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports, __nested_webpack_require_6101__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SensorEvent = __nested_webpack_require_6101__(46);\r\n\r\nObject.keys(_SensorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SensorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports, __nested_webpack_require_6568__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_6568__(49);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Sensor2.default;\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports, __nested_webpack_require_6967__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragEvent = __nested_webpack_require_6967__(14);\r\n\r\nObject.keys(_DragEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DragEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _DraggableEvent = __nested_webpack_require_6967__(13);\r\n\r\nObject.keys(_DraggableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DraggableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Plugins = __nested_webpack_require_6967__(12);\r\n\r\nObject.keys(_Plugins).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _Plugins[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Sensors = __nested_webpack_require_6967__(6);\r\n\r\nObject.keys(_Sensors).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _Sensors[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Draggable = __nested_webpack_require_6967__(39);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Draggable2.default;\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports, __nested_webpack_require_8552__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_8552__(4);\r\n\r\nObject.defineProperty(exports, 'Sensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Sensor).default;\r\n  }\r\n});\r\n\r\nvar _MouseSensor = __nested_webpack_require_8552__(48);\r\n\r\nObject.defineProperty(exports, 'MouseSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_MouseSensor).default;\r\n  }\r\n});\r\n\r\nvar _TouchSensor = __nested_webpack_require_8552__(45);\r\n\r\nObject.defineProperty(exports, 'TouchSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_TouchSensor).default;\r\n  }\r\n});\r\n\r\nvar _DragSensor = __nested_webpack_require_8552__(43);\r\n\r\nObject.defineProperty(exports, 'DragSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_DragSensor).default;\r\n  }\r\n});\r\n\r\nvar _ForceTouchSensor = __nested_webpack_require_8552__(41);\r\n\r\nObject.defineProperty(exports, 'ForceTouchSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_ForceTouchSensor).default;\r\n  }\r\n});\r\n\r\nvar _SensorEvent = __nested_webpack_require_8552__(3);\r\n\r\nObject.keys(_SensorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SensorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports, __nested_webpack_require_10158__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SnappableEvent = __nested_webpack_require_10158__(20);\r\n\r\nObject.keys(_SnappableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SnappableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ (function(module, exports, __nested_webpack_require_10634__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _CollidableEvent = __nested_webpack_require_10634__(25);\r\n\r\nObject.keys(_CollidableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _CollidableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ (function(module, exports, __nested_webpack_require_11113__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SortableEvent = __nested_webpack_require_11113__(29);\r\n\r\nObject.keys(_SortableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SortableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ (function(module, exports, __nested_webpack_require_11587__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SwappableEvent = __nested_webpack_require_11587__(32);\r\n\r\nObject.keys(_SwappableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SwappableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ (function(module, exports, __nested_webpack_require_12064__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DroppableEvent = __nested_webpack_require_12064__(35);\r\n\r\nObject.keys(_DroppableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DroppableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ (function(module, exports, __nested_webpack_require_12541__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Announcement = __nested_webpack_require_12541__(68);\r\n\r\nObject.defineProperty(exports, 'Announcement', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Announcement).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultAnnouncementOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Announcement.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Focusable = __nested_webpack_require_12541__(65);\r\n\r\nObject.defineProperty(exports, 'Focusable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Focusable).default;\r\n  }\r\n});\r\n\r\nvar _Mirror = __nested_webpack_require_12541__(63);\r\n\r\nObject.defineProperty(exports, 'Mirror', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Mirror).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultMirrorOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Mirror.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Scrollable = __nested_webpack_require_12541__(59);\r\n\r\nObject.defineProperty(exports, 'Scrollable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Scrollable).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultScrollableOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Scrollable.defaultOptions;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 13 */\r\n/***/ (function(module, exports, __nested_webpack_require_14085__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DraggableEvent = __nested_webpack_require_14085__(69);\r\n\r\nObject.keys(_DraggableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DraggableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 14 */\r\n/***/ (function(module, exports, __nested_webpack_require_14562__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragEvent = __nested_webpack_require_14562__(71);\r\n\r\nObject.keys(_DragEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DragEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 15 */\r\n/***/ (function(module, exports, __nested_webpack_require_15024__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_15024__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onSortableSorted = Symbol('onSortableSorted');\r\nconst onSortableSort = Symbol('onSortableSort');\r\n\r\n/**\r\n * SortAnimation default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.duration\r\n * @property {String} defaultOptions.easingFunction\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  duration: 150,\r\n  easingFunction: 'ease-in-out'\r\n};\r\n\r\n/**\r\n * SortAnimation plugin adds sort animation for sortable\r\n * @class SortAnimation\r\n * @module SortAnimation\r\n * @extends AbstractPlugin\r\n */\r\nclass SortAnimation extends _AbstractPlugin2.default {\r\n  /**\r\n   * SortAnimation constructor.\r\n   * @constructs SortAnimation\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * SortAnimation options\r\n     * @property {Object} options\r\n     * @property {Number} defaultOptions.duration\r\n     * @property {String} defaultOptions.easingFunction\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Last animation frame\r\n     * @property {Number} lastAnimationFrame\r\n     * @type {Number}\r\n     */\r\n    this.lastAnimationFrame = null;\r\n    this.lastElements = [];\r\n\r\n    this[onSortableSorted] = this[onSortableSorted].bind(this);\r\n    this[onSortableSort] = this[onSortableSort].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('sortable:sort', this[onSortableSort]);\r\n    this.draggable.on('sortable:sorted', this[onSortableSorted]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('sortable:sort', this[onSortableSort]);\r\n    this.draggable.off('sortable:sorted', this[onSortableSorted]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.sortAnimation || {};\r\n  }\r\n\r\n  /**\r\n   * Sortable sort handler\r\n   * @param {SortableSortEvent} sortableEvent\r\n   * @private\r\n   */\r\n  [onSortableSort]({ dragEvent }) {\r\n    const { sourceContainer } = dragEvent;\r\n    const elements = this.draggable.getDraggableElementsForContainer(sourceContainer);\r\n    this.lastElements = Array.from(elements).map(el => {\r\n      return {\r\n        domEl: el,\r\n        offsetTop: el.offsetTop,\r\n        offsetLeft: el.offsetLeft\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sortable sorted handler\r\n   * @param {SortableSortedEvent} sortableEvent\r\n   * @private\r\n   */\r\n  [onSortableSorted]({ oldIndex, newIndex }) {\r\n    if (oldIndex === newIndex) {\r\n      return;\r\n    }\r\n\r\n    const effectedElements = [];\r\n    let start;\r\n    let end;\r\n    let num;\r\n    if (oldIndex > newIndex) {\r\n      start = newIndex;\r\n      end = oldIndex - 1;\r\n      num = 1;\r\n    } else {\r\n      start = oldIndex + 1;\r\n      end = newIndex;\r\n      num = -1;\r\n    }\r\n\r\n    for (let i = start; i <= end; i++) {\r\n      const from = this.lastElements[i];\r\n      const to = this.lastElements[i + num];\r\n      effectedElements.push({ from, to });\r\n    }\r\n    cancelAnimationFrame(this.lastAnimationFrame);\r\n\r\n    // Can be done in a separate frame\r\n    this.lastAnimationFrame = requestAnimationFrame(() => {\r\n      effectedElements.forEach(element => animate(element, this.options));\r\n    });\r\n  }\r\n}\r\n\r\nexports.default = SortAnimation; /**\r\n                                  * Animates two elements\r\n                                  * @param {Object} element\r\n                                  * @param {Object} element.from\r\n                                  * @param {Object} element.to\r\n                                  * @param {Object} options\r\n                                  * @param {Number} options.duration\r\n                                  * @param {String} options.easingFunction\r\n                                  * @private\r\n                                  */\r\n\r\nfunction animate({ from, to }, { duration, easingFunction }) {\r\n  const domEl = from.domEl;\r\n  const x = from.offsetLeft - to.offsetLeft;\r\n  const y = from.offsetTop - to.offsetTop;\r\n\r\n  domEl.style.pointerEvents = 'none';\r\n  domEl.style.transform = `translate3d(${x}px, ${y}px, 0)`;\r\n\r\n  requestAnimationFrame(() => {\r\n    domEl.addEventListener('transitionend', resetElementOnTransitionEnd);\r\n    domEl.style.transition = `transform ${duration}ms ${easingFunction}`;\r\n    domEl.style.transform = '';\r\n  });\r\n}\r\n\r\n/**\r\n * Resets animation style properties after animation has completed\r\n * @param {Event} event\r\n * @private\r\n */\r\nfunction resetElementOnTransitionEnd(event) {\r\n  event.target.style.transition = '';\r\n  event.target.style.pointerEvents = '';\r\n  event.target.removeEventListener('transitionend', resetElementOnTransitionEnd);\r\n}\r\n\r\n/***/ }),\r\n/* 16 */\r\n/***/ (function(module, exports, __nested_webpack_require_20494__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _SortAnimation = __nested_webpack_require_20494__(15);\r\n\r\nvar _SortAnimation2 = _interopRequireDefault(_SortAnimation);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _SortAnimation2.default;\r\nexports.defaultOptions = _SortAnimation.defaultOptions;\r\n\r\n/***/ }),\r\n/* 17 */\r\n/***/ (function(module, exports, __nested_webpack_require_21016__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_21016__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onSortableSorted = Symbol('onSortableSorted');\r\n\r\n/**\r\n * SwapAnimation default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.duration\r\n * @property {String} defaultOptions.easingFunction\r\n * @property {Boolean} defaultOptions.horizontal\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  duration: 150,\r\n  easingFunction: 'ease-in-out',\r\n  horizontal: false\r\n};\r\n\r\n/**\r\n * SwapAnimation plugin adds swap animations for sortable\r\n * @class SwapAnimation\r\n * @module SwapAnimation\r\n * @extends AbstractPlugin\r\n */\r\nclass SwapAnimation extends _AbstractPlugin2.default {\r\n  /**\r\n   * SwapAnimation constructor.\r\n   * @constructs SwapAnimation\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * SwapAnimation options\r\n     * @property {Object} options\r\n     * @property {Number} defaultOptions.duration\r\n     * @property {String} defaultOptions.easingFunction\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Last animation frame\r\n     * @property {Number} lastAnimationFrame\r\n     * @type {Number}\r\n     */\r\n    this.lastAnimationFrame = null;\r\n\r\n    this[onSortableSorted] = this[onSortableSorted].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('sortable:sorted', this[onSortableSorted]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('sortable:sorted', this[onSortableSorted]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.swapAnimation || {};\r\n  }\r\n\r\n  /**\r\n   * Sortable sorted handler\r\n   * @param {SortableSortedEvent} sortableEvent\r\n   * @private\r\n   */\r\n  [onSortableSorted]({ oldIndex, newIndex, dragEvent }) {\r\n    const { source, over } = dragEvent;\r\n\r\n    cancelAnimationFrame(this.lastAnimationFrame);\r\n\r\n    // Can be done in a separate frame\r\n    this.lastAnimationFrame = requestAnimationFrame(() => {\r\n      if (oldIndex >= newIndex) {\r\n        animate(source, over, this.options);\r\n      } else {\r\n        animate(over, source, this.options);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexports.default = SwapAnimation; /**\r\n                                  * Animates two elements\r\n                                  * @param {HTMLElement} from\r\n                                  * @param {HTMLElement} to\r\n                                  * @param {Object} options\r\n                                  * @param {Number} options.duration\r\n                                  * @param {String} options.easingFunction\r\n                                  * @param {String} options.horizontal\r\n                                  * @private\r\n                                  */\r\n\r\nfunction animate(from, to, { duration, easingFunction, horizontal }) {\r\n  for (const element of [from, to]) {\r\n    element.style.pointerEvents = 'none';\r\n  }\r\n\r\n  if (horizontal) {\r\n    const width = from.offsetWidth;\r\n    from.style.transform = `translate3d(${width}px, 0, 0)`;\r\n    to.style.transform = `translate3d(-${width}px, 0, 0)`;\r\n  } else {\r\n    const height = from.offsetHeight;\r\n    from.style.transform = `translate3d(0, ${height}px, 0)`;\r\n    to.style.transform = `translate3d(0, -${height}px, 0)`;\r\n  }\r\n\r\n  requestAnimationFrame(() => {\r\n    for (const element of [from, to]) {\r\n      element.addEventListener('transitionend', resetElementOnTransitionEnd);\r\n      element.style.transition = `transform ${duration}ms ${easingFunction}`;\r\n      element.style.transform = '';\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Resets animation style properties after animation has completed\r\n * @param {Event} event\r\n * @private\r\n */\r\nfunction resetElementOnTransitionEnd(event) {\r\n  event.target.style.transition = '';\r\n  event.target.style.pointerEvents = '';\r\n  event.target.removeEventListener('transitionend', resetElementOnTransitionEnd);\r\n}\r\n\r\n/***/ }),\r\n/* 18 */\r\n/***/ (function(module, exports, __nested_webpack_require_25750__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _SwapAnimation = __nested_webpack_require_25750__(17);\r\n\r\nvar _SwapAnimation2 = _interopRequireDefault(_SwapAnimation);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _SwapAnimation2.default;\r\nexports.defaultOptions = _SwapAnimation.defaultOptions;\r\n\r\n/***/ }),\r\n/* 19 */\r\n/***/ (function(module, exports, __nested_webpack_require_26272__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_26272__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _SnappableEvent = __nested_webpack_require_26272__(7);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragOut = Symbol('onDragOut');\r\nconst onMirrorCreated = Symbol('onMirrorCreated');\r\nconst onMirrorDestroy = Symbol('onMirrorDestroy');\r\n\r\n/**\r\n * Snappable plugin which snaps draggable elements into place\r\n * @class Snappable\r\n * @module Snappable\r\n * @extends AbstractPlugin\r\n */\r\nclass Snappable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Snappable constructor.\r\n   * @constructs Snappable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Keeps track of the first source element\r\n     * @property {HTMLElement|null} firstSource\r\n     */\r\n    this.firstSource = null;\r\n\r\n    /**\r\n     * Keeps track of the mirror element\r\n     * @property {HTMLElement} mirror\r\n     */\r\n    this.mirror = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragOut] = this[onDragOut].bind(this);\r\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\r\n    this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:stop', this[onDragStop]).on('drag:over', this[onDragOver]).on('drag:out', this[onDragOut]).on('droppable:over', this[onDragOver]).on('droppable:out', this[onDragOut]).on('mirror:created', this[onMirrorCreated]).on('mirror:destroy', this[onMirrorDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:stop', this[onDragStop]).off('drag:over', this[onDragOver]).off('drag:out', this[onDragOut]).off('droppable:over', this[onDragOver]).off('droppable:out', this[onDragOut]).off('mirror:created', this[onMirrorCreated]).off('mirror:destroy', this[onMirrorDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {DragStartEvent} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    this.firstSource = event.source;\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop]() {\r\n    this.firstSource = null;\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {DragOverEvent|DroppableOverEvent} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const source = event.source || event.dragEvent.source;\r\n\r\n    if (source === this.firstSource) {\r\n      this.firstSource = null;\r\n      return;\r\n    }\r\n\r\n    const snapInEvent = new _SnappableEvent.SnapInEvent({\r\n      dragEvent: event,\r\n      snappable: event.over || event.droppable\r\n    });\r\n\r\n    this.draggable.trigger(snapInEvent);\r\n\r\n    if (snapInEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    if (this.mirror) {\r\n      this.mirror.style.display = 'none';\r\n    }\r\n\r\n    source.classList.remove(...this.draggable.getClassNamesFor('source:dragging'));\r\n    source.classList.add(...this.draggable.getClassNamesFor('source:placed'));\r\n\r\n    // Need to cancel this in drag out\r\n    setTimeout(() => {\r\n      source.classList.remove(...this.draggable.getClassNamesFor('source:placed'));\r\n    }, this.draggable.options.placedTimeout);\r\n  }\r\n\r\n  /**\r\n   * Drag out handler\r\n   * @private\r\n   * @param {DragOutEvent|DroppableOutEvent} event - Drag out event\r\n   */\r\n  [onDragOut](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const source = event.source || event.dragEvent.source;\r\n\r\n    const snapOutEvent = new _SnappableEvent.SnapOutEvent({\r\n      dragEvent: event,\r\n      snappable: event.over || event.droppable\r\n    });\r\n\r\n    this.draggable.trigger(snapOutEvent);\r\n\r\n    if (snapOutEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    if (this.mirror) {\r\n      this.mirror.style.display = '';\r\n    }\r\n\r\n    source.classList.add(...this.draggable.getClassNamesFor('source:dragging'));\r\n  }\r\n\r\n  /**\r\n   * Mirror created handler\r\n   * @param {MirrorCreatedEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorCreated]({ mirror }) {\r\n    this.mirror = mirror;\r\n  }\r\n\r\n  /**\r\n   * Mirror destroy handler\r\n   * @param {MirrorDestroyEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorDestroy]() {\r\n    this.mirror = null;\r\n  }\r\n}\r\nexports.default = Snappable;\r\n\r\n/***/ }),\r\n/* 20 */\r\n/***/ (function(module, exports, __nested_webpack_require_31258__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.SnapOutEvent = exports.SnapInEvent = exports.SnapEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_31258__(1);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base snap event\r\n * @class SnapEvent\r\n * @module SnapEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SnapEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Drag event that triggered this snap event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n\r\n  /**\r\n   * Snappable element\r\n   * @property snappable\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get snappable() {\r\n    return this.data.snappable;\r\n  }\r\n}\r\n\r\nexports.SnapEvent = SnapEvent; /**\r\n                                * Snap in event\r\n                                * @class SnapInEvent\r\n                                * @module SnapInEvent\r\n                                * @extends SnapEvent\r\n                                */\r\n\r\nSnapEvent.type = 'snap';\r\nclass SnapInEvent extends SnapEvent {}\r\n\r\nexports.SnapInEvent = SnapInEvent; /**\r\n                                    * Snap out event\r\n                                    * @class SnapOutEvent\r\n                                    * @module SnapOutEvent\r\n                                    * @extends SnapEvent\r\n                                    */\r\n\r\nSnapInEvent.type = 'snap:in';\r\nSnapInEvent.cancelable = true;\r\nclass SnapOutEvent extends SnapEvent {}\r\nexports.SnapOutEvent = SnapOutEvent;\r\nSnapOutEvent.type = 'snap:out';\r\nSnapOutEvent.cancelable = true;\r\n\r\n/***/ }),\r\n/* 21 */\r\n/***/ (function(module, exports, __nested_webpack_require_33105__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SnappableEvent = __nested_webpack_require_33105__(7);\r\n\r\nObject.keys(_SnappableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SnappableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Snappable = __nested_webpack_require_33105__(19);\r\n\r\nvar _Snappable2 = _interopRequireDefault(_Snappable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Snappable2.default;\r\n\r\n/***/ }),\r\n/* 22 */\r\n/***/ (function(module, exports, __nested_webpack_require_33824__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_33824__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _utils = __nested_webpack_require_33824__(2);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMirrorCreated = Symbol('onMirrorCreated');\r\nconst onMirrorDestroy = Symbol('onMirrorDestroy');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst resize = Symbol('resize');\r\n\r\n/**\r\n * ResizeMirror default options\r\n * @property {Object} defaultOptions\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {};\r\n\r\n/**\r\n * The ResizeMirror plugin resizes the mirror element to the dimensions of the draggable element that the mirror is hovering over\r\n * @class ResizeMirror\r\n * @module ResizeMirror\r\n * @extends AbstractPlugin\r\n */\r\nclass ResizeMirror extends _AbstractPlugin2.default {\r\n  /**\r\n   * ResizeMirror constructor.\r\n   * @constructs ResizeMirror\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * ResizeMirror options\r\n     * @property {Object} options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * ResizeMirror remembers the last width when resizing the mirror\r\n     * to avoid additional writes to the DOM\r\n     * @property {number} lastWidth\r\n     */\r\n    this.lastWidth = 0;\r\n\r\n    /**\r\n     * ResizeMirror remembers the last height when resizing the mirror\r\n     * to avoid additional writes to the DOM\r\n     * @property {number} lastHeight\r\n     */\r\n    this.lastHeight = 0;\r\n\r\n    /**\r\n     * Keeps track of the mirror element\r\n     * @property {HTMLElement} mirror\r\n     */\r\n    this.mirror = null;\r\n\r\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\r\n    this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('mirror:created', this[onMirrorCreated]).on('drag:over', this[onDragOver]).on('drag:over:container', this[onDragOver]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('mirror:created', this[onMirrorCreated]).off('mirror:destroy', this[onMirrorDestroy]).off('drag:over', this[onDragOver]).off('drag:over:container', this[onDragOver]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.resizeMirror || {};\r\n  }\r\n\r\n  /**\r\n   * Mirror created handler\r\n   * @param {MirrorCreatedEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorCreated]({ mirror }) {\r\n    this.mirror = mirror;\r\n  }\r\n\r\n  /**\r\n   * Mirror destroy handler\r\n   * @param {MirrorDestroyEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorDestroy]() {\r\n    this.mirror = null;\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @param {DragOverEvent | DragOverContainer} dragEvent\r\n   * @private\r\n   */\r\n  [onDragOver](dragEvent) {\r\n    this[resize](dragEvent);\r\n  }\r\n\r\n  /**\r\n   * Resize function for\r\n   * @param {DragOverEvent | DragOverContainer} dragEvent\r\n   * @private\r\n   */\r\n  [resize]({ overContainer, over }) {\r\n    requestAnimationFrame(() => {\r\n      if (!this.mirror.parentNode) {\r\n        return;\r\n      }\r\n\r\n      if (this.mirror.parentNode !== overContainer) {\r\n        overContainer.appendChild(this.mirror);\r\n      }\r\n\r\n      const overElement = over || this.draggable.getDraggableElementsForContainer(overContainer)[0];\r\n\r\n      if (!overElement) {\r\n        return;\r\n      }\r\n\r\n      (0, _utils.requestNextAnimationFrame)(() => {\r\n        const overRect = overElement.getBoundingClientRect();\r\n\r\n        if (this.lastHeight === overRect.height && this.lastWidth === overRect.width) {\r\n          return;\r\n        }\r\n\r\n        this.mirror.style.width = `${overRect.width}px`;\r\n        this.mirror.style.height = `${overRect.height}px`;\r\n\r\n        this.lastWidth = overRect.width;\r\n        this.lastHeight = overRect.height;\r\n      });\r\n    });\r\n  }\r\n}\r\nexports.default = ResizeMirror;\r\n\r\n/***/ }),\r\n/* 23 */\r\n/***/ (function(module, exports, __nested_webpack_require_38425__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _ResizeMirror = __nested_webpack_require_38425__(22);\r\n\r\nvar _ResizeMirror2 = _interopRequireDefault(_ResizeMirror);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _ResizeMirror2.default;\r\nexports.defaultOptions = _ResizeMirror.defaultOptions;\r\n\r\n/***/ }),\r\n/* 24 */\r\n/***/ (function(module, exports, __nested_webpack_require_38942__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_38942__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _utils = __nested_webpack_require_38942__(2);\r\n\r\nvar _CollidableEvent = __nested_webpack_require_38942__(8);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragMove = Symbol('onDragMove');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst onRequestAnimationFrame = Symbol('onRequestAnimationFrame');\r\n\r\n/**\r\n * Collidable plugin which detects colliding elements while dragging\r\n * @class Collidable\r\n * @module Collidable\r\n * @extends AbstractPlugin\r\n */\r\nclass Collidable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Collidable constructor.\r\n   * @constructs Collidable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Keeps track of currently colliding elements\r\n     * @property {HTMLElement|null} currentlyCollidingElement\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.currentlyCollidingElement = null;\r\n\r\n    /**\r\n     * Keeps track of currently colliding elements\r\n     * @property {HTMLElement|null} lastCollidingElement\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.lastCollidingElement = null;\r\n\r\n    /**\r\n     * Animation frame for finding colliding elements\r\n     * @property {Number|null} currentAnimationFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.currentAnimationFrame = null;\r\n\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onRequestAnimationFrame] = this[onRequestAnimationFrame].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Returns current collidables based on `collidables` option\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getCollidables() {\r\n    const collidables = this.draggable.options.collidables;\r\n\r\n    if (typeof collidables === 'string') {\r\n      return Array.prototype.slice.call(document.querySelectorAll(collidables));\r\n    } else if (collidables instanceof NodeList || collidables instanceof Array) {\r\n      return Array.prototype.slice.call(collidables);\r\n    } else if (collidables instanceof HTMLElement) {\r\n      return [collidables];\r\n    } else if (typeof collidables === 'function') {\r\n      return collidables();\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag move handler\r\n   * @private\r\n   * @param {DragMoveEvent} event - Drag move event\r\n   */\r\n  [onDragMove](event) {\r\n    const target = event.sensorEvent.target;\r\n\r\n    this.currentAnimationFrame = requestAnimationFrame(this[onRequestAnimationFrame](target));\r\n\r\n    if (this.currentlyCollidingElement) {\r\n      event.cancel();\r\n    }\r\n\r\n    const collidableInEvent = new _CollidableEvent.CollidableInEvent({\r\n      dragEvent: event,\r\n      collidingElement: this.currentlyCollidingElement\r\n    });\r\n\r\n    const collidableOutEvent = new _CollidableEvent.CollidableOutEvent({\r\n      dragEvent: event,\r\n      collidingElement: this.lastCollidingElement\r\n    });\r\n\r\n    const enteringCollidable = Boolean(this.currentlyCollidingElement && this.lastCollidingElement !== this.currentlyCollidingElement);\r\n    const leavingCollidable = Boolean(!this.currentlyCollidingElement && this.lastCollidingElement);\r\n\r\n    if (enteringCollidable) {\r\n      if (this.lastCollidingElement) {\r\n        this.draggable.trigger(collidableOutEvent);\r\n      }\r\n\r\n      this.draggable.trigger(collidableInEvent);\r\n    } else if (leavingCollidable) {\r\n      this.draggable.trigger(collidableOutEvent);\r\n    }\r\n\r\n    this.lastCollidingElement = this.currentlyCollidingElement;\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop](event) {\r\n    const lastCollidingElement = this.currentlyCollidingElement || this.lastCollidingElement;\r\n    const collidableOutEvent = new _CollidableEvent.CollidableOutEvent({\r\n      dragEvent: event,\r\n      collidingElement: lastCollidingElement\r\n    });\r\n\r\n    if (lastCollidingElement) {\r\n      this.draggable.trigger(collidableOutEvent);\r\n    }\r\n\r\n    this.lastCollidingElement = null;\r\n    this.currentlyCollidingElement = null;\r\n  }\r\n\r\n  /**\r\n   * Animation frame function\r\n   * @private\r\n   * @param {HTMLElement} target - Current move target\r\n   * @return {Function}\r\n   */\r\n  [onRequestAnimationFrame](target) {\r\n    return () => {\r\n      const collidables = this.getCollidables();\r\n      this.currentlyCollidingElement = (0, _utils.closest)(target, element => collidables.includes(element));\r\n    };\r\n  }\r\n}\r\nexports.default = Collidable;\r\n\r\n/***/ }),\r\n/* 25 */\r\n/***/ (function(module, exports, __nested_webpack_require_44004__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.CollidableOutEvent = exports.CollidableInEvent = exports.CollidableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_44004__(1);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base collidable event\r\n * @class CollidableEvent\r\n * @module CollidableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass CollidableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Drag event that triggered this colliable event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n}\r\n\r\nexports.CollidableEvent = CollidableEvent; /**\r\n                                            * Collidable in event\r\n                                            * @class CollidableInEvent\r\n                                            * @module CollidableInEvent\r\n                                            * @extends CollidableEvent\r\n                                            */\r\n\r\nCollidableEvent.type = 'collidable';\r\nclass CollidableInEvent extends CollidableEvent {\r\n\r\n  /**\r\n   * Element you are currently colliding with\r\n   * @property collidingElement\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get collidingElement() {\r\n    return this.data.collidingElement;\r\n  }\r\n}\r\n\r\nexports.CollidableInEvent = CollidableInEvent; /**\r\n                                                * Collidable out event\r\n                                                * @class CollidableOutEvent\r\n                                                * @module CollidableOutEvent\r\n                                                * @extends CollidableEvent\r\n                                                */\r\n\r\nCollidableInEvent.type = 'collidable:in';\r\nclass CollidableOutEvent extends CollidableEvent {\r\n\r\n  /**\r\n   * Element you were previously colliding with\r\n   * @property collidingElement\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get collidingElement() {\r\n    return this.data.collidingElement;\r\n  }\r\n}\r\nexports.CollidableOutEvent = CollidableOutEvent;\r\nCollidableOutEvent.type = 'collidable:out';\r\n\r\n/***/ }),\r\n/* 26 */\r\n/***/ (function(module, exports, __nested_webpack_require_46358__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _CollidableEvent = __nested_webpack_require_46358__(8);\r\n\r\nObject.keys(_CollidableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _CollidableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Collidable = __nested_webpack_require_46358__(24);\r\n\r\nvar _Collidable2 = _interopRequireDefault(_Collidable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Collidable2.default;\r\n\r\n/***/ }),\r\n/* 27 */\r\n/***/ (function(module, exports, __nested_webpack_require_47084__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Collidable = __nested_webpack_require_47084__(26);\r\n\r\nObject.defineProperty(exports, 'Collidable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Collidable).default;\r\n  }\r\n});\r\n\r\nvar _ResizeMirror = __nested_webpack_require_47084__(23);\r\n\r\nObject.defineProperty(exports, 'ResizeMirror', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_ResizeMirror).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultResizeMirrorOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _ResizeMirror.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Snappable = __nested_webpack_require_47084__(21);\r\n\r\nObject.defineProperty(exports, 'Snappable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Snappable).default;\r\n  }\r\n});\r\n\r\nvar _SwapAnimation = __nested_webpack_require_47084__(18);\r\n\r\nObject.defineProperty(exports, 'SwapAnimation', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_SwapAnimation).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultSwapAnimationOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _SwapAnimation.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _SortAnimation = __nested_webpack_require_47084__(16);\r\n\r\nObject.defineProperty(exports, 'SortAnimation', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_SortAnimation).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultSortAnimationOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _SortAnimation.defaultOptions;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 28 */\r\n/***/ (function(module, exports, __nested_webpack_require_48884__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _Draggable = __nested_webpack_require_48884__(5);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nvar _SortableEvent = __nested_webpack_require_48884__(9);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragOverContainer = Symbol('onDragOverContainer');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragStop = Symbol('onDragStop');\r\n\r\n/**\r\n * Returns announcement message when a Draggable element has been sorted with another Draggable element\r\n * or moved into a new container\r\n * @param {SortableSortedEvent} sortableEvent\r\n * @return {String}\r\n */\r\nfunction onSortableSortedDefaultAnnouncement({ dragEvent }) {\r\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'sortable element';\r\n\r\n  if (dragEvent.over) {\r\n    const overText = dragEvent.over.textContent.trim() || dragEvent.over.id || 'sortable element';\r\n    const isFollowing = dragEvent.source.compareDocumentPosition(dragEvent.over) & Node.DOCUMENT_POSITION_FOLLOWING;\r\n\r\n    if (isFollowing) {\r\n      return `Placed ${sourceText} after ${overText}`;\r\n    } else {\r\n      return `Placed ${sourceText} before ${overText}`;\r\n    }\r\n  } else {\r\n    // need to figure out how to compute container name\r\n    return `Placed ${sourceText} into a different container`;\r\n  }\r\n}\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['sortable:sorted']\r\n */\r\nconst defaultAnnouncements = {\r\n  'sortable:sorted': onSortableSortedDefaultAnnouncement\r\n};\r\n\r\n/**\r\n * Sortable is built on top of Draggable and allows sorting of draggable elements. Sortable will keep\r\n * track of the original index and emits the new index as you drag over draggable elements.\r\n * @class Sortable\r\n * @module Sortable\r\n * @extends Draggable\r\n */\r\nclass Sortable extends _Draggable2.default {\r\n  /**\r\n   * Sortable constructor.\r\n   * @constructs Sortable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Sortable containers\r\n   * @param {Object} options - Options for Sortable\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, _extends({}, options, {\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {})\r\n    }));\r\n\r\n    /**\r\n     * start index of source on drag start\r\n     * @property startIndex\r\n     * @type {Number}\r\n     */\r\n    this.startIndex = null;\r\n\r\n    /**\r\n     * start container on drag start\r\n     * @property startContainer\r\n     * @type {HTMLElement}\r\n     * @default null\r\n     */\r\n    this.startContainer = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragOverContainer] = this[onDragOverContainer].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n\r\n    this.on('drag:start', this[onDragStart]).on('drag:over:container', this[onDragOverContainer]).on('drag:over', this[onDragOver]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Destroys Sortable instance.\r\n   */\r\n  destroy() {\r\n    super.destroy();\r\n\r\n    this.off('drag:start', this[onDragStart]).off('drag:over:container', this[onDragOverContainer]).off('drag:over', this[onDragOver]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Returns true index of element within its container during drag operation, i.e. excluding mirror and original source\r\n   * @param {HTMLElement} element - An element\r\n   * @return {Number}\r\n   */\r\n  index(element) {\r\n    return this.getSortableElementsForContainer(element.parentNode).indexOf(element);\r\n  }\r\n\r\n  /**\r\n   * Returns sortable elements for a given container, excluding the mirror and\r\n   * original source element if present\r\n   * @param {HTMLElement} container\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getSortableElementsForContainer(container) {\r\n    const allSortableElements = container.querySelectorAll(this.options.draggable);\r\n\r\n    return [...allSortableElements].filter(childElement => {\r\n      return childElement !== this.originalSource && childElement !== this.mirror && childElement.parentNode === container;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {DragStartEvent} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    this.startContainer = event.source.parentNode;\r\n    this.startIndex = this.index(event.source);\r\n\r\n    const sortableStartEvent = new _SortableEvent.SortableStartEvent({\r\n      dragEvent: event,\r\n      startIndex: this.startIndex,\r\n      startContainer: this.startContainer\r\n    });\r\n\r\n    this.trigger(sortableStartEvent);\r\n\r\n    if (sortableStartEvent.canceled()) {\r\n      event.cancel();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag over container handler\r\n   * @private\r\n   * @param {DragOverContainerEvent} event - Drag over container event\r\n   */\r\n  [onDragOverContainer](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const { source, over, overContainer } = event;\r\n    const oldIndex = this.index(source);\r\n\r\n    const sortableSortEvent = new _SortableEvent.SortableSortEvent({\r\n      dragEvent: event,\r\n      currentIndex: oldIndex,\r\n      source,\r\n      over\r\n    });\r\n\r\n    this.trigger(sortableSortEvent);\r\n\r\n    if (sortableSortEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const children = this.getSortableElementsForContainer(overContainer);\r\n    const moves = move({ source, over, overContainer, children });\r\n\r\n    if (!moves) {\r\n      return;\r\n    }\r\n\r\n    const { oldContainer, newContainer } = moves;\r\n    const newIndex = this.index(event.source);\r\n\r\n    const sortableSortedEvent = new _SortableEvent.SortableSortedEvent({\r\n      dragEvent: event,\r\n      oldIndex,\r\n      newIndex,\r\n      oldContainer,\r\n      newContainer\r\n    });\r\n\r\n    this.trigger(sortableSortedEvent);\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {DragOverEvent} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (event.over === event.originalSource || event.over === event.source) {\r\n      return;\r\n    }\r\n\r\n    const { source, over, overContainer } = event;\r\n    const oldIndex = this.index(source);\r\n\r\n    const sortableSortEvent = new _SortableEvent.SortableSortEvent({\r\n      dragEvent: event,\r\n      currentIndex: oldIndex,\r\n      source,\r\n      over\r\n    });\r\n\r\n    this.trigger(sortableSortEvent);\r\n\r\n    if (sortableSortEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const children = this.getDraggableElementsForContainer(overContainer);\r\n    const moves = move({ source, over, overContainer, children });\r\n\r\n    if (!moves) {\r\n      return;\r\n    }\r\n\r\n    const { oldContainer, newContainer } = moves;\r\n    const newIndex = this.index(source);\r\n\r\n    const sortableSortedEvent = new _SortableEvent.SortableSortedEvent({\r\n      dragEvent: event,\r\n      oldIndex,\r\n      newIndex,\r\n      oldContainer,\r\n      newContainer\r\n    });\r\n\r\n    this.trigger(sortableSortedEvent);\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop](event) {\r\n    const sortableStopEvent = new _SortableEvent.SortableStopEvent({\r\n      dragEvent: event,\r\n      oldIndex: this.startIndex,\r\n      newIndex: this.index(event.source),\r\n      oldContainer: this.startContainer,\r\n      newContainer: event.source.parentNode\r\n    });\r\n\r\n    this.trigger(sortableStopEvent);\r\n\r\n    this.startIndex = null;\r\n    this.startContainer = null;\r\n  }\r\n}\r\n\r\nexports.default = Sortable;\r\nfunction index(element) {\r\n  return Array.prototype.indexOf.call(element.parentNode.children, element);\r\n}\r\n\r\nfunction move({ source, over, overContainer, children }) {\r\n  const emptyOverContainer = !children.length;\r\n  const differentContainer = source.parentNode !== overContainer;\r\n  const sameContainer = over && source.parentNode === over.parentNode;\r\n\r\n  if (emptyOverContainer) {\r\n    return moveInsideEmptyContainer(source, overContainer);\r\n  } else if (sameContainer) {\r\n    return moveWithinContainer(source, over);\r\n  } else if (differentContainer) {\r\n    return moveOutsideContainer(source, over, overContainer);\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\nfunction moveInsideEmptyContainer(source, overContainer) {\r\n  const oldContainer = source.parentNode;\r\n\r\n  overContainer.appendChild(source);\r\n\r\n  return { oldContainer, newContainer: overContainer };\r\n}\r\n\r\nfunction moveWithinContainer(source, over) {\r\n  const oldIndex = index(source);\r\n  const newIndex = index(over);\r\n\r\n  if (oldIndex < newIndex) {\r\n    source.parentNode.insertBefore(source, over.nextElementSibling);\r\n  } else {\r\n    source.parentNode.insertBefore(source, over);\r\n  }\r\n\r\n  return { oldContainer: source.parentNode, newContainer: source.parentNode };\r\n}\r\n\r\nfunction moveOutsideContainer(source, over, overContainer) {\r\n  const oldContainer = source.parentNode;\r\n\r\n  if (over) {\r\n    over.parentNode.insertBefore(source, over);\r\n  } else {\r\n    // need to figure out proper position\r\n    overContainer.appendChild(source);\r\n  }\r\n\r\n  return { oldContainer, newContainer: source.parentNode };\r\n}\r\n\r\n/***/ }),\r\n/* 29 */\r\n/***/ (function(module, exports, __nested_webpack_require_58354__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.SortableStopEvent = exports.SortableSortedEvent = exports.SortableSortEvent = exports.SortableStartEvent = exports.SortableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_58354__(1);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base sortable event\r\n * @class SortableEvent\r\n * @module SortableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SortableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Original drag event that triggered this sortable event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n}\r\n\r\nexports.SortableEvent = SortableEvent; /**\r\n                                        * Sortable start event\r\n                                        * @class SortableStartEvent\r\n                                        * @module SortableStartEvent\r\n                                        * @extends SortableEvent\r\n                                        */\r\n\r\nSortableEvent.type = 'sortable';\r\nclass SortableStartEvent extends SortableEvent {\r\n\r\n  /**\r\n   * Start index of source on sortable start\r\n   * @property startIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get startIndex() {\r\n    return this.data.startIndex;\r\n  }\r\n\r\n  /**\r\n   * Start container on sortable start\r\n   * @property startContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get startContainer() {\r\n    return this.data.startContainer;\r\n  }\r\n}\r\n\r\nexports.SortableStartEvent = SortableStartEvent; /**\r\n                                                  * Sortable sort event\r\n                                                  * @class SortableSortEvent\r\n                                                  * @module SortableSortEvent\r\n                                                  * @extends SortableEvent\r\n                                                  */\r\n\r\nSortableStartEvent.type = 'sortable:start';\r\nSortableStartEvent.cancelable = true;\r\nclass SortableSortEvent extends SortableEvent {\r\n\r\n  /**\r\n   * Index of current draggable element\r\n   * @property currentIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get currentIndex() {\r\n    return this.data.currentIndex;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you are hovering over\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n\r\n  /**\r\n   * Draggable container element you are hovering over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.dragEvent.overContainer;\r\n  }\r\n}\r\n\r\nexports.SortableSortEvent = SortableSortEvent; /**\r\n                                                * Sortable sorted event\r\n                                                * @class SortableSortedEvent\r\n                                                * @module SortableSortedEvent\r\n                                                * @extends SortableEvent\r\n                                                */\r\n\r\nSortableSortEvent.type = 'sortable:sort';\r\nSortableSortEvent.cancelable = true;\r\nclass SortableSortedEvent extends SortableEvent {\r\n\r\n  /**\r\n   * Index of last sorted event\r\n   * @property oldIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get oldIndex() {\r\n    return this.data.oldIndex;\r\n  }\r\n\r\n  /**\r\n   * New index of this sorted event\r\n   * @property newIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get newIndex() {\r\n    return this.data.newIndex;\r\n  }\r\n\r\n  /**\r\n   * Old container of draggable element\r\n   * @property oldContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get oldContainer() {\r\n    return this.data.oldContainer;\r\n  }\r\n\r\n  /**\r\n   * New container of draggable element\r\n   * @property newContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get newContainer() {\r\n    return this.data.newContainer;\r\n  }\r\n}\r\n\r\nexports.SortableSortedEvent = SortableSortedEvent; /**\r\n                                                    * Sortable stop event\r\n                                                    * @class SortableStopEvent\r\n                                                    * @module SortableStopEvent\r\n                                                    * @extends SortableEvent\r\n                                                    */\r\n\r\nSortableSortedEvent.type = 'sortable:sorted';\r\nclass SortableStopEvent extends SortableEvent {\r\n\r\n  /**\r\n   * Original index on sortable start\r\n   * @property oldIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get oldIndex() {\r\n    return this.data.oldIndex;\r\n  }\r\n\r\n  /**\r\n   * New index of draggable element\r\n   * @property newIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get newIndex() {\r\n    return this.data.newIndex;\r\n  }\r\n\r\n  /**\r\n   * Original container of draggable element\r\n   * @property oldContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get oldContainer() {\r\n    return this.data.oldContainer;\r\n  }\r\n\r\n  /**\r\n   * New container of draggable element\r\n   * @property newContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get newContainer() {\r\n    return this.data.newContainer;\r\n  }\r\n}\r\nexports.SortableStopEvent = SortableStopEvent;\r\nSortableStopEvent.type = 'sortable:stop';\r\n\r\n/***/ }),\r\n/* 30 */\r\n/***/ (function(module, exports, __nested_webpack_require_63860__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SortableEvent = __nested_webpack_require_63860__(9);\r\n\r\nObject.keys(_SortableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SortableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Sortable = __nested_webpack_require_63860__(28);\r\n\r\nvar _Sortable2 = _interopRequireDefault(_Sortable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Sortable2.default;\r\n\r\n/***/ }),\r\n/* 31 */\r\n/***/ (function(module, exports, __nested_webpack_require_64572__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _Draggable = __nested_webpack_require_64572__(5);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nvar _SwappableEvent = __nested_webpack_require_64572__(10);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragStop = Symbol('onDragStop');\r\n\r\n/**\r\n * Returns an announcement message when the Draggable element is swapped with another draggable element\r\n * @param {SwappableSwappedEvent} swappableEvent\r\n * @return {String}\r\n */\r\nfunction onSwappableSwappedDefaultAnnouncement({ dragEvent, swappedElement }) {\r\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'swappable element';\r\n  const overText = swappedElement.textContent.trim() || swappedElement.id || 'swappable element';\r\n\r\n  return `Swapped ${sourceText} with ${overText}`;\r\n}\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['swappabled:swapped']\r\n */\r\nconst defaultAnnouncements = {\r\n  'swappabled:swapped': onSwappableSwappedDefaultAnnouncement\r\n};\r\n\r\n/**\r\n * Swappable is built on top of Draggable and allows swapping of draggable elements.\r\n * Order is irrelevant to Swappable.\r\n * @class Swappable\r\n * @module Swappable\r\n * @extends Draggable\r\n */\r\nclass Swappable extends _Draggable2.default {\r\n  /**\r\n   * Swappable constructor.\r\n   * @constructs Swappable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Swappable containers\r\n   * @param {Object} options - Options for Swappable\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, _extends({}, options, {\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {})\r\n    }));\r\n\r\n    /**\r\n     * Last draggable element that was dragged over\r\n     * @property lastOver\r\n     * @type {HTMLElement}\r\n     */\r\n    this.lastOver = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n\r\n    this.on('drag:start', this[onDragStart]).on('drag:over', this[onDragOver]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Destroys Swappable instance.\r\n   */\r\n  destroy() {\r\n    super.destroy();\r\n\r\n    this.off('drag:start', this._onDragStart).off('drag:over', this._onDragOver).off('drag:stop', this._onDragStop);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {DragStartEvent} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    const swappableStartEvent = new _SwappableEvent.SwappableStartEvent({\r\n      dragEvent: event\r\n    });\r\n\r\n    this.trigger(swappableStartEvent);\r\n\r\n    if (swappableStartEvent.canceled()) {\r\n      event.cancel();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {DragOverEvent} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (event.over === event.originalSource || event.over === event.source || event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const swappableSwapEvent = new _SwappableEvent.SwappableSwapEvent({\r\n      dragEvent: event,\r\n      over: event.over,\r\n      overContainer: event.overContainer\r\n    });\r\n\r\n    this.trigger(swappableSwapEvent);\r\n\r\n    if (swappableSwapEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    // swap originally swapped element back\r\n    if (this.lastOver && this.lastOver !== event.over) {\r\n      swap(this.lastOver, event.source);\r\n    }\r\n\r\n    if (this.lastOver === event.over) {\r\n      this.lastOver = null;\r\n    } else {\r\n      this.lastOver = event.over;\r\n    }\r\n\r\n    swap(event.source, event.over);\r\n\r\n    const swappableSwappedEvent = new _SwappableEvent.SwappableSwappedEvent({\r\n      dragEvent: event,\r\n      swappedElement: event.over\r\n    });\r\n\r\n    this.trigger(swappableSwappedEvent);\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop](event) {\r\n    const swappableStopEvent = new _SwappableEvent.SwappableStopEvent({\r\n      dragEvent: event\r\n    });\r\n\r\n    this.trigger(swappableStopEvent);\r\n    this.lastOver = null;\r\n  }\r\n}\r\n\r\nexports.default = Swappable;\r\nfunction withTempElement(callback) {\r\n  const tmpElement = document.createElement('div');\r\n  callback(tmpElement);\r\n  tmpElement.parentNode.removeChild(tmpElement);\r\n}\r\n\r\nfunction swap(source, over) {\r\n  const overParent = over.parentNode;\r\n  const sourceParent = source.parentNode;\r\n\r\n  withTempElement(tmpElement => {\r\n    sourceParent.insertBefore(tmpElement, source);\r\n    overParent.insertBefore(source, over);\r\n    sourceParent.insertBefore(over, tmpElement);\r\n  });\r\n}\r\n\r\n/***/ }),\r\n/* 32 */\r\n/***/ (function(module, exports, __nested_webpack_require_69678__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.SwappableStopEvent = exports.SwappableSwappedEvent = exports.SwappableSwapEvent = exports.SwappableStartEvent = exports.SwappableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_69678__(1);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base swappable event\r\n * @class SwappableEvent\r\n * @module SwappableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SwappableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Original drag event that triggered this swappable event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n}\r\n\r\nexports.SwappableEvent = SwappableEvent; /**\r\n                                          * Swappable start event\r\n                                          * @class SwappableStartEvent\r\n                                          * @module SwappableStartEvent\r\n                                          * @extends SwappableEvent\r\n                                          */\r\n\r\nSwappableEvent.type = 'swappable';\r\nclass SwappableStartEvent extends SwappableEvent {}\r\n\r\nexports.SwappableStartEvent = SwappableStartEvent; /**\r\n                                                    * Swappable swap event\r\n                                                    * @class SwappableSwapEvent\r\n                                                    * @module SwappableSwapEvent\r\n                                                    * @extends SwappableEvent\r\n                                                    */\r\n\r\nSwappableStartEvent.type = 'swappable:start';\r\nSwappableStartEvent.cancelable = true;\r\nclass SwappableSwapEvent extends SwappableEvent {\r\n\r\n  /**\r\n   * Draggable element you are over\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.SwappableSwapEvent = SwappableSwapEvent; /**\r\n                                                  * Swappable swapped event\r\n                                                  * @class SwappableSwappedEvent\r\n                                                  * @module SwappableSwappedEvent\r\n                                                  * @extends SwappableEvent\r\n                                                  */\r\n\r\nSwappableSwapEvent.type = 'swappable:swap';\r\nSwappableSwapEvent.cancelable = true;\r\nclass SwappableSwappedEvent extends SwappableEvent {\r\n\r\n  /**\r\n   * The draggable element that you swapped with\r\n   * @property swappedElement\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get swappedElement() {\r\n    return this.data.swappedElement;\r\n  }\r\n}\r\n\r\nexports.SwappableSwappedEvent = SwappableSwappedEvent; /**\r\n                                                        * Swappable stop event\r\n                                                        * @class SwappableStopEvent\r\n                                                        * @module SwappableStopEvent\r\n                                                        * @extends SwappableEvent\r\n                                                        */\r\n\r\nSwappableSwappedEvent.type = 'swappable:swapped';\r\nclass SwappableStopEvent extends SwappableEvent {}\r\nexports.SwappableStopEvent = SwappableStopEvent;\r\nSwappableStopEvent.type = 'swappable:stop';\r\n\r\n/***/ }),\r\n/* 33 */\r\n/***/ (function(module, exports, __nested_webpack_require_73431__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SwappableEvent = __nested_webpack_require_73431__(10);\r\n\r\nObject.keys(_SwappableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SwappableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Swappable = __nested_webpack_require_73431__(31);\r\n\r\nvar _Swappable2 = _interopRequireDefault(_Swappable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Swappable2.default;\r\n\r\n/***/ }),\r\n/* 34 */\r\n/***/ (function(module, exports, __nested_webpack_require_74151__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _utils = __nested_webpack_require_74151__(2);\r\n\r\nvar _Draggable = __nested_webpack_require_74151__(5);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nvar _DroppableEvent = __nested_webpack_require_74151__(11);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragMove = Symbol('onDragMove');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst dropInDropzone = Symbol('dropInDropZone');\r\nconst returnToOriginalDropzone = Symbol('returnToOriginalDropzone');\r\nconst closestDropzone = Symbol('closestDropzone');\r\nconst getDropzones = Symbol('getDropzones');\r\n\r\n/**\r\n * Returns an announcement message when the Draggable element is dropped into a dropzone element\r\n * @param {DroppableDroppedEvent} droppableEvent\r\n * @return {String}\r\n */\r\nfunction onDroppableDroppedDefaultAnnouncement({ dragEvent, dropzone }) {\r\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'draggable element';\r\n  const dropzoneText = dropzone.textContent.trim() || dropzone.id || 'droppable element';\r\n\r\n  return `Dropped ${sourceText} into ${dropzoneText}`;\r\n}\r\n\r\n/**\r\n * Returns an announcement message when the Draggable element has returned to its original dropzone element\r\n * @param {DroppableReturnedEvent} droppableEvent\r\n * @return {String}\r\n */\r\nfunction onDroppableReturnedDefaultAnnouncement({ dragEvent, dropzone }) {\r\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'draggable element';\r\n  const dropzoneText = dropzone.textContent.trim() || dropzone.id || 'droppable element';\r\n\r\n  return `Returned ${sourceText} from ${dropzoneText}`;\r\n}\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['droppable:dropped']\r\n * @const {Function} defaultAnnouncements['droppable:returned']\r\n */\r\nconst defaultAnnouncements = {\r\n  'droppable:dropped': onDroppableDroppedDefaultAnnouncement,\r\n  'droppable:returned': onDroppableReturnedDefaultAnnouncement\r\n};\r\n\r\nconst defaultClasses = {\r\n  'droppable:active': 'draggable-dropzone--active',\r\n  'droppable:occupied': 'draggable-dropzone--occupied'\r\n};\r\n\r\nconst defaultOptions = {\r\n  dropzone: '.draggable-droppable'\r\n};\r\n\r\n/**\r\n * Droppable is built on top of Draggable and allows dropping draggable elements\r\n * into dropzone element\r\n * @class Droppable\r\n * @module Droppable\r\n * @extends Draggable\r\n */\r\nclass Droppable extends _Draggable2.default {\r\n  /**\r\n   * Droppable constructor.\r\n   * @constructs Droppable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Droppable containers\r\n   * @param {Object} options - Options for Droppable\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, _extends({}, defaultOptions, options, {\r\n      classes: _extends({}, defaultClasses, options.classes || {}),\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {})\r\n    }));\r\n\r\n    /**\r\n     * All dropzone elements on drag start\r\n     * @property dropzones\r\n     * @type {HTMLElement[]}\r\n     */\r\n    this.dropzones = null;\r\n\r\n    /**\r\n     * Last dropzone element that the source was dropped into\r\n     * @property lastDropzone\r\n     * @type {HTMLElement}\r\n     */\r\n    this.lastDropzone = null;\r\n\r\n    /**\r\n     * Initial dropzone element that the source was drag from\r\n     * @property initialDropzone\r\n     * @type {HTMLElement}\r\n     */\r\n    this.initialDropzone = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n\r\n    this.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Destroys Droppable instance.\r\n   */\r\n  destroy() {\r\n    super.destroy();\r\n\r\n    this.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {DragStartEvent} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    this.dropzones = [...this[getDropzones]()];\r\n    const dropzone = (0, _utils.closest)(event.sensorEvent.target, this.options.dropzone);\r\n\r\n    if (!dropzone) {\r\n      event.cancel();\r\n      return;\r\n    }\r\n\r\n    const droppableStartEvent = new _DroppableEvent.DroppableStartEvent({\r\n      dragEvent: event,\r\n      dropzone\r\n    });\r\n\r\n    this.trigger(droppableStartEvent);\r\n\r\n    if (droppableStartEvent.canceled()) {\r\n      event.cancel();\r\n      return;\r\n    }\r\n\r\n    this.initialDropzone = dropzone;\r\n\r\n    for (const dropzoneElement of this.dropzones) {\r\n      if (dropzoneElement.classList.contains(this.getClassNameFor('droppable:occupied'))) {\r\n        continue;\r\n      }\r\n\r\n      dropzoneElement.classList.add(...this.getClassNamesFor('droppable:active'));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag move handler\r\n   * @private\r\n   * @param {DragMoveEvent} event - Drag move event\r\n   */\r\n  [onDragMove](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const dropzone = this[closestDropzone](event.sensorEvent.target);\r\n    const overEmptyDropzone = dropzone && !dropzone.classList.contains(this.getClassNameFor('droppable:occupied'));\r\n\r\n    if (overEmptyDropzone && this[dropInDropzone](event, dropzone)) {\r\n      this.lastDropzone = dropzone;\r\n    } else if ((!dropzone || dropzone === this.initialDropzone) && this.lastDropzone) {\r\n      this[returnToOriginalDropzone](event);\r\n      this.lastDropzone = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop](event) {\r\n    const droppableStopEvent = new _DroppableEvent.DroppableStopEvent({\r\n      dragEvent: event,\r\n      dropzone: this.lastDropzone || this.initialDropzone\r\n    });\r\n\r\n    this.trigger(droppableStopEvent);\r\n\r\n    const occupiedClasses = this.getClassNamesFor('droppable:occupied');\r\n\r\n    for (const dropzone of this.dropzones) {\r\n      dropzone.classList.remove(...this.getClassNamesFor('droppable:active'));\r\n    }\r\n\r\n    if (this.lastDropzone && this.lastDropzone !== this.initialDropzone) {\r\n      this.initialDropzone.classList.remove(...occupiedClasses);\r\n    }\r\n\r\n    this.dropzones = null;\r\n    this.lastDropzone = null;\r\n    this.initialDropzone = null;\r\n  }\r\n\r\n  /**\r\n   * Drops a draggable element into a dropzone element\r\n   * @private\r\n   * @param {DragMoveEvent} event - Drag move event\r\n   * @param {HTMLElement} dropzone - Dropzone element to drop draggable into\r\n   */\r\n  [dropInDropzone](event, dropzone) {\r\n    const droppableDroppedEvent = new _DroppableEvent.DroppableDroppedEvent({\r\n      dragEvent: event,\r\n      dropzone\r\n    });\r\n\r\n    this.trigger(droppableDroppedEvent);\r\n\r\n    if (droppableDroppedEvent.canceled()) {\r\n      return false;\r\n    }\r\n\r\n    const occupiedClasses = this.getClassNamesFor('droppable:occupied');\r\n\r\n    if (this.lastDropzone) {\r\n      this.lastDropzone.classList.remove(...occupiedClasses);\r\n    }\r\n\r\n    dropzone.appendChild(event.source);\r\n    dropzone.classList.add(...occupiedClasses);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Moves the previously dropped element back into its original dropzone\r\n   * @private\r\n   * @param {DragMoveEvent} event - Drag move event\r\n   */\r\n  [returnToOriginalDropzone](event) {\r\n    const droppableReturnedEvent = new _DroppableEvent.DroppableReturnedEvent({\r\n      dragEvent: event,\r\n      dropzone: this.lastDropzone\r\n    });\r\n\r\n    this.trigger(droppableReturnedEvent);\r\n\r\n    if (droppableReturnedEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    this.initialDropzone.appendChild(event.source);\r\n    this.lastDropzone.classList.remove(...this.getClassNamesFor('droppable:occupied'));\r\n  }\r\n\r\n  /**\r\n   * Returns closest dropzone element for even target\r\n   * @private\r\n   * @param {HTMLElement} target - Event target\r\n   * @return {HTMLElement|null}\r\n   */\r\n  [closestDropzone](target) {\r\n    if (!this.dropzones) {\r\n      return null;\r\n    }\r\n\r\n    return (0, _utils.closest)(target, this.dropzones);\r\n  }\r\n\r\n  /**\r\n   * Returns all current dropzone elements for this draggable instance\r\n   * @private\r\n   * @return {NodeList|HTMLElement[]|Array}\r\n   */\r\n  [getDropzones]() {\r\n    const dropzone = this.options.dropzone;\r\n\r\n    if (typeof dropzone === 'string') {\r\n      return document.querySelectorAll(dropzone);\r\n    } else if (dropzone instanceof NodeList || dropzone instanceof Array) {\r\n      return dropzone;\r\n    } else if (typeof dropzone === 'function') {\r\n      return dropzone();\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n}\r\nexports.default = Droppable;\r\n\r\n/***/ }),\r\n/* 35 */\r\n/***/ (function(module, exports, __nested_webpack_require_83263__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DroppableStopEvent = exports.DroppableReturnedEvent = exports.DroppableDroppedEvent = exports.DroppableStartEvent = exports.DroppableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_83263__(1);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base droppable event\r\n * @class DroppableEvent\r\n * @module DroppableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DroppableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Original drag event that triggered this droppable event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n}\r\n\r\nexports.DroppableEvent = DroppableEvent; /**\r\n                                          * Droppable start event\r\n                                          * @class DroppableStartEvent\r\n                                          * @module DroppableStartEvent\r\n                                          * @extends DroppableEvent\r\n                                          */\r\n\r\nDroppableEvent.type = 'droppable';\r\nclass DroppableStartEvent extends DroppableEvent {\r\n\r\n  /**\r\n   * The initial dropzone element of the currently dragging draggable element\r\n   * @property dropzone\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get dropzone() {\r\n    return this.data.dropzone;\r\n  }\r\n}\r\n\r\nexports.DroppableStartEvent = DroppableStartEvent; /**\r\n                                                    * Droppable dropped event\r\n                                                    * @class DroppableDroppedEvent\r\n                                                    * @module DroppableDroppedEvent\r\n                                                    * @extends DroppableEvent\r\n                                                    */\r\n\r\nDroppableStartEvent.type = 'droppable:start';\r\nDroppableStartEvent.cancelable = true;\r\nclass DroppableDroppedEvent extends DroppableEvent {\r\n\r\n  /**\r\n   * The dropzone element you dropped the draggable element into\r\n   * @property dropzone\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get dropzone() {\r\n    return this.data.dropzone;\r\n  }\r\n}\r\n\r\nexports.DroppableDroppedEvent = DroppableDroppedEvent; /**\r\n                                                        * Droppable returned event\r\n                                                        * @class DroppableReturnedEvent\r\n                                                        * @module DroppableReturnedEvent\r\n                                                        * @extends DroppableEvent\r\n                                                        */\r\n\r\nDroppableDroppedEvent.type = 'droppable:dropped';\r\nDroppableDroppedEvent.cancelable = true;\r\nclass DroppableReturnedEvent extends DroppableEvent {\r\n\r\n  /**\r\n   * The dropzone element you dragged away from\r\n   * @property dropzone\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get dropzone() {\r\n    return this.data.dropzone;\r\n  }\r\n}\r\n\r\nexports.DroppableReturnedEvent = DroppableReturnedEvent; /**\r\n                                                          * Droppable stop event\r\n                                                          * @class DroppableStopEvent\r\n                                                          * @module DroppableStopEvent\r\n                                                          * @extends DroppableEvent\r\n                                                          */\r\n\r\nDroppableReturnedEvent.type = 'droppable:returned';\r\nDroppableReturnedEvent.cancelable = true;\r\nclass DroppableStopEvent extends DroppableEvent {\r\n\r\n  /**\r\n   * The final dropzone element of the draggable element\r\n   * @property dropzone\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get dropzone() {\r\n    return this.data.dropzone;\r\n  }\r\n}\r\nexports.DroppableStopEvent = DroppableStopEvent;\r\nDroppableStopEvent.type = 'droppable:stop';\r\nDroppableStopEvent.cancelable = true;\r\n\r\n/***/ }),\r\n/* 36 */\r\n/***/ (function(module, exports, __nested_webpack_require_87426__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DroppableEvent = __nested_webpack_require_87426__(11);\r\n\r\nObject.keys(_DroppableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DroppableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Droppable = __nested_webpack_require_87426__(34);\r\n\r\nvar _Droppable2 = _interopRequireDefault(_Droppable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Droppable2.default;\r\n\r\n/***/ }),\r\n/* 37 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * The Emitter is a simple emitter class that provides you with `on()`, `off()` and `trigger()` methods\r\n * @class Emitter\r\n * @module Emitter\r\n */\r\nclass Emitter {\r\n  constructor() {\r\n    this.callbacks = {};\r\n  }\r\n\r\n  /**\r\n   * Registers callbacks by event name\r\n   * @param {String} type\r\n   * @param {...Function} callbacks\r\n   */\r\n  on(type, ...callbacks) {\r\n    if (!this.callbacks[type]) {\r\n      this.callbacks[type] = [];\r\n    }\r\n\r\n    this.callbacks[type].push(...callbacks);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Unregisters callbacks by event name\r\n   * @param {String} type\r\n   * @param {Function} callback\r\n   */\r\n  off(type, callback) {\r\n    if (!this.callbacks[type]) {\r\n      return null;\r\n    }\r\n\r\n    const copy = this.callbacks[type].slice(0);\r\n\r\n    for (let i = 0; i < copy.length; i++) {\r\n      if (callback === copy[i]) {\r\n        this.callbacks[type].splice(i, 1);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Triggers event callbacks by event object\r\n   * @param {AbstractEvent} event\r\n   */\r\n  trigger(event) {\r\n    if (!this.callbacks[event.type]) {\r\n      return null;\r\n    }\r\n\r\n    const callbacks = [...this.callbacks[event.type]];\r\n    const caughtErrors = [];\r\n\r\n    for (let i = callbacks.length - 1; i >= 0; i--) {\r\n      const callback = callbacks[i];\r\n\r\n      try {\r\n        callback(event);\r\n      } catch (error) {\r\n        caughtErrors.push(error);\r\n      }\r\n    }\r\n\r\n    if (caughtErrors.length) {\r\n      /* eslint-disable no-console */\r\n      console.error(`Draggable caught errors while triggering '${event.type}'`, caughtErrors);\r\n      /* eslint-disable no-console */\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\nexports.default = Emitter;\r\n\r\n/***/ }),\r\n/* 38 */\r\n/***/ (function(module, exports, __nested_webpack_require_90010__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Emitter = __nested_webpack_require_90010__(37);\r\n\r\nvar _Emitter2 = _interopRequireDefault(_Emitter);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Emitter2.default;\r\n\r\n/***/ }),\r\n/* 39 */\r\n/***/ (function(module, exports, __nested_webpack_require_90414__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _utils = __nested_webpack_require_90414__(2);\r\n\r\nvar _Plugins = __nested_webpack_require_90414__(12);\r\n\r\nvar _Emitter = __nested_webpack_require_90414__(38);\r\n\r\nvar _Emitter2 = _interopRequireDefault(_Emitter);\r\n\r\nvar _Sensors = __nested_webpack_require_90414__(6);\r\n\r\nvar _DraggableEvent = __nested_webpack_require_90414__(13);\r\n\r\nvar _DragEvent = __nested_webpack_require_90414__(14);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragMove = Symbol('onDragMove');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst onDragPressure = Symbol('onDragPressure');\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['drag:start']\r\n * @const {Function} defaultAnnouncements['drag:stop']\r\n */\r\nconst defaultAnnouncements = {\r\n  'drag:start': event => `Picked up ${event.source.textContent.trim() || event.source.id || 'draggable element'}`,\r\n  'drag:stop': event => `Released ${event.source.textContent.trim() || event.source.id || 'draggable element'}`\r\n};\r\n\r\nconst defaultClasses = {\r\n  'container:dragging': 'draggable-container--is-dragging',\r\n  'source:dragging': 'draggable-source--is-dragging',\r\n  'source:placed': 'draggable-source--placed',\r\n  'container:placed': 'draggable-container--placed',\r\n  'body:dragging': 'draggable--is-dragging',\r\n  'draggable:over': 'draggable--over',\r\n  'container:over': 'draggable-container--over',\r\n  'source:original': 'draggable--original',\r\n  mirror: 'draggable-mirror'\r\n};\r\n\r\nconst defaultOptions = exports.defaultOptions = {\r\n  draggable: '.draggable-source',\r\n  handle: null,\r\n  delay: {},\r\n  distance: 0,\r\n  placedTimeout: 800,\r\n  plugins: [],\r\n  sensors: [],\r\n  exclude: {\r\n    plugins: [],\r\n    sensors: []\r\n  }\r\n};\r\n\r\n/**\r\n * This is the core draggable library that does the heavy lifting\r\n * @class Draggable\r\n * @module Draggable\r\n */\r\nclass Draggable {\r\n\r\n  /**\r\n   * Draggable constructor.\r\n   * @constructs Draggable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Draggable containers\r\n   * @param {Object} options - Options for draggable\r\n   */\r\n\r\n  /**\r\n   * Default plugins draggable uses\r\n   * @static\r\n   * @property {Object} Plugins\r\n   * @property {Announcement} Plugins.Announcement\r\n   * @property {Focusable} Plugins.Focusable\r\n   * @property {Mirror} Plugins.Mirror\r\n   * @property {Scrollable} Plugins.Scrollable\r\n   * @type {Object}\r\n   */\r\n  constructor(containers = [document.body], options = {}) {\r\n    /**\r\n     * Draggable containers\r\n     * @property containers\r\n     * @type {HTMLElement[]}\r\n     */\r\n    if (containers instanceof NodeList || containers instanceof Array) {\r\n      this.containers = [...containers];\r\n    } else if (containers instanceof HTMLElement) {\r\n      this.containers = [containers];\r\n    } else {\r\n      throw new Error('Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`');\r\n    }\r\n\r\n    this.options = _extends({}, defaultOptions, options, {\r\n      classes: _extends({}, defaultClasses, options.classes || {}),\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {}),\r\n      exclude: {\r\n        plugins: options.exclude && options.exclude.plugins || [],\r\n        sensors: options.exclude && options.exclude.sensors || []\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Draggables event emitter\r\n     * @property emitter\r\n     * @type {Emitter}\r\n     */\r\n    this.emitter = new _Emitter2.default();\r\n\r\n    /**\r\n     * Current drag state\r\n     * @property dragging\r\n     * @type {Boolean}\r\n     */\r\n    this.dragging = false;\r\n\r\n    /**\r\n     * Active plugins\r\n     * @property plugins\r\n     * @type {Plugin[]}\r\n     */\r\n    this.plugins = [];\r\n\r\n    /**\r\n     * Active sensors\r\n     * @property sensors\r\n     * @type {Sensor[]}\r\n     */\r\n    this.sensors = [];\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onDragPressure] = this[onDragPressure].bind(this);\r\n\r\n    document.addEventListener('drag:start', this[onDragStart], true);\r\n    document.addEventListener('drag:move', this[onDragMove], true);\r\n    document.addEventListener('drag:stop', this[onDragStop], true);\r\n    document.addEventListener('drag:pressure', this[onDragPressure], true);\r\n\r\n    const defaultPlugins = Object.values(Draggable.Plugins).filter(Plugin => !this.options.exclude.plugins.includes(Plugin));\r\n    const defaultSensors = Object.values(Draggable.Sensors).filter(sensor => !this.options.exclude.sensors.includes(sensor));\r\n\r\n    this.addPlugin(...[...defaultPlugins, ...this.options.plugins]);\r\n    this.addSensor(...[...defaultSensors, ...this.options.sensors]);\r\n\r\n    const draggableInitializedEvent = new _DraggableEvent.DraggableInitializedEvent({\r\n      draggable: this\r\n    });\r\n\r\n    this.on('mirror:created', ({ mirror }) => this.mirror = mirror);\r\n    this.on('mirror:destroy', () => this.mirror = null);\r\n\r\n    this.trigger(draggableInitializedEvent);\r\n  }\r\n\r\n  /**\r\n   * Destroys Draggable instance. This removes all internal event listeners and\r\n   * deactivates sensors and plugins\r\n   */\r\n\r\n\r\n  /**\r\n   * Default sensors draggable uses\r\n   * @static\r\n   * @property {Object} Sensors\r\n   * @property {MouseSensor} Sensors.MouseSensor\r\n   * @property {TouchSensor} Sensors.TouchSensor\r\n   * @type {Object}\r\n   */\r\n  destroy() {\r\n    document.removeEventListener('drag:start', this[onDragStart], true);\r\n    document.removeEventListener('drag:move', this[onDragMove], true);\r\n    document.removeEventListener('drag:stop', this[onDragStop], true);\r\n    document.removeEventListener('drag:pressure', this[onDragPressure], true);\r\n\r\n    const draggableDestroyEvent = new _DraggableEvent.DraggableDestroyEvent({\r\n      draggable: this\r\n    });\r\n\r\n    this.trigger(draggableDestroyEvent);\r\n\r\n    this.removePlugin(...this.plugins.map(plugin => plugin.constructor));\r\n    this.removeSensor(...this.sensors.map(sensor => sensor.constructor));\r\n  }\r\n\r\n  /**\r\n   * Adds plugin to this draggable instance. This will end up calling the attach method of the plugin\r\n   * @param {...typeof Plugin} plugins - Plugins that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addPlugin(CustomA11yPlugin, CustomMirrorPlugin)\r\n   */\r\n  addPlugin(...plugins) {\r\n    const activePlugins = plugins.map(Plugin => new Plugin(this));\r\n\r\n    activePlugins.forEach(plugin => plugin.attach());\r\n    this.plugins = [...this.plugins, ...activePlugins];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes plugins that are already attached to this draggable instance. This will end up calling\r\n   * the detach method of the plugin\r\n   * @param {...typeof Plugin} plugins - Plugins that you want detached from draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removePlugin(MirrorPlugin, CustomMirrorPlugin)\r\n   */\r\n  removePlugin(...plugins) {\r\n    const removedPlugins = this.plugins.filter(plugin => plugins.includes(plugin.constructor));\r\n\r\n    removedPlugins.forEach(plugin => plugin.detach());\r\n    this.plugins = this.plugins.filter(plugin => !plugins.includes(plugin.constructor));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds sensors to this draggable instance. This will end up calling the attach method of the sensor\r\n   * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addSensor(ForceTouchSensor, CustomSensor)\r\n   */\r\n  addSensor(...sensors) {\r\n    const activeSensors = sensors.map(Sensor => new Sensor(this.containers, this.options));\r\n\r\n    activeSensors.forEach(sensor => sensor.attach());\r\n    this.sensors = [...this.sensors, ...activeSensors];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes sensors that are already attached to this draggable instance. This will end up calling\r\n   * the detach method of the sensor\r\n   * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removeSensor(TouchSensor, DragSensor)\r\n   */\r\n  removeSensor(...sensors) {\r\n    const removedSensors = this.sensors.filter(sensor => sensors.includes(sensor.constructor));\r\n\r\n    removedSensors.forEach(sensor => sensor.detach());\r\n    this.sensors = this.sensors.filter(sensor => !sensors.includes(sensor.constructor));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds container to this draggable instance\r\n   * @param {...HTMLElement} containers - Containers you want to add to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addContainer(document.body)\r\n   */\r\n  addContainer(...containers) {\r\n    this.containers = [...this.containers, ...containers];\r\n    this.sensors.forEach(sensor => sensor.addContainer(...containers));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes container from this draggable instance\r\n   * @param {...HTMLElement} containers - Containers you want to remove from draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removeContainer(document.body)\r\n   */\r\n  removeContainer(...containers) {\r\n    this.containers = this.containers.filter(container => !containers.includes(container));\r\n    this.sensors.forEach(sensor => sensor.removeContainer(...containers));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds listener for draggable events\r\n   * @param {String} type - Event name\r\n   * @param {...Function} callbacks - Event callbacks\r\n   * @return {Draggable}\r\n   * @example draggable.on('drag:start', (dragEvent) => dragEvent.cancel());\r\n   */\r\n  on(type, ...callbacks) {\r\n    this.emitter.on(type, ...callbacks);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes listener from draggable\r\n   * @param {String} type - Event name\r\n   * @param {Function} callback - Event callback\r\n   * @return {Draggable}\r\n   * @example draggable.off('drag:start', handlerFunction);\r\n   */\r\n  off(type, callback) {\r\n    this.emitter.off(type, callback);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Triggers draggable event\r\n   * @param {AbstractEvent} event - Event instance\r\n   * @return {Draggable}\r\n   * @example draggable.trigger(event);\r\n   */\r\n  trigger(event) {\r\n    this.emitter.trigger(event);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns class name for class identifier\r\n   * @param {String} name - Name of class identifier\r\n   * @return {String|null}\r\n   */\r\n  getClassNameFor(name) {\r\n    return this.getClassNamesFor(name)[0];\r\n  }\r\n\r\n  /**\r\n   * Returns class names for class identifier\r\n   * @return {String[]}\r\n   */\r\n  getClassNamesFor(name) {\r\n    const classNames = this.options.classes[name];\r\n\r\n    if (classNames instanceof Array) {\r\n      return classNames;\r\n    } else if (typeof classNames === 'string' || classNames instanceof String) {\r\n      return [classNames];\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if this draggable instance is currently dragging\r\n   * @return {Boolean}\r\n   */\r\n  isDragging() {\r\n    return Boolean(this.dragging);\r\n  }\r\n\r\n  /**\r\n   * Returns all draggable elements\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getDraggableElements() {\r\n    return this.containers.reduce((current, container) => {\r\n      return [...current, ...this.getDraggableElementsForContainer(container)];\r\n    }, []);\r\n  }\r\n\r\n  /**\r\n   * Returns draggable elements for a given container, excluding the mirror and\r\n   * original source element if present\r\n   * @param {HTMLElement} container\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getDraggableElementsForContainer(container) {\r\n    const allDraggableElements = container.querySelectorAll(this.options.draggable);\r\n\r\n    return [...allDraggableElements].filter(childElement => {\r\n      return childElement !== this.originalSource && childElement !== this.mirror;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragStart](event) {\r\n    const sensorEvent = getSensorEvent(event);\r\n    const { target, container } = sensorEvent;\r\n\r\n    if (!this.containers.includes(container)) {\r\n      return;\r\n    }\r\n\r\n    if (this.options.handle && target && !(0, _utils.closest)(target, this.options.handle)) {\r\n      sensorEvent.cancel();\r\n      return;\r\n    }\r\n\r\n    // Find draggable source element\r\n    this.originalSource = (0, _utils.closest)(target, this.options.draggable);\r\n    this.sourceContainer = container;\r\n\r\n    if (!this.originalSource) {\r\n      sensorEvent.cancel();\r\n      return;\r\n    }\r\n\r\n    if (this.lastPlacedSource && this.lastPlacedContainer) {\r\n      clearTimeout(this.placedTimeoutID);\r\n      this.lastPlacedSource.classList.remove(...this.getClassNamesFor('source:placed'));\r\n      this.lastPlacedContainer.classList.remove(...this.getClassNamesFor('container:placed'));\r\n    }\r\n\r\n    this.source = this.originalSource.cloneNode(true);\r\n    this.originalSource.parentNode.insertBefore(this.source, this.originalSource);\r\n    this.originalSource.style.display = 'none';\r\n\r\n    const dragEvent = new _DragEvent.DragStartEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sourceContainer: container,\r\n      sensorEvent\r\n    });\r\n\r\n    this.trigger(dragEvent);\r\n\r\n    this.dragging = !dragEvent.canceled();\r\n\r\n    if (dragEvent.canceled()) {\r\n      this.source.parentNode.removeChild(this.source);\r\n      this.originalSource.style.display = null;\r\n      return;\r\n    }\r\n\r\n    this.originalSource.classList.add(...this.getClassNamesFor('source:original'));\r\n    this.source.classList.add(...this.getClassNamesFor('source:dragging'));\r\n    this.sourceContainer.classList.add(...this.getClassNamesFor('container:dragging'));\r\n    document.body.classList.add(...this.getClassNamesFor('body:dragging'));\r\n    applyUserSelect(document.body, 'none');\r\n\r\n    requestAnimationFrame(() => {\r\n      const oldSensorEvent = getSensorEvent(event);\r\n      const newSensorEvent = oldSensorEvent.clone({ target: this.source });\r\n\r\n      this[onDragMove](_extends({}, event, {\r\n        detail: newSensorEvent\r\n      }));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag move handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = getSensorEvent(event);\r\n    const { container } = sensorEvent;\r\n    let target = sensorEvent.target;\r\n\r\n    const dragMoveEvent = new _DragEvent.DragMoveEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sourceContainer: container,\r\n      sensorEvent\r\n    });\r\n\r\n    this.trigger(dragMoveEvent);\r\n\r\n    if (dragMoveEvent.canceled()) {\r\n      sensorEvent.cancel();\r\n    }\r\n\r\n    target = (0, _utils.closest)(target, this.options.draggable);\r\n    const withinCorrectContainer = (0, _utils.closest)(sensorEvent.target, this.containers);\r\n    const overContainer = sensorEvent.overContainer || withinCorrectContainer;\r\n    const isLeavingContainer = this.currentOverContainer && overContainer !== this.currentOverContainer;\r\n    const isLeavingDraggable = this.currentOver && target !== this.currentOver;\r\n    const isOverContainer = overContainer && this.currentOverContainer !== overContainer;\r\n    const isOverDraggable = withinCorrectContainer && target && this.currentOver !== target;\r\n\r\n    if (isLeavingDraggable) {\r\n      const dragOutEvent = new _DragEvent.DragOutEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        over: this.currentOver,\r\n        overContainer: this.currentOverContainer\r\n      });\r\n\r\n      this.currentOver.classList.remove(...this.getClassNamesFor('draggable:over'));\r\n      this.currentOver = null;\r\n\r\n      this.trigger(dragOutEvent);\r\n    }\r\n\r\n    if (isLeavingContainer) {\r\n      const dragOutContainerEvent = new _DragEvent.DragOutContainerEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer: this.currentOverContainer\r\n      });\r\n\r\n      this.currentOverContainer.classList.remove(...this.getClassNamesFor('container:over'));\r\n      this.currentOverContainer = null;\r\n\r\n      this.trigger(dragOutContainerEvent);\r\n    }\r\n\r\n    if (isOverContainer) {\r\n      overContainer.classList.add(...this.getClassNamesFor('container:over'));\r\n\r\n      const dragOverContainerEvent = new _DragEvent.DragOverContainerEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer\r\n      });\r\n\r\n      this.currentOverContainer = overContainer;\r\n\r\n      this.trigger(dragOverContainerEvent);\r\n    }\r\n\r\n    if (isOverDraggable) {\r\n      target.classList.add(...this.getClassNamesFor('draggable:over'));\r\n\r\n      const dragOverEvent = new _DragEvent.DragOverEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer,\r\n        over: target\r\n      });\r\n\r\n      this.currentOver = target;\r\n\r\n      this.trigger(dragOverEvent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragStop](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    this.dragging = false;\r\n\r\n    const dragStopEvent = new _DragEvent.DragStopEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sensorEvent: event.sensorEvent,\r\n      sourceContainer: this.sourceContainer\r\n    });\r\n\r\n    this.trigger(dragStopEvent);\r\n\r\n    this.source.parentNode.insertBefore(this.originalSource, this.source);\r\n    this.source.parentNode.removeChild(this.source);\r\n    this.originalSource.style.display = '';\r\n\r\n    this.source.classList.remove(...this.getClassNamesFor('source:dragging'));\r\n    this.originalSource.classList.remove(...this.getClassNamesFor('source:original'));\r\n    this.originalSource.classList.add(...this.getClassNamesFor('source:placed'));\r\n    this.sourceContainer.classList.add(...this.getClassNamesFor('container:placed'));\r\n    this.sourceContainer.classList.remove(...this.getClassNamesFor('container:dragging'));\r\n    document.body.classList.remove(...this.getClassNamesFor('body:dragging'));\r\n    applyUserSelect(document.body, '');\r\n\r\n    if (this.currentOver) {\r\n      this.currentOver.classList.remove(...this.getClassNamesFor('draggable:over'));\r\n    }\r\n\r\n    if (this.currentOverContainer) {\r\n      this.currentOverContainer.classList.remove(...this.getClassNamesFor('container:over'));\r\n    }\r\n\r\n    this.lastPlacedSource = this.originalSource;\r\n    this.lastPlacedContainer = this.sourceContainer;\r\n\r\n    this.placedTimeoutID = setTimeout(() => {\r\n      if (this.lastPlacedSource) {\r\n        this.lastPlacedSource.classList.remove(...this.getClassNamesFor('source:placed'));\r\n      }\r\n\r\n      if (this.lastPlacedContainer) {\r\n        this.lastPlacedContainer.classList.remove(...this.getClassNamesFor('container:placed'));\r\n      }\r\n\r\n      this.lastPlacedSource = null;\r\n      this.lastPlacedContainer = null;\r\n    }, this.options.placedTimeout);\r\n\r\n    const dragStoppedEvent = new _DragEvent.DragStoppedEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sensorEvent: event.sensorEvent,\r\n      sourceContainer: this.sourceContainer\r\n    });\r\n\r\n    this.trigger(dragStoppedEvent);\r\n\r\n    this.source = null;\r\n    this.originalSource = null;\r\n    this.currentOverContainer = null;\r\n    this.currentOver = null;\r\n    this.sourceContainer = null;\r\n  }\r\n\r\n  /**\r\n   * Drag pressure handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragPressure](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = getSensorEvent(event);\r\n    const source = this.source || (0, _utils.closest)(sensorEvent.originalEvent.target, this.options.draggable);\r\n\r\n    const dragPressureEvent = new _DragEvent.DragPressureEvent({\r\n      sensorEvent,\r\n      source,\r\n      pressure: sensorEvent.pressure\r\n    });\r\n\r\n    this.trigger(dragPressureEvent);\r\n  }\r\n}\r\n\r\nexports.default = Draggable;\r\nDraggable.Plugins = { Announcement: _Plugins.Announcement, Focusable: _Plugins.Focusable, Mirror: _Plugins.Mirror, Scrollable: _Plugins.Scrollable };\r\nDraggable.Sensors = { MouseSensor: _Sensors.MouseSensor, TouchSensor: _Sensors.TouchSensor };\r\nfunction getSensorEvent(event) {\r\n  return event.detail;\r\n}\r\n\r\nfunction applyUserSelect(element, value) {\r\n  element.style.webkitUserSelect = value;\r\n  element.style.mozUserSelect = value;\r\n  element.style.msUserSelect = value;\r\n  element.style.oUserSelect = value;\r\n  element.style.userSelect = value;\r\n}\r\n\r\n/***/ }),\r\n/* 40 */\r\n/***/ (function(module, exports, __nested_webpack_require_111550__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_111550__(4);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_111550__(3);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMouseForceWillBegin = Symbol('onMouseForceWillBegin');\r\nconst onMouseForceDown = Symbol('onMouseForceDown');\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseForceChange = Symbol('onMouseForceChange');\r\nconst onMouseMove = Symbol('onMouseMove');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst onMouseForceGlobalChange = Symbol('onMouseForceGlobalChange');\r\n\r\n/**\r\n * This sensor picks up native force touch events and dictates drag operations\r\n * @class ForceTouchSensor\r\n * @module ForceTouchSensor\r\n * @extends Sensor\r\n */\r\nclass ForceTouchSensor extends _Sensor2.default {\r\n  /**\r\n   * ForceTouchSensor constructor.\r\n   * @constructs ForceTouchSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed\r\n     * @property mightDrag\r\n     * @type {Boolean}\r\n     */\r\n    this.mightDrag = false;\r\n\r\n    this[onMouseForceWillBegin] = this[onMouseForceWillBegin].bind(this);\r\n    this[onMouseForceDown] = this[onMouseForceDown].bind(this);\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseForceChange] = this[onMouseForceChange].bind(this);\r\n    this[onMouseMove] = this[onMouseMove].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    for (const container of this.containers) {\r\n      container.addEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\r\n      container.addEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\r\n      container.addEventListener('mousedown', this[onMouseDown], true);\r\n      container.addEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\r\n    }\r\n\r\n    document.addEventListener('mousemove', this[onMouseMove]);\r\n    document.addEventListener('mouseup', this[onMouseUp]);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    for (const container of this.containers) {\r\n      container.removeEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\r\n      container.removeEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\r\n      container.removeEventListener('mousedown', this[onMouseDown], true);\r\n      container.removeEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\r\n    }\r\n\r\n    document.removeEventListener('mousemove', this[onMouseMove]);\r\n    document.removeEventListener('mouseup', this[onMouseUp]);\r\n  }\r\n\r\n  /**\r\n   * Mouse force will begin handler\r\n   * @private\r\n   * @param {Event} event - Mouse force will begin event\r\n   */\r\n  [onMouseForceWillBegin](event) {\r\n    event.preventDefault();\r\n    this.mightDrag = true;\r\n  }\r\n\r\n  /**\r\n   * Mouse force down handler\r\n   * @private\r\n   * @param {Event} event - Mouse force down event\r\n   */\r\n  [onMouseForceDown](event) {\r\n    if (this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = event.currentTarget;\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragStartEvent);\r\n\r\n    this.currentContainer = container;\r\n    this.dragging = !dragStartEvent.canceled();\r\n    this.mightDrag = false;\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target: null,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.mightDrag = false;\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    if (!this.mightDrag) {\r\n      return;\r\n    }\r\n\r\n    // Need workaround for real click\r\n    // Cancel potential drag events\r\n    event.stopPropagation();\r\n    event.stopImmediatePropagation();\r\n    event.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler\r\n   * @private\r\n   * @param {Event} event - Mouse force will begin event\r\n   */\r\n  [onMouseMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse force change handler\r\n   * @private\r\n   * @param {Event} event - Mouse force change event\r\n   */\r\n  [onMouseForceChange](event) {\r\n    if (this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = event.target;\r\n    const container = event.currentTarget;\r\n\r\n    const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({\r\n      pressure: event.webkitForce,\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragPressureEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse force global change handler\r\n   * @private\r\n   * @param {Event} event - Mouse force global change event\r\n   */\r\n  [onMouseForceGlobalChange](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = event.target;\r\n\r\n    const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({\r\n      pressure: event.webkitForce,\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragPressureEvent);\r\n  }\r\n}\r\nexports.default = ForceTouchSensor;\r\n\r\n/***/ }),\r\n/* 41 */\r\n/***/ (function(module, exports, __nested_webpack_require_118290__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _ForceTouchSensor = __nested_webpack_require_118290__(40);\r\n\r\nvar _ForceTouchSensor2 = _interopRequireDefault(_ForceTouchSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _ForceTouchSensor2.default;\r\n\r\n/***/ }),\r\n/* 42 */\r\n/***/ (function(module, exports, __nested_webpack_require_118730__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_118730__(2);\r\n\r\nvar _Sensor = __nested_webpack_require_118730__(4);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_118730__(3);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragEnd = Symbol('onDragEnd');\r\nconst onDrop = Symbol('onDrop');\r\nconst reset = Symbol('reset');\r\n\r\n/**\r\n * This sensor picks up native browser drag events and dictates drag operations\r\n * @class DragSensor\r\n * @module DragSensor\r\n * @extends Sensor\r\n */\r\nclass DragSensor extends _Sensor2.default {\r\n  /**\r\n   * DragSensor constructor.\r\n   * @constructs DragSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Mouse down timer which will end up setting the draggable attribute, unless canceled\r\n     * @property mouseDownTimeout\r\n     * @type {Number}\r\n     */\r\n    this.mouseDownTimeout = null;\r\n\r\n    /**\r\n     * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed\r\n     * @property draggableElement\r\n     * @type {HTMLElement}\r\n     */\r\n    this.draggableElement = null;\r\n\r\n    /**\r\n     * Native draggable element could be links or images, their draggable state will be disabled during drag operation\r\n     * @property nativeDraggableElement\r\n     * @type {HTMLElement}\r\n     */\r\n    this.nativeDraggableElement = null;\r\n\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragEnd] = this[onDragEnd].bind(this);\r\n    this[onDrop] = this[onDrop].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {Event} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    // Need for firefox. \"text\" key is needed for IE\r\n    event.dataTransfer.setData('text', '');\r\n    event.dataTransfer.effectAllowed = this.options.type;\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    this.currentContainer = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!this.currentContainer) {\r\n      return;\r\n    }\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    // Workaround\r\n    setTimeout(() => {\r\n      this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n      if (dragStartEvent.canceled()) {\r\n        this.dragging = false;\r\n      } else {\r\n        this.dragging = true;\r\n      }\r\n    }, 0);\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {Event} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = this.currentContainer;\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragMoveEvent);\r\n\r\n    if (!dragMoveEvent.canceled()) {\r\n      event.preventDefault();\r\n      event.dataTransfer.dropEffect = this.options.type;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag end handler\r\n   * @private\r\n   * @param {Event} event - Drag end event\r\n   */\r\n  [onDragEnd](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp], true);\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = this.currentContainer;\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragStopEvent);\r\n\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n\r\n    this[reset]();\r\n  }\r\n\r\n  /**\r\n   * Drop handler\r\n   * @private\r\n   * @param {Event} event - Drop event\r\n   */\r\n  [onDrop](event) {\r\n    // eslint-disable-line class-methods-use-this\r\n    event.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    // Firefox bug for inputs within draggables https://bugzilla.mozilla.org/show_bug.cgi?id=739071\r\n    if (event.target && (event.target.form || event.target.contenteditable)) {\r\n      return;\r\n    }\r\n\r\n    const nativeDraggableElement = (0, _utils.closest)(event.target, element => element.draggable);\r\n\r\n    if (nativeDraggableElement) {\r\n      nativeDraggableElement.draggable = false;\r\n      this.nativeDraggableElement = nativeDraggableElement;\r\n    }\r\n\r\n    document.addEventListener('mouseup', this[onMouseUp], true);\r\n    document.addEventListener('dragstart', this[onDragStart], false);\r\n    document.addEventListener('dragover', this[onDragOver], false);\r\n    document.addEventListener('dragend', this[onDragEnd], false);\r\n    document.addEventListener('drop', this[onDrop], false);\r\n\r\n    const target = (0, _utils.closest)(event.target, this.options.draggable);\r\n\r\n    if (!target) {\r\n      return;\r\n    }\r\n\r\n    this.startEvent = event;\r\n\r\n    this.mouseDownTimeout = setTimeout(() => {\r\n      target.draggable = true;\r\n      this.draggableElement = target;\r\n    }, this.delay.drag);\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp]() {\r\n    this[reset]();\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [reset]() {\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp], true);\r\n    document.removeEventListener('dragstart', this[onDragStart], false);\r\n    document.removeEventListener('dragover', this[onDragOver], false);\r\n    document.removeEventListener('dragend', this[onDragEnd], false);\r\n    document.removeEventListener('drop', this[onDrop], false);\r\n\r\n    if (this.nativeDraggableElement) {\r\n      this.nativeDraggableElement.draggable = true;\r\n      this.nativeDraggableElement = null;\r\n    }\r\n\r\n    if (this.draggableElement) {\r\n      this.draggableElement.draggable = false;\r\n      this.draggableElement = null;\r\n    }\r\n  }\r\n}\r\nexports.default = DragSensor;\r\n\r\n/***/ }),\r\n/* 43 */\r\n/***/ (function(module, exports, __nested_webpack_require_126003__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragSensor = __nested_webpack_require_126003__(42);\r\n\r\nvar _DragSensor2 = _interopRequireDefault(_DragSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _DragSensor2.default;\r\n\r\n/***/ }),\r\n/* 44 */\r\n/***/ (function(module, exports, __nested_webpack_require_126419__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_126419__(2);\r\n\r\nvar _Sensor = __nested_webpack_require_126419__(4);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_126419__(3);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onTouchStart = Symbol('onTouchStart');\r\nconst onTouchEnd = Symbol('onTouchEnd');\r\nconst onTouchMove = Symbol('onTouchMove');\r\nconst startDrag = Symbol('startDrag');\r\nconst onDistanceChange = Symbol('onDistanceChange');\r\n\r\n/**\r\n * Prevents scrolling when set to true\r\n * @var {Boolean} preventScrolling\r\n */\r\nlet preventScrolling = false;\r\n\r\n// WebKit requires cancelable `touchmove` events to be added as early as possible\r\nwindow.addEventListener('touchmove', event => {\r\n  if (!preventScrolling) {\r\n    return;\r\n  }\r\n\r\n  // Prevent scrolling\r\n  event.preventDefault();\r\n}, { passive: false });\r\n\r\n/**\r\n * This sensor picks up native browser touch events and dictates drag operations\r\n * @class TouchSensor\r\n * @module TouchSensor\r\n * @extends Sensor\r\n */\r\nclass TouchSensor extends _Sensor2.default {\r\n  /**\r\n   * TouchSensor constructor.\r\n   * @constructs TouchSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Closest scrollable container so accidental scroll can cancel long touch\r\n     * @property currentScrollableParent\r\n     * @type {HTMLElement}\r\n     */\r\n    this.currentScrollableParent = null;\r\n\r\n    /**\r\n     * TimeoutID for managing delay\r\n     * @property tapTimeout\r\n     * @type {Number}\r\n     */\r\n    this.tapTimeout = null;\r\n\r\n    /**\r\n     * touchMoved indicates if touch has moved during tapTimeout\r\n     * @property touchMoved\r\n     * @type {Boolean}\r\n     */\r\n    this.touchMoved = false;\r\n\r\n    /**\r\n     * Save pageX coordinates for delay drag\r\n     * @property {Numbre} pageX\r\n     * @private\r\n     */\r\n    this.pageX = null;\r\n\r\n    /**\r\n     * Save pageY coordinates for delay drag\r\n     * @property {Numbre} pageY\r\n     * @private\r\n     */\r\n    this.pageY = null;\r\n\r\n    this[onTouchStart] = this[onTouchStart].bind(this);\r\n    this[onTouchEnd] = this[onTouchEnd].bind(this);\r\n    this[onTouchMove] = this[onTouchMove].bind(this);\r\n    this[startDrag] = this[startDrag].bind(this);\r\n    this[onDistanceChange] = this[onDistanceChange].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('touchstart', this[onTouchStart]);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('touchstart', this[onTouchStart]);\r\n  }\r\n\r\n  /**\r\n   * Touch start handler\r\n   * @private\r\n   * @param {Event} event - Touch start event\r\n   */\r\n  [onTouchStart](event) {\r\n    const container = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!container) {\r\n      return;\r\n    }\r\n    const { distance = 0 } = this.options;\r\n    const { delay } = this;\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n    this.onTouchStartAt = Date.now();\r\n    this.startEvent = event;\r\n    this.currentContainer = container;\r\n\r\n    document.addEventListener('touchend', this[onTouchEnd]);\r\n    document.addEventListener('touchcancel', this[onTouchEnd]);\r\n    document.addEventListener('touchmove', this[onDistanceChange]);\r\n    container.addEventListener('contextmenu', onContextMenu);\r\n\r\n    if (distance) {\r\n      preventScrolling = true;\r\n    }\r\n\r\n    this.tapTimeout = window.setTimeout(() => {\r\n      this[onDistanceChange]({ touches: [{ pageX: this.pageX, pageY: this.pageY }] });\r\n    }, delay.touch);\r\n  }\r\n\r\n  /**\r\n   * Start the drag\r\n   * @private\r\n   */\r\n  [startDrag]() {\r\n    const startEvent = this.startEvent;\r\n    const container = this.currentContainer;\r\n    const touch = (0, _utils.touchCoords)(startEvent);\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: touch.pageX,\r\n      clientY: touch.pageY,\r\n      target: startEvent.target,\r\n      container,\r\n      originalEvent: startEvent\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n    this.dragging = !dragStartEvent.canceled();\r\n\r\n    if (this.dragging) {\r\n      document.addEventListener('touchmove', this[onTouchMove]);\r\n    }\r\n    preventScrolling = this.dragging;\r\n  }\r\n\r\n  /**\r\n   * Touch move handler prior to drag start.\r\n   * @private\r\n   * @param {Event} event - Touch move event\r\n   */\r\n  [onDistanceChange](event) {\r\n    const { distance } = this.options;\r\n    const { startEvent, delay } = this;\r\n    const start = (0, _utils.touchCoords)(startEvent);\r\n    const current = (0, _utils.touchCoords)(event);\r\n    const timeElapsed = Date.now() - this.onTouchStartAt;\r\n    const distanceTravelled = (0, _utils.distance)(start.pageX, start.pageY, current.pageX, current.pageY);\r\n\r\n    Object.assign(this, current);\r\n\r\n    clearTimeout(this.tapTimeout);\r\n\r\n    if (timeElapsed < delay.touch) {\r\n      // moved during delay\r\n      document.removeEventListener('touchmove', this[onDistanceChange]);\r\n    } else if (distanceTravelled >= distance) {\r\n      document.removeEventListener('touchmove', this[onDistanceChange]);\r\n      this[startDrag]();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler while dragging\r\n   * @private\r\n   * @param {Event} event - Touch move event\r\n   */\r\n  [onTouchMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n    const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: pageX,\r\n      clientY: pageY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Touch end handler\r\n   * @private\r\n   * @param {Event} event - Touch end event\r\n   */\r\n  [onTouchEnd](event) {\r\n    clearTimeout(this.tapTimeout);\r\n    preventScrolling = false;\r\n\r\n    document.removeEventListener('touchend', this[onTouchEnd]);\r\n    document.removeEventListener('touchcancel', this[onTouchEnd]);\r\n    document.removeEventListener('touchmove', this[onDistanceChange]);\r\n\r\n    if (this.currentContainer) {\r\n      this.currentContainer.removeEventListener('contextmenu', onContextMenu);\r\n    }\r\n\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('touchmove', this[onTouchMove]);\r\n\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n    const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);\r\n\r\n    event.preventDefault();\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: pageX,\r\n      clientY: pageY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n  }\r\n}\r\n\r\nexports.default = TouchSensor;\r\nfunction onContextMenu(event) {\r\n  event.preventDefault();\r\n  event.stopPropagation();\r\n}\r\n\r\n/***/ }),\r\n/* 45 */\r\n/***/ (function(module, exports, __nested_webpack_require_133899__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _TouchSensor = __nested_webpack_require_133899__(44);\r\n\r\nvar _TouchSensor2 = _interopRequireDefault(_TouchSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _TouchSensor2.default;\r\n\r\n/***/ }),\r\n/* 46 */\r\n/***/ (function(module, exports, __nested_webpack_require_134319__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DragPressureSensorEvent = exports.DragStopSensorEvent = exports.DragMoveSensorEvent = exports.DragStartSensorEvent = exports.SensorEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_134319__(1);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base sensor event\r\n * @class SensorEvent\r\n * @module SensorEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SensorEvent extends _AbstractEvent2.default {\r\n  /**\r\n   * Original browser event that triggered a sensor\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    return this.data.originalEvent;\r\n  }\r\n\r\n  /**\r\n   * Normalized clientX for both touch and mouse events\r\n   * @property clientX\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get clientX() {\r\n    return this.data.clientX;\r\n  }\r\n\r\n  /**\r\n   * Normalized clientY for both touch and mouse events\r\n   * @property clientY\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get clientY() {\r\n    return this.data.clientY;\r\n  }\r\n\r\n  /**\r\n   * Normalized target for both touch and mouse events\r\n   * Returns the element that is behind cursor or touch pointer\r\n   * @property target\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get target() {\r\n    return this.data.target;\r\n  }\r\n\r\n  /**\r\n   * Container that initiated the sensor\r\n   * @property container\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get container() {\r\n    return this.data.container;\r\n  }\r\n\r\n  /**\r\n   * Trackpad pressure\r\n   * @property pressure\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get pressure() {\r\n    return this.data.pressure;\r\n  }\r\n}\r\n\r\nexports.SensorEvent = SensorEvent; /**\r\n                                    * Drag start sensor event\r\n                                    * @class DragStartSensorEvent\r\n                                    * @module DragStartSensorEvent\r\n                                    * @extends SensorEvent\r\n                                    */\r\n\r\nclass DragStartSensorEvent extends SensorEvent {}\r\n\r\nexports.DragStartSensorEvent = DragStartSensorEvent; /**\r\n                                                      * Drag move sensor event\r\n                                                      * @class DragMoveSensorEvent\r\n                                                      * @module DragMoveSensorEvent\r\n                                                      * @extends SensorEvent\r\n                                                      */\r\n\r\nDragStartSensorEvent.type = 'drag:start';\r\nclass DragMoveSensorEvent extends SensorEvent {}\r\n\r\nexports.DragMoveSensorEvent = DragMoveSensorEvent; /**\r\n                                                    * Drag stop sensor event\r\n                                                    * @class DragStopSensorEvent\r\n                                                    * @module DragStopSensorEvent\r\n                                                    * @extends SensorEvent\r\n                                                    */\r\n\r\nDragMoveSensorEvent.type = 'drag:move';\r\nclass DragStopSensorEvent extends SensorEvent {}\r\n\r\nexports.DragStopSensorEvent = DragStopSensorEvent; /**\r\n                                                    * Drag pressure sensor event\r\n                                                    * @class DragPressureSensorEvent\r\n                                                    * @module DragPressureSensorEvent\r\n                                                    * @extends SensorEvent\r\n                                                    */\r\n\r\nDragStopSensorEvent.type = 'drag:stop';\r\nclass DragPressureSensorEvent extends SensorEvent {}\r\nexports.DragPressureSensorEvent = DragPressureSensorEvent;\r\nDragPressureSensorEvent.type = 'drag:pressure';\r\n\r\n/***/ }),\r\n/* 47 */\r\n/***/ (function(module, exports, __nested_webpack_require_138310__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_138310__(2);\r\n\r\nvar _Sensor = __nested_webpack_require_138310__(4);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_138310__(3);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onContextMenuWhileDragging = Symbol('onContextMenuWhileDragging');\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseMove = Symbol('onMouseMove');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst startDrag = Symbol('startDrag');\r\nconst onDistanceChange = Symbol('onDistanceChange');\r\n\r\n/**\r\n * This sensor picks up native browser mouse events and dictates drag operations\r\n * @class MouseSensor\r\n * @module MouseSensor\r\n * @extends Sensor\r\n */\r\nclass MouseSensor extends _Sensor2.default {\r\n  /**\r\n   * MouseSensor constructor.\r\n   * @constructs MouseSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Mouse down timer which will end up triggering the drag start operation\r\n     * @property mouseDownTimeout\r\n     * @type {Number}\r\n     */\r\n    this.mouseDownTimeout = null;\r\n\r\n    /**\r\n     * Save pageX coordinates for delay drag\r\n     * @property {Numbre} pageX\r\n     * @private\r\n     */\r\n    this.pageX = null;\r\n\r\n    /**\r\n     * Save pageY coordinates for delay drag\r\n     * @property {Numbre} pageY\r\n     * @private\r\n     */\r\n    this.pageY = null;\r\n\r\n    this[onContextMenuWhileDragging] = this[onContextMenuWhileDragging].bind(this);\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseMove] = this[onMouseMove].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n    this[startDrag] = this[startDrag].bind(this);\r\n    this[onDistanceChange] = this[onDistanceChange].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    if (event.button !== 0 || event.ctrlKey || event.metaKey) {\r\n      return;\r\n    }\r\n    const container = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!container) {\r\n      return;\r\n    }\r\n\r\n    const { delay } = this;\r\n    const { pageX, pageY } = event;\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n    this.onMouseDownAt = Date.now();\r\n    this.startEvent = event;\r\n\r\n    this.currentContainer = container;\r\n    document.addEventListener('mouseup', this[onMouseUp]);\r\n    document.addEventListener('dragstart', preventNativeDragStart);\r\n    document.addEventListener('mousemove', this[onDistanceChange]);\r\n\r\n    this.mouseDownTimeout = window.setTimeout(() => {\r\n      this[onDistanceChange]({ pageX: this.pageX, pageY: this.pageY });\r\n    }, delay.mouse);\r\n  }\r\n\r\n  /**\r\n   * Start the drag\r\n   * @private\r\n   */\r\n  [startDrag]() {\r\n    const startEvent = this.startEvent;\r\n    const container = this.currentContainer;\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: startEvent.clientX,\r\n      clientY: startEvent.clientY,\r\n      target: startEvent.target,\r\n      container,\r\n      originalEvent: startEvent\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n    this.dragging = !dragStartEvent.canceled();\r\n\r\n    if (this.dragging) {\r\n      document.addEventListener('contextmenu', this[onContextMenuWhileDragging], true);\r\n      document.addEventListener('mousemove', this[onMouseMove]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect change in distance, starting drag when both\r\n   * delay and distance requirements are met\r\n   * @private\r\n   * @param {Event} event - Mouse move event\r\n   */\r\n  [onDistanceChange](event) {\r\n    const { pageX, pageY } = event;\r\n    const { distance } = this.options;\r\n    const { startEvent, delay } = this;\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n\r\n    if (!this.currentContainer) {\r\n      return;\r\n    }\r\n\r\n    const timeElapsed = Date.now() - this.onMouseDownAt;\r\n    const distanceTravelled = (0, _utils.distance)(startEvent.pageX, startEvent.pageY, pageX, pageY) || 0;\r\n\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    if (timeElapsed < delay.mouse) {\r\n      // moved during delay\r\n      document.removeEventListener('mousemove', this[onDistanceChange]);\r\n    } else if (distanceTravelled >= distance) {\r\n      document.removeEventListener('mousemove', this[onDistanceChange]);\r\n      this[startDrag]();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler\r\n   * @private\r\n   * @param {Event} event - Mouse move event\r\n   */\r\n  [onMouseMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp](event) {\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    if (event.button !== 0) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp]);\r\n    document.removeEventListener('dragstart', preventNativeDragStart);\r\n    document.removeEventListener('mousemove', this[onDistanceChange]);\r\n\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    document.removeEventListener('contextmenu', this[onContextMenuWhileDragging], true);\r\n    document.removeEventListener('mousemove', this[onMouseMove]);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n  }\r\n\r\n  /**\r\n   * Context menu handler\r\n   * @private\r\n   * @param {Event} event - Context menu event\r\n   */\r\n  [onContextMenuWhileDragging](event) {\r\n    event.preventDefault();\r\n  }\r\n}\r\n\r\nexports.default = MouseSensor;\r\nfunction preventNativeDragStart(event) {\r\n  event.preventDefault();\r\n}\r\n\r\n/***/ }),\r\n/* 48 */\r\n/***/ (function(module, exports, __nested_webpack_require_145182__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _MouseSensor = __nested_webpack_require_145182__(47);\r\n\r\nvar _MouseSensor2 = _interopRequireDefault(_MouseSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _MouseSensor2.default;\r\n\r\n/***/ }),\r\n/* 49 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst defaultDealy = {\r\n  mouse: 0,\r\n  drag: 0,\r\n  touch: 100\r\n};\r\n\r\n/**\r\n * Base sensor class. Extend from this class to create a new or custom sensor\r\n * @class Sensor\r\n * @module Sensor\r\n */\r\nclass Sensor {\r\n  /**\r\n   * Sensor constructor.\r\n   * @constructs Sensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    /**\r\n     * Current containers\r\n     * @property containers\r\n     * @type {HTMLElement[]}\r\n     */\r\n    this.containers = [...containers];\r\n\r\n    /**\r\n     * Current options\r\n     * @property options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, options);\r\n\r\n    /**\r\n     * Current drag state\r\n     * @property dragging\r\n     * @type {Boolean}\r\n     */\r\n    this.dragging = false;\r\n\r\n    /**\r\n     * Current container\r\n     * @property currentContainer\r\n     * @type {HTMLElement}\r\n     */\r\n    this.currentContainer = null;\r\n\r\n    /**\r\n     * The event of the initial sensor down\r\n     * @property startEvent\r\n     * @type {Event}\r\n     */\r\n    this.startEvent = null;\r\n\r\n    /**\r\n     * The delay of each sensor\r\n     * @property delay\r\n     * @type {Object}\r\n     */\r\n    this.delay = calcDelay(options.delay);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   * @return {Sensor}\r\n   */\r\n  attach() {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   * @return {Sensor}\r\n   */\r\n  detach() {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds container to this sensor instance\r\n   * @param {...HTMLElement} containers - Containers you want to add to this sensor\r\n   * @example draggable.addContainer(document.body)\r\n   */\r\n  addContainer(...containers) {\r\n    this.containers = [...this.containers, ...containers];\r\n  }\r\n\r\n  /**\r\n   * Removes container from this sensor instance\r\n   * @param {...HTMLElement} containers - Containers you want to remove from this sensor\r\n   * @example draggable.removeContainer(document.body)\r\n   */\r\n  removeContainer(...containers) {\r\n    this.containers = this.containers.filter(container => !containers.includes(container));\r\n  }\r\n\r\n  /**\r\n   * Triggers event on target element\r\n   * @param {HTMLElement} element - Element to trigger event on\r\n   * @param {SensorEvent} sensorEvent - Sensor event to trigger\r\n   */\r\n  trigger(element, sensorEvent) {\r\n    const event = document.createEvent('Event');\r\n    event.detail = sensorEvent;\r\n    event.initEvent(sensorEvent.type, true, true);\r\n    element.dispatchEvent(event);\r\n    this.lastEvent = sensorEvent;\r\n\r\n    return sensorEvent;\r\n  }\r\n}\r\n\r\nexports.default = Sensor; /**\r\n                           * Calculate the delay of each sensor through the delay in the options\r\n                           * @param {undefined|Number|Object} optionsDelay - the delay in the options\r\n                           * @return {Object}\r\n                           */\r\n\r\nfunction calcDelay(optionsDelay) {\r\n  const delay = {};\r\n\r\n  if (optionsDelay === undefined) {\r\n    return _extends({}, defaultDealy);\r\n  }\r\n\r\n  if (typeof optionsDelay === 'number') {\r\n    for (const key in defaultDealy) {\r\n      if (defaultDealy.hasOwnProperty(key)) {\r\n        delay[key] = optionsDelay;\r\n      }\r\n    }\r\n    return delay;\r\n  }\r\n\r\n  for (const key in defaultDealy) {\r\n    if (defaultDealy.hasOwnProperty(key)) {\r\n      if (optionsDelay[key] === undefined) {\r\n        delay[key] = defaultDealy[key];\r\n      } else {\r\n        delay[key] = optionsDelay[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  return delay;\r\n}\r\n\r\n/***/ }),\r\n/* 50 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = touchCoords;\r\n/**\r\n * Returns the first touch event found in touches or changedTouches of a touch events.\r\n * @param {TouchEvent} event a touch event\r\n * @return {Touch} a touch object\r\n */\r\nfunction touchCoords(event = {}) {\r\n  const { touches, changedTouches } = event;\r\n  return touches && touches[0] || changedTouches && changedTouches[0];\r\n}\r\n\r\n/***/ }),\r\n/* 51 */\r\n/***/ (function(module, exports, __nested_webpack_require_150139__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_150139__(50);\r\n\r\nvar _touchCoords2 = _interopRequireDefault(_touchCoords);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _touchCoords2.default;\r\n\r\n/***/ }),\r\n/* 52 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = distance;\r\n/**\r\n * Returns the distance between two points\r\n * @param  {Number} x1 The X position of the first point\r\n * @param  {Number} y1 The Y position of the first point\r\n * @param  {Number} x2 The X position of the second point\r\n * @param  {Number} y2 The Y position of the second point\r\n * @return {Number}\r\n */\r\nfunction distance(x1, y1, x2, y2) {\r\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\r\n}\r\n\r\n/***/ }),\r\n/* 53 */\r\n/***/ (function(module, exports, __nested_webpack_require_151160__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _distance = __nested_webpack_require_151160__(52);\r\n\r\nvar _distance2 = _interopRequireDefault(_distance);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _distance2.default;\r\n\r\n/***/ }),\r\n/* 54 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = requestNextAnimationFrame;\r\nfunction requestNextAnimationFrame(callback) {\r\n  return requestAnimationFrame(() => {\r\n    requestAnimationFrame(callback);\r\n  });\r\n}\r\n\r\n/***/ }),\r\n/* 55 */\r\n/***/ (function(module, exports, __nested_webpack_require_151919__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_151919__(54);\r\n\r\nvar _requestNextAnimationFrame2 = _interopRequireDefault(_requestNextAnimationFrame);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _requestNextAnimationFrame2.default;\r\n\r\n/***/ }),\r\n/* 56 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = closest;\r\nconst matchFunction = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector;\r\n\r\n/**\r\n * Get the closest parent element of a given element that matches the given\r\n * selector string or matching function\r\n *\r\n * @param {Element} element The child element to find a parent of\r\n * @param {String|Function} selector The string or function to use to match\r\n *     the parent element\r\n * @return {Element|null}\r\n */\r\nfunction closest(element, value) {\r\n  if (!element) {\r\n    return null;\r\n  }\r\n\r\n  const selector = value;\r\n  const callback = value;\r\n  const nodeList = value;\r\n  const singleElement = value;\r\n\r\n  const isSelector = Boolean(typeof value === 'string');\r\n  const isFunction = Boolean(typeof value === 'function');\r\n  const isNodeList = Boolean(value instanceof NodeList || value instanceof Array);\r\n  const isElement = Boolean(value instanceof HTMLElement);\r\n\r\n  function conditionFn(currentElement) {\r\n    if (!currentElement) {\r\n      return currentElement;\r\n    } else if (isSelector) {\r\n      return matchFunction.call(currentElement, selector);\r\n    } else if (isNodeList) {\r\n      return [...nodeList].includes(currentElement);\r\n    } else if (isElement) {\r\n      return singleElement === currentElement;\r\n    } else if (isFunction) {\r\n      return callback(currentElement);\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  let current = element;\r\n\r\n  do {\r\n    current = current.correspondingUseElement || current.correspondingElement || current;\r\n\r\n    if (conditionFn(current)) {\r\n      return current;\r\n    }\r\n\r\n    current = current.parentNode;\r\n  } while (current && current !== document.body && current !== document);\r\n\r\n  return null;\r\n}\r\n\r\n/***/ }),\r\n/* 57 */\r\n/***/ (function(module, exports, __nested_webpack_require_154349__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_154349__(56);\r\n\r\nvar _closest2 = _interopRequireDefault(_closest);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _closest2.default;\r\n\r\n/***/ }),\r\n/* 58 */\r\n/***/ (function(module, exports, __nested_webpack_require_154753__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = exports.scroll = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_154753__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _utils = __nested_webpack_require_154753__(2);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = exports.onDragStart = Symbol('onDragStart');\r\nconst onDragMove = exports.onDragMove = Symbol('onDragMove');\r\nconst onDragStop = exports.onDragStop = Symbol('onDragStop');\r\nconst scroll = exports.scroll = Symbol('scroll');\r\n\r\n/**\r\n * Scrollable default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.speed\r\n * @property {Number} defaultOptions.sensitivity\r\n * @property {HTMLElement[]} defaultOptions.scrollableElements\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  speed: 6,\r\n  sensitivity: 50,\r\n  scrollableElements: []\r\n};\r\n\r\n/**\r\n * Scrollable plugin which scrolls the closest scrollable parent\r\n * @class Scrollable\r\n * @module Scrollable\r\n * @extends AbstractPlugin\r\n */\r\nclass Scrollable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Scrollable constructor.\r\n   * @constructs Scrollable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Scrollable options\r\n     * @property {Object} options\r\n     * @property {Number} options.speed\r\n     * @property {Number} options.sensitivity\r\n     * @property {HTMLElement[]} options.scrollableElements\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Keeps current mouse position\r\n     * @property {Object} currentMousePosition\r\n     * @property {Number} currentMousePosition.clientX\r\n     * @property {Number} currentMousePosition.clientY\r\n     * @type {Object|null}\r\n     */\r\n    this.currentMousePosition = null;\r\n\r\n    /**\r\n     * Scroll animation frame\r\n     * @property scrollAnimationFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.scrollAnimationFrame = null;\r\n\r\n    /**\r\n     * Closest scrollable element\r\n     * @property scrollableElement\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.scrollableElement = null;\r\n\r\n    /**\r\n     * Animation frame looking for the closest scrollable element\r\n     * @property findScrollableElementFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.findScrollableElementFrame = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[scroll] = this[scroll].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.scrollable || {};\r\n  }\r\n\r\n  /**\r\n   * Returns closest scrollable elements by element\r\n   * @param {HTMLElement} target\r\n   * @return {HTMLElement}\r\n   */\r\n  getScrollableElement(target) {\r\n    if (this.hasDefinedScrollableElements()) {\r\n      return (0, _utils.closest)(target, this.options.scrollableElements) || document.documentElement;\r\n    } else {\r\n      return closestScrollableElement(target);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if at least one scrollable element have been defined via options\r\n   * @param {HTMLElement} target\r\n   * @return {Boolean}\r\n   */\r\n  hasDefinedScrollableElements() {\r\n    return Boolean(this.options.scrollableElements.length !== 0);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler. Finds closest scrollable parent in separate frame\r\n   * @param {DragStartEvent} dragEvent\r\n   * @private\r\n   */\r\n  [onDragStart](dragEvent) {\r\n    this.findScrollableElementFrame = requestAnimationFrame(() => {\r\n      this.scrollableElement = this.getScrollableElement(dragEvent.source);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag move handler. Remembers mouse position and initiates scrolling\r\n   * @param {DragMoveEvent} dragEvent\r\n   * @private\r\n   */\r\n  [onDragMove](dragEvent) {\r\n    this.findScrollableElementFrame = requestAnimationFrame(() => {\r\n      this.scrollableElement = this.getScrollableElement(dragEvent.sensorEvent.target);\r\n    });\r\n\r\n    if (!this.scrollableElement) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = dragEvent.sensorEvent;\r\n    const scrollOffset = { x: 0, y: 0 };\r\n\r\n    if ('ontouchstart' in window) {\r\n      scrollOffset.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\r\n      scrollOffset.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;\r\n    }\r\n\r\n    this.currentMousePosition = {\r\n      clientX: sensorEvent.clientX - scrollOffset.x,\r\n      clientY: sensorEvent.clientY - scrollOffset.y\r\n    };\r\n\r\n    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler. Cancels scroll animations and resets state\r\n   * @private\r\n   */\r\n  [onDragStop]() {\r\n    cancelAnimationFrame(this.scrollAnimationFrame);\r\n    cancelAnimationFrame(this.findScrollableElementFrame);\r\n\r\n    this.scrollableElement = null;\r\n    this.scrollAnimationFrame = null;\r\n    this.findScrollableElementFrame = null;\r\n    this.currentMousePosition = null;\r\n  }\r\n\r\n  /**\r\n   * Scroll function that does the heavylifting\r\n   * @private\r\n   */\r\n  [scroll]() {\r\n    if (!this.scrollableElement || !this.currentMousePosition) {\r\n      return;\r\n    }\r\n\r\n    cancelAnimationFrame(this.scrollAnimationFrame);\r\n\r\n    const { speed, sensitivity } = this.options;\r\n\r\n    const rect = this.scrollableElement.getBoundingClientRect();\r\n    const bottomCutOff = rect.bottom > window.innerHeight;\r\n    const topCutOff = rect.top < 0;\r\n    const cutOff = topCutOff || bottomCutOff;\r\n\r\n    const documentScrollingElement = getDocumentScrollingElement();\r\n    const scrollableElement = this.scrollableElement;\r\n    const clientX = this.currentMousePosition.clientX;\r\n    const clientY = this.currentMousePosition.clientY;\r\n\r\n    if (scrollableElement !== document.body && scrollableElement !== document.documentElement && !cutOff) {\r\n      const { offsetHeight, offsetWidth } = scrollableElement;\r\n\r\n      if (rect.top + offsetHeight - clientY < sensitivity) {\r\n        scrollableElement.scrollTop += speed;\r\n      } else if (clientY - rect.top < sensitivity) {\r\n        scrollableElement.scrollTop -= speed;\r\n      }\r\n\r\n      if (rect.left + offsetWidth - clientX < sensitivity) {\r\n        scrollableElement.scrollLeft += speed;\r\n      } else if (clientX - rect.left < sensitivity) {\r\n        scrollableElement.scrollLeft -= speed;\r\n      }\r\n    } else {\r\n      const { innerHeight, innerWidth } = window;\r\n\r\n      if (clientY < sensitivity) {\r\n        documentScrollingElement.scrollTop -= speed;\r\n      } else if (innerHeight - clientY < sensitivity) {\r\n        documentScrollingElement.scrollTop += speed;\r\n      }\r\n\r\n      if (clientX < sensitivity) {\r\n        documentScrollingElement.scrollLeft -= speed;\r\n      } else if (innerWidth - clientX < sensitivity) {\r\n        documentScrollingElement.scrollLeft += speed;\r\n      }\r\n    }\r\n\r\n    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\r\n  }\r\n}\r\n\r\nexports.default = Scrollable; /**\r\n                               * Returns true if the passed element has overflow\r\n                               * @param {HTMLElement} element\r\n                               * @return {Boolean}\r\n                               * @private\r\n                               */\r\n\r\nfunction hasOverflow(element) {\r\n  const overflowRegex = /(auto|scroll)/;\r\n  const computedStyles = getComputedStyle(element, null);\r\n\r\n  const overflow = computedStyles.getPropertyValue('overflow') + computedStyles.getPropertyValue('overflow-y') + computedStyles.getPropertyValue('overflow-x');\r\n\r\n  return overflowRegex.test(overflow);\r\n}\r\n\r\n/**\r\n * Returns true if the passed element is statically positioned\r\n * @param {HTMLElement} element\r\n * @return {Boolean}\r\n * @private\r\n */\r\nfunction isStaticallyPositioned(element) {\r\n  const position = getComputedStyle(element).getPropertyValue('position');\r\n  return position === 'static';\r\n}\r\n\r\n/**\r\n * Finds closest scrollable element\r\n * @param {HTMLElement} element\r\n * @return {HTMLElement}\r\n * @private\r\n */\r\nfunction closestScrollableElement(element) {\r\n  if (!element) {\r\n    return getDocumentScrollingElement();\r\n  }\r\n\r\n  const position = getComputedStyle(element).getPropertyValue('position');\r\n  const excludeStaticParents = position === 'absolute';\r\n\r\n  const scrollableElement = (0, _utils.closest)(element, parent => {\r\n    if (excludeStaticParents && isStaticallyPositioned(parent)) {\r\n      return false;\r\n    }\r\n    return hasOverflow(parent);\r\n  });\r\n\r\n  if (position === 'fixed' || !scrollableElement) {\r\n    return getDocumentScrollingElement();\r\n  } else {\r\n    return scrollableElement;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns element that scrolls document\r\n * @return {HTMLElement}\r\n * @private\r\n */\r\nfunction getDocumentScrollingElement() {\r\n  return document.scrollingElement || document.documentElement;\r\n}\r\n\r\n/***/ }),\r\n/* 59 */\r\n/***/ (function(module, exports, __nested_webpack_require_164675__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Scrollable = __nested_webpack_require_164675__(58);\r\n\r\nvar _Scrollable2 = _interopRequireDefault(_Scrollable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Scrollable2.default;\r\nexports.defaultOptions = _Scrollable.defaultOptions;\r\n\r\n/***/ }),\r\n/* 60 */\r\n/***/ (function(module, exports, __nested_webpack_require_165182__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.MirrorDestroyEvent = exports.MirrorMoveEvent = exports.MirrorAttachedEvent = exports.MirrorCreatedEvent = exports.MirrorCreateEvent = exports.MirrorEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_165182__(1);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base mirror event\r\n * @class MirrorEvent\r\n * @module MirrorEvent\r\n * @extends AbstractEvent\r\n */\r\nclass MirrorEvent extends _AbstractEvent2.default {\r\n  /**\r\n   * Draggables source element\r\n   * @property source\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get source() {\r\n    return this.data.source;\r\n  }\r\n\r\n  /**\r\n   * Draggables original source element\r\n   * @property originalSource\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get originalSource() {\r\n    return this.data.originalSource;\r\n  }\r\n\r\n  /**\r\n   * Draggables source container element\r\n   * @property sourceContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get sourceContainer() {\r\n    return this.data.sourceContainer;\r\n  }\r\n\r\n  /**\r\n   * Sensor event\r\n   * @property sensorEvent\r\n   * @type {SensorEvent}\r\n   * @readonly\r\n   */\r\n  get sensorEvent() {\r\n    return this.data.sensorEvent;\r\n  }\r\n\r\n  /**\r\n   * Drag event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n\r\n  /**\r\n   * Original event that triggered sensor event\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    if (this.sensorEvent) {\r\n      return this.sensorEvent.originalEvent;\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexports.MirrorEvent = MirrorEvent; /**\r\n                                    * Mirror create event\r\n                                    * @class MirrorCreateEvent\r\n                                    * @module MirrorCreateEvent\r\n                                    * @extends MirrorEvent\r\n                                    */\r\n\r\nclass MirrorCreateEvent extends MirrorEvent {}\r\n\r\nexports.MirrorCreateEvent = MirrorCreateEvent; /**\r\n                                                * Mirror created event\r\n                                                * @class MirrorCreatedEvent\r\n                                                * @module MirrorCreatedEvent\r\n                                                * @extends MirrorEvent\r\n                                                */\r\n\r\nMirrorCreateEvent.type = 'mirror:create';\r\nclass MirrorCreatedEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\n\r\nexports.MirrorCreatedEvent = MirrorCreatedEvent; /**\r\n                                                  * Mirror attached event\r\n                                                  * @class MirrorAttachedEvent\r\n                                                  * @module MirrorAttachedEvent\r\n                                                  * @extends MirrorEvent\r\n                                                  */\r\n\r\nMirrorCreatedEvent.type = 'mirror:created';\r\nclass MirrorAttachedEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\n\r\nexports.MirrorAttachedEvent = MirrorAttachedEvent; /**\r\n                                                    * Mirror move event\r\n                                                    * @class MirrorMoveEvent\r\n                                                    * @module MirrorMoveEvent\r\n                                                    * @extends MirrorEvent\r\n                                                    */\r\n\r\nMirrorAttachedEvent.type = 'mirror:attached';\r\nclass MirrorMoveEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n\r\n  /**\r\n   * Sensor has exceeded mirror's threshold on x axis\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  get passedThreshX() {\r\n    return this.data.passedThreshX;\r\n  }\r\n\r\n  /**\r\n   * Sensor has exceeded mirror's threshold on y axis\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  get passedThreshY() {\r\n    return this.data.passedThreshY;\r\n  }\r\n}\r\n\r\nexports.MirrorMoveEvent = MirrorMoveEvent; /**\r\n                                            * Mirror destroy event\r\n                                            * @class MirrorDestroyEvent\r\n                                            * @module MirrorDestroyEvent\r\n                                            * @extends MirrorEvent\r\n                                            */\r\n\r\nMirrorMoveEvent.type = 'mirror:move';\r\nMirrorMoveEvent.cancelable = true;\r\nclass MirrorDestroyEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\nexports.MirrorDestroyEvent = MirrorDestroyEvent;\r\nMirrorDestroyEvent.type = 'mirror:destroy';\r\nMirrorDestroyEvent.cancelable = true;\r\n\r\n/***/ }),\r\n/* 61 */\r\n/***/ (function(module, exports, __nested_webpack_require_170634__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _MirrorEvent = __nested_webpack_require_170634__(60);\r\n\r\nObject.keys(_MirrorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _MirrorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 62 */\r\n/***/ (function(module, exports, __nested_webpack_require_171102__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = exports.getAppendableContainer = exports.onScroll = exports.onMirrorMove = exports.onMirrorCreated = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_171102__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _MirrorEvent = __nested_webpack_require_171102__(61);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\r\n\r\nconst onDragStart = exports.onDragStart = Symbol('onDragStart');\r\nconst onDragMove = exports.onDragMove = Symbol('onDragMove');\r\nconst onDragStop = exports.onDragStop = Symbol('onDragStop');\r\nconst onMirrorCreated = exports.onMirrorCreated = Symbol('onMirrorCreated');\r\nconst onMirrorMove = exports.onMirrorMove = Symbol('onMirrorMove');\r\nconst onScroll = exports.onScroll = Symbol('onScroll');\r\nconst getAppendableContainer = exports.getAppendableContainer = Symbol('getAppendableContainer');\r\n\r\n/**\r\n * Mirror default options\r\n * @property {Object} defaultOptions\r\n * @property {Boolean} defaultOptions.constrainDimensions\r\n * @property {Boolean} defaultOptions.xAxis\r\n * @property {Boolean} defaultOptions.yAxis\r\n * @property {null} defaultOptions.cursorOffsetX\r\n * @property {null} defaultOptions.cursorOffsetY\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  constrainDimensions: false,\r\n  xAxis: true,\r\n  yAxis: true,\r\n  cursorOffsetX: null,\r\n  cursorOffsetY: null,\r\n  thresholdX: null,\r\n  thresholdY: null\r\n};\r\n\r\n/**\r\n * Mirror plugin which controls the mirror positioning while dragging\r\n * @class Mirror\r\n * @module Mirror\r\n * @extends AbstractPlugin\r\n */\r\nclass Mirror extends _AbstractPlugin2.default {\r\n  /**\r\n   * Mirror constructor.\r\n   * @constructs Mirror\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Mirror options\r\n     * @property {Object} options\r\n     * @property {Boolean} options.constrainDimensions\r\n     * @property {Boolean} options.xAxis\r\n     * @property {Boolean} options.yAxis\r\n     * @property {Number|null} options.cursorOffsetX\r\n     * @property {Number|null} options.cursorOffsetY\r\n     * @property {String|HTMLElement|Function} options.appendTo\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Scroll offset for touch devices because the mirror is positioned fixed\r\n     * @property {Object} scrollOffset\r\n     * @property {Number} scrollOffset.x\r\n     * @property {Number} scrollOffset.y\r\n     */\r\n    this.scrollOffset = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Initial scroll offset for touch devices because the mirror is positioned fixed\r\n     * @property {Object} scrollOffset\r\n     * @property {Number} scrollOffset.x\r\n     * @property {Number} scrollOffset.y\r\n     */\r\n    this.initialScrollOffset = {\r\n      x: window.scrollX,\r\n      y: window.scrollY\r\n    };\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\r\n    this[onMirrorMove] = this[onMirrorMove].bind(this);\r\n    this[onScroll] = this[onScroll].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]).on('mirror:created', this[onMirrorCreated]).on('mirror:move', this[onMirrorMove]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]).off('mirror:created', this[onMirrorCreated]).off('mirror:move', this[onMirrorMove]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.mirror || {};\r\n  }\r\n\r\n  [onDragStart](dragEvent) {\r\n    if (dragEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    if ('ontouchstart' in window) {\r\n      document.addEventListener('scroll', this[onScroll], true);\r\n    }\r\n\r\n    this.initialScrollOffset = {\r\n      x: window.scrollX,\r\n      y: window.scrollY\r\n    };\r\n\r\n    const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    // Last sensor position of mirror move\r\n    this.lastMirrorMovedClient = {\r\n      x: sensorEvent.clientX,\r\n      y: sensorEvent.clientY\r\n    };\r\n\r\n    const mirrorCreateEvent = new _MirrorEvent.MirrorCreateEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent\r\n    });\r\n\r\n    this.draggable.trigger(mirrorCreateEvent);\r\n\r\n    if (isNativeDragEvent(sensorEvent) || mirrorCreateEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const appendableContainer = this[getAppendableContainer](source) || sourceContainer;\r\n    this.mirror = source.cloneNode(true);\r\n\r\n    const mirrorCreatedEvent = new _MirrorEvent.MirrorCreatedEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror\r\n    });\r\n\r\n    const mirrorAttachedEvent = new _MirrorEvent.MirrorAttachedEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror\r\n    });\r\n\r\n    this.draggable.trigger(mirrorCreatedEvent);\r\n    appendableContainer.appendChild(this.mirror);\r\n    this.draggable.trigger(mirrorAttachedEvent);\r\n  }\r\n\r\n  [onDragMove](dragEvent) {\r\n    if (!this.mirror || dragEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    let passedThreshX = true;\r\n    let passedThreshY = true;\r\n\r\n    if (this.options.thresholdX || this.options.thresholdY) {\r\n      const { x: lastX, y: lastY } = this.lastMirrorMovedClient;\r\n\r\n      if (Math.abs(lastX - sensorEvent.clientX) < this.options.thresholdX) {\r\n        passedThreshX = false;\r\n      } else {\r\n        this.lastMirrorMovedClient.x = sensorEvent.clientX;\r\n      }\r\n\r\n      if (Math.abs(lastY - sensorEvent.clientY) < this.options.thresholdY) {\r\n        passedThreshY = false;\r\n      } else {\r\n        this.lastMirrorMovedClient.y = sensorEvent.clientY;\r\n      }\r\n\r\n      if (!passedThreshX && !passedThreshY) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const mirrorMoveEvent = new _MirrorEvent.MirrorMoveEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror,\r\n      passedThreshX,\r\n      passedThreshY\r\n    });\r\n\r\n    this.draggable.trigger(mirrorMoveEvent);\r\n  }\r\n\r\n  [onDragStop](dragEvent) {\r\n    if ('ontouchstart' in window) {\r\n      document.removeEventListener('scroll', this[onScroll], true);\r\n    }\r\n\r\n    this.initialScrollOffset = { x: 0, y: 0 };\r\n    this.scrollOffset = { x: 0, y: 0 };\r\n\r\n    if (!this.mirror) {\r\n      return;\r\n    }\r\n\r\n    const { source, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    const mirrorDestroyEvent = new _MirrorEvent.MirrorDestroyEvent({\r\n      source,\r\n      mirror: this.mirror,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent\r\n    });\r\n\r\n    this.draggable.trigger(mirrorDestroyEvent);\r\n\r\n    if (!mirrorDestroyEvent.canceled()) {\r\n      this.mirror.parentNode.removeChild(this.mirror);\r\n    }\r\n  }\r\n\r\n  [onScroll]() {\r\n    this.scrollOffset = {\r\n      x: window.scrollX - this.initialScrollOffset.x,\r\n      y: window.scrollY - this.initialScrollOffset.y\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Mirror created handler\r\n   * @param {MirrorCreatedEvent} mirrorEvent\r\n   * @return {Promise}\r\n   * @private\r\n   */\r\n  [onMirrorCreated]({ mirror, source, sensorEvent }) {\r\n    const mirrorClasses = this.draggable.getClassNamesFor('mirror');\r\n\r\n    const setState = (_ref) => {\r\n      let { mirrorOffset, initialX, initialY } = _ref,\r\n          args = _objectWithoutProperties(_ref, ['mirrorOffset', 'initialX', 'initialY']);\r\n\r\n      this.mirrorOffset = mirrorOffset;\r\n      this.initialX = initialX;\r\n      this.initialY = initialY;\r\n      this.lastMovedX = initialX;\r\n      this.lastMovedY = initialY;\r\n      return _extends({ mirrorOffset, initialX, initialY }, args);\r\n    };\r\n\r\n    mirror.style.display = 'none';\r\n\r\n    const initialState = {\r\n      mirror,\r\n      source,\r\n      sensorEvent,\r\n      mirrorClasses,\r\n      scrollOffset: this.scrollOffset,\r\n      options: this.options,\r\n      passedThreshX: true,\r\n      passedThreshY: true\r\n    };\r\n\r\n    return Promise.resolve(initialState)\r\n    // Fix reflow here\r\n    .then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({ initial: true })).then(removeMirrorID).then(setState);\r\n  }\r\n\r\n  /**\r\n   * Mirror move handler\r\n   * @param {MirrorMoveEvent} mirrorEvent\r\n   * @return {Promise|null}\r\n   * @private\r\n   */\r\n  [onMirrorMove](mirrorEvent) {\r\n    if (mirrorEvent.canceled()) {\r\n      return null;\r\n    }\r\n\r\n    const setState = (_ref2) => {\r\n      let { lastMovedX, lastMovedY } = _ref2,\r\n          args = _objectWithoutProperties(_ref2, ['lastMovedX', 'lastMovedY']);\r\n\r\n      this.lastMovedX = lastMovedX;\r\n      this.lastMovedY = lastMovedY;\r\n\r\n      return _extends({ lastMovedX, lastMovedY }, args);\r\n    };\r\n\r\n    const initialState = {\r\n      mirror: mirrorEvent.mirror,\r\n      sensorEvent: mirrorEvent.sensorEvent,\r\n      mirrorOffset: this.mirrorOffset,\r\n      options: this.options,\r\n      initialX: this.initialX,\r\n      initialY: this.initialY,\r\n      scrollOffset: this.scrollOffset,\r\n      passedThreshX: mirrorEvent.passedThreshX,\r\n      passedThreshY: mirrorEvent.passedThreshY,\r\n      lastMovedX: this.lastMovedX,\r\n      lastMovedY: this.lastMovedY\r\n    };\r\n\r\n    return Promise.resolve(initialState).then(positionMirror({ raf: true })).then(setState);\r\n  }\r\n\r\n  /**\r\n   * Returns appendable container for mirror based on the appendTo option\r\n   * @private\r\n   * @param {Object} options\r\n   * @param {HTMLElement} options.source - Current source\r\n   * @return {HTMLElement}\r\n   */\r\n  [getAppendableContainer](source) {\r\n    const appendTo = this.options.appendTo;\r\n\r\n    if (typeof appendTo === 'string') {\r\n      return document.querySelector(appendTo);\r\n    } else if (appendTo instanceof HTMLElement) {\r\n      return appendTo;\r\n    } else if (typeof appendTo === 'function') {\r\n      return appendTo(source);\r\n    } else {\r\n      return source.parentNode;\r\n    }\r\n  }\r\n}\r\n\r\nexports.default = Mirror; /**\r\n                           * Computes mirror dimensions based on the source element\r\n                           * Adds sourceRect to state\r\n                           * @param {Object} state\r\n                           * @param {HTMLElement} state.source\r\n                           * @return {Promise}\r\n                           * @private\r\n                           */\r\n\r\nfunction computeMirrorDimensions(_ref3) {\r\n  let { source } = _ref3,\r\n      args = _objectWithoutProperties(_ref3, ['source']);\r\n\r\n  return withPromise(resolve => {\r\n    const sourceRect = source.getBoundingClientRect();\r\n    resolve(_extends({ source, sourceRect }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Calculates mirror offset\r\n * Adds mirrorOffset to state\r\n * @param {Object} state\r\n * @param {SensorEvent} state.sensorEvent\r\n * @param {DOMRect} state.sourceRect\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction calculateMirrorOffset(_ref4) {\r\n  let { sensorEvent, sourceRect, options } = _ref4,\r\n      args = _objectWithoutProperties(_ref4, ['sensorEvent', 'sourceRect', 'options']);\r\n\r\n  return withPromise(resolve => {\r\n    const top = options.cursorOffsetY === null ? sensorEvent.clientY - sourceRect.top : options.cursorOffsetY;\r\n    const left = options.cursorOffsetX === null ? sensorEvent.clientX - sourceRect.left : options.cursorOffsetX;\r\n\r\n    const mirrorOffset = { top, left };\r\n\r\n    resolve(_extends({ sensorEvent, sourceRect, mirrorOffset, options }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Applys mirror styles\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {HTMLElement} state.source\r\n * @param {Object} state.options\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction resetMirror(_ref5) {\r\n  let { mirror, source, options } = _ref5,\r\n      args = _objectWithoutProperties(_ref5, ['mirror', 'source', 'options']);\r\n\r\n  return withPromise(resolve => {\r\n    let offsetHeight;\r\n    let offsetWidth;\r\n\r\n    if (options.constrainDimensions) {\r\n      const computedSourceStyles = getComputedStyle(source);\r\n      offsetHeight = computedSourceStyles.getPropertyValue('height');\r\n      offsetWidth = computedSourceStyles.getPropertyValue('width');\r\n    }\r\n\r\n    mirror.style.display = null;\r\n    mirror.style.position = 'fixed';\r\n    mirror.style.pointerEvents = 'none';\r\n    mirror.style.top = 0;\r\n    mirror.style.left = 0;\r\n    mirror.style.margin = 0;\r\n\r\n    if (options.constrainDimensions) {\r\n      mirror.style.height = offsetHeight;\r\n      mirror.style.width = offsetWidth;\r\n    }\r\n\r\n    resolve(_extends({ mirror, source, options }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Applys mirror class on mirror element\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {String[]} state.mirrorClasses\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction addMirrorClasses(_ref6) {\r\n  let { mirror, mirrorClasses } = _ref6,\r\n      args = _objectWithoutProperties(_ref6, ['mirror', 'mirrorClasses']);\r\n\r\n  return withPromise(resolve => {\r\n    mirror.classList.add(...mirrorClasses);\r\n    resolve(_extends({ mirror, mirrorClasses }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Removes source ID from cloned mirror element\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction removeMirrorID(_ref7) {\r\n  let { mirror } = _ref7,\r\n      args = _objectWithoutProperties(_ref7, ['mirror']);\r\n\r\n  return withPromise(resolve => {\r\n    mirror.removeAttribute('id');\r\n    delete mirror.id;\r\n    resolve(_extends({ mirror }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Positions mirror with translate3d\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {SensorEvent} state.sensorEvent\r\n * @param {Object} state.mirrorOffset\r\n * @param {Number} state.initialY\r\n * @param {Number} state.initialX\r\n * @param {Object} state.options\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction positionMirror({ withFrame = false, initial = false } = {}) {\r\n  return (_ref8) => {\r\n    let {\r\n      mirror,\r\n      sensorEvent,\r\n      mirrorOffset,\r\n      initialY,\r\n      initialX,\r\n      scrollOffset,\r\n      options,\r\n      passedThreshX,\r\n      passedThreshY,\r\n      lastMovedX,\r\n      lastMovedY\r\n    } = _ref8,\r\n        args = _objectWithoutProperties(_ref8, ['mirror', 'sensorEvent', 'mirrorOffset', 'initialY', 'initialX', 'scrollOffset', 'options', 'passedThreshX', 'passedThreshY', 'lastMovedX', 'lastMovedY']);\r\n\r\n    return withPromise(resolve => {\r\n      const result = _extends({\r\n        mirror,\r\n        sensorEvent,\r\n        mirrorOffset,\r\n        options\r\n      }, args);\r\n\r\n      if (mirrorOffset) {\r\n        const x = passedThreshX ? Math.round((sensorEvent.clientX - mirrorOffset.left - scrollOffset.x) / (options.thresholdX || 1)) * (options.thresholdX || 1) : Math.round(lastMovedX);\r\n        const y = passedThreshY ? Math.round((sensorEvent.clientY - mirrorOffset.top - scrollOffset.y) / (options.thresholdY || 1)) * (options.thresholdY || 1) : Math.round(lastMovedY);\r\n\r\n        if (options.xAxis && options.yAxis || initial) {\r\n          mirror.style.transform = `translate3d(${x}px, ${y}px, 0)`;\r\n        } else if (options.xAxis && !options.yAxis) {\r\n          mirror.style.transform = `translate3d(${x}px, ${initialY}px, 0)`;\r\n        } else if (options.yAxis && !options.xAxis) {\r\n          mirror.style.transform = `translate3d(${initialX}px, ${y}px, 0)`;\r\n        }\r\n\r\n        if (initial) {\r\n          result.initialX = x;\r\n          result.initialY = y;\r\n        }\r\n\r\n        result.lastMovedX = x;\r\n        result.lastMovedY = y;\r\n      }\r\n\r\n      resolve(result);\r\n    }, { frame: withFrame });\r\n  };\r\n}\r\n\r\n/**\r\n * Wraps functions in promise with potential animation frame option\r\n * @param {Function} callback\r\n * @param {Object} options\r\n * @param {Boolean} options.raf\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction withPromise(callback, { raf = false } = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    if (raf) {\r\n      requestAnimationFrame(() => {\r\n        callback(resolve, reject);\r\n      });\r\n    } else {\r\n      callback(resolve, reject);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Returns true if the sensor event was triggered by a native browser drag event\r\n * @param {SensorEvent} sensorEvent\r\n */\r\nfunction isNativeDragEvent(sensorEvent) {\r\n  return (/^drag/.test(sensorEvent.originalEvent.type)\r\n  );\r\n}\r\n\r\n/***/ }),\r\n/* 63 */\r\n/***/ (function(module, exports, __nested_webpack_require_188616__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Mirror = __nested_webpack_require_188616__(62);\r\n\r\nvar _Mirror2 = _interopRequireDefault(_Mirror);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Mirror2.default;\r\nexports.defaultOptions = _Mirror.defaultOptions;\r\n\r\n/***/ }),\r\n/* 64 */\r\n/***/ (function(module, exports, __nested_webpack_require_189103__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_189103__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onInitialize = Symbol('onInitialize');\r\nconst onDestroy = Symbol('onDestroy');\r\n\r\n/**\r\n * Focusable default options\r\n * @property {Object} defaultOptions\r\n * @type {Object}\r\n */\r\nconst defaultOptions = {};\r\n\r\n/**\r\n * Focusable plugin\r\n * @class Focusable\r\n * @module Focusable\r\n * @extends AbstractPlugin\r\n */\r\nclass Focusable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Focusable constructor.\r\n   * @constructs Focusable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Focusable options\r\n     * @property {Object} options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    this[onInitialize] = this[onInitialize].bind(this);\r\n    this[onDestroy] = this[onDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches listeners to draggable\r\n   */\r\n  attach() {\r\n    this.draggable.on('draggable:initialize', this[onInitialize]).on('draggable:destroy', this[onDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Detaches listeners from draggable\r\n   */\r\n  detach() {\r\n    this.draggable.off('draggable:initialize', this[onInitialize]).off('draggable:destroy', this[onDestroy]);\r\n\r\n    // Remove modified elements when detach\r\n    this[onDestroy]();\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.focusable || {};\r\n  }\r\n\r\n  /**\r\n   * Returns draggable containers and elements\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getElements() {\r\n    return [...this.draggable.containers, ...this.draggable.getDraggableElements()];\r\n  }\r\n\r\n  /**\r\n   * Intialize handler\r\n   * @private\r\n   */\r\n  [onInitialize]() {\r\n    // Can wait until the next best frame is available\r\n    requestAnimationFrame(() => {\r\n      this.getElements().forEach(element => decorateElement(element));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Destroy handler\r\n   * @private\r\n   */\r\n  [onDestroy]() {\r\n    // Can wait until the next best frame is available\r\n    requestAnimationFrame(() => {\r\n      this.getElements().forEach(element => stripElement(element));\r\n    });\r\n  }\r\n}\r\n\r\nexports.default = Focusable; /**\r\n                              * Keeps track of all the elements that are missing tabindex attributes\r\n                              * so they can be reset when draggable gets destroyed\r\n                              * @const {HTMLElement[]} elementsWithMissingTabIndex\r\n                              */\r\n\r\nconst elementsWithMissingTabIndex = [];\r\n\r\n/**\r\n * Decorates element with tabindex attributes\r\n * @param {HTMLElement} element\r\n * @return {Object}\r\n * @private\r\n */\r\nfunction decorateElement(element) {\r\n  const hasMissingTabIndex = Boolean(!element.getAttribute('tabindex') && element.tabIndex === -1);\r\n\r\n  if (hasMissingTabIndex) {\r\n    elementsWithMissingTabIndex.push(element);\r\n    element.tabIndex = 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Removes elements tabindex attributes\r\n * @param {HTMLElement} element\r\n * @private\r\n */\r\nfunction stripElement(element) {\r\n  const tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);\r\n\r\n  if (tabIndexElementPosition !== -1) {\r\n    element.tabIndex = -1;\r\n    elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);\r\n  }\r\n}\r\n\r\n/***/ }),\r\n/* 65 */\r\n/***/ (function(module, exports, __nested_webpack_require_193015__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Focusable = __nested_webpack_require_193015__(64);\r\n\r\nvar _Focusable2 = _interopRequireDefault(_Focusable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Focusable2.default;\r\n\r\n/***/ }),\r\n/* 66 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * All draggable plugins inherit from this class.\r\n * @abstract\r\n * @class AbstractPlugin\r\n * @module AbstractPlugin\r\n */\r\nclass AbstractPlugin {\r\n  /**\r\n   * AbstractPlugin constructor.\r\n   * @constructs AbstractPlugin\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    /**\r\n     * Draggable instance\r\n     * @property draggable\r\n     * @type {Draggable}\r\n     */\r\n    this.draggable = draggable;\r\n  }\r\n\r\n  /**\r\n   * Override to add listeners\r\n   * @abstract\r\n   */\r\n  attach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n\r\n  /**\r\n   * Override to remove listeners\r\n   * @abstract\r\n   */\r\n  detach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n}\r\nexports.default = AbstractPlugin;\r\n\r\n/***/ }),\r\n/* 67 */\r\n/***/ (function(module, exports, __nested_webpack_require_194339__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_194339__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onInitialize = Symbol('onInitialize');\r\nconst onDestroy = Symbol('onDestroy');\r\nconst announceEvent = Symbol('announceEvent');\r\nconst announceMessage = Symbol('announceMessage');\r\n\r\nconst ARIA_RELEVANT = 'aria-relevant';\r\nconst ARIA_ATOMIC = 'aria-atomic';\r\nconst ARIA_LIVE = 'aria-live';\r\nconst ROLE = 'role';\r\n\r\n/**\r\n * Announcement default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.expire\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  expire: 7000\r\n};\r\n\r\n/**\r\n * Announcement plugin\r\n * @class Announcement\r\n * @module Announcement\r\n * @extends AbstractPlugin\r\n */\r\nclass Announcement extends _AbstractPlugin2.default {\r\n  /**\r\n   * Announcement constructor.\r\n   * @constructs Announcement\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Plugin options\r\n     * @property options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Original draggable trigger method. Hack until we have onAll or on('all')\r\n     * @property originalTriggerMethod\r\n     * @type {Function}\r\n     */\r\n    this.originalTriggerMethod = this.draggable.trigger;\r\n\r\n    this[onInitialize] = this[onInitialize].bind(this);\r\n    this[onDestroy] = this[onDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches listeners to draggable\r\n   */\r\n  attach() {\r\n    this.draggable.on('draggable:initialize', this[onInitialize]);\r\n  }\r\n\r\n  /**\r\n   * Detaches listeners from draggable\r\n   */\r\n  detach() {\r\n    this.draggable.off('draggable:destroy', this[onDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Returns passed in options\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.announcements || {};\r\n  }\r\n\r\n  /**\r\n   * Announces event\r\n   * @private\r\n   * @param {AbstractEvent} event\r\n   */\r\n  [announceEvent](event) {\r\n    const message = this.options[event.type];\r\n\r\n    if (message && typeof message === 'string') {\r\n      this[announceMessage](message);\r\n    }\r\n\r\n    if (message && typeof message === 'function') {\r\n      this[announceMessage](message(event));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Announces message to screen reader\r\n   * @private\r\n   * @param {String} message\r\n   */\r\n  [announceMessage](message) {\r\n    announce(message, { expire: this.options.expire });\r\n  }\r\n\r\n  /**\r\n   * Initialize hander\r\n   * @private\r\n   */\r\n  [onInitialize]() {\r\n    // Hack until there is an api for listening for all events\r\n    this.draggable.trigger = event => {\r\n      try {\r\n        this[announceEvent](event);\r\n      } finally {\r\n        // Ensure that original trigger is called\r\n        this.originalTriggerMethod.call(this.draggable, event);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Destroy hander\r\n   * @private\r\n   */\r\n  [onDestroy]() {\r\n    this.draggable.trigger = this.originalTriggerMethod;\r\n  }\r\n}\r\n\r\nexports.default = Announcement; /**\r\n                                 * @const {HTMLElement} liveRegion\r\n                                 */\r\n\r\nconst liveRegion = createRegion();\r\n\r\n/**\r\n * Announces message via live region\r\n * @param {String} message\r\n * @param {Object} options\r\n * @param {Number} options.expire\r\n */\r\nfunction announce(message, { expire }) {\r\n  const element = document.createElement('div');\r\n\r\n  element.textContent = message;\r\n  liveRegion.appendChild(element);\r\n\r\n  return setTimeout(() => {\r\n    liveRegion.removeChild(element);\r\n  }, expire);\r\n}\r\n\r\n/**\r\n * Creates region element\r\n * @return {HTMLElement}\r\n */\r\nfunction createRegion() {\r\n  const element = document.createElement('div');\r\n\r\n  element.setAttribute('id', 'draggable-live-region');\r\n  element.setAttribute(ARIA_RELEVANT, 'additions');\r\n  element.setAttribute(ARIA_ATOMIC, 'true');\r\n  element.setAttribute(ARIA_LIVE, 'assertive');\r\n  element.setAttribute(ROLE, 'log');\r\n\r\n  element.style.position = 'fixed';\r\n  element.style.width = '1px';\r\n  element.style.height = '1px';\r\n  element.style.top = '-1px';\r\n  element.style.overflow = 'hidden';\r\n\r\n  return element;\r\n}\r\n\r\n// Append live region element as early as possible\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  document.body.appendChild(liveRegion);\r\n});\r\n\r\n/***/ }),\r\n/* 68 */\r\n/***/ (function(module, exports, __nested_webpack_require_199227__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Announcement = __nested_webpack_require_199227__(67);\r\n\r\nvar _Announcement2 = _interopRequireDefault(_Announcement);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Announcement2.default;\r\nexports.defaultOptions = _Announcement.defaultOptions;\r\n\r\n/***/ }),\r\n/* 69 */\r\n/***/ (function(module, exports, __nested_webpack_require_199744__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DraggableDestroyEvent = exports.DraggableInitializedEvent = exports.DraggableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_199744__(1);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base draggable event\r\n * @class DraggableEvent\r\n * @module DraggableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DraggableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Draggable instance\r\n   * @property draggable\r\n   * @type {Draggable}\r\n   * @readonly\r\n   */\r\n  get draggable() {\r\n    return this.data.draggable;\r\n  }\r\n}\r\n\r\nexports.DraggableEvent = DraggableEvent; /**\r\n                                          * Draggable initialized event\r\n                                          * @class DraggableInitializedEvent\r\n                                          * @module DraggableInitializedEvent\r\n                                          * @extends DraggableEvent\r\n                                          */\r\n\r\nDraggableEvent.type = 'draggable';\r\nclass DraggableInitializedEvent extends DraggableEvent {}\r\n\r\nexports.DraggableInitializedEvent = DraggableInitializedEvent; /**\r\n                                                                * Draggable destory event\r\n                                                                * @class DraggableInitializedEvent\r\n                                                                * @module DraggableDestroyEvent\r\n                                                                * @extends DraggableDestroyEvent\r\n                                                                */\r\n\r\nDraggableInitializedEvent.type = 'draggable:initialize';\r\nclass DraggableDestroyEvent extends DraggableEvent {}\r\nexports.DraggableDestroyEvent = DraggableDestroyEvent;\r\nDraggableDestroyEvent.type = 'draggable:destroy';\r\n\r\n/***/ }),\r\n/* 70 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst canceled = Symbol('canceled');\r\n\r\n/**\r\n * All events fired by draggable inherit this class. You can call `cancel()` to\r\n * cancel a specific event or you can check if an event has been canceled by\r\n * calling `canceled()`.\r\n * @abstract\r\n * @class AbstractEvent\r\n * @module AbstractEvent\r\n */\r\nclass AbstractEvent {\r\n\r\n  /**\r\n   * AbstractEvent constructor.\r\n   * @constructs AbstractEvent\r\n   * @param {object} data - Event data\r\n   */\r\n\r\n  /**\r\n   * Event type\r\n   * @static\r\n   * @abstract\r\n   * @property type\r\n   * @type {String}\r\n   */\r\n  constructor(data) {\r\n    this[canceled] = false;\r\n    this.data = data;\r\n  }\r\n\r\n  /**\r\n   * Read-only type\r\n   * @abstract\r\n   * @return {String}\r\n   */\r\n\r\n\r\n  /**\r\n   * Event cancelable\r\n   * @static\r\n   * @abstract\r\n   * @property cancelable\r\n   * @type {Boolean}\r\n   */\r\n  get type() {\r\n    return this.constructor.type;\r\n  }\r\n\r\n  /**\r\n   * Read-only cancelable\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  get cancelable() {\r\n    return this.constructor.cancelable;\r\n  }\r\n\r\n  /**\r\n   * Cancels the event instance\r\n   * @abstract\r\n   */\r\n  cancel() {\r\n    this[canceled] = true;\r\n  }\r\n\r\n  /**\r\n   * Check if event has been canceled\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  canceled() {\r\n    return Boolean(this[canceled]);\r\n  }\r\n\r\n  /**\r\n   * Returns new event instance with existing event data.\r\n   * This method allows for overriding of event data.\r\n   * @param {Object} data\r\n   * @return {AbstractEvent}\r\n   */\r\n  clone(data) {\r\n    return new this.constructor(_extends({}, this.data, data));\r\n  }\r\n}\r\nexports.default = AbstractEvent;\r\nAbstractEvent.type = 'event';\r\nAbstractEvent.cancelable = false;\r\n\r\n/***/ }),\r\n/* 71 */\r\n/***/ (function(module, exports, __nested_webpack_require_203914__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DragStoppedEvent = exports.DragStopEvent = exports.DragPressureEvent = exports.DragOutContainerEvent = exports.DragOverContainerEvent = exports.DragOutEvent = exports.DragOverEvent = exports.DragMoveEvent = exports.DragStartEvent = exports.DragEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_203914__(1);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base drag event\r\n * @class DragEvent\r\n * @module DragEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DragEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Draggables source element\r\n   * @property source\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get source() {\r\n    return this.data.source;\r\n  }\r\n\r\n  /**\r\n   * Draggables original source element\r\n   * @property originalSource\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get originalSource() {\r\n    return this.data.originalSource;\r\n  }\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n\r\n  /**\r\n   * Draggables source container element\r\n   * @property sourceContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get sourceContainer() {\r\n    return this.data.sourceContainer;\r\n  }\r\n\r\n  /**\r\n   * Sensor event\r\n   * @property sensorEvent\r\n   * @type {SensorEvent}\r\n   * @readonly\r\n   */\r\n  get sensorEvent() {\r\n    return this.data.sensorEvent;\r\n  }\r\n\r\n  /**\r\n   * Original event that triggered sensor event\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    if (this.sensorEvent) {\r\n      return this.sensorEvent.originalEvent;\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexports.DragEvent = DragEvent; /**\r\n                                * Drag start event\r\n                                * @class DragStartEvent\r\n                                * @module DragStartEvent\r\n                                * @extends DragEvent\r\n                                */\r\n\r\nDragEvent.type = 'drag';\r\nclass DragStartEvent extends DragEvent {}\r\n\r\nexports.DragStartEvent = DragStartEvent; /**\r\n                                          * Drag move event\r\n                                          * @class DragMoveEvent\r\n                                          * @module DragMoveEvent\r\n                                          * @extends DragEvent\r\n                                          */\r\n\r\nDragStartEvent.type = 'drag:start';\r\nDragStartEvent.cancelable = true;\r\nclass DragMoveEvent extends DragEvent {}\r\n\r\nexports.DragMoveEvent = DragMoveEvent; /**\r\n                                        * Drag over event\r\n                                        * @class DragOverEvent\r\n                                        * @module DragOverEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragMoveEvent.type = 'drag:move';\r\nclass DragOverEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you are over\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n}\r\n\r\nexports.DragOverEvent = DragOverEvent; /**\r\n                                        * Drag out event\r\n                                        * @class DragOutEvent\r\n                                        * @module DragOutEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragOverEvent.type = 'drag:over';\r\nDragOverEvent.cancelable = true;\r\nclass DragOutEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you left\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n}\r\n\r\nexports.DragOutEvent = DragOutEvent; /**\r\n                                      * Drag over container event\r\n                                      * @class DragOverContainerEvent\r\n                                      * @module DragOverContainerEvent\r\n                                      * @extends DragEvent\r\n                                      */\r\n\r\nDragOutEvent.type = 'drag:out';\r\nclass DragOverContainerEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.DragOverContainerEvent = DragOverContainerEvent; /**\r\n                                                          * Drag out container event\r\n                                                          * @class DragOutContainerEvent\r\n                                                          * @module DragOutContainerEvent\r\n                                                          * @extends DragEvent\r\n                                                          */\r\n\r\nDragOverContainerEvent.type = 'drag:over:container';\r\nclass DragOutContainerEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you left\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.DragOutContainerEvent = DragOutContainerEvent; /**\r\n                                                        * Drag pressure event\r\n                                                        * @class DragPressureEvent\r\n                                                        * @module DragPressureEvent\r\n                                                        * @extends DragEvent\r\n                                                        */\r\n\r\nDragOutContainerEvent.type = 'drag:out:container';\r\nclass DragPressureEvent extends DragEvent {\r\n\r\n  /**\r\n   * Pressure applied on draggable element\r\n   * @property pressure\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get pressure() {\r\n    return this.data.pressure;\r\n  }\r\n}\r\n\r\nexports.DragPressureEvent = DragPressureEvent; /**\r\n                                                * Drag stop event\r\n                                                * @class DragStopEvent\r\n                                                * @module DragStopEvent\r\n                                                * @extends DragEvent\r\n                                                */\r\n\r\nDragPressureEvent.type = 'drag:pressure';\r\nclass DragStopEvent extends DragEvent {}\r\n\r\nexports.DragStopEvent = DragStopEvent; /**\r\n                                        * Drag stopped event\r\n                                        * @class DragStoppedEvent\r\n                                        * @module DragStoppedEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragStopEvent.type = 'drag:stop';\r\nclass DragStoppedEvent extends DragEvent {}\r\nexports.DragStoppedEvent = DragStoppedEvent;\r\nDragStoppedEvent.type = 'drag:stopped';\r\n\r\n/***/ }),\r\n/* 72 */\r\n/***/ (function(module, exports, __nested_webpack_require_211439__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.Plugins = exports.Sensors = exports.Sortable = exports.Swappable = exports.Droppable = exports.Draggable = exports.BasePlugin = exports.BaseEvent = undefined;\r\n\r\nvar _Draggable = __nested_webpack_require_211439__(5);\r\n\r\nObject.defineProperty(exports, 'Draggable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Draggable).default;\r\n  }\r\n});\r\n\r\nvar _Droppable = __nested_webpack_require_211439__(36);\r\n\r\nObject.defineProperty(exports, 'Droppable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Droppable).default;\r\n  }\r\n});\r\n\r\nvar _Swappable = __nested_webpack_require_211439__(33);\r\n\r\nObject.defineProperty(exports, 'Swappable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Swappable).default;\r\n  }\r\n});\r\n\r\nvar _Sortable = __nested_webpack_require_211439__(30);\r\n\r\nObject.defineProperty(exports, 'Sortable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Sortable).default;\r\n  }\r\n});\r\n\r\nvar _AbstractEvent = __nested_webpack_require_211439__(1);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_211439__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _Sensors = __nested_webpack_require_211439__(6);\r\n\r\nvar Sensors = _interopRequireWildcard(_Sensors);\r\n\r\nvar _Plugins = __nested_webpack_require_211439__(27);\r\n\r\nvar Plugins = _interopRequireWildcard(_Plugins);\r\n\r\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.BaseEvent = _AbstractEvent2.default;\r\nexports.BasePlugin = _AbstractPlugin2.default;\r\nexports.Sensors = Sensors;\r\nexports.Plugins = Plugins;\r\n\r\n/***/ })\r\n/******/ ]);\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9kcmFnZ2FibGUuYnVuZGxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLMEI7QUFDaEMsQ0FBQztBQUNELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsOEJBQW1CO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixlQUFlLDhCQUFtQjtBQUNsQyxtREFBbUQsK0JBQStCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQSxpRUFBaUUsaUJBQWlCO0FBQ2xGO0FBQ0EsMERBQTBELGFBQWE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixnQ0FBZ0MsOEJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQW1CO0FBQzlCLGtEQUFrRCxnQ0FBZ0M7QUFDbEYsMEVBQTBFLDhCQUFtQiw0QkFBNEIsb0JBQW9CO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFLDBDQUEwQztBQUMxQyxXQUFXLDhCQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhCQUFtQixDQUFD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Q2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxh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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9DQUFvQztBQUNqRCxhQUFhLFFBQVE7QUFDckI7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHdCQUF3QixpQ0FBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWEsaUNBQW1CO0FBQ2hDO0FBQ0EsY0FBYyxpQ0FBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFtQjtBQUN0QztBQUNBLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9DQUFvQztBQUNqRCxhQUFhLFFBQVE7QUFDckI7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0JBQWtCLGlDQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUNBQXVDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHFCQUFxQixpQ0FBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsbUJBQW1CLGlDQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELGlDQUFpQztBQUNoUDtBQUNBLHNCQUFzQixpQ0FBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFtQjtBQUN0QztBQUNBLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQSwrQ0FBK0MsaUJBQWlCLHFCQUFxQixvQ0FBb0MsNkRBQTZELHNCQUFzQjtBQUM1TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsTUFBTTtBQUNwQixjQUFjLE1BQU07QUFDcEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsU0FBUztBQUMzQixrQkFBa0IsU0FBUztBQUMzQixrQkFBa0IsU0FBUztBQUMzQixrQkFBa0IsYUFBYTtBQUMvQixrQkFBa0IsYUFBYTtBQUMvQixrQkFBa0IsNkJBQTZCO0FBQy9DLGNBQWM7QUFDZDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVEQUF1RDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQXVEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlCQUFpQixpQ0FBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaUJBQWlCLGlDQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpQkFBaUIsaUNBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdCQUFnQixpQ0FBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUJBQXFCLGlDQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUNBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUNBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUNBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw2QkFBNkIsY0FBYyxPQUFPLGlCQUFpQixtQkFBbUIsdUJBQXVCLGdGQUFnRixzQkFBc0I7QUFDM1A7QUFDQSx1Q0FBdUMsdUNBQXVDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9kcmFnZ2FibGUuYnVuZGxlLmpzPzc3ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuXHRcdGRlZmluZShcIkRyYWdnYWJsZVwiLCBbXSwgZmFjdG9yeSk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcblx0XHRleHBvcnRzW1wiRHJhZ2dhYmxlXCJdID0gZmFjdG9yeSgpO1xyXG5cdGVsc2VcclxuXHRcdHJvb3RbXCJEcmFnZ2FibGVcIl0gPSBmYWN0b3J5KCk7XHJcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XHJcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXHJcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcclxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XHJcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcclxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcclxuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXHJcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxyXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxyXG4vKioqKioqLyBcdFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXHJcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxyXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG4vKioqKioqLyBcdH1cclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xyXG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XHJcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcclxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XHJcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xyXG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XHJcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcclxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA3Mik7XHJcbi8qKioqKiovIH0pXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKioqKiovIChbXHJcbi8qIDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2Nsb3Nlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY2xvc2VzdCcsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb3Nlc3QpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9kaXN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkaXN0YW5jZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc3RhbmNlKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX3RvdWNoQ29vcmRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3RvdWNoQ29vcmRzJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG91Y2hDb29yZHMpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKioqLyB9KSxcclxuLyogMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcclxuXHJcbk9iamVjdC5rZXlzKF9TZW5zb3JFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9TZW5zb3JFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcclxuXHJcbnZhciBfU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX1NlbnNvcjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9EcmFnRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxuXHJcbk9iamVjdC5rZXlzKF9EcmFnRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfRHJhZ0V2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9EcmFnZ2FibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cclxuT2JqZWN0LmtleXMoX0RyYWdnYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX0RyYWdnYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9QbHVnaW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcblxyXG5PYmplY3Qua2V5cyhfUGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9QbHVnaW5zW2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcbk9iamVjdC5rZXlzKF9TZW5zb3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1NlbnNvcnNba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX0RyYWdnYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xyXG5cclxudmFyIF9EcmFnZ2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ2dhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfRHJhZ2dhYmxlMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1NlbnNvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Nb3VzZVNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdNb3VzZVNlbnNvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vdXNlU2Vuc29yKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1RvdWNoU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1RvdWNoU2Vuc29yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVG91Y2hTZW5zb3IpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfRHJhZ1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdEcmFnU2Vuc29yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ1NlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Gb3JjZVRvdWNoU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0ZvcmNlVG91Y2hTZW5zb3InLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Gb3JjZVRvdWNoU2Vuc29yKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHJcbk9iamVjdC5rZXlzKF9TZW5zb3JFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9TZW5zb3JFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKioqLyB9KSxcclxuLyogNyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU25hcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxuXHJcbk9iamVjdC5rZXlzKF9TbmFwcGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9TbmFwcGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Db2xsaWRhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcclxuXHJcbk9iamVjdC5rZXlzKF9Db2xsaWRhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfQ29sbGlkYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NvcnRhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcclxuXHJcbk9iamVjdC5rZXlzKF9Tb3J0YWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1NvcnRhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1N3YXBwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XHJcblxyXG5PYmplY3Qua2V5cyhfU3dhcHBhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfU3dhcHBhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Ryb3BwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XHJcblxyXG5PYmplY3Qua2V5cyhfRHJvcHBhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfRHJvcHBhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fubm91bmNlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNjgpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdBbm5vdW5jZW1lbnQnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Bbm5vdW5jZW1lbnQpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0QW5ub3VuY2VtZW50T3B0aW9ucycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9Bbm5vdW5jZW1lbnQuZGVmYXVsdE9wdGlvbnM7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfRm9jdXNhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0ZvY3VzYWJsZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZvY3VzYWJsZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9NaXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTWlycm9yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWlycm9yKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGVmYXVsdE1pcnJvck9wdGlvbnMnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfTWlycm9yLmRlZmF1bHRPcHRpb25zO1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1Njcm9sbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU2Nyb2xsYWJsZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Njcm9sbGFibGUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0U2Nyb2xsYWJsZU9wdGlvbnMnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfU2Nyb2xsYWJsZS5kZWZhdWx0T3B0aW9ucztcclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRHJhZ2dhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcclxuXHJcbk9iamVjdC5rZXlzKF9EcmFnZ2FibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9EcmFnZ2FibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRHJhZ0V2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XHJcblxyXG5PYmplY3Qua2V5cyhfRHJhZ0V2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX0RyYWdFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uU29ydGFibGVTb3J0ZWQgPSBTeW1ib2woJ29uU29ydGFibGVTb3J0ZWQnKTtcclxuY29uc3Qgb25Tb3J0YWJsZVNvcnQgPSBTeW1ib2woJ29uU29ydGFibGVTb3J0Jyk7XHJcblxyXG4vKipcclxuICogU29ydEFuaW1hdGlvbiBkZWZhdWx0IG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWZhdWx0T3B0aW9ucy5kdXJhdGlvblxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGVmYXVsdE9wdGlvbnMuZWFzaW5nRnVuY3Rpb25cclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcclxuICBkdXJhdGlvbjogMTUwLFxyXG4gIGVhc2luZ0Z1bmN0aW9uOiAnZWFzZS1pbi1vdXQnXHJcbn07XHJcblxyXG4vKipcclxuICogU29ydEFuaW1hdGlvbiBwbHVnaW4gYWRkcyBzb3J0IGFuaW1hdGlvbiBmb3Igc29ydGFibGVcclxuICogQGNsYXNzIFNvcnRBbmltYXRpb25cclxuICogQG1vZHVsZSBTb3J0QW5pbWF0aW9uXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBTb3J0QW5pbWF0aW9uIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBTb3J0QW5pbWF0aW9uIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFNvcnRBbmltYXRpb25cclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU29ydEFuaW1hdGlvbiBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLmR1cmF0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZGVmYXVsdE9wdGlvbnMuZWFzaW5nRnVuY3Rpb25cclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGFzdCBhbmltYXRpb24gZnJhbWVcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsYXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcclxuICAgIHRoaXMubGFzdEVsZW1lbnRzID0gW107XHJcblxyXG4gICAgdGhpc1tvblNvcnRhYmxlU29ydGVkXSA9IHRoaXNbb25Tb3J0YWJsZVNvcnRlZF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Tb3J0YWJsZVNvcnRdID0gdGhpc1tvblNvcnRhYmxlU29ydF0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ3NvcnRhYmxlOnNvcnQnLCB0aGlzW29uU29ydGFibGVTb3J0XSk7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignc29ydGFibGU6c29ydGVkJywgdGhpc1tvblNvcnRhYmxlU29ydGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignc29ydGFibGU6c29ydCcsIHRoaXNbb25Tb3J0YWJsZVNvcnRdKTtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignc29ydGFibGU6c29ydGVkJywgdGhpc1tvblNvcnRhYmxlU29ydGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5zb3J0QW5pbWF0aW9uIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU29ydGFibGUgc29ydCBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtTb3J0YWJsZVNvcnRFdmVudH0gc29ydGFibGVFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uU29ydGFibGVTb3J0XSh7IGRyYWdFdmVudCB9KSB7XHJcbiAgICBjb25zdCB7IHNvdXJjZUNvbnRhaW5lciB9ID0gZHJhZ0V2ZW50O1xyXG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmRyYWdnYWJsZS5nZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihzb3VyY2VDb250YWluZXIpO1xyXG4gICAgdGhpcy5sYXN0RWxlbWVudHMgPSBBcnJheS5mcm9tKGVsZW1lbnRzKS5tYXAoZWwgPT4ge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGRvbUVsOiBlbCxcclxuICAgICAgICBvZmZzZXRUb3A6IGVsLm9mZnNldFRvcCxcclxuICAgICAgICBvZmZzZXRMZWZ0OiBlbC5vZmZzZXRMZWZ0XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNvcnRhYmxlIHNvcnRlZCBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtTb3J0YWJsZVNvcnRlZEV2ZW50fSBzb3J0YWJsZUV2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25Tb3J0YWJsZVNvcnRlZF0oeyBvbGRJbmRleCwgbmV3SW5kZXggfSkge1xyXG4gICAgaWYgKG9sZEluZGV4ID09PSBuZXdJbmRleCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZWZmZWN0ZWRFbGVtZW50cyA9IFtdO1xyXG4gICAgbGV0IHN0YXJ0O1xyXG4gICAgbGV0IGVuZDtcclxuICAgIGxldCBudW07XHJcbiAgICBpZiAob2xkSW5kZXggPiBuZXdJbmRleCkge1xyXG4gICAgICBzdGFydCA9IG5ld0luZGV4O1xyXG4gICAgICBlbmQgPSBvbGRJbmRleCAtIDE7XHJcbiAgICAgIG51bSA9IDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGFydCA9IG9sZEluZGV4ICsgMTtcclxuICAgICAgZW5kID0gbmV3SW5kZXg7XHJcbiAgICAgIG51bSA9IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xyXG4gICAgICBjb25zdCBmcm9tID0gdGhpcy5sYXN0RWxlbWVudHNbaV07XHJcbiAgICAgIGNvbnN0IHRvID0gdGhpcy5sYXN0RWxlbWVudHNbaSArIG51bV07XHJcbiAgICAgIGVmZmVjdGVkRWxlbWVudHMucHVzaCh7IGZyb20sIHRvIH0pO1xyXG4gICAgfVxyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUpO1xyXG5cclxuICAgIC8vIENhbiBiZSBkb25lIGluIGEgc2VwYXJhdGUgZnJhbWVcclxuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgZWZmZWN0ZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4gYW5pbWF0ZShlbGVtZW50LCB0aGlzLm9wdGlvbnMpKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gU29ydEFuaW1hdGlvbjsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFuaW1hdGVzIHR3byBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudC5mcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50LnRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmVhc2luZ0Z1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuZnVuY3Rpb24gYW5pbWF0ZSh7IGZyb20sIHRvIH0sIHsgZHVyYXRpb24sIGVhc2luZ0Z1bmN0aW9uIH0pIHtcclxuICBjb25zdCBkb21FbCA9IGZyb20uZG9tRWw7XHJcbiAgY29uc3QgeCA9IGZyb20ub2Zmc2V0TGVmdCAtIHRvLm9mZnNldExlZnQ7XHJcbiAgY29uc3QgeSA9IGZyb20ub2Zmc2V0VG9wIC0gdG8ub2Zmc2V0VG9wO1xyXG5cclxuICBkb21FbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG4gIGRvbUVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7eX1weCwgMClgO1xyXG5cclxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgZG9tRWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZCk7XHJcbiAgICBkb21FbC5zdHlsZS50cmFuc2l0aW9uID0gYHRyYW5zZm9ybSAke2R1cmF0aW9ufW1zICR7ZWFzaW5nRnVuY3Rpb259YDtcclxuICAgIGRvbUVsLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmVzZXRzIGFuaW1hdGlvbiBzdHlsZSBwcm9wZXJ0aWVzIGFmdGVyIGFuaW1hdGlvbiBoYXMgY29tcGxldGVkXHJcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQoZXZlbnQpIHtcclxuICBldmVudC50YXJnZXQuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xyXG4gIGV2ZW50LnRhcmdldC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XHJcbiAgZXZlbnQudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX1NvcnRBbmltYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxuXHJcbnZhciBfU29ydEFuaW1hdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Tb3J0QW5pbWF0aW9uKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfU29ydEFuaW1hdGlvbjIuZGVmYXVsdDtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IF9Tb3J0QW5pbWF0aW9uLmRlZmF1bHRPcHRpb25zO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Tb3J0YWJsZVNvcnRlZCA9IFN5bWJvbCgnb25Tb3J0YWJsZVNvcnRlZCcpO1xyXG5cclxuLyoqXHJcbiAqIFN3YXBBbmltYXRpb24gZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMuZHVyYXRpb25cclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRlZmF1bHRPcHRpb25zLmVhc2luZ0Z1bmN0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVmYXVsdE9wdGlvbnMuaG9yaXpvbnRhbFxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xyXG4gIGR1cmF0aW9uOiAxNTAsXHJcbiAgZWFzaW5nRnVuY3Rpb246ICdlYXNlLWluLW91dCcsXHJcbiAgaG9yaXpvbnRhbDogZmFsc2VcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTd2FwQW5pbWF0aW9uIHBsdWdpbiBhZGRzIHN3YXAgYW5pbWF0aW9ucyBmb3Igc29ydGFibGVcclxuICogQGNsYXNzIFN3YXBBbmltYXRpb25cclxuICogQG1vZHVsZSBTd2FwQW5pbWF0aW9uXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBTd2FwQW5pbWF0aW9uIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBTd2FwQW5pbWF0aW9uIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFN3YXBBbmltYXRpb25cclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3dhcEFuaW1hdGlvbiBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLmR1cmF0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZGVmYXVsdE9wdGlvbnMuZWFzaW5nRnVuY3Rpb25cclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGFzdCBhbmltYXRpb24gZnJhbWVcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsYXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uU29ydGFibGVTb3J0ZWRdID0gdGhpc1tvblNvcnRhYmxlU29ydGVkXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignc29ydGFibGU6c29ydGVkJywgdGhpc1tvblNvcnRhYmxlU29ydGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignc29ydGFibGU6c29ydGVkJywgdGhpc1tvblNvcnRhYmxlU29ydGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5zd2FwQW5pbWF0aW9uIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU29ydGFibGUgc29ydGVkIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge1NvcnRhYmxlU29ydGVkRXZlbnR9IHNvcnRhYmxlRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvblNvcnRhYmxlU29ydGVkXSh7IG9sZEluZGV4LCBuZXdJbmRleCwgZHJhZ0V2ZW50IH0pIHtcclxuICAgIGNvbnN0IHsgc291cmNlLCBvdmVyIH0gPSBkcmFnRXZlbnQ7XHJcblxyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUpO1xyXG5cclxuICAgIC8vIENhbiBiZSBkb25lIGluIGEgc2VwYXJhdGUgZnJhbWVcclxuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgaWYgKG9sZEluZGV4ID49IG5ld0luZGV4KSB7XHJcbiAgICAgICAgYW5pbWF0ZShzb3VyY2UsIG92ZXIsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYW5pbWF0ZShvdmVyLCBzb3VyY2UsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gU3dhcEFuaW1hdGlvbjsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFuaW1hdGVzIHR3byBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmVhc2luZ0Z1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmhvcml6b250YWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5mdW5jdGlvbiBhbmltYXRlKGZyb20sIHRvLCB7IGR1cmF0aW9uLCBlYXNpbmdGdW5jdGlvbiwgaG9yaXpvbnRhbCB9KSB7XHJcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtmcm9tLCB0b10pIHtcclxuICAgIGVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcclxuICB9XHJcblxyXG4gIGlmIChob3Jpem9udGFsKSB7XHJcbiAgICBjb25zdCB3aWR0aCA9IGZyb20ub2Zmc2V0V2lkdGg7XHJcbiAgICBmcm9tLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3dpZHRofXB4LCAwLCAwKWA7XHJcbiAgICB0by5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoLSR7d2lkdGh9cHgsIDAsIDApYDtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gZnJvbS5vZmZzZXRIZWlnaHQ7XHJcbiAgICBmcm9tLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgwLCAke2hlaWdodH1weCwgMClgO1xyXG4gICAgdG8uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDAsIC0ke2hlaWdodH1weCwgMClgO1xyXG4gIH1cclxuXHJcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbZnJvbSwgdG9dKSB7XHJcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZCk7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbiA9IGB0cmFuc2Zvcm0gJHtkdXJhdGlvbn1tcyAke2Vhc2luZ0Z1bmN0aW9ufWA7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJyc7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXNldHMgYW5pbWF0aW9uIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgYW5pbWF0aW9uIGhhcyBjb21wbGV0ZWRcclxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZChldmVudCkge1xyXG4gIGV2ZW50LnRhcmdldC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XHJcbiAgZXZlbnQudGFyZ2V0LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcclxuICBldmVudC50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZCk7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfU3dhcEFuaW1hdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG5cclxudmFyIF9Td2FwQW5pbWF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N3YXBBbmltYXRpb24pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Td2FwQW5pbWF0aW9uMi5kZWZhdWx0O1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gX1N3YXBBbmltYXRpb24uZGVmYXVsdE9wdGlvbnM7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxudmFyIF9TbmFwcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xyXG5jb25zdCBvbkRyYWdPdXQgPSBTeW1ib2woJ29uRHJhZ091dCcpO1xyXG5jb25zdCBvbk1pcnJvckNyZWF0ZWQgPSBTeW1ib2woJ29uTWlycm9yQ3JlYXRlZCcpO1xyXG5jb25zdCBvbk1pcnJvckRlc3Ryb3kgPSBTeW1ib2woJ29uTWlycm9yRGVzdHJveScpO1xyXG5cclxuLyoqXHJcbiAqIFNuYXBwYWJsZSBwbHVnaW4gd2hpY2ggc25hcHMgZHJhZ2dhYmxlIGVsZW1lbnRzIGludG8gcGxhY2VcclxuICogQGNsYXNzIFNuYXBwYWJsZVxyXG4gKiBAbW9kdWxlIFNuYXBwYWJsZVxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgU25hcHBhYmxlIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBTbmFwcGFibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgU25hcHBhYmxlXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBmaXJzdCBzb3VyY2UgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxudWxsfSBmaXJzdFNvdXJjZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpcnN0U291cmNlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBtaXJyb3IgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gbWlycm9yXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWlycm9yID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnT3V0XSA9IHRoaXNbb25EcmFnT3V0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1pcnJvckNyZWF0ZWRdID0gdGhpc1tvbk1pcnJvckNyZWF0ZWRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTWlycm9yRGVzdHJveV0gPSB0aGlzW29uTWlycm9yRGVzdHJveV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9uKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vbignZHJhZzpvdXQnLCB0aGlzW29uRHJhZ091dF0pLm9uKCdkcm9wcGFibGU6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcm9wcGFibGU6b3V0JywgdGhpc1tvbkRyYWdPdXRdKS5vbignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9uKCdtaXJyb3I6ZGVzdHJveScsIHRoaXNbb25NaXJyb3JEZXN0cm95XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9mZignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub2ZmKCdkcmFnOm91dCcsIHRoaXNbb25EcmFnT3V0XSkub2ZmKCdkcm9wcGFibGU6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9mZignZHJvcHBhYmxlOm91dCcsIHRoaXNbb25EcmFnT3V0XSkub2ZmKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub2ZmKCdtaXJyb3I6ZGVzdHJveScsIHRoaXNbb25NaXJyb3JEZXN0cm95XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0YXJ0RXZlbnR9IGV2ZW50IC0gRHJhZyBzdGFydCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcclxuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmZpcnN0U291cmNlID0gZXZlbnQuc291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdG9wIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0b3BFdmVudH0gZXZlbnQgLSBEcmFnIHN0b3AgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RvcF0oKSB7XHJcbiAgICB0aGlzLmZpcnN0U291cmNlID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgb3ZlciBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyRXZlbnR8RHJvcHBhYmxlT3ZlckV2ZW50fSBldmVudCAtIERyYWcgb3ZlciBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdmVyXShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNvdXJjZSA9IGV2ZW50LnNvdXJjZSB8fCBldmVudC5kcmFnRXZlbnQuc291cmNlO1xyXG5cclxuICAgIGlmIChzb3VyY2UgPT09IHRoaXMuZmlyc3RTb3VyY2UpIHtcclxuICAgICAgdGhpcy5maXJzdFNvdXJjZSA9IG51bGw7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzbmFwSW5FdmVudCA9IG5ldyBfU25hcHBhYmxlRXZlbnQuU25hcEluRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBzbmFwcGFibGU6IGV2ZW50Lm92ZXIgfHwgZXZlbnQuZHJvcHBhYmxlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKHNuYXBJbkV2ZW50KTtcclxuXHJcbiAgICBpZiAoc25hcEluRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubWlycm9yKSB7XHJcbiAgICAgIHRoaXMubWlycm9yLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICB9XHJcblxyXG4gICAgc291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOmRyYWdnaW5nJykpO1xyXG4gICAgc291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcclxuXHJcbiAgICAvLyBOZWVkIHRvIGNhbmNlbCB0aGlzIGluIGRyYWcgb3V0XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgc291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcclxuICAgIH0sIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMucGxhY2VkVGltZW91dCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG91dCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdPdXRFdmVudHxEcm9wcGFibGVPdXRFdmVudH0gZXZlbnQgLSBEcmFnIG91dCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdXRdKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc291cmNlID0gZXZlbnQuc291cmNlIHx8IGV2ZW50LmRyYWdFdmVudC5zb3VyY2U7XHJcblxyXG4gICAgY29uc3Qgc25hcE91dEV2ZW50ID0gbmV3IF9TbmFwcGFibGVFdmVudC5TbmFwT3V0RXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBzbmFwcGFibGU6IGV2ZW50Lm92ZXIgfHwgZXZlbnQuZHJvcHBhYmxlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKHNuYXBPdXRFdmVudCk7XHJcblxyXG4gICAgaWYgKHNuYXBPdXRFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5taXJyb3IpIHtcclxuICAgICAgdGhpcy5taXJyb3Iuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHNvdXJjZS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZHJhZ2dhYmxlLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpkcmFnZ2luZycpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1pcnJvciBjcmVhdGVkIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge01pcnJvckNyZWF0ZWRFdmVudH0gbWlycm9yRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbk1pcnJvckNyZWF0ZWRdKHsgbWlycm9yIH0pIHtcclxuICAgIHRoaXMubWlycm9yID0gbWlycm9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlycm9yIGRlc3Ryb3kgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7TWlycm9yRGVzdHJveUV2ZW50fSBtaXJyb3JFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uTWlycm9yRGVzdHJveV0oKSB7XHJcbiAgICB0aGlzLm1pcnJvciA9IG51bGw7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNuYXBwYWJsZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5TbmFwT3V0RXZlbnQgPSBleHBvcnRzLlNuYXBJbkV2ZW50ID0gZXhwb3J0cy5TbmFwRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIHNuYXAgZXZlbnRcclxuICogQGNsYXNzIFNuYXBFdmVudFxyXG4gKiBAbW9kdWxlIFNuYXBFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBTbmFwRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBzbmFwIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IGRyYWdFdmVudFxyXG4gICAqIEB0eXBlIHtEcmFnRXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyYWdFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU25hcHBhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgc25hcHBhYmxlXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzbmFwcGFibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNuYXBwYWJsZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuU25hcEV2ZW50ID0gU25hcEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNuYXAgaW4gZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTbmFwSW5FdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBTbmFwSW5FdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU25hcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblNuYXBFdmVudC50eXBlID0gJ3NuYXAnO1xyXG5jbGFzcyBTbmFwSW5FdmVudCBleHRlbmRzIFNuYXBFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5TbmFwSW5FdmVudCA9IFNuYXBJbkV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTbmFwIG91dCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTbmFwT3V0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNuYXBPdXRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNuYXBFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuU25hcEluRXZlbnQudHlwZSA9ICdzbmFwOmluJztcclxuU25hcEluRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIFNuYXBPdXRFdmVudCBleHRlbmRzIFNuYXBFdmVudCB7fVxyXG5leHBvcnRzLlNuYXBPdXRFdmVudCA9IFNuYXBPdXRFdmVudDtcclxuU25hcE91dEV2ZW50LnR5cGUgPSAnc25hcDpvdXQnO1xyXG5TbmFwT3V0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NuYXBwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuXHJcbk9iamVjdC5rZXlzKF9TbmFwcGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9TbmFwcGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbnZhciBfU25hcHBhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcblxyXG52YXIgX1NuYXBwYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TbmFwcGFibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9TbmFwcGFibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uTWlycm9yQ3JlYXRlZCA9IFN5bWJvbCgnb25NaXJyb3JDcmVhdGVkJyk7XHJcbmNvbnN0IG9uTWlycm9yRGVzdHJveSA9IFN5bWJvbCgnb25NaXJyb3JEZXN0cm95Jyk7XHJcbmNvbnN0IG9uRHJhZ092ZXIgPSBTeW1ib2woJ29uRHJhZ092ZXInKTtcclxuY29uc3QgcmVzaXplID0gU3ltYm9sKCdyZXNpemUnKTtcclxuXHJcbi8qKlxyXG4gKiBSZXNpemVNaXJyb3IgZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge307XHJcblxyXG4vKipcclxuICogVGhlIFJlc2l6ZU1pcnJvciBwbHVnaW4gcmVzaXplcyB0aGUgbWlycm9yIGVsZW1lbnQgdG8gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGRyYWdnYWJsZSBlbGVtZW50IHRoYXQgdGhlIG1pcnJvciBpcyBob3ZlcmluZyBvdmVyXHJcbiAqIEBjbGFzcyBSZXNpemVNaXJyb3JcclxuICogQG1vZHVsZSBSZXNpemVNaXJyb3JcclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIFJlc2l6ZU1pcnJvciBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogUmVzaXplTWlycm9yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFJlc2l6ZU1pcnJvclxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVNaXJyb3Igb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplTWlycm9yIHJlbWVtYmVycyB0aGUgbGFzdCB3aWR0aCB3aGVuIHJlc2l6aW5nIHRoZSBtaXJyb3JcclxuICAgICAqIHRvIGF2b2lkIGFkZGl0aW9uYWwgd3JpdGVzIHRvIHRoZSBET01cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXN0V2lkdGhcclxuICAgICAqL1xyXG4gICAgdGhpcy5sYXN0V2lkdGggPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplTWlycm9yIHJlbWVtYmVycyB0aGUgbGFzdCBoZWlnaHQgd2hlbiByZXNpemluZyB0aGUgbWlycm9yXHJcbiAgICAgKiB0byBhdm9pZCBhZGRpdGlvbmFsIHdyaXRlcyB0byB0aGUgRE9NXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbGFzdEhlaWdodFxyXG4gICAgICovXHJcbiAgICB0aGlzLmxhc3RIZWlnaHQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIG1pcnJvciBlbGVtZW50XHJcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBtaXJyb3JcclxuICAgICAqL1xyXG4gICAgdGhpcy5taXJyb3IgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25NaXJyb3JDcmVhdGVkXSA9IHRoaXNbb25NaXJyb3JDcmVhdGVkXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1pcnJvckRlc3Ryb3ldID0gdGhpc1tvbk1pcnJvckRlc3Ryb3ldLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ092ZXJdID0gdGhpc1tvbkRyYWdPdmVyXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9uKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vbignZHJhZzpvdmVyOmNvbnRhaW5lcicsIHRoaXNbb25EcmFnT3Zlcl0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ21pcnJvcjpjcmVhdGVkJywgdGhpc1tvbk1pcnJvckNyZWF0ZWRdKS5vZmYoJ21pcnJvcjpkZXN0cm95JywgdGhpc1tvbk1pcnJvckRlc3Ryb3ldKS5vZmYoJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9mZignZHJhZzpvdmVyOmNvbnRhaW5lcicsIHRoaXNbb25EcmFnT3Zlcl0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBvcHRpb25zIHBhc3NlZCB0aHJvdWdoIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMucmVzaXplTWlycm9yIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlycm9yIGNyZWF0ZWQgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7TWlycm9yQ3JlYXRlZEV2ZW50fSBtaXJyb3JFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uTWlycm9yQ3JlYXRlZF0oeyBtaXJyb3IgfSkge1xyXG4gICAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNaXJyb3IgZGVzdHJveSBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtNaXJyb3JEZXN0cm95RXZlbnR9IG1pcnJvckV2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25NaXJyb3JEZXN0cm95XSgpIHtcclxuICAgIHRoaXMubWlycm9yID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgb3ZlciBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtEcmFnT3ZlckV2ZW50IHwgRHJhZ092ZXJDb250YWluZXJ9IGRyYWdFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRHJhZ092ZXJdKGRyYWdFdmVudCkge1xyXG4gICAgdGhpc1tyZXNpemVdKGRyYWdFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNpemUgZnVuY3Rpb24gZm9yXHJcbiAgICogQHBhcmFtIHtEcmFnT3ZlckV2ZW50IHwgRHJhZ092ZXJDb250YWluZXJ9IGRyYWdFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW3Jlc2l6ZV0oeyBvdmVyQ29udGFpbmVyLCBvdmVyIH0pIHtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5taXJyb3IucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMubWlycm9yLnBhcmVudE5vZGUgIT09IG92ZXJDb250YWluZXIpIHtcclxuICAgICAgICBvdmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubWlycm9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgb3ZlckVsZW1lbnQgPSBvdmVyIHx8IHRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG92ZXJDb250YWluZXIpWzBdO1xyXG5cclxuICAgICAgaWYgKCFvdmVyRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgKDAsIF91dGlscy5yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKSgoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb3ZlclJlY3QgPSBvdmVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGFzdEhlaWdodCA9PT0gb3ZlclJlY3QuaGVpZ2h0ICYmIHRoaXMubGFzdFdpZHRoID09PSBvdmVyUmVjdC53aWR0aCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5taXJyb3Iuc3R5bGUud2lkdGggPSBgJHtvdmVyUmVjdC53aWR0aH1weGA7XHJcbiAgICAgICAgdGhpcy5taXJyb3Iuc3R5bGUuaGVpZ2h0ID0gYCR7b3ZlclJlY3QuaGVpZ2h0fXB4YDtcclxuXHJcbiAgICAgICAgdGhpcy5sYXN0V2lkdGggPSBvdmVyUmVjdC53aWR0aDtcclxuICAgICAgICB0aGlzLmxhc3RIZWlnaHQgPSBvdmVyUmVjdC5oZWlnaHQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJlc2l6ZU1pcnJvcjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfUmVzaXplTWlycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcblxyXG52YXIgX1Jlc2l6ZU1pcnJvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZXNpemVNaXJyb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9SZXNpemVNaXJyb3IyLmRlZmF1bHQ7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfUmVzaXplTWlycm9yLmRlZmF1bHRPcHRpb25zO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxudmFyIF9Db2xsaWRhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcclxuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xyXG5jb25zdCBvblJlcXVlc3RBbmltYXRpb25GcmFtZSA9IFN5bWJvbCgnb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcclxuXHJcbi8qKlxyXG4gKiBDb2xsaWRhYmxlIHBsdWdpbiB3aGljaCBkZXRlY3RzIGNvbGxpZGluZyBlbGVtZW50cyB3aGlsZSBkcmFnZ2luZ1xyXG4gKiBAY2xhc3MgQ29sbGlkYWJsZVxyXG4gKiBAbW9kdWxlIENvbGxpZGFibGVcclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIENvbGxpZGFibGUgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIENvbGxpZGFibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgQ29sbGlkYWJsZVxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZWVwcyB0cmFjayBvZiBjdXJyZW50bHkgY29sbGlkaW5nIGVsZW1lbnRzXHJcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fG51bGx9IGN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnRcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2VlcHMgdHJhY2sgb2YgY3VycmVudGx5IGNvbGxpZGluZyBlbGVtZW50c1xyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxudWxsfSBsYXN0Q29sbGlkaW5nRWxlbWVudFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW5pbWF0aW9uIGZyYW1lIGZvciBmaW5kaW5nIGNvbGxpZGluZyBlbGVtZW50c1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8bnVsbH0gY3VycmVudEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWVdID0gdGhpc1tvblJlcXVlc3RBbmltYXRpb25GcmFtZV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjdXJyZW50IGNvbGxpZGFibGVzIGJhc2VkIG9uIGBjb2xsaWRhYmxlc2Agb3B0aW9uXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnRbXX1cclxuICAgKi9cclxuICBnZXRDb2xsaWRhYmxlcygpIHtcclxuICAgIGNvbnN0IGNvbGxpZGFibGVzID0gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5jb2xsaWRhYmxlcztcclxuXHJcbiAgICBpZiAodHlwZW9mIGNvbGxpZGFibGVzID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChjb2xsaWRhYmxlcykpO1xyXG4gICAgfSBlbHNlIGlmIChjb2xsaWRhYmxlcyBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGNvbGxpZGFibGVzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbGxpZGFibGVzKTtcclxuICAgIH0gZWxzZSBpZiAoY29sbGlkYWJsZXMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gW2NvbGxpZGFibGVzXTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbGxpZGFibGVzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHJldHVybiBjb2xsaWRhYmxlcygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ01vdmVFdmVudH0gZXZlbnQgLSBEcmFnIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnTW92ZV0oZXZlbnQpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnNlbnNvckV2ZW50LnRhcmdldDtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzW29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lXSh0YXJnZXQpKTtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50KSB7XHJcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbGxpZGFibGVJbkV2ZW50ID0gbmV3IF9Db2xsaWRhYmxlRXZlbnQuQ29sbGlkYWJsZUluRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBjb2xsaWRpbmdFbGVtZW50OiB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnRcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGNvbGxpZGFibGVPdXRFdmVudCA9IG5ldyBfQ29sbGlkYWJsZUV2ZW50LkNvbGxpZGFibGVPdXRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGNvbGxpZGluZ0VsZW1lbnQ6IHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnRcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGVudGVyaW5nQ29sbGlkYWJsZSA9IEJvb2xlYW4odGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ICYmIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgIT09IHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCk7XHJcbiAgICBjb25zdCBsZWF2aW5nQ29sbGlkYWJsZSA9IEJvb2xlYW4oIXRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCAmJiB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50KTtcclxuXHJcbiAgICBpZiAoZW50ZXJpbmdDb2xsaWRhYmxlKSB7XHJcbiAgICAgIGlmICh0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKGNvbGxpZGFibGVJbkV2ZW50KTtcclxuICAgIH0gZWxzZSBpZiAobGVhdmluZ0NvbGxpZGFibGUpIHtcclxuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgPSB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0b3AgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RvcEV2ZW50fSBldmVudCAtIERyYWcgc3RvcCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdG9wXShldmVudCkge1xyXG4gICAgY29uc3QgbGFzdENvbGxpZGluZ0VsZW1lbnQgPSB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgfHwgdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudDtcclxuICAgIGNvbnN0IGNvbGxpZGFibGVPdXRFdmVudCA9IG5ldyBfQ29sbGlkYWJsZUV2ZW50LkNvbGxpZGFibGVPdXRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGNvbGxpZGluZ0VsZW1lbnQ6IGxhc3RDb2xsaWRpbmdFbGVtZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAobGFzdENvbGxpZGluZ0VsZW1lbnQpIHtcclxuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xyXG4gICAgdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuaW1hdGlvbiBmcmFtZSBmdW5jdGlvblxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gQ3VycmVudCBtb3ZlIHRhcmdldFxyXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxyXG4gICAqL1xyXG4gIFtvblJlcXVlc3RBbmltYXRpb25GcmFtZV0odGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCBjb2xsaWRhYmxlcyA9IHRoaXMuZ2V0Q29sbGlkYWJsZXMoKTtcclxuICAgICAgdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ID0gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIGVsZW1lbnQgPT4gY29sbGlkYWJsZXMuaW5jbHVkZXMoZWxlbWVudCkpO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29sbGlkYWJsZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5Db2xsaWRhYmxlT3V0RXZlbnQgPSBleHBvcnRzLkNvbGxpZGFibGVJbkV2ZW50ID0gZXhwb3J0cy5Db2xsaWRhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNvbGxpZGFibGUgZXZlbnRcclxuICogQGNsYXNzIENvbGxpZGFibGVFdmVudFxyXG4gKiBAbW9kdWxlIENvbGxpZGFibGVFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBDb2xsaWRhYmxlRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjb2xsaWFibGUgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgZHJhZ0V2ZW50XHJcbiAgICogQHR5cGUge0RyYWdFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ0V2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkNvbGxpZGFibGVFdmVudCA9IENvbGxpZGFibGVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb2xsaWRhYmxlIGluIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgQ29sbGlkYWJsZUluRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgQ29sbGlkYWJsZUluRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIENvbGxpZGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Db2xsaWRhYmxlRXZlbnQudHlwZSA9ICdjb2xsaWRhYmxlJztcclxuY2xhc3MgQ29sbGlkYWJsZUluRXZlbnQgZXh0ZW5kcyBDb2xsaWRhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBFbGVtZW50IHlvdSBhcmUgY3VycmVudGx5IGNvbGxpZGluZyB3aXRoXHJcbiAgICogQHByb3BlcnR5IGNvbGxpZGluZ0VsZW1lbnRcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGNvbGxpZGluZ0VsZW1lbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNvbGxpZGluZ0VsZW1lbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkNvbGxpZGFibGVJbkV2ZW50ID0gQ29sbGlkYWJsZUluRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbGxpZGFibGUgb3V0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIENvbGxpZGFibGVPdXRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgQ29sbGlkYWJsZU91dEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgQ29sbGlkYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Db2xsaWRhYmxlSW5FdmVudC50eXBlID0gJ2NvbGxpZGFibGU6aW4nO1xyXG5jbGFzcyBDb2xsaWRhYmxlT3V0RXZlbnQgZXh0ZW5kcyBDb2xsaWRhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBFbGVtZW50IHlvdSB3ZXJlIHByZXZpb3VzbHkgY29sbGlkaW5nIHdpdGhcclxuICAgKiBAcHJvcGVydHkgY29sbGlkaW5nRWxlbWVudFxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgY29sbGlkaW5nRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuY29sbGlkaW5nRWxlbWVudDtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5Db2xsaWRhYmxlT3V0RXZlbnQgPSBDb2xsaWRhYmxlT3V0RXZlbnQ7XHJcbkNvbGxpZGFibGVPdXRFdmVudC50eXBlID0gJ2NvbGxpZGFibGU6b3V0JztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQ29sbGlkYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHJcbk9iamVjdC5rZXlzKF9Db2xsaWRhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfQ29sbGlkYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9Db2xsaWRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XHJcblxyXG52YXIgX0NvbGxpZGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29sbGlkYWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0NvbGxpZGFibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0NvbGxpZGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQ29sbGlkYWJsZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbGxpZGFibGUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfUmVzaXplTWlycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1Jlc2l6ZU1pcnJvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Jlc2l6ZU1pcnJvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRSZXNpemVNaXJyb3JPcHRpb25zJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX1Jlc2l6ZU1pcnJvci5kZWZhdWx0T3B0aW9ucztcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9TbmFwcGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU25hcHBhYmxlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU25hcHBhYmxlKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1N3YXBBbmltYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU3dhcEFuaW1hdGlvbicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N3YXBBbmltYXRpb24pLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0U3dhcEFuaW1hdGlvbk9wdGlvbnMnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfU3dhcEFuaW1hdGlvbi5kZWZhdWx0T3B0aW9ucztcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Tb3J0QW5pbWF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1NvcnRBbmltYXRpb24nLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Tb3J0QW5pbWF0aW9uKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGVmYXVsdFNvcnRBbmltYXRpb25PcHRpb25zJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX1NvcnRBbmltYXRpb24uZGVmYXVsdE9wdGlvbnM7XHJcbiAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9EcmFnZ2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxudmFyIF9EcmFnZ2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ2dhYmxlKTtcclxuXHJcbnZhciBfU29ydGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XHJcbmNvbnN0IG9uRHJhZ092ZXJDb250YWluZXIgPSBTeW1ib2woJ29uRHJhZ092ZXJDb250YWluZXInKTtcclxuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xyXG5jb25zdCBvbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbm5vdW5jZW1lbnQgbWVzc2FnZSB3aGVuIGEgRHJhZ2dhYmxlIGVsZW1lbnQgaGFzIGJlZW4gc29ydGVkIHdpdGggYW5vdGhlciBEcmFnZ2FibGUgZWxlbWVudFxyXG4gKiBvciBtb3ZlZCBpbnRvIGEgbmV3IGNvbnRhaW5lclxyXG4gKiBAcGFyYW0ge1NvcnRhYmxlU29ydGVkRXZlbnR9IHNvcnRhYmxlRXZlbnRcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gb25Tb3J0YWJsZVNvcnRlZERlZmF1bHRBbm5vdW5jZW1lbnQoeyBkcmFnRXZlbnQgfSkge1xyXG4gIGNvbnN0IHNvdXJjZVRleHQgPSBkcmFnRXZlbnQuc291cmNlLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcmFnRXZlbnQuc291cmNlLmlkIHx8ICdzb3J0YWJsZSBlbGVtZW50JztcclxuXHJcbiAgaWYgKGRyYWdFdmVudC5vdmVyKSB7XHJcbiAgICBjb25zdCBvdmVyVGV4dCA9IGRyYWdFdmVudC5vdmVyLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcmFnRXZlbnQub3Zlci5pZCB8fCAnc29ydGFibGUgZWxlbWVudCc7XHJcbiAgICBjb25zdCBpc0ZvbGxvd2luZyA9IGRyYWdFdmVudC5zb3VyY2UuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZHJhZ0V2ZW50Lm92ZXIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XHJcblxyXG4gICAgaWYgKGlzRm9sbG93aW5nKSB7XHJcbiAgICAgIHJldHVybiBgUGxhY2VkICR7c291cmNlVGV4dH0gYWZ0ZXIgJHtvdmVyVGV4dH1gO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGBQbGFjZWQgJHtzb3VyY2VUZXh0fSBiZWZvcmUgJHtvdmVyVGV4dH1gO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBuZWVkIHRvIGZpZ3VyZSBvdXQgaG93IHRvIGNvbXB1dGUgY29udGFpbmVyIG5hbWVcclxuICAgIHJldHVybiBgUGxhY2VkICR7c291cmNlVGV4dH0gaW50byBhIGRpZmZlcmVudCBjb250YWluZXJgO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBjb25zdCB7T2JqZWN0fSBkZWZhdWx0QW5ub3VuY2VtZW50c1xyXG4gKiBAY29uc3Qge0Z1bmN0aW9ufSBkZWZhdWx0QW5ub3VuY2VtZW50c1snc29ydGFibGU6c29ydGVkJ11cclxuICovXHJcbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xyXG4gICdzb3J0YWJsZTpzb3J0ZWQnOiBvblNvcnRhYmxlU29ydGVkRGVmYXVsdEFubm91bmNlbWVudFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNvcnRhYmxlIGlzIGJ1aWx0IG9uIHRvcCBvZiBEcmFnZ2FibGUgYW5kIGFsbG93cyBzb3J0aW5nIG9mIGRyYWdnYWJsZSBlbGVtZW50cy4gU29ydGFibGUgd2lsbCBrZWVwXHJcbiAqIHRyYWNrIG9mIHRoZSBvcmlnaW5hbCBpbmRleCBhbmQgZW1pdHMgdGhlIG5ldyBpbmRleCBhcyB5b3UgZHJhZyBvdmVyIGRyYWdnYWJsZSBlbGVtZW50cy5cclxuICogQGNsYXNzIFNvcnRhYmxlXHJcbiAqIEBtb2R1bGUgU29ydGFibGVcclxuICogQGV4dGVuZHMgRHJhZ2dhYmxlXHJcbiAqL1xyXG5jbGFzcyBTb3J0YWJsZSBleHRlbmRzIF9EcmFnZ2FibGUyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIFNvcnRhYmxlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFNvcnRhYmxlXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gU29ydGFibGUgY29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgU29ydGFibGVcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcclxuICAgICAgYW5ub3VuY2VtZW50czogX2V4dGVuZHMoe30sIGRlZmF1bHRBbm5vdW5jZW1lbnRzLCBvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pXHJcbiAgICB9KSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzdGFydCBpbmRleCBvZiBzb3VyY2Ugb24gZHJhZyBzdGFydFxyXG4gICAgICogQHByb3BlcnR5IHN0YXJ0SW5kZXhcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RhcnRJbmRleCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzdGFydCBjb250YWluZXIgb24gZHJhZyBzdGFydFxyXG4gICAgICogQHByb3BlcnR5IHN0YXJ0Q29udGFpbmVyXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RhcnRDb250YWluZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnT3ZlckNvbnRhaW5lcl0gPSB0aGlzW29uRHJhZ092ZXJDb250YWluZXJdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ092ZXJdID0gdGhpc1tvbkRyYWdPdmVyXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLm9uKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9uKCdkcmFnOm92ZXI6Y29udGFpbmVyJywgdGhpc1tvbkRyYWdPdmVyQ29udGFpbmVyXSkub24oJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3lzIFNvcnRhYmxlIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBzdXBlci5kZXN0cm95KCk7XHJcblxyXG4gICAgdGhpcy5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm92ZXI6Y29udGFpbmVyJywgdGhpc1tvbkRyYWdPdmVyQ29udGFpbmVyXSkub2ZmKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGluZGV4IG9mIGVsZW1lbnQgd2l0aGluIGl0cyBjb250YWluZXIgZHVyaW5nIGRyYWcgb3BlcmF0aW9uLCBpLmUuIGV4Y2x1ZGluZyBtaXJyb3IgYW5kIG9yaWdpbmFsIHNvdXJjZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBBbiBlbGVtZW50XHJcbiAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAqL1xyXG4gIGluZGV4KGVsZW1lbnQpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFNvcnRhYmxlRWxlbWVudHNGb3JDb250YWluZXIoZWxlbWVudC5wYXJlbnROb2RlKS5pbmRleE9mKGVsZW1lbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBzb3J0YWJsZSBlbGVtZW50cyBmb3IgYSBnaXZlbiBjb250YWluZXIsIGV4Y2x1ZGluZyB0aGUgbWlycm9yIGFuZFxyXG4gICAqIG9yaWdpbmFsIHNvdXJjZSBlbGVtZW50IGlmIHByZXNlbnRcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudFtdfVxyXG4gICAqL1xyXG4gIGdldFNvcnRhYmxlRWxlbWVudHNGb3JDb250YWluZXIoY29udGFpbmVyKSB7XHJcbiAgICBjb25zdCBhbGxTb3J0YWJsZUVsZW1lbnRzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XHJcblxyXG4gICAgcmV0dXJuIFsuLi5hbGxTb3J0YWJsZUVsZW1lbnRzXS5maWx0ZXIoY2hpbGRFbGVtZW50ID0+IHtcclxuICAgICAgcmV0dXJuIGNoaWxkRWxlbWVudCAhPT0gdGhpcy5vcmlnaW5hbFNvdXJjZSAmJiBjaGlsZEVsZW1lbnQgIT09IHRoaXMubWlycm9yICYmIGNoaWxkRWxlbWVudC5wYXJlbnROb2RlID09PSBjb250YWluZXI7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RhcnRFdmVudH0gZXZlbnQgLSBEcmFnIHN0YXJ0IGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xyXG4gICAgdGhpcy5zdGFydENvbnRhaW5lciA9IGV2ZW50LnNvdXJjZS5wYXJlbnROb2RlO1xyXG4gICAgdGhpcy5zdGFydEluZGV4ID0gdGhpcy5pbmRleChldmVudC5zb3VyY2UpO1xyXG5cclxuICAgIGNvbnN0IHNvcnRhYmxlU3RhcnRFdmVudCA9IG5ldyBfU29ydGFibGVFdmVudC5Tb3J0YWJsZVN0YXJ0RXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBzdGFydEluZGV4OiB0aGlzLnN0YXJ0SW5kZXgsXHJcbiAgICAgIHN0YXJ0Q29udGFpbmVyOiB0aGlzLnN0YXJ0Q29udGFpbmVyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTdGFydEV2ZW50KTtcclxuXHJcbiAgICBpZiAoc29ydGFibGVTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgZXZlbnQuY2FuY2VsKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG92ZXIgY29udGFpbmVyIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ092ZXJDb250YWluZXJFdmVudH0gZXZlbnQgLSBEcmFnIG92ZXIgY29udGFpbmVyIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ092ZXJDb250YWluZXJdKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBzb3VyY2UsIG92ZXIsIG92ZXJDb250YWluZXIgfSA9IGV2ZW50O1xyXG4gICAgY29uc3Qgb2xkSW5kZXggPSB0aGlzLmluZGV4KHNvdXJjZSk7XHJcblxyXG4gICAgY29uc3Qgc29ydGFibGVTb3J0RXZlbnQgPSBuZXcgX1NvcnRhYmxlRXZlbnQuU29ydGFibGVTb3J0RXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBjdXJyZW50SW5kZXg6IG9sZEluZGV4LFxyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG92ZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVNvcnRFdmVudCk7XHJcblxyXG4gICAgaWYgKHNvcnRhYmxlU29ydEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRTb3J0YWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG92ZXJDb250YWluZXIpO1xyXG4gICAgY29uc3QgbW92ZXMgPSBtb3ZlKHsgc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyLCBjaGlsZHJlbiB9KTtcclxuXHJcbiAgICBpZiAoIW1vdmVzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IG9sZENvbnRhaW5lciwgbmV3Q29udGFpbmVyIH0gPSBtb3ZlcztcclxuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5pbmRleChldmVudC5zb3VyY2UpO1xyXG5cclxuICAgIGNvbnN0IHNvcnRhYmxlU29ydGVkRXZlbnQgPSBuZXcgX1NvcnRhYmxlRXZlbnQuU29ydGFibGVTb3J0ZWRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIG9sZEluZGV4LFxyXG4gICAgICBuZXdJbmRleCxcclxuICAgICAgb2xkQ29udGFpbmVyLFxyXG4gICAgICBuZXdDb250YWluZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVNvcnRlZEV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgb3ZlciBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyRXZlbnR9IGV2ZW50IC0gRHJhZyBvdmVyIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ092ZXJdKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQub3ZlciA9PT0gZXZlbnQub3JpZ2luYWxTb3VyY2UgfHwgZXZlbnQub3ZlciA9PT0gZXZlbnQuc291cmNlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHNvdXJjZSwgb3Zlciwgb3ZlckNvbnRhaW5lciB9ID0gZXZlbnQ7XHJcbiAgICBjb25zdCBvbGRJbmRleCA9IHRoaXMuaW5kZXgoc291cmNlKTtcclxuXHJcbiAgICBjb25zdCBzb3J0YWJsZVNvcnRFdmVudCA9IG5ldyBfU29ydGFibGVFdmVudC5Tb3J0YWJsZVNvcnRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGN1cnJlbnRJbmRleDogb2xkSW5kZXgsXHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgb3ZlclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHNvcnRhYmxlU29ydEV2ZW50KTtcclxuXHJcbiAgICBpZiAoc29ydGFibGVTb3J0RXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG92ZXJDb250YWluZXIpO1xyXG4gICAgY29uc3QgbW92ZXMgPSBtb3ZlKHsgc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyLCBjaGlsZHJlbiB9KTtcclxuXHJcbiAgICBpZiAoIW1vdmVzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IG9sZENvbnRhaW5lciwgbmV3Q29udGFpbmVyIH0gPSBtb3ZlcztcclxuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5pbmRleChzb3VyY2UpO1xyXG5cclxuICAgIGNvbnN0IHNvcnRhYmxlU29ydGVkRXZlbnQgPSBuZXcgX1NvcnRhYmxlRXZlbnQuU29ydGFibGVTb3J0ZWRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIG9sZEluZGV4LFxyXG4gICAgICBuZXdJbmRleCxcclxuICAgICAgb2xkQ29udGFpbmVyLFxyXG4gICAgICBuZXdDb250YWluZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVNvcnRlZEV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RvcCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdTdG9wRXZlbnR9IGV2ZW50IC0gRHJhZyBzdG9wIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XHJcbiAgICBjb25zdCBzb3J0YWJsZVN0b3BFdmVudCA9IG5ldyBfU29ydGFibGVFdmVudC5Tb3J0YWJsZVN0b3BFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIG9sZEluZGV4OiB0aGlzLnN0YXJ0SW5kZXgsXHJcbiAgICAgIG5ld0luZGV4OiB0aGlzLmluZGV4KGV2ZW50LnNvdXJjZSksXHJcbiAgICAgIG9sZENvbnRhaW5lcjogdGhpcy5zdGFydENvbnRhaW5lcixcclxuICAgICAgbmV3Q29udGFpbmVyOiBldmVudC5zb3VyY2UucGFyZW50Tm9kZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHNvcnRhYmxlU3RvcEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSBudWxsO1xyXG4gICAgdGhpcy5zdGFydENvbnRhaW5lciA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBTb3J0YWJsZTtcclxuZnVuY3Rpb24gaW5kZXgoZWxlbWVudCkge1xyXG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGVsZW1lbnQucGFyZW50Tm9kZS5jaGlsZHJlbiwgZWxlbWVudCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vdmUoeyBzb3VyY2UsIG92ZXIsIG92ZXJDb250YWluZXIsIGNoaWxkcmVuIH0pIHtcclxuICBjb25zdCBlbXB0eU92ZXJDb250YWluZXIgPSAhY2hpbGRyZW4ubGVuZ3RoO1xyXG4gIGNvbnN0IGRpZmZlcmVudENvbnRhaW5lciA9IHNvdXJjZS5wYXJlbnROb2RlICE9PSBvdmVyQ29udGFpbmVyO1xyXG4gIGNvbnN0IHNhbWVDb250YWluZXIgPSBvdmVyICYmIHNvdXJjZS5wYXJlbnROb2RlID09PSBvdmVyLnBhcmVudE5vZGU7XHJcblxyXG4gIGlmIChlbXB0eU92ZXJDb250YWluZXIpIHtcclxuICAgIHJldHVybiBtb3ZlSW5zaWRlRW1wdHlDb250YWluZXIoc291cmNlLCBvdmVyQ29udGFpbmVyKTtcclxuICB9IGVsc2UgaWYgKHNhbWVDb250YWluZXIpIHtcclxuICAgIHJldHVybiBtb3ZlV2l0aGluQ29udGFpbmVyKHNvdXJjZSwgb3Zlcik7XHJcbiAgfSBlbHNlIGlmIChkaWZmZXJlbnRDb250YWluZXIpIHtcclxuICAgIHJldHVybiBtb3ZlT3V0c2lkZUNvbnRhaW5lcihzb3VyY2UsIG92ZXIsIG92ZXJDb250YWluZXIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vdmVJbnNpZGVFbXB0eUNvbnRhaW5lcihzb3VyY2UsIG92ZXJDb250YWluZXIpIHtcclxuICBjb25zdCBvbGRDb250YWluZXIgPSBzb3VyY2UucGFyZW50Tm9kZTtcclxuXHJcbiAgb3ZlckNvbnRhaW5lci5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG5cclxuICByZXR1cm4geyBvbGRDb250YWluZXIsIG5ld0NvbnRhaW5lcjogb3ZlckNvbnRhaW5lciB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBtb3ZlV2l0aGluQ29udGFpbmVyKHNvdXJjZSwgb3Zlcikge1xyXG4gIGNvbnN0IG9sZEluZGV4ID0gaW5kZXgoc291cmNlKTtcclxuICBjb25zdCBuZXdJbmRleCA9IGluZGV4KG92ZXIpO1xyXG5cclxuICBpZiAob2xkSW5kZXggPCBuZXdJbmRleCkge1xyXG4gICAgc291cmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNvdXJjZSwgb3Zlci5uZXh0RWxlbWVudFNpYmxpbmcpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzb3VyY2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc291cmNlLCBvdmVyKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7IG9sZENvbnRhaW5lcjogc291cmNlLnBhcmVudE5vZGUsIG5ld0NvbnRhaW5lcjogc291cmNlLnBhcmVudE5vZGUgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gbW92ZU91dHNpZGVDb250YWluZXIoc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyKSB7XHJcbiAgY29uc3Qgb2xkQ29udGFpbmVyID0gc291cmNlLnBhcmVudE5vZGU7XHJcblxyXG4gIGlmIChvdmVyKSB7XHJcbiAgICBvdmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNvdXJjZSwgb3Zlcik7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIG5lZWQgdG8gZmlndXJlIG91dCBwcm9wZXIgcG9zaXRpb25cclxuICAgIG92ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoc291cmNlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7IG9sZENvbnRhaW5lciwgbmV3Q29udGFpbmVyOiBzb3VyY2UucGFyZW50Tm9kZSB9O1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuU29ydGFibGVTdG9wRXZlbnQgPSBleHBvcnRzLlNvcnRhYmxlU29ydGVkRXZlbnQgPSBleHBvcnRzLlNvcnRhYmxlU29ydEV2ZW50ID0gZXhwb3J0cy5Tb3J0YWJsZVN0YXJ0RXZlbnQgPSBleHBvcnRzLlNvcnRhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIHNvcnRhYmxlIGV2ZW50XHJcbiAqIEBjbGFzcyBTb3J0YWJsZUV2ZW50XHJcbiAqIEBtb2R1bGUgU29ydGFibGVFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBTb3J0YWJsZUV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBkcmFnIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgc29ydGFibGUgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgZHJhZ0V2ZW50XHJcbiAgICogQHR5cGUge0RyYWdFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ0V2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLlNvcnRhYmxlRXZlbnQgPSBTb3J0YWJsZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU29ydGFibGUgc3RhcnQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFNvcnRhYmxlU3RhcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNvcnRhYmxlU3RhcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTb3J0YWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuU29ydGFibGVFdmVudC50eXBlID0gJ3NvcnRhYmxlJztcclxuY2xhc3MgU29ydGFibGVTdGFydEV2ZW50IGV4dGVuZHMgU29ydGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGluZGV4IG9mIHNvdXJjZSBvbiBzb3J0YWJsZSBzdGFydFxyXG4gICAqIEBwcm9wZXJ0eSBzdGFydEluZGV4XHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc3RhcnRJbmRleCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc3RhcnRJbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGNvbnRhaW5lciBvbiBzb3J0YWJsZSBzdGFydFxyXG4gICAqIEBwcm9wZXJ0eSBzdGFydENvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc3RhcnRDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN0YXJ0Q29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Tb3J0YWJsZVN0YXJ0RXZlbnQgPSBTb3J0YWJsZVN0YXJ0RXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU29ydGFibGUgc29ydCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFNvcnRhYmxlU29ydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNvcnRhYmxlU29ydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTb3J0YWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblNvcnRhYmxlU3RhcnRFdmVudC50eXBlID0gJ3NvcnRhYmxlOnN0YXJ0JztcclxuU29ydGFibGVTdGFydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBTb3J0YWJsZVNvcnRFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBJbmRleCBvZiBjdXJyZW50IGRyYWdnYWJsZSBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IGN1cnJlbnRJbmRleFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGN1cnJlbnRJbmRleCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuY3VycmVudEluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGVsZW1lbnQgeW91IGFyZSBob3ZlcmluZyBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIGVsZW1lbnQgeW91IGFyZSBob3ZlcmluZyBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudC5vdmVyQ29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Tb3J0YWJsZVNvcnRFdmVudCA9IFNvcnRhYmxlU29ydEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTb3J0YWJsZSBzb3J0ZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgU29ydGFibGVTb3J0ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU29ydGFibGVTb3J0ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNvcnRhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblNvcnRhYmxlU29ydEV2ZW50LnR5cGUgPSAnc29ydGFibGU6c29ydCc7XHJcblNvcnRhYmxlU29ydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBTb3J0YWJsZVNvcnRlZEV2ZW50IGV4dGVuZHMgU29ydGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEluZGV4IG9mIGxhc3Qgc29ydGVkIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IG9sZEluZGV4XHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb2xkSW5kZXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9sZEluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTmV3IGluZGV4IG9mIHRoaXMgc29ydGVkIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IG5ld0luZGV4XHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbmV3SW5kZXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0luZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT2xkIGNvbnRhaW5lciBvZiBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBvbGRDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9sZENvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub2xkQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTmV3IGNvbnRhaW5lciBvZiBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBuZXdDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG5ld0NvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubmV3Q29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Tb3J0YWJsZVNvcnRlZEV2ZW50ID0gU29ydGFibGVTb3J0ZWRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNvcnRhYmxlIHN0b3AgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFNvcnRhYmxlU3RvcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU29ydGFibGVTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU29ydGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblNvcnRhYmxlU29ydGVkRXZlbnQudHlwZSA9ICdzb3J0YWJsZTpzb3J0ZWQnO1xyXG5jbGFzcyBTb3J0YWJsZVN0b3BFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBpbmRleCBvbiBzb3J0YWJsZSBzdGFydFxyXG4gICAqIEBwcm9wZXJ0eSBvbGRJbmRleFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9sZEluZGV4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vbGRJbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5ldyBpbmRleCBvZiBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBuZXdJbmRleFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG5ld0luZGV4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5uZXdJbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9yaWdpbmFsIGNvbnRhaW5lciBvZiBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBvbGRDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9sZENvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub2xkQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTmV3IGNvbnRhaW5lciBvZiBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBuZXdDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG5ld0NvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubmV3Q29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLlNvcnRhYmxlU3RvcEV2ZW50ID0gU29ydGFibGVTdG9wRXZlbnQ7XHJcblNvcnRhYmxlU3RvcEV2ZW50LnR5cGUgPSAnc29ydGFibGU6c3RvcCc7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NvcnRhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cclxuT2JqZWN0LmtleXMoX1NvcnRhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfU29ydGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbnZhciBfU29ydGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcclxuXHJcbnZhciBfU29ydGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU29ydGFibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Tb3J0YWJsZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0RyYWdnYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG52YXIgX0RyYWdnYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnZ2FibGUpO1xyXG5cclxudmFyIF9Td2FwcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdPdmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyJyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGFubm91bmNlbWVudCBtZXNzYWdlIHdoZW4gdGhlIERyYWdnYWJsZSBlbGVtZW50IGlzIHN3YXBwZWQgd2l0aCBhbm90aGVyIGRyYWdnYWJsZSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7U3dhcHBhYmxlU3dhcHBlZEV2ZW50fSBzd2FwcGFibGVFdmVudFxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBvblN3YXBwYWJsZVN3YXBwZWREZWZhdWx0QW5ub3VuY2VtZW50KHsgZHJhZ0V2ZW50LCBzd2FwcGVkRWxlbWVudCB9KSB7XHJcbiAgY29uc3Qgc291cmNlVGV4dCA9IGRyYWdFdmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyYWdFdmVudC5zb3VyY2UuaWQgfHwgJ3N3YXBwYWJsZSBlbGVtZW50JztcclxuICBjb25zdCBvdmVyVGV4dCA9IHN3YXBwZWRFbGVtZW50LnRleHRDb250ZW50LnRyaW0oKSB8fCBzd2FwcGVkRWxlbWVudC5pZCB8fCAnc3dhcHBhYmxlIGVsZW1lbnQnO1xyXG5cclxuICByZXR1cm4gYFN3YXBwZWQgJHtzb3VyY2VUZXh0fSB3aXRoICR7b3ZlclRleHR9YDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBjb25zdCB7T2JqZWN0fSBkZWZhdWx0QW5ub3VuY2VtZW50c1xyXG4gKiBAY29uc3Qge0Z1bmN0aW9ufSBkZWZhdWx0QW5ub3VuY2VtZW50c1snc3dhcHBhYmxlZDpzd2FwcGVkJ11cclxuICovXHJcbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xyXG4gICdzd2FwcGFibGVkOnN3YXBwZWQnOiBvblN3YXBwYWJsZVN3YXBwZWREZWZhdWx0QW5ub3VuY2VtZW50XHJcbn07XHJcblxyXG4vKipcclxuICogU3dhcHBhYmxlIGlzIGJ1aWx0IG9uIHRvcCBvZiBEcmFnZ2FibGUgYW5kIGFsbG93cyBzd2FwcGluZyBvZiBkcmFnZ2FibGUgZWxlbWVudHMuXHJcbiAqIE9yZGVyIGlzIGlycmVsZXZhbnQgdG8gU3dhcHBhYmxlLlxyXG4gKiBAY2xhc3MgU3dhcHBhYmxlXHJcbiAqIEBtb2R1bGUgU3dhcHBhYmxlXHJcbiAqIEBleHRlbmRzIERyYWdnYWJsZVxyXG4gKi9cclxuY2xhc3MgU3dhcHBhYmxlIGV4dGVuZHMgX0RyYWdnYWJsZTIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogU3dhcHBhYmxlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFN3YXBwYWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIFN3YXBwYWJsZSBjb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciBTd2FwcGFibGVcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcclxuICAgICAgYW5ub3VuY2VtZW50czogX2V4dGVuZHMoe30sIGRlZmF1bHRBbm5vdW5jZW1lbnRzLCBvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pXHJcbiAgICB9KSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMYXN0IGRyYWdnYWJsZSBlbGVtZW50IHRoYXQgd2FzIGRyYWdnZWQgb3ZlclxyXG4gICAgICogQHByb3BlcnR5IGxhc3RPdmVyXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGFzdE92ZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnT3Zlcl0gPSB0aGlzW29uRHJhZ092ZXJdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3lzIFN3YXBwYWJsZSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgc3VwZXIuZGVzdHJveSgpO1xyXG5cclxuICAgIHRoaXMub2ZmKCdkcmFnOnN0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpLm9mZignZHJhZzpvdmVyJywgdGhpcy5fb25EcmFnT3Zlcikub2ZmKCdkcmFnOnN0b3AnLCB0aGlzLl9vbkRyYWdTdG9wKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RhcnRFdmVudH0gZXZlbnQgLSBEcmFnIHN0YXJ0IGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xyXG4gICAgY29uc3Qgc3dhcHBhYmxlU3RhcnRFdmVudCA9IG5ldyBfU3dhcHBhYmxlRXZlbnQuU3dhcHBhYmxlU3RhcnRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzd2FwcGFibGVTdGFydEV2ZW50KTtcclxuXHJcbiAgICBpZiAoc3dhcHBhYmxlU3RhcnRFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBvdmVyIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ092ZXJFdmVudH0gZXZlbnQgLSBEcmFnIG92ZXIgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnT3Zlcl0oZXZlbnQpIHtcclxuICAgIGlmIChldmVudC5vdmVyID09PSBldmVudC5vcmlnaW5hbFNvdXJjZSB8fCBldmVudC5vdmVyID09PSBldmVudC5zb3VyY2UgfHwgZXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3dhcHBhYmxlU3dhcEV2ZW50ID0gbmV3IF9Td2FwcGFibGVFdmVudC5Td2FwcGFibGVTd2FwRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBvdmVyOiBldmVudC5vdmVyLFxyXG4gICAgICBvdmVyQ29udGFpbmVyOiBldmVudC5vdmVyQ29udGFpbmVyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoc3dhcHBhYmxlU3dhcEV2ZW50KTtcclxuXHJcbiAgICBpZiAoc3dhcHBhYmxlU3dhcEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHN3YXAgb3JpZ2luYWxseSBzd2FwcGVkIGVsZW1lbnQgYmFja1xyXG4gICAgaWYgKHRoaXMubGFzdE92ZXIgJiYgdGhpcy5sYXN0T3ZlciAhPT0gZXZlbnQub3Zlcikge1xyXG4gICAgICBzd2FwKHRoaXMubGFzdE92ZXIsIGV2ZW50LnNvdXJjZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubGFzdE92ZXIgPT09IGV2ZW50Lm92ZXIpIHtcclxuICAgICAgdGhpcy5sYXN0T3ZlciA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmxhc3RPdmVyID0gZXZlbnQub3ZlcjtcclxuICAgIH1cclxuXHJcbiAgICBzd2FwKGV2ZW50LnNvdXJjZSwgZXZlbnQub3Zlcik7XHJcblxyXG4gICAgY29uc3Qgc3dhcHBhYmxlU3dhcHBlZEV2ZW50ID0gbmV3IF9Td2FwcGFibGVFdmVudC5Td2FwcGFibGVTd2FwcGVkRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBzd2FwcGVkRWxlbWVudDogZXZlbnQub3ZlclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHN3YXBwYWJsZVN3YXBwZWRFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0b3AgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RvcEV2ZW50fSBldmVudCAtIERyYWcgc3RvcCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdG9wXShldmVudCkge1xyXG4gICAgY29uc3Qgc3dhcHBhYmxlU3RvcEV2ZW50ID0gbmV3IF9Td2FwcGFibGVFdmVudC5Td2FwcGFibGVTdG9wRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoc3dhcHBhYmxlU3RvcEV2ZW50KTtcclxuICAgIHRoaXMubGFzdE92ZXIgPSBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gU3dhcHBhYmxlO1xyXG5mdW5jdGlvbiB3aXRoVGVtcEVsZW1lbnQoY2FsbGJhY2spIHtcclxuICBjb25zdCB0bXBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgY2FsbGJhY2sodG1wRWxlbWVudCk7XHJcbiAgdG1wRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRtcEVsZW1lbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzd2FwKHNvdXJjZSwgb3Zlcikge1xyXG4gIGNvbnN0IG92ZXJQYXJlbnQgPSBvdmVyLnBhcmVudE5vZGU7XHJcbiAgY29uc3Qgc291cmNlUGFyZW50ID0gc291cmNlLnBhcmVudE5vZGU7XHJcblxyXG4gIHdpdGhUZW1wRWxlbWVudCh0bXBFbGVtZW50ID0+IHtcclxuICAgIHNvdXJjZVBhcmVudC5pbnNlcnRCZWZvcmUodG1wRWxlbWVudCwgc291cmNlKTtcclxuICAgIG92ZXJQYXJlbnQuaW5zZXJ0QmVmb3JlKHNvdXJjZSwgb3Zlcik7XHJcbiAgICBzb3VyY2VQYXJlbnQuaW5zZXJ0QmVmb3JlKG92ZXIsIHRtcEVsZW1lbnQpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuU3dhcHBhYmxlU3RvcEV2ZW50ID0gZXhwb3J0cy5Td2FwcGFibGVTd2FwcGVkRXZlbnQgPSBleHBvcnRzLlN3YXBwYWJsZVN3YXBFdmVudCA9IGV4cG9ydHMuU3dhcHBhYmxlU3RhcnRFdmVudCA9IGV4cG9ydHMuU3dhcHBhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIHN3YXBwYWJsZSBldmVudFxyXG4gKiBAY2xhc3MgU3dhcHBhYmxlRXZlbnRcclxuICogQG1vZHVsZSBTd2FwcGFibGVFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBTd2FwcGFibGVFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgZHJhZyBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIHN3YXBwYWJsZSBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBkcmFnRXZlbnRcclxuICAgKiBAdHlwZSB7RHJhZ0V2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkcmFnRXZlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuU3dhcHBhYmxlRXZlbnQgPSBTd2FwcGFibGVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3dhcHBhYmxlIHN0YXJ0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFN3YXBwYWJsZVN0YXJ0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFN3YXBwYWJsZVN0YXJ0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTd2FwcGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuU3dhcHBhYmxlRXZlbnQudHlwZSA9ICdzd2FwcGFibGUnO1xyXG5jbGFzcyBTd2FwcGFibGVTdGFydEV2ZW50IGV4dGVuZHMgU3dhcHBhYmxlRXZlbnQge31cclxuXHJcbmV4cG9ydHMuU3dhcHBhYmxlU3RhcnRFdmVudCA9IFN3YXBwYWJsZVN0YXJ0RXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTd2FwcGFibGUgc3dhcCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgU3dhcHBhYmxlU3dhcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU3dhcHBhYmxlU3dhcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFN3YXBwYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuU3dhcHBhYmxlU3RhcnRFdmVudC50eXBlID0gJ3N3YXBwYWJsZTpzdGFydCc7XHJcblN3YXBwYWJsZVN0YXJ0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIFN3YXBwYWJsZVN3YXBFdmVudCBleHRlbmRzIFN3YXBwYWJsZUV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGVsZW1lbnQgeW91IGFyZSBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIHlvdSBhcmUgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Td2FwcGFibGVTd2FwRXZlbnQgPSBTd2FwcGFibGVTd2FwRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3dhcHBhYmxlIHN3YXBwZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTd2FwcGFibGVTd2FwcGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU3dhcHBhYmxlU3dhcHBlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTd2FwcGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Td2FwcGFibGVTd2FwRXZlbnQudHlwZSA9ICdzd2FwcGFibGU6c3dhcCc7XHJcblN3YXBwYWJsZVN3YXBFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgU3dhcHBhYmxlU3dhcHBlZEV2ZW50IGV4dGVuZHMgU3dhcHBhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZHJhZ2dhYmxlIGVsZW1lbnQgdGhhdCB5b3Ugc3dhcHBlZCB3aXRoXHJcbiAgICogQHByb3BlcnR5IHN3YXBwZWRFbGVtZW50XHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzd2FwcGVkRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc3dhcHBlZEVsZW1lbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLlN3YXBwYWJsZVN3YXBwZWRFdmVudCA9IFN3YXBwYWJsZVN3YXBwZWRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTd2FwcGFibGUgc3RvcCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFN3YXBwYWJsZVN0b3BFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBTd2FwcGFibGVTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFN3YXBwYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblN3YXBwYWJsZVN3YXBwZWRFdmVudC50eXBlID0gJ3N3YXBwYWJsZTpzd2FwcGVkJztcclxuY2xhc3MgU3dhcHBhYmxlU3RvcEV2ZW50IGV4dGVuZHMgU3dhcHBhYmxlRXZlbnQge31cclxuZXhwb3J0cy5Td2FwcGFibGVTdG9wRXZlbnQgPSBTd2FwcGFibGVTdG9wRXZlbnQ7XHJcblN3YXBwYWJsZVN0b3BFdmVudC50eXBlID0gJ3N3YXBwYWJsZTpzdG9wJztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU3dhcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuXHJcbk9iamVjdC5rZXlzKF9Td2FwcGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9Td2FwcGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbnZhciBfU3dhcHBhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XHJcblxyXG52YXIgX1N3YXBwYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Td2FwcGFibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Td2FwcGFibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG52YXIgX0RyYWdnYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG52YXIgX0RyYWdnYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnZ2FibGUpO1xyXG5cclxudmFyIF9Ecm9wcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdNb3ZlID0gU3ltYm9sKCdvbkRyYWdNb3ZlJyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3QgZHJvcEluRHJvcHpvbmUgPSBTeW1ib2woJ2Ryb3BJbkRyb3Bab25lJyk7XHJcbmNvbnN0IHJldHVyblRvT3JpZ2luYWxEcm9wem9uZSA9IFN5bWJvbCgncmV0dXJuVG9PcmlnaW5hbERyb3B6b25lJyk7XHJcbmNvbnN0IGNsb3Nlc3REcm9wem9uZSA9IFN5bWJvbCgnY2xvc2VzdERyb3B6b25lJyk7XHJcbmNvbnN0IGdldERyb3B6b25lcyA9IFN5bWJvbCgnZ2V0RHJvcHpvbmVzJyk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBhbm5vdW5jZW1lbnQgbWVzc2FnZSB3aGVuIHRoZSBEcmFnZ2FibGUgZWxlbWVudCBpcyBkcm9wcGVkIGludG8gYSBkcm9wem9uZSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7RHJvcHBhYmxlRHJvcHBlZEV2ZW50fSBkcm9wcGFibGVFdmVudFxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBvbkRyb3BwYWJsZURyb3BwZWREZWZhdWx0QW5ub3VuY2VtZW50KHsgZHJhZ0V2ZW50LCBkcm9wem9uZSB9KSB7XHJcbiAgY29uc3Qgc291cmNlVGV4dCA9IGRyYWdFdmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyYWdFdmVudC5zb3VyY2UuaWQgfHwgJ2RyYWdnYWJsZSBlbGVtZW50JztcclxuICBjb25zdCBkcm9wem9uZVRleHQgPSBkcm9wem9uZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJvcHpvbmUuaWQgfHwgJ2Ryb3BwYWJsZSBlbGVtZW50JztcclxuXHJcbiAgcmV0dXJuIGBEcm9wcGVkICR7c291cmNlVGV4dH0gaW50byAke2Ryb3B6b25lVGV4dH1gO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBhbm5vdW5jZW1lbnQgbWVzc2FnZSB3aGVuIHRoZSBEcmFnZ2FibGUgZWxlbWVudCBoYXMgcmV0dXJuZWQgdG8gaXRzIG9yaWdpbmFsIGRyb3B6b25lIGVsZW1lbnRcclxuICogQHBhcmFtIHtEcm9wcGFibGVSZXR1cm5lZEV2ZW50fSBkcm9wcGFibGVFdmVudFxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBvbkRyb3BwYWJsZVJldHVybmVkRGVmYXVsdEFubm91bmNlbWVudCh7IGRyYWdFdmVudCwgZHJvcHpvbmUgfSkge1xyXG4gIGNvbnN0IHNvdXJjZVRleHQgPSBkcmFnRXZlbnQuc291cmNlLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcmFnRXZlbnQuc291cmNlLmlkIHx8ICdkcmFnZ2FibGUgZWxlbWVudCc7XHJcbiAgY29uc3QgZHJvcHpvbmVUZXh0ID0gZHJvcHpvbmUudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyb3B6b25lLmlkIHx8ICdkcm9wcGFibGUgZWxlbWVudCc7XHJcblxyXG4gIHJldHVybiBgUmV0dXJuZWQgJHtzb3VyY2VUZXh0fSBmcm9tICR7ZHJvcHpvbmVUZXh0fWA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAY29uc3Qge09iamVjdH0gZGVmYXVsdEFubm91bmNlbWVudHNcclxuICogQGNvbnN0IHtGdW5jdGlvbn0gZGVmYXVsdEFubm91bmNlbWVudHNbJ2Ryb3BwYWJsZTpkcm9wcGVkJ11cclxuICogQGNvbnN0IHtGdW5jdGlvbn0gZGVmYXVsdEFubm91bmNlbWVudHNbJ2Ryb3BwYWJsZTpyZXR1cm5lZCddXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0QW5ub3VuY2VtZW50cyA9IHtcclxuICAnZHJvcHBhYmxlOmRyb3BwZWQnOiBvbkRyb3BwYWJsZURyb3BwZWREZWZhdWx0QW5ub3VuY2VtZW50LFxyXG4gICdkcm9wcGFibGU6cmV0dXJuZWQnOiBvbkRyb3BwYWJsZVJldHVybmVkRGVmYXVsdEFubm91bmNlbWVudFxyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdENsYXNzZXMgPSB7XHJcbiAgJ2Ryb3BwYWJsZTphY3RpdmUnOiAnZHJhZ2dhYmxlLWRyb3B6b25lLS1hY3RpdmUnLFxyXG4gICdkcm9wcGFibGU6b2NjdXBpZWQnOiAnZHJhZ2dhYmxlLWRyb3B6b25lLS1vY2N1cGllZCdcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xyXG4gIGRyb3B6b25lOiAnLmRyYWdnYWJsZS1kcm9wcGFibGUnXHJcbn07XHJcblxyXG4vKipcclxuICogRHJvcHBhYmxlIGlzIGJ1aWx0IG9uIHRvcCBvZiBEcmFnZ2FibGUgYW5kIGFsbG93cyBkcm9wcGluZyBkcmFnZ2FibGUgZWxlbWVudHNcclxuICogaW50byBkcm9wem9uZSBlbGVtZW50XHJcbiAqIEBjbGFzcyBEcm9wcGFibGVcclxuICogQG1vZHVsZSBEcm9wcGFibGVcclxuICogQGV4dGVuZHMgRHJhZ2dhYmxlXHJcbiAqL1xyXG5jbGFzcyBEcm9wcGFibGUgZXh0ZW5kcyBfRHJhZ2dhYmxlMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBEcm9wcGFibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgRHJvcHBhYmxlXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gRHJvcHBhYmxlIGNvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIERyb3BwYWJsZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihjb250YWluZXJzLCBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMsIHtcclxuICAgICAgY2xhc3NlczogX2V4dGVuZHMoe30sIGRlZmF1bHRDbGFzc2VzLCBvcHRpb25zLmNsYXNzZXMgfHwge30pLFxyXG4gICAgICBhbm5vdW5jZW1lbnRzOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdEFubm91bmNlbWVudHMsIG9wdGlvbnMuYW5ub3VuY2VtZW50cyB8fCB7fSlcclxuICAgIH0pKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCBkcm9wem9uZSBlbGVtZW50cyBvbiBkcmFnIHN0YXJ0XHJcbiAgICAgKiBAcHJvcGVydHkgZHJvcHpvbmVzXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcm9wem9uZXMgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGFzdCBkcm9wem9uZSBlbGVtZW50IHRoYXQgdGhlIHNvdXJjZSB3YXMgZHJvcHBlZCBpbnRvXHJcbiAgICAgKiBAcHJvcGVydHkgbGFzdERyb3B6b25lXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGFzdERyb3B6b25lID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWwgZHJvcHpvbmUgZWxlbWVudCB0aGF0IHRoZSBzb3VyY2Ugd2FzIGRyYWcgZnJvbVxyXG4gICAgICogQHByb3BlcnR5IGluaXRpYWxEcm9wem9uZVxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmluaXRpYWxEcm9wem9uZSA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzdHJveXMgRHJvcHBhYmxlIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBzdXBlci5kZXN0cm95KCk7XHJcblxyXG4gICAgdGhpcy5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdGFydCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdTdGFydEV2ZW50fSBldmVudCAtIERyYWcgc3RhcnQgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RhcnRdKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kcm9wem9uZXMgPSBbLi4udGhpc1tnZXREcm9wem9uZXNdKCldO1xyXG4gICAgY29uc3QgZHJvcHpvbmUgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGV2ZW50LnNlbnNvckV2ZW50LnRhcmdldCwgdGhpcy5vcHRpb25zLmRyb3B6b25lKTtcclxuXHJcbiAgICBpZiAoIWRyb3B6b25lKSB7XHJcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZHJvcHBhYmxlU3RhcnRFdmVudCA9IG5ldyBfRHJvcHBhYmxlRXZlbnQuRHJvcHBhYmxlU3RhcnRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGRyb3B6b25lXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJvcHBhYmxlU3RhcnRFdmVudCk7XHJcblxyXG4gICAgaWYgKGRyb3BwYWJsZVN0YXJ0RXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICBldmVudC5jYW5jZWwoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaW5pdGlhbERyb3B6b25lID0gZHJvcHpvbmU7XHJcblxyXG4gICAgZm9yIChjb25zdCBkcm9wem9uZUVsZW1lbnQgb2YgdGhpcy5kcm9wem9uZXMpIHtcclxuICAgICAgaWYgKGRyb3B6b25lRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5nZXRDbGFzc05hbWVGb3IoJ2Ryb3BwYWJsZTpvY2N1cGllZCcpKSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkcm9wem9uZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2Ryb3BwYWJsZTphY3RpdmUnKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG1vdmUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnTW92ZUV2ZW50fSBldmVudCAtIERyYWcgbW92ZSBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdNb3ZlXShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyb3B6b25lID0gdGhpc1tjbG9zZXN0RHJvcHpvbmVdKGV2ZW50LnNlbnNvckV2ZW50LnRhcmdldCk7XHJcbiAgICBjb25zdCBvdmVyRW1wdHlEcm9wem9uZSA9IGRyb3B6b25lICYmICFkcm9wem9uZS5jbGFzc0xpc3QuY29udGFpbnModGhpcy5nZXRDbGFzc05hbWVGb3IoJ2Ryb3BwYWJsZTpvY2N1cGllZCcpKTtcclxuXHJcbiAgICBpZiAob3ZlckVtcHR5RHJvcHpvbmUgJiYgdGhpc1tkcm9wSW5Ecm9wem9uZV0oZXZlbnQsIGRyb3B6b25lKSkge1xyXG4gICAgICB0aGlzLmxhc3REcm9wem9uZSA9IGRyb3B6b25lO1xyXG4gICAgfSBlbHNlIGlmICgoIWRyb3B6b25lIHx8IGRyb3B6b25lID09PSB0aGlzLmluaXRpYWxEcm9wem9uZSkgJiYgdGhpcy5sYXN0RHJvcHpvbmUpIHtcclxuICAgICAgdGhpc1tyZXR1cm5Ub09yaWdpbmFsRHJvcHpvbmVdKGV2ZW50KTtcclxuICAgICAgdGhpcy5sYXN0RHJvcHpvbmUgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdG9wIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0b3BFdmVudH0gZXZlbnQgLSBEcmFnIHN0b3AgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RvcF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IGRyb3BwYWJsZVN0b3BFdmVudCA9IG5ldyBfRHJvcHBhYmxlRXZlbnQuRHJvcHBhYmxlU3RvcEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcclxuICAgICAgZHJvcHpvbmU6IHRoaXMubGFzdERyb3B6b25lIHx8IHRoaXMuaW5pdGlhbERyb3B6b25lXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJvcHBhYmxlU3RvcEV2ZW50KTtcclxuXHJcbiAgICBjb25zdCBvY2N1cGllZENsYXNzZXMgPSB0aGlzLmdldENsYXNzTmFtZXNGb3IoJ2Ryb3BwYWJsZTpvY2N1cGllZCcpO1xyXG5cclxuICAgIGZvciAoY29uc3QgZHJvcHpvbmUgb2YgdGhpcy5kcm9wem9uZXMpIHtcclxuICAgICAgZHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2Ryb3BwYWJsZTphY3RpdmUnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubGFzdERyb3B6b25lICYmIHRoaXMubGFzdERyb3B6b25lICE9PSB0aGlzLmluaXRpYWxEcm9wem9uZSkge1xyXG4gICAgICB0aGlzLmluaXRpYWxEcm9wem9uZS5jbGFzc0xpc3QucmVtb3ZlKC4uLm9jY3VwaWVkQ2xhc3Nlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kcm9wem9uZXMgPSBudWxsO1xyXG4gICAgdGhpcy5sYXN0RHJvcHpvbmUgPSBudWxsO1xyXG4gICAgdGhpcy5pbml0aWFsRHJvcHpvbmUgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJvcHMgYSBkcmFnZ2FibGUgZWxlbWVudCBpbnRvIGEgZHJvcHpvbmUgZWxlbWVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnTW92ZUV2ZW50fSBldmVudCAtIERyYWcgbW92ZSBldmVudFxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRyb3B6b25lIC0gRHJvcHpvbmUgZWxlbWVudCB0byBkcm9wIGRyYWdnYWJsZSBpbnRvXHJcbiAgICovXHJcbiAgW2Ryb3BJbkRyb3B6b25lXShldmVudCwgZHJvcHpvbmUpIHtcclxuICAgIGNvbnN0IGRyb3BwYWJsZURyb3BwZWRFdmVudCA9IG5ldyBfRHJvcHBhYmxlRXZlbnQuRHJvcHBhYmxlRHJvcHBlZEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcclxuICAgICAgZHJvcHpvbmVcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcm9wcGFibGVEcm9wcGVkRXZlbnQpO1xyXG5cclxuICAgIGlmIChkcm9wcGFibGVEcm9wcGVkRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb2NjdXBpZWRDbGFzc2VzID0gdGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKTtcclxuXHJcbiAgICBpZiAodGhpcy5sYXN0RHJvcHpvbmUpIHtcclxuICAgICAgdGhpcy5sYXN0RHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZSguLi5vY2N1cGllZENsYXNzZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGRyb3B6b25lLmFwcGVuZENoaWxkKGV2ZW50LnNvdXJjZSk7XHJcbiAgICBkcm9wem9uZS5jbGFzc0xpc3QuYWRkKC4uLm9jY3VwaWVkQ2xhc3Nlcyk7XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3ZlcyB0aGUgcHJldmlvdXNseSBkcm9wcGVkIGVsZW1lbnQgYmFjayBpbnRvIGl0cyBvcmlnaW5hbCBkcm9wem9uZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnTW92ZUV2ZW50fSBldmVudCAtIERyYWcgbW92ZSBldmVudFxyXG4gICAqL1xyXG4gIFtyZXR1cm5Ub09yaWdpbmFsRHJvcHpvbmVdKGV2ZW50KSB7XHJcbiAgICBjb25zdCBkcm9wcGFibGVSZXR1cm5lZEV2ZW50ID0gbmV3IF9Ecm9wcGFibGVFdmVudC5Ecm9wcGFibGVSZXR1cm5lZEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcclxuICAgICAgZHJvcHpvbmU6IHRoaXMubGFzdERyb3B6b25lXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJvcHBhYmxlUmV0dXJuZWRFdmVudCk7XHJcblxyXG4gICAgaWYgKGRyb3BwYWJsZVJldHVybmVkRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pbml0aWFsRHJvcHpvbmUuYXBwZW5kQ2hpbGQoZXZlbnQuc291cmNlKTtcclxuICAgIHRoaXMubGFzdERyb3B6b25lLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGNsb3Nlc3QgZHJvcHpvbmUgZWxlbWVudCBmb3IgZXZlbiB0YXJnZXRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIEV2ZW50IHRhcmdldFxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9XHJcbiAgICovXHJcbiAgW2Nsb3Nlc3REcm9wem9uZV0odGFyZ2V0KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJvcHpvbmVzKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgdGhpcy5kcm9wem9uZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbGwgY3VycmVudCBkcm9wem9uZSBlbGVtZW50cyBmb3IgdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm4ge05vZGVMaXN0fEhUTUxFbGVtZW50W118QXJyYXl9XHJcbiAgICovXHJcbiAgW2dldERyb3B6b25lc10oKSB7XHJcbiAgICBjb25zdCBkcm9wem9uZSA9IHRoaXMub3B0aW9ucy5kcm9wem9uZTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGRyb3B6b25lID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChkcm9wem9uZSk7XHJcbiAgICB9IGVsc2UgaWYgKGRyb3B6b25lIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgZHJvcHpvbmUgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICByZXR1cm4gZHJvcHpvbmU7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkcm9wem9uZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gZHJvcHpvbmUoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gRHJvcHBhYmxlO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkRyb3BwYWJsZVN0b3BFdmVudCA9IGV4cG9ydHMuRHJvcHBhYmxlUmV0dXJuZWRFdmVudCA9IGV4cG9ydHMuRHJvcHBhYmxlRHJvcHBlZEV2ZW50ID0gZXhwb3J0cy5Ecm9wcGFibGVTdGFydEV2ZW50ID0gZXhwb3J0cy5Ecm9wcGFibGVFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgZHJvcHBhYmxlIGV2ZW50XHJcbiAqIEBjbGFzcyBEcm9wcGFibGVFdmVudFxyXG4gKiBAbW9kdWxlIERyb3BwYWJsZUV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIERyb3BwYWJsZUV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBkcmFnIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZHJvcHBhYmxlIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IGRyYWdFdmVudFxyXG4gICAqIEB0eXBlIHtEcmFnRXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyYWdFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Ecm9wcGFibGVFdmVudCA9IERyb3BwYWJsZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcm9wcGFibGUgc3RhcnQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJvcHBhYmxlU3RhcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJvcHBhYmxlU3RhcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyb3BwYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Ecm9wcGFibGVFdmVudC50eXBlID0gJ2Ryb3BwYWJsZSc7XHJcbmNsYXNzIERyb3BwYWJsZVN0YXJ0RXZlbnQgZXh0ZW5kcyBEcm9wcGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBpbml0aWFsIGRyb3B6b25lIGVsZW1lbnQgb2YgdGhlIGN1cnJlbnRseSBkcmFnZ2luZyBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBkcm9wem9uZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJvcHpvbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyb3B6b25lO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Ecm9wcGFibGVTdGFydEV2ZW50ID0gRHJvcHBhYmxlU3RhcnRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyb3BwYWJsZSBkcm9wcGVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcm9wcGFibGVEcm9wcGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcm9wcGFibGVEcm9wcGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJvcHBhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Ecm9wcGFibGVTdGFydEV2ZW50LnR5cGUgPSAnZHJvcHBhYmxlOnN0YXJ0JztcclxuRHJvcHBhYmxlU3RhcnRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgRHJvcHBhYmxlRHJvcHBlZEV2ZW50IGV4dGVuZHMgRHJvcHBhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZHJvcHpvbmUgZWxlbWVudCB5b3UgZHJvcHBlZCB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaW50b1xyXG4gICAqIEBwcm9wZXJ0eSBkcm9wem9uZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJvcHpvbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyb3B6b25lO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Ecm9wcGFibGVEcm9wcGVkRXZlbnQgPSBEcm9wcGFibGVEcm9wcGVkRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJvcHBhYmxlIHJldHVybmVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJvcHBhYmxlUmV0dXJuZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcm9wcGFibGVSZXR1cm5lZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcm9wcGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Ecm9wcGFibGVEcm9wcGVkRXZlbnQudHlwZSA9ICdkcm9wcGFibGU6ZHJvcHBlZCc7XHJcbkRyb3BwYWJsZURyb3BwZWRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgRHJvcHBhYmxlUmV0dXJuZWRFdmVudCBleHRlbmRzIERyb3BwYWJsZUV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRyb3B6b25lIGVsZW1lbnQgeW91IGRyYWdnZWQgYXdheSBmcm9tXHJcbiAgICogQHByb3BlcnR5IGRyb3B6b25lXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkcm9wem9uZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuZHJvcHpvbmU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyb3BwYWJsZVJldHVybmVkRXZlbnQgPSBEcm9wcGFibGVSZXR1cm5lZEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJvcHBhYmxlIHN0b3AgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyb3BwYWJsZVN0b3BFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyb3BwYWJsZVN0b3BFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcm9wcGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyb3BwYWJsZVJldHVybmVkRXZlbnQudHlwZSA9ICdkcm9wcGFibGU6cmV0dXJuZWQnO1xyXG5Ecm9wcGFibGVSZXR1cm5lZEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBEcm9wcGFibGVTdG9wRXZlbnQgZXh0ZW5kcyBEcm9wcGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBmaW5hbCBkcm9wem9uZSBlbGVtZW50IG9mIHRoZSBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBkcm9wem9uZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJvcHpvbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyb3B6b25lO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLkRyb3BwYWJsZVN0b3BFdmVudCA9IERyb3BwYWJsZVN0b3BFdmVudDtcclxuRHJvcHBhYmxlU3RvcEV2ZW50LnR5cGUgPSAnZHJvcHBhYmxlOnN0b3AnO1xyXG5Ecm9wcGFibGVTdG9wRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Ryb3BwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblxyXG5PYmplY3Qua2V5cyhfRHJvcHBhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfRHJvcHBhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX0Ryb3BwYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG5cclxudmFyIF9Ecm9wcGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJvcHBhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfRHJvcHBhYmxlMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG4vKipcclxuICogVGhlIEVtaXR0ZXIgaXMgYSBzaW1wbGUgZW1pdHRlciBjbGFzcyB0aGF0IHByb3ZpZGVzIHlvdSB3aXRoIGBvbigpYCwgYG9mZigpYCBhbmQgYHRyaWdnZXIoKWAgbWV0aG9kc1xyXG4gKiBAY2xhc3MgRW1pdHRlclxyXG4gKiBAbW9kdWxlIEVtaXR0ZXJcclxuICovXHJcbmNsYXNzIEVtaXR0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgYnkgZXZlbnQgbmFtZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXHJcbiAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gY2FsbGJhY2tzXHJcbiAgICovXHJcbiAgb24odHlwZSwgLi4uY2FsbGJhY2tzKSB7XHJcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW3R5cGVdKSB7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jYWxsYmFja3NbdHlwZV0ucHVzaCguLi5jYWxsYmFja3MpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVW5yZWdpc3RlcnMgY2FsbGJhY2tzIGJ5IGV2ZW50IG5hbWVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgb2ZmKHR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW3R5cGVdKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvcHkgPSB0aGlzLmNhbGxiYWNrc1t0eXBlXS5zbGljZSgwKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvcHkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGNhbGxiYWNrID09PSBjb3B5W2ldKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3NbdHlwZV0uc3BsaWNlKGksIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmlnZ2VycyBldmVudCBjYWxsYmFja3MgYnkgZXZlbnQgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtBYnN0cmFjdEV2ZW50fSBldmVudFxyXG4gICAqL1xyXG4gIHRyaWdnZXIoZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5jYWxsYmFja3NbZXZlbnQudHlwZV0pIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2FsbGJhY2tzID0gWy4uLnRoaXMuY2FsbGJhY2tzW2V2ZW50LnR5cGVdXTtcclxuICAgIGNvbnN0IGNhdWdodEVycm9ycyA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSBjYWxsYmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgY29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjYXVnaHRFcnJvcnMucHVzaChlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2F1Z2h0RXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYERyYWdnYWJsZSBjYXVnaHQgZXJyb3JzIHdoaWxlIHRyaWdnZXJpbmcgJyR7ZXZlbnQudHlwZX0nYCwgY2F1Z2h0RXJyb3JzKTtcclxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBFbWl0dGVyO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9FbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XHJcblxyXG52YXIgX0VtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRW1pdHRlcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0VtaXR0ZXIyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG52YXIgX1BsdWdpbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuXHJcbnZhciBfRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xyXG5cclxudmFyIF9FbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VtaXR0ZXIpO1xyXG5cclxudmFyIF9TZW5zb3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcbnZhciBfRHJhZ2dhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHJcbnZhciBfRHJhZ0V2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XHJcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcclxuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xyXG5jb25zdCBvbkRyYWdQcmVzc3VyZSA9IFN5bWJvbCgnb25EcmFnUHJlc3N1cmUnKTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3Qge09iamVjdH0gZGVmYXVsdEFubm91bmNlbWVudHNcclxuICogQGNvbnN0IHtGdW5jdGlvbn0gZGVmYXVsdEFubm91bmNlbWVudHNbJ2RyYWc6c3RhcnQnXVxyXG4gKiBAY29uc3Qge0Z1bmN0aW9ufSBkZWZhdWx0QW5ub3VuY2VtZW50c1snZHJhZzpzdG9wJ11cclxuICovXHJcbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xyXG4gICdkcmFnOnN0YXJ0JzogZXZlbnQgPT4gYFBpY2tlZCB1cCAke2V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZXZlbnQuc291cmNlLmlkIHx8ICdkcmFnZ2FibGUgZWxlbWVudCd9YCxcclxuICAnZHJhZzpzdG9wJzogZXZlbnQgPT4gYFJlbGVhc2VkICR7ZXZlbnQuc291cmNlLnRleHRDb250ZW50LnRyaW0oKSB8fCBldmVudC5zb3VyY2UuaWQgfHwgJ2RyYWdnYWJsZSBlbGVtZW50J31gXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0Q2xhc3NlcyA9IHtcclxuICAnY29udGFpbmVyOmRyYWdnaW5nJzogJ2RyYWdnYWJsZS1jb250YWluZXItLWlzLWRyYWdnaW5nJyxcclxuICAnc291cmNlOmRyYWdnaW5nJzogJ2RyYWdnYWJsZS1zb3VyY2UtLWlzLWRyYWdnaW5nJyxcclxuICAnc291cmNlOnBsYWNlZCc6ICdkcmFnZ2FibGUtc291cmNlLS1wbGFjZWQnLFxyXG4gICdjb250YWluZXI6cGxhY2VkJzogJ2RyYWdnYWJsZS1jb250YWluZXItLXBsYWNlZCcsXHJcbiAgJ2JvZHk6ZHJhZ2dpbmcnOiAnZHJhZ2dhYmxlLS1pcy1kcmFnZ2luZycsXHJcbiAgJ2RyYWdnYWJsZTpvdmVyJzogJ2RyYWdnYWJsZS0tb3ZlcicsXHJcbiAgJ2NvbnRhaW5lcjpvdmVyJzogJ2RyYWdnYWJsZS1jb250YWluZXItLW92ZXInLFxyXG4gICdzb3VyY2U6b3JpZ2luYWwnOiAnZHJhZ2dhYmxlLS1vcmlnaW5hbCcsXHJcbiAgbWlycm9yOiAnZHJhZ2dhYmxlLW1pcnJvcidcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcclxuICBkcmFnZ2FibGU6ICcuZHJhZ2dhYmxlLXNvdXJjZScsXHJcbiAgaGFuZGxlOiBudWxsLFxyXG4gIGRlbGF5OiB7fSxcclxuICBkaXN0YW5jZTogMCxcclxuICBwbGFjZWRUaW1lb3V0OiA4MDAsXHJcbiAgcGx1Z2luczogW10sXHJcbiAgc2Vuc29yczogW10sXHJcbiAgZXhjbHVkZToge1xyXG4gICAgcGx1Z2luczogW10sXHJcbiAgICBzZW5zb3JzOiBbXVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBjb3JlIGRyYWdnYWJsZSBsaWJyYXJ5IHRoYXQgZG9lcyB0aGUgaGVhdnkgbGlmdGluZ1xyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlXHJcbiAqIEBtb2R1bGUgRHJhZ2dhYmxlXHJcbiAqL1xyXG5jbGFzcyBEcmFnZ2FibGUge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgRHJhZ2dhYmxlXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gRHJhZ2dhYmxlIGNvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGRyYWdnYWJsZVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBEZWZhdWx0IHBsdWdpbnMgZHJhZ2dhYmxlIHVzZXNcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IFBsdWdpbnNcclxuICAgKiBAcHJvcGVydHkge0Fubm91bmNlbWVudH0gUGx1Z2lucy5Bbm5vdW5jZW1lbnRcclxuICAgKiBAcHJvcGVydHkge0ZvY3VzYWJsZX0gUGx1Z2lucy5Gb2N1c2FibGVcclxuICAgKiBAcHJvcGVydHkge01pcnJvcn0gUGx1Z2lucy5NaXJyb3JcclxuICAgKiBAcHJvcGVydHkge1Njcm9sbGFibGV9IFBsdWdpbnMuU2Nyb2xsYWJsZVxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtkb2N1bWVudC5ib2R5XSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZSBjb250YWluZXJzXHJcbiAgICAgKiBAcHJvcGVydHkgY29udGFpbmVyc1xyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XHJcbiAgICAgKi9cclxuICAgIGlmIChjb250YWluZXJzIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgY29udGFpbmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi5jb250YWluZXJzXTtcclxuICAgIH0gZWxzZSBpZiAoY29udGFpbmVycyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuY29udGFpbmVycyA9IFtjb250YWluZXJzXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRHJhZ2dhYmxlIGNvbnRhaW5lcnMgYXJlIGV4cGVjdGVkIHRvIGJlIG9mIHR5cGUgYE5vZGVMaXN0YCwgYEhUTUxFbGVtZW50W11gIG9yIGBIVE1MRWxlbWVudGAnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMsIHtcclxuICAgICAgY2xhc3NlczogX2V4dGVuZHMoe30sIGRlZmF1bHRDbGFzc2VzLCBvcHRpb25zLmNsYXNzZXMgfHwge30pLFxyXG4gICAgICBhbm5vdW5jZW1lbnRzOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdEFubm91bmNlbWVudHMsIG9wdGlvbnMuYW5ub3VuY2VtZW50cyB8fCB7fSksXHJcbiAgICAgIGV4Y2x1ZGU6IHtcclxuICAgICAgICBwbHVnaW5zOiBvcHRpb25zLmV4Y2x1ZGUgJiYgb3B0aW9ucy5leGNsdWRlLnBsdWdpbnMgfHwgW10sXHJcbiAgICAgICAgc2Vuc29yczogb3B0aW9ucy5leGNsdWRlICYmIG9wdGlvbnMuZXhjbHVkZS5zZW5zb3JzIHx8IFtdXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhZ2dhYmxlcyBldmVudCBlbWl0dGVyXHJcbiAgICAgKiBAcHJvcGVydHkgZW1pdHRlclxyXG4gICAgICogQHR5cGUge0VtaXR0ZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZW1pdHRlciA9IG5ldyBfRW1pdHRlcjIuZGVmYXVsdCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBkcmFnIHN0YXRlXHJcbiAgICAgKiBAcHJvcGVydHkgZHJhZ2dpbmdcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmUgcGx1Z2luc1xyXG4gICAgICogQHByb3BlcnR5IHBsdWdpbnNcclxuICAgICAqIEB0eXBlIHtQbHVnaW5bXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5wbHVnaW5zID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmUgc2Vuc29yc1xyXG4gICAgICogQHByb3BlcnR5IHNlbnNvcnNcclxuICAgICAqIEB0eXBlIHtTZW5zb3JbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZW5zb3JzID0gW107XHJcblxyXG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1ByZXNzdXJlXSA9IHRoaXNbb25EcmFnUHJlc3N1cmVdLmJpbmQodGhpcyk7XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOnByZXNzdXJlJywgdGhpc1tvbkRyYWdQcmVzc3VyZV0sIHRydWUpO1xyXG5cclxuICAgIGNvbnN0IGRlZmF1bHRQbHVnaW5zID0gT2JqZWN0LnZhbHVlcyhEcmFnZ2FibGUuUGx1Z2lucykuZmlsdGVyKFBsdWdpbiA9PiAhdGhpcy5vcHRpb25zLmV4Y2x1ZGUucGx1Z2lucy5pbmNsdWRlcyhQbHVnaW4pKTtcclxuICAgIGNvbnN0IGRlZmF1bHRTZW5zb3JzID0gT2JqZWN0LnZhbHVlcyhEcmFnZ2FibGUuU2Vuc29ycykuZmlsdGVyKHNlbnNvciA9PiAhdGhpcy5vcHRpb25zLmV4Y2x1ZGUuc2Vuc29ycy5pbmNsdWRlcyhzZW5zb3IpKTtcclxuXHJcbiAgICB0aGlzLmFkZFBsdWdpbiguLi5bLi4uZGVmYXVsdFBsdWdpbnMsIC4uLnRoaXMub3B0aW9ucy5wbHVnaW5zXSk7XHJcbiAgICB0aGlzLmFkZFNlbnNvciguLi5bLi4uZGVmYXVsdFNlbnNvcnMsIC4uLnRoaXMub3B0aW9ucy5zZW5zb3JzXSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCA9IG5ldyBfRHJhZ2dhYmxlRXZlbnQuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCh7XHJcbiAgICAgIGRyYWdnYWJsZTogdGhpc1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5vbignbWlycm9yOmNyZWF0ZWQnLCAoeyBtaXJyb3IgfSkgPT4gdGhpcy5taXJyb3IgPSBtaXJyb3IpO1xyXG4gICAgdGhpcy5vbignbWlycm9yOmRlc3Ryb3knLCAoKSA9PiB0aGlzLm1pcnJvciA9IG51bGwpO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3lzIERyYWdnYWJsZSBpbnN0YW5jZS4gVGhpcyByZW1vdmVzIGFsbCBpbnRlcm5hbCBldmVudCBsaXN0ZW5lcnMgYW5kXHJcbiAgICogZGVhY3RpdmF0ZXMgc2Vuc29ycyBhbmQgcGx1Z2luc1xyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRGVmYXVsdCBzZW5zb3JzIGRyYWdnYWJsZSB1c2VzXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBTZW5zb3JzXHJcbiAgICogQHByb3BlcnR5IHtNb3VzZVNlbnNvcn0gU2Vuc29ycy5Nb3VzZVNlbnNvclxyXG4gICAqIEBwcm9wZXJ0eSB7VG91Y2hTZW5zb3J9IFNlbnNvcnMuVG91Y2hTZW5zb3JcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6cHJlc3N1cmUnLCB0aGlzW29uRHJhZ1ByZXNzdXJlXSwgdHJ1ZSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ2dhYmxlRGVzdHJveUV2ZW50ID0gbmV3IF9EcmFnZ2FibGVFdmVudC5EcmFnZ2FibGVEZXN0cm95RXZlbnQoe1xyXG4gICAgICBkcmFnZ2FibGU6IHRoaXNcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnZ2FibGVEZXN0cm95RXZlbnQpO1xyXG5cclxuICAgIHRoaXMucmVtb3ZlUGx1Z2luKC4uLnRoaXMucGx1Z2lucy5tYXAocGx1Z2luID0+IHBsdWdpbi5jb25zdHJ1Y3RvcikpO1xyXG4gICAgdGhpcy5yZW1vdmVTZW5zb3IoLi4udGhpcy5zZW5zb3JzLm1hcChzZW5zb3IgPT4gc2Vuc29yLmNvbnN0cnVjdG9yKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIHBsdWdpbiB0byB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZS4gVGhpcyB3aWxsIGVuZCB1cCBjYWxsaW5nIHRoZSBhdHRhY2ggbWV0aG9kIG9mIHRoZSBwbHVnaW5cclxuICAgKiBAcGFyYW0gey4uLnR5cGVvZiBQbHVnaW59IHBsdWdpbnMgLSBQbHVnaW5zIHRoYXQgeW91IHdhbnQgYXR0YWNoZWQgdG8gZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5hZGRQbHVnaW4oQ3VzdG9tQTExeVBsdWdpbiwgQ3VzdG9tTWlycm9yUGx1Z2luKVxyXG4gICAqL1xyXG4gIGFkZFBsdWdpbiguLi5wbHVnaW5zKSB7XHJcbiAgICBjb25zdCBhY3RpdmVQbHVnaW5zID0gcGx1Z2lucy5tYXAoUGx1Z2luID0+IG5ldyBQbHVnaW4odGhpcykpO1xyXG5cclxuICAgIGFjdGl2ZVBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4gcGx1Z2luLmF0dGFjaCgpKTtcclxuICAgIHRoaXMucGx1Z2lucyA9IFsuLi50aGlzLnBsdWdpbnMsIC4uLmFjdGl2ZVBsdWdpbnNdO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBwbHVnaW5zIHRoYXQgYXJlIGFscmVhZHkgYXR0YWNoZWQgdG8gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2UuIFRoaXMgd2lsbCBlbmQgdXAgY2FsbGluZ1xyXG4gICAqIHRoZSBkZXRhY2ggbWV0aG9kIG9mIHRoZSBwbHVnaW5cclxuICAgKiBAcGFyYW0gey4uLnR5cGVvZiBQbHVnaW59IHBsdWdpbnMgLSBQbHVnaW5zIHRoYXQgeW91IHdhbnQgZGV0YWNoZWQgZnJvbSBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLnJlbW92ZVBsdWdpbihNaXJyb3JQbHVnaW4sIEN1c3RvbU1pcnJvclBsdWdpbilcclxuICAgKi9cclxuICByZW1vdmVQbHVnaW4oLi4ucGx1Z2lucykge1xyXG4gICAgY29uc3QgcmVtb3ZlZFBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiBwbHVnaW5zLmluY2x1ZGVzKHBsdWdpbi5jb25zdHJ1Y3RvcikpO1xyXG5cclxuICAgIHJlbW92ZWRQbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHBsdWdpbi5kZXRhY2goKSk7XHJcbiAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiAhcGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4uY29uc3RydWN0b3IpKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgc2Vuc29ycyB0byB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZS4gVGhpcyB3aWxsIGVuZCB1cCBjYWxsaW5nIHRoZSBhdHRhY2ggbWV0aG9kIG9mIHRoZSBzZW5zb3JcclxuICAgKiBAcGFyYW0gey4uLnR5cGVvZiBTZW5zb3J9IHNlbnNvcnMgLSBTZW5zb3JzIHRoYXQgeW91IHdhbnQgYXR0YWNoZWQgdG8gZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5hZGRTZW5zb3IoRm9yY2VUb3VjaFNlbnNvciwgQ3VzdG9tU2Vuc29yKVxyXG4gICAqL1xyXG4gIGFkZFNlbnNvciguLi5zZW5zb3JzKSB7XHJcbiAgICBjb25zdCBhY3RpdmVTZW5zb3JzID0gc2Vuc29ycy5tYXAoU2Vuc29yID0+IG5ldyBTZW5zb3IodGhpcy5jb250YWluZXJzLCB0aGlzLm9wdGlvbnMpKTtcclxuXHJcbiAgICBhY3RpdmVTZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5hdHRhY2goKSk7XHJcbiAgICB0aGlzLnNlbnNvcnMgPSBbLi4udGhpcy5zZW5zb3JzLCAuLi5hY3RpdmVTZW5zb3JzXTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgc2Vuc29ycyB0aGF0IGFyZSBhbHJlYWR5IGF0dGFjaGVkIHRvIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlLiBUaGlzIHdpbGwgZW5kIHVwIGNhbGxpbmdcclxuICAgKiB0aGUgZGV0YWNoIG1ldGhvZCBvZiB0aGUgc2Vuc29yXHJcbiAgICogQHBhcmFtIHsuLi50eXBlb2YgU2Vuc29yfSBzZW5zb3JzIC0gU2Vuc29ycyB0aGF0IHlvdSB3YW50IGF0dGFjaGVkIHRvIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUucmVtb3ZlU2Vuc29yKFRvdWNoU2Vuc29yLCBEcmFnU2Vuc29yKVxyXG4gICAqL1xyXG4gIHJlbW92ZVNlbnNvciguLi5zZW5zb3JzKSB7XHJcbiAgICBjb25zdCByZW1vdmVkU2Vuc29ycyA9IHRoaXMuc2Vuc29ycy5maWx0ZXIoc2Vuc29yID0+IHNlbnNvcnMuaW5jbHVkZXMoc2Vuc29yLmNvbnN0cnVjdG9yKSk7XHJcblxyXG4gICAgcmVtb3ZlZFNlbnNvcnMuZm9yRWFjaChzZW5zb3IgPT4gc2Vuc29yLmRldGFjaCgpKTtcclxuICAgIHRoaXMuc2Vuc29ycyA9IHRoaXMuc2Vuc29ycy5maWx0ZXIoc2Vuc29yID0+ICFzZW5zb3JzLmluY2x1ZGVzKHNlbnNvci5jb25zdHJ1Y3RvcikpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBjb250YWluZXIgdG8gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0gey4uLkhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVycyB5b3Ugd2FudCB0byBhZGQgdG8gZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5hZGRDb250YWluZXIoZG9jdW1lbnQuYm9keSlcclxuICAgKi9cclxuICBhZGRDb250YWluZXIoLi4uY29udGFpbmVycykge1xyXG4gICAgdGhpcy5jb250YWluZXJzID0gWy4uLnRoaXMuY29udGFpbmVycywgLi4uY29udGFpbmVyc107XHJcbiAgICB0aGlzLnNlbnNvcnMuZm9yRWFjaChzZW5zb3IgPT4gc2Vuc29yLmFkZENvbnRhaW5lciguLi5jb250YWluZXJzKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgY29udGFpbmVyIGZyb20gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0gey4uLkhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVycyB5b3Ugd2FudCB0byByZW1vdmUgZnJvbSBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLnJlbW92ZUNvbnRhaW5lcihkb2N1bWVudC5ib2R5KVxyXG4gICAqL1xyXG4gIHJlbW92ZUNvbnRhaW5lciguLi5jb250YWluZXJzKSB7XHJcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSB0aGlzLmNvbnRhaW5lcnMuZmlsdGVyKGNvbnRhaW5lciA9PiAhY29udGFpbmVycy5pbmNsdWRlcyhjb250YWluZXIpKTtcclxuICAgIHRoaXMuc2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IucmVtb3ZlQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBsaXN0ZW5lciBmb3IgZHJhZ2dhYmxlIGV2ZW50c1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gRXZlbnQgbmFtZVxyXG4gICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGNhbGxiYWNrcyAtIEV2ZW50IGNhbGxiYWNrc1xyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCAoZHJhZ0V2ZW50KSA9PiBkcmFnRXZlbnQuY2FuY2VsKCkpO1xyXG4gICAqL1xyXG4gIG9uKHR5cGUsIC4uLmNhbGxiYWNrcykge1xyXG4gICAgdGhpcy5lbWl0dGVyLm9uKHR5cGUsIC4uLmNhbGxiYWNrcyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgbGlzdGVuZXIgZnJvbSBkcmFnZ2FibGVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIEV2ZW50IG5hbWVcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEV2ZW50IGNhbGxiYWNrXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCBoYW5kbGVyRnVuY3Rpb24pO1xyXG4gICAqL1xyXG4gIG9mZih0eXBlLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5lbWl0dGVyLm9mZih0eXBlLCBjYWxsYmFjayk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXJzIGRyYWdnYWJsZSBldmVudFxyXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RFdmVudH0gZXZlbnQgLSBFdmVudCBpbnN0YW5jZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUudHJpZ2dlcihldmVudCk7XHJcbiAgICovXHJcbiAgdHJpZ2dlcihldmVudCkge1xyXG4gICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoZXZlbnQpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGNsYXNzIG5hbWUgZm9yIGNsYXNzIGlkZW50aWZpZXJcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgY2xhc3MgaWRlbnRpZmllclxyXG4gICAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxyXG4gICAqL1xyXG4gIGdldENsYXNzTmFtZUZvcihuYW1lKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRDbGFzc05hbWVzRm9yKG5hbWUpWzBdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjbGFzcyBuYW1lcyBmb3IgY2xhc3MgaWRlbnRpZmllclxyXG4gICAqIEByZXR1cm4ge1N0cmluZ1tdfVxyXG4gICAqL1xyXG4gIGdldENsYXNzTmFtZXNGb3IobmFtZSkge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IHRoaXMub3B0aW9ucy5jbGFzc2VzW25hbWVdO1xyXG5cclxuICAgIGlmIChjbGFzc05hbWVzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjbGFzc05hbWVzID09PSAnc3RyaW5nJyB8fCBjbGFzc05hbWVzIGluc3RhbmNlb2YgU3RyaW5nKSB7XHJcbiAgICAgIHJldHVybiBbY2xhc3NOYW1lc107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2UgaXMgY3VycmVudGx5IGRyYWdnaW5nXHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBpc0RyYWdnaW5nKCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5kcmFnZ2luZyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFsbCBkcmFnZ2FibGUgZWxlbWVudHNcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudFtdfVxyXG4gICAqL1xyXG4gIGdldERyYWdnYWJsZUVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVycy5yZWR1Y2UoKGN1cnJlbnQsIGNvbnRhaW5lcikgPT4ge1xyXG4gICAgICByZXR1cm4gWy4uLmN1cnJlbnQsIC4uLnRoaXMuZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIoY29udGFpbmVyKV07XHJcbiAgICB9LCBbXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGRyYWdnYWJsZSBlbGVtZW50cyBmb3IgYSBnaXZlbiBjb250YWluZXIsIGV4Y2x1ZGluZyB0aGUgbWlycm9yIGFuZFxyXG4gICAqIG9yaWdpbmFsIHNvdXJjZSBlbGVtZW50IGlmIHByZXNlbnRcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudFtdfVxyXG4gICAqL1xyXG4gIGdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gICAgY29uc3QgYWxsRHJhZ2dhYmxlRWxlbWVudHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcclxuXHJcbiAgICByZXR1cm4gWy4uLmFsbERyYWdnYWJsZUVsZW1lbnRzXS5maWx0ZXIoY2hpbGRFbGVtZW50ID0+IHtcclxuICAgICAgcmV0dXJuIGNoaWxkRWxlbWVudCAhPT0gdGhpcy5vcmlnaW5hbFNvdXJjZSAmJiBjaGlsZEVsZW1lbnQgIT09IHRoaXMubWlycm9yO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRE9NIERyYWcgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RhcnRdKGV2ZW50KSB7XHJcbiAgICBjb25zdCBzZW5zb3JFdmVudCA9IGdldFNlbnNvckV2ZW50KGV2ZW50KTtcclxuICAgIGNvbnN0IHsgdGFyZ2V0LCBjb250YWluZXIgfSA9IHNlbnNvckV2ZW50O1xyXG5cclxuICAgIGlmICghdGhpcy5jb250YWluZXJzLmluY2x1ZGVzKGNvbnRhaW5lcikpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlICYmIHRhcmdldCAmJiAhKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIHRoaXMub3B0aW9ucy5oYW5kbGUpKSB7XHJcbiAgICAgIHNlbnNvckV2ZW50LmNhbmNlbCgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmluZCBkcmFnZ2FibGUgc291cmNlIGVsZW1lbnRcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XHJcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuXHJcbiAgICBpZiAoIXRoaXMub3JpZ2luYWxTb3VyY2UpIHtcclxuICAgICAgc2Vuc29yRXZlbnQuY2FuY2VsKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5sYXN0UGxhY2VkU291cmNlICYmIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lcikge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5wbGFjZWRUaW1lb3V0SUQpO1xyXG4gICAgICB0aGlzLmxhc3RQbGFjZWRTb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XHJcbiAgICAgIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOnBsYWNlZCcpKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNvdXJjZSA9IHRoaXMub3JpZ2luYWxTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnNvdXJjZSwgdGhpcy5vcmlnaW5hbFNvdXJjZSk7XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgY29uc3QgZHJhZ0V2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ1N0YXJ0RXZlbnQoe1xyXG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ0V2ZW50KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdFdmVudC5jYW5jZWxlZCgpO1xyXG5cclxuICAgIGlmIChkcmFnRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICB0aGlzLnNvdXJjZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc291cmNlKTtcclxuICAgICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpvcmlnaW5hbCcpKTtcclxuICAgIHRoaXMuc291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6ZHJhZ2dpbmcnKSk7XHJcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOmRyYWdnaW5nJykpO1xyXG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignYm9keTpkcmFnZ2luZycpKTtcclxuICAgIGFwcGx5VXNlclNlbGVjdChkb2N1bWVudC5ib2R5LCAnbm9uZScpO1xyXG5cclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG9sZFNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xyXG4gICAgICBjb25zdCBuZXdTZW5zb3JFdmVudCA9IG9sZFNlbnNvckV2ZW50LmNsb25lKHsgdGFyZ2V0OiB0aGlzLnNvdXJjZSB9KTtcclxuXHJcbiAgICAgIHRoaXNbb25EcmFnTW92ZV0oX2V4dGVuZHMoe30sIGV2ZW50LCB7XHJcbiAgICAgICAgZGV0YWlsOiBuZXdTZW5zb3JFdmVudFxyXG4gICAgICB9KSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgbW92ZSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERPTSBEcmFnIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ01vdmVdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xyXG4gICAgY29uc3QgeyBjb250YWluZXIgfSA9IHNlbnNvckV2ZW50O1xyXG4gICAgbGV0IHRhcmdldCA9IHNlbnNvckV2ZW50LnRhcmdldDtcclxuXHJcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ01vdmVFdmVudCh7XHJcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnTW92ZUV2ZW50KTtcclxuXHJcbiAgICBpZiAoZHJhZ01vdmVFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHNlbnNvckV2ZW50LmNhbmNlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRhcmdldCA9ICgwLCBfdXRpbHMuY2xvc2VzdCkodGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcclxuICAgIGNvbnN0IHdpdGhpbkNvcnJlY3RDb250YWluZXIgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKHNlbnNvckV2ZW50LnRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcclxuICAgIGNvbnN0IG92ZXJDb250YWluZXIgPSBzZW5zb3JFdmVudC5vdmVyQ29udGFpbmVyIHx8IHdpdGhpbkNvcnJlY3RDb250YWluZXI7XHJcbiAgICBjb25zdCBpc0xlYXZpbmdDb250YWluZXIgPSB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyICYmIG92ZXJDb250YWluZXIgIT09IHRoaXMuY3VycmVudE92ZXJDb250YWluZXI7XHJcbiAgICBjb25zdCBpc0xlYXZpbmdEcmFnZ2FibGUgPSB0aGlzLmN1cnJlbnRPdmVyICYmIHRhcmdldCAhPT0gdGhpcy5jdXJyZW50T3ZlcjtcclxuICAgIGNvbnN0IGlzT3ZlckNvbnRhaW5lciA9IG92ZXJDb250YWluZXIgJiYgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciAhPT0gb3ZlckNvbnRhaW5lcjtcclxuICAgIGNvbnN0IGlzT3ZlckRyYWdnYWJsZSA9IHdpdGhpbkNvcnJlY3RDb250YWluZXIgJiYgdGFyZ2V0ICYmIHRoaXMuY3VycmVudE92ZXIgIT09IHRhcmdldDtcclxuXHJcbiAgICBpZiAoaXNMZWF2aW5nRHJhZ2dhYmxlKSB7XHJcbiAgICAgIGNvbnN0IGRyYWdPdXRFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdPdXRFdmVudCh7XHJcbiAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcclxuICAgICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgICBvdmVyOiB0aGlzLmN1cnJlbnRPdmVyLFxyXG4gICAgICAgIG92ZXJDb250YWluZXI6IHRoaXMuY3VycmVudE92ZXJDb250YWluZXJcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcmFnZ2FibGU6b3ZlcicpKTtcclxuICAgICAgdGhpcy5jdXJyZW50T3ZlciA9IG51bGw7XHJcblxyXG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ091dEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNMZWF2aW5nQ29udGFpbmVyKSB7XHJcbiAgICAgIGNvbnN0IGRyYWdPdXRDb250YWluZXJFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdPdXRDb250YWluZXJFdmVudCh7XHJcbiAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcclxuICAgICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgICBvdmVyQ29udGFpbmVyOiB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOm92ZXInKSk7XHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgPSBudWxsO1xyXG5cclxuICAgICAgdGhpcy50cmlnZ2VyKGRyYWdPdXRDb250YWluZXJFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzT3ZlckNvbnRhaW5lcikge1xyXG4gICAgICBvdmVyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6b3ZlcicpKTtcclxuXHJcbiAgICAgIGNvbnN0IGRyYWdPdmVyQ29udGFpbmVyRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnT3ZlckNvbnRhaW5lckV2ZW50KHtcclxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG92ZXJDb250YWluZXJcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyID0gb3ZlckNvbnRhaW5lcjtcclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3ZlckNvbnRhaW5lckV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNPdmVyRHJhZ2dhYmxlKSB7XHJcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJhZ2dhYmxlOm92ZXInKSk7XHJcblxyXG4gICAgICBjb25zdCBkcmFnT3ZlckV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ092ZXJFdmVudCh7XHJcbiAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcclxuICAgICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgICBvdmVyQ29udGFpbmVyLFxyXG4gICAgICAgIG92ZXI6IHRhcmdldFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXIgPSB0YXJnZXQ7XHJcblxyXG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ092ZXJFdmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0b3AgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBET00gRHJhZyBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdG9wXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdTdG9wRXZlbnQoe1xyXG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc2Vuc29yRXZlbnQ6IGV2ZW50LnNlbnNvckV2ZW50LFxyXG4gICAgICBzb3VyY2VDb250YWluZXI6IHRoaXMuc291cmNlQ29udGFpbmVyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ1N0b3BFdmVudCk7XHJcblxyXG4gICAgdGhpcy5zb3VyY2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5vcmlnaW5hbFNvdXJjZSwgdGhpcy5zb3VyY2UpO1xyXG4gICAgdGhpcy5zb3VyY2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNvdXJjZSk7XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuXHJcbiAgICB0aGlzLnNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOmRyYWdnaW5nJykpO1xyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOm9yaWdpbmFsJykpO1xyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcclxuICAgIHRoaXMuc291cmNlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6cGxhY2VkJykpO1xyXG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpkcmFnZ2luZycpKTtcclxuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2JvZHk6ZHJhZ2dpbmcnKSk7XHJcbiAgICBhcHBseVVzZXJTZWxlY3QoZG9jdW1lbnQuYm9keSwgJycpO1xyXG5cclxuICAgIGlmICh0aGlzLmN1cnJlbnRPdmVyKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2RyYWdnYWJsZTpvdmVyJykpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpvdmVyJykpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZSA9IHRoaXMub3JpZ2luYWxTb3VyY2U7XHJcbiAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIgPSB0aGlzLnNvdXJjZUNvbnRhaW5lcjtcclxuXHJcbiAgICB0aGlzLnBsYWNlZFRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy5sYXN0UGxhY2VkU291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0UGxhY2VkU291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6cGxhY2VkJykpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmxhc3RQbGFjZWRTb3VyY2UgPSBudWxsO1xyXG4gICAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIgPSBudWxsO1xyXG4gICAgfSwgdGhpcy5vcHRpb25zLnBsYWNlZFRpbWVvdXQpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdG9wcGVkRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnU3RvcHBlZEV2ZW50KHtcclxuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNlbnNvckV2ZW50OiBldmVudC5zZW5zb3JFdmVudCxcclxuICAgICAgc291cmNlQ29udGFpbmVyOiB0aGlzLnNvdXJjZUNvbnRhaW5lclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdTdG9wcGVkRXZlbnQpO1xyXG5cclxuICAgIHRoaXMuc291cmNlID0gbnVsbDtcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UgPSBudWxsO1xyXG4gICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciA9IG51bGw7XHJcbiAgICB0aGlzLmN1cnJlbnRPdmVyID0gbnVsbDtcclxuICAgIHRoaXMuc291cmNlQ29udGFpbmVyID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgcHJlc3N1cmUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBET00gRHJhZyBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdQcmVzc3VyZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XHJcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZSB8fCAoMCwgX3V0aWxzLmNsb3Nlc3QpKHNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcclxuXHJcbiAgICBjb25zdCBkcmFnUHJlc3N1cmVFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdQcmVzc3VyZUV2ZW50KHtcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgcHJlc3N1cmU6IHNlbnNvckV2ZW50LnByZXNzdXJlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ1ByZXNzdXJlRXZlbnQpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ2dhYmxlO1xyXG5EcmFnZ2FibGUuUGx1Z2lucyA9IHsgQW5ub3VuY2VtZW50OiBfUGx1Z2lucy5Bbm5vdW5jZW1lbnQsIEZvY3VzYWJsZTogX1BsdWdpbnMuRm9jdXNhYmxlLCBNaXJyb3I6IF9QbHVnaW5zLk1pcnJvciwgU2Nyb2xsYWJsZTogX1BsdWdpbnMuU2Nyb2xsYWJsZSB9O1xyXG5EcmFnZ2FibGUuU2Vuc29ycyA9IHsgTW91c2VTZW5zb3I6IF9TZW5zb3JzLk1vdXNlU2Vuc29yLCBUb3VjaFNlbnNvcjogX1NlbnNvcnMuVG91Y2hTZW5zb3IgfTtcclxuZnVuY3Rpb24gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpIHtcclxuICByZXR1cm4gZXZlbnQuZGV0YWlsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVVzZXJTZWxlY3QoZWxlbWVudCwgdmFsdWUpIHtcclxuICBlbGVtZW50LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSB2YWx1ZTtcclxuICBlbGVtZW50LnN0eWxlLm1velVzZXJTZWxlY3QgPSB2YWx1ZTtcclxuICBlbGVtZW50LnN0eWxlLm1zVXNlclNlbGVjdCA9IHZhbHVlO1xyXG4gIGVsZW1lbnQuc3R5bGUub1VzZXJTZWxlY3QgPSB2YWx1ZTtcclxuICBlbGVtZW50LnN0eWxlLnVzZXJTZWxlY3QgPSB2YWx1ZTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uTW91c2VGb3JjZVdpbGxCZWdpbiA9IFN5bWJvbCgnb25Nb3VzZUZvcmNlV2lsbEJlZ2luJyk7XHJcbmNvbnN0IG9uTW91c2VGb3JjZURvd24gPSBTeW1ib2woJ29uTW91c2VGb3JjZURvd24nKTtcclxuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XHJcbmNvbnN0IG9uTW91c2VGb3JjZUNoYW5nZSA9IFN5bWJvbCgnb25Nb3VzZUZvcmNlQ2hhbmdlJyk7XHJcbmNvbnN0IG9uTW91c2VNb3ZlID0gU3ltYm9sKCdvbk1vdXNlTW92ZScpO1xyXG5jb25zdCBvbk1vdXNlVXAgPSBTeW1ib2woJ29uTW91c2VVcCcpO1xyXG5jb25zdCBvbk1vdXNlRm9yY2VHbG9iYWxDaGFuZ2UgPSBTeW1ib2woJ29uTW91c2VGb3JjZUdsb2JhbENoYW5nZScpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgc2Vuc29yIHBpY2tzIHVwIG5hdGl2ZSBmb3JjZSB0b3VjaCBldmVudHMgYW5kIGRpY3RhdGVzIGRyYWcgb3BlcmF0aW9uc1xyXG4gKiBAY2xhc3MgRm9yY2VUb3VjaFNlbnNvclxyXG4gKiBAbW9kdWxlIEZvcmNlVG91Y2hTZW5zb3JcclxuICogQGV4dGVuZHMgU2Vuc29yXHJcbiAqL1xyXG5jbGFzcyBGb3JjZVRvdWNoU2Vuc29yIGV4dGVuZHMgX1NlbnNvcjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogRm9yY2VUb3VjaFNlbnNvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBGb3JjZVRvdWNoU2Vuc29yXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZSBlbGVtZW50IG5lZWRzIHRvIGJlIHJlbWVtYmVyZWQgdG8gdW5zZXQgdGhlIGRyYWdnYWJsZSBhdHRyaWJ1dGUgYWZ0ZXIgZHJhZyBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZFxyXG4gICAgICogQHByb3BlcnR5IG1pZ2h0RHJhZ1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWlnaHREcmFnID0gZmFsc2U7XHJcblxyXG4gICAgdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dID0gdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VGb3JjZURvd25dID0gdGhpc1tvbk1vdXNlRm9yY2VEb3duXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlRG93bl0gPSB0aGlzW29uTW91c2VEb3duXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdID0gdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VNb3ZlXSA9IHRoaXNbb25Nb3VzZU1vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VVcF0gPSB0aGlzW29uTW91c2VVcF0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICBmb3IgKGNvbnN0IGNvbnRhaW5lciBvZiB0aGlzLmNvbnRhaW5lcnMpIHtcclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2V3aWxsYmVnaW4nLCB0aGlzW29uTW91c2VGb3JjZVdpbGxCZWdpbl0sIGZhbHNlKTtcclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2Vkb3duJywgdGhpc1tvbk1vdXNlRm9yY2VEb3duXSwgZmFsc2UpO1xyXG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZWNoYW5nZWQnLCB0aGlzW29uTW91c2VGb3JjZUNoYW5nZV0sIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uTW91c2VNb3ZlXSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICBmb3IgKGNvbnN0IGNvbnRhaW5lciBvZiB0aGlzLmNvbnRhaW5lcnMpIHtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2V3aWxsYmVnaW4nLCB0aGlzW29uTW91c2VGb3JjZVdpbGxCZWdpbl0sIGZhbHNlKTtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2Vkb3duJywgdGhpc1tvbk1vdXNlRm9yY2VEb3duXSwgZmFsc2UpO1xyXG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZWNoYW5nZWQnLCB0aGlzW29uTW91c2VGb3JjZUNoYW5nZV0sIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uTW91c2VNb3ZlXSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGZvcmNlIHdpbGwgYmVnaW4gaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBmb3JjZSB3aWxsIGJlZ2luIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VGb3JjZVdpbGxCZWdpbl0oZXZlbnQpIHtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBmb3JjZSBkb3duIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2UgZG93biBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRm9yY2VEb3duXShldmVudCkge1xyXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RhcnRTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGNvbnRhaW5lciwgZHJhZ1N0YXJ0RXZlbnQpO1xyXG5cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIHRoaXMuZHJhZ2dpbmcgPSAhZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKTtcclxuICAgIHRoaXMubWlnaHREcmFnID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSB1cCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIHVwIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VVcF0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0b3BTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldDogbnVsbCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RvcEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBudWxsO1xyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5taWdodERyYWcgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGRvd24gaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBkb3duIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VEb3duXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLm1pZ2h0RHJhZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTmVlZCB3b3JrYXJvdW5kIGZvciByZWFsIGNsaWNrXHJcbiAgICAvLyBDYW5jZWwgcG90ZW50aWFsIGRyYWcgZXZlbnRzXHJcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIG1vdmUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBmb3JjZSB3aWxsIGJlZ2luIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VNb3ZlXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdNb3ZlU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ01vdmVFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBmb3JjZSBjaGFuZ2UgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBmb3JjZSBjaGFuZ2UgZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZUZvcmNlQ2hhbmdlXShldmVudCkge1xyXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XHJcblxyXG4gICAgY29uc3QgZHJhZ1ByZXNzdXJlRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdQcmVzc3VyZVNlbnNvckV2ZW50KHtcclxuICAgICAgcHJlc3N1cmU6IGV2ZW50LndlYmtpdEZvcmNlLFxyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdQcmVzc3VyZUV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGZvcmNlIGdsb2JhbCBjaGFuZ2UgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBmb3JjZSBnbG9iYWwgY2hhbmdlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VGb3JjZUdsb2JhbENoYW5nZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuICAgIGNvbnN0IGRyYWdQcmVzc3VyZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnUHJlc3N1cmVTZW5zb3JFdmVudCh7XHJcbiAgICAgIHByZXNzdXJlOiBldmVudC53ZWJraXRGb3JjZSxcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdQcmVzc3VyZUV2ZW50KTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gRm9yY2VUb3VjaFNlbnNvcjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRm9yY2VUb3VjaFNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xyXG5cclxudmFyIF9Gb3JjZVRvdWNoU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZvcmNlVG91Y2hTZW5zb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Gb3JjZVRvdWNoU2Vuc29yMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG52YXIgX1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpO1xyXG5cclxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XHJcbmNvbnN0IG9uTW91c2VVcCA9IFN5bWJvbCgnb25Nb3VzZVVwJyk7XHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdPdmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyJyk7XHJcbmNvbnN0IG9uRHJhZ0VuZCA9IFN5bWJvbCgnb25EcmFnRW5kJyk7XHJcbmNvbnN0IG9uRHJvcCA9IFN5bWJvbCgnb25Ecm9wJyk7XHJcbmNvbnN0IHJlc2V0ID0gU3ltYm9sKCdyZXNldCcpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgc2Vuc29yIHBpY2tzIHVwIG5hdGl2ZSBicm93c2VyIGRyYWcgZXZlbnRzIGFuZCBkaWN0YXRlcyBkcmFnIG9wZXJhdGlvbnNcclxuICogQGNsYXNzIERyYWdTZW5zb3JcclxuICogQG1vZHVsZSBEcmFnU2Vuc29yXHJcbiAqIEBleHRlbmRzIFNlbnNvclxyXG4gKi9cclxuY2xhc3MgRHJhZ1NlbnNvciBleHRlbmRzIF9TZW5zb3IyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIERyYWdTZW5zb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgRHJhZ1NlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBkb3duIHRpbWVyIHdoaWNoIHdpbGwgZW5kIHVwIHNldHRpbmcgdGhlIGRyYWdnYWJsZSBhdHRyaWJ1dGUsIHVubGVzcyBjYW5jZWxlZFxyXG4gICAgICogQHByb3BlcnR5IG1vdXNlRG93blRpbWVvdXRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubW91c2VEb3duVGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmFnZ2FibGUgZWxlbWVudCBuZWVkcyB0byBiZSByZW1lbWJlcmVkIHRvIHVuc2V0IHRoZSBkcmFnZ2FibGUgYXR0cmlidXRlIGFmdGVyIGRyYWcgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWRcclxuICAgICAqIEBwcm9wZXJ0eSBkcmFnZ2FibGVFbGVtZW50XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJhZ2dhYmxlRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOYXRpdmUgZHJhZ2dhYmxlIGVsZW1lbnQgY291bGQgYmUgbGlua3Mgb3IgaW1hZ2VzLCB0aGVpciBkcmFnZ2FibGUgc3RhdGUgd2lsbCBiZSBkaXNhYmxlZCBkdXJpbmcgZHJhZyBvcGVyYXRpb25cclxuICAgICAqIEBwcm9wZXJ0eSBuYXRpdmVEcmFnZ2FibGVFbGVtZW50XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvbk1vdXNlRG93bl0gPSB0aGlzW29uTW91c2VEb3duXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlVXBdID0gdGhpc1tvbk1vdXNlVXBdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ092ZXJdID0gdGhpc1tvbkRyYWdPdmVyXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdFbmRdID0gdGhpc1tvbkRyYWdFbmRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJvcF0gPSB0aGlzW29uRHJvcF0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdGFydCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERyYWcgc3RhcnQgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RhcnRdKGV2ZW50KSB7XHJcbiAgICAvLyBOZWVkIGZvciBmaXJlZm94LiBcInRleHRcIiBrZXkgaXMgbmVlZGVkIGZvciBJRVxyXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoJ3RleHQnLCAnJyk7XHJcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IHRoaXMub3B0aW9ucy50eXBlO1xyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGV2ZW50LnRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuY3VycmVudENvbnRhaW5lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdGFydFNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFdvcmthcm91bmRcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XHJcblxyXG4gICAgICBpZiAoZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSwgMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG92ZXIgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBEcmFnIG92ZXIgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnT3Zlcl0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbnRhaW5lcjtcclxuXHJcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnTW92ZVNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcclxuXHJcbiAgICBpZiAoIWRyYWdNb3ZlRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IHRoaXMub3B0aW9ucy50eXBlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBlbmQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBEcmFnIGVuZCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdFbmRdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0sIHRydWUpO1xyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0b3BTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGNvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5zdGFydEV2ZW50ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW3Jlc2V0XSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJvcCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERyb3AgZXZlbnRcclxuICAgKi9cclxuICBbb25Ecm9wXShldmVudCkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZG93biBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGRvd24gZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZURvd25dKGV2ZW50KSB7XHJcbiAgICAvLyBGaXJlZm94IGJ1ZyBmb3IgaW5wdXRzIHdpdGhpbiBkcmFnZ2FibGVzIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTczOTA3MVxyXG4gICAgaWYgKGV2ZW50LnRhcmdldCAmJiAoZXZlbnQudGFyZ2V0LmZvcm0gfHwgZXZlbnQudGFyZ2V0LmNvbnRlbnRlZGl0YWJsZSkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5hdGl2ZURyYWdnYWJsZUVsZW1lbnQgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGV2ZW50LnRhcmdldCwgZWxlbWVudCA9PiBlbGVtZW50LmRyYWdnYWJsZSk7XHJcblxyXG4gICAgaWYgKG5hdGl2ZURyYWdnYWJsZUVsZW1lbnQpIHtcclxuICAgICAgbmF0aXZlRHJhZ2dhYmxlRWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcclxuICAgICAgdGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gbmF0aXZlRHJhZ2dhYmxlRWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0sIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCB0aGlzW29uRHJhZ0VuZF0sIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzW29uRHJvcF0sIGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGV2ZW50LnRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XHJcblxyXG4gICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IGV2ZW50O1xyXG5cclxuICAgIHRoaXMubW91c2VEb3duVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0YXJnZXQuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuICAgICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50ID0gdGFyZ2V0O1xyXG4gICAgfSwgdGhpcy5kZWxheS5kcmFnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIHVwIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgdXAgZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZVVwXSgpIHtcclxuICAgIHRoaXNbcmVzZXRdKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSB1cCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIHVwIGV2ZW50XHJcbiAgICovXHJcbiAgW3Jlc2V0XSgpIHtcclxuICAgIGNsZWFyVGltZW91dCh0aGlzLm1vdXNlRG93blRpbWVvdXQpO1xyXG5cclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0sIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIHRoaXNbb25EcmFnRW5kXSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXNbb25Ecm9wXSwgZmFsc2UpO1xyXG5cclxuICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7XHJcbiAgICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZHJhZ2dhYmxlRWxlbWVudCkge1xyXG4gICAgICB0aGlzLmRyYWdnYWJsZUVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuZHJhZ2dhYmxlRWxlbWVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERyYWdTZW5zb3I7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0RyYWdTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcclxuXHJcbnZhciBfRHJhZ1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnU2Vuc29yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfRHJhZ1NlbnNvcjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0NCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uVG91Y2hTdGFydCA9IFN5bWJvbCgnb25Ub3VjaFN0YXJ0Jyk7XHJcbmNvbnN0IG9uVG91Y2hFbmQgPSBTeW1ib2woJ29uVG91Y2hFbmQnKTtcclxuY29uc3Qgb25Ub3VjaE1vdmUgPSBTeW1ib2woJ29uVG91Y2hNb3ZlJyk7XHJcbmNvbnN0IHN0YXJ0RHJhZyA9IFN5bWJvbCgnc3RhcnREcmFnJyk7XHJcbmNvbnN0IG9uRGlzdGFuY2VDaGFuZ2UgPSBTeW1ib2woJ29uRGlzdGFuY2VDaGFuZ2UnKTtcclxuXHJcbi8qKlxyXG4gKiBQcmV2ZW50cyBzY3JvbGxpbmcgd2hlbiBzZXQgdG8gdHJ1ZVxyXG4gKiBAdmFyIHtCb29sZWFufSBwcmV2ZW50U2Nyb2xsaW5nXHJcbiAqL1xyXG5sZXQgcHJldmVudFNjcm9sbGluZyA9IGZhbHNlO1xyXG5cclxuLy8gV2ViS2l0IHJlcXVpcmVzIGNhbmNlbGFibGUgYHRvdWNobW92ZWAgZXZlbnRzIHRvIGJlIGFkZGVkIGFzIGVhcmx5IGFzIHBvc3NpYmxlXHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBldmVudCA9PiB7XHJcbiAgaWYgKCFwcmV2ZW50U2Nyb2xsaW5nKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBQcmV2ZW50IHNjcm9sbGluZ1xyXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbn0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XHJcblxyXG4vKipcclxuICogVGhpcyBzZW5zb3IgcGlja3MgdXAgbmF0aXZlIGJyb3dzZXIgdG91Y2ggZXZlbnRzIGFuZCBkaWN0YXRlcyBkcmFnIG9wZXJhdGlvbnNcclxuICogQGNsYXNzIFRvdWNoU2Vuc29yXHJcbiAqIEBtb2R1bGUgVG91Y2hTZW5zb3JcclxuICogQGV4dGVuZHMgU2Vuc29yXHJcbiAqL1xyXG5jbGFzcyBUb3VjaFNlbnNvciBleHRlbmRzIF9TZW5zb3IyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIFRvdWNoU2Vuc29yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFRvdWNoU2Vuc29yXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb3Nlc3Qgc2Nyb2xsYWJsZSBjb250YWluZXIgc28gYWNjaWRlbnRhbCBzY3JvbGwgY2FuIGNhbmNlbCBsb25nIHRvdWNoXHJcbiAgICAgKiBAcHJvcGVydHkgY3VycmVudFNjcm9sbGFibGVQYXJlbnRcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXJyZW50U2Nyb2xsYWJsZVBhcmVudCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaW1lb3V0SUQgZm9yIG1hbmFnaW5nIGRlbGF5XHJcbiAgICAgKiBAcHJvcGVydHkgdGFwVGltZW91dFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy50YXBUaW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHRvdWNoTW92ZWQgaW5kaWNhdGVzIGlmIHRvdWNoIGhhcyBtb3ZlZCBkdXJpbmcgdGFwVGltZW91dFxyXG4gICAgICogQHByb3BlcnR5IHRvdWNoTW92ZWRcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRvdWNoTW92ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNhdmUgcGFnZVggY29vcmRpbmF0ZXMgZm9yIGRlbGF5IGRyYWdcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYnJlfSBwYWdlWFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5wYWdlWCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTYXZlIHBhZ2VZIGNvb3JkaW5hdGVzIGZvciBkZWxheSBkcmFnXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJyZX0gcGFnZVlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFnZVkgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25Ub3VjaFN0YXJ0XSA9IHRoaXNbb25Ub3VjaFN0YXJ0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvblRvdWNoRW5kXSA9IHRoaXNbb25Ub3VjaEVuZF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Ub3VjaE1vdmVdID0gdGhpc1tvblRvdWNoTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbc3RhcnREcmFnXSA9IHRoaXNbc3RhcnREcmFnXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSA9IHRoaXNbb25EaXN0YW5jZUNoYW5nZV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpc1tvblRvdWNoU3RhcnRdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpc1tvblRvdWNoU3RhcnRdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRvdWNoIHN0YXJ0IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVG91Y2ggc3RhcnQgZXZlbnRcclxuICAgKi9cclxuICBbb25Ub3VjaFN0YXJ0XShldmVudCkge1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC50YXJnZXQsIHRoaXMuY29udGFpbmVycyk7XHJcblxyXG4gICAgaWYgKCFjb250YWluZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBkaXN0YW5jZSA9IDAgfSA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IHsgZGVsYXkgfSA9IHRoaXM7XHJcbiAgICBjb25zdCB7IHBhZ2VYLCBwYWdlWSB9ID0gKDAsIF91dGlscy50b3VjaENvb3JkcykoZXZlbnQpO1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBwYWdlWCwgcGFnZVkgfSk7XHJcbiAgICB0aGlzLm9uVG91Y2hTdGFydEF0ID0gRGF0ZS5ub3coKTtcclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IGV2ZW50O1xyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gY29udGFpbmVyO1xyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpc1tvblRvdWNoRW5kXSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51KTtcclxuXHJcbiAgICBpZiAoZGlzdGFuY2UpIHtcclxuICAgICAgcHJldmVudFNjcm9sbGluZyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy50YXBUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKHsgdG91Y2hlczogW3sgcGFnZVg6IHRoaXMucGFnZVgsIHBhZ2VZOiB0aGlzLnBhZ2VZIH1dIH0pO1xyXG4gICAgfSwgZGVsYXkudG91Y2gpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdGhlIGRyYWdcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtzdGFydERyYWddKCkge1xyXG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IHRoaXMuc3RhcnRFdmVudDtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbnRhaW5lcjtcclxuICAgIGNvbnN0IHRvdWNoID0gKDAsIF91dGlscy50b3VjaENvb3Jkcykoc3RhcnRFdmVudCk7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdGFydFNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogdG91Y2gucGFnZVgsXHJcbiAgICAgIGNsaWVudFk6IHRvdWNoLnBhZ2VZLFxyXG4gICAgICB0YXJnZXQ6IHN0YXJ0RXZlbnQudGFyZ2V0LFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IHN0YXJ0RXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCk7XHJcblxyXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvblRvdWNoTW92ZV0pO1xyXG4gICAgfVxyXG4gICAgcHJldmVudFNjcm9sbGluZyA9IHRoaXMuZHJhZ2dpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUb3VjaCBtb3ZlIGhhbmRsZXIgcHJpb3IgdG8gZHJhZyBzdGFydC5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVG91Y2ggbW92ZSBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRpc3RhbmNlQ2hhbmdlXShldmVudCkge1xyXG4gICAgY29uc3QgeyBkaXN0YW5jZSB9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgY29uc3QgeyBzdGFydEV2ZW50LCBkZWxheSB9ID0gdGhpcztcclxuICAgIGNvbnN0IHN0YXJ0ID0gKDAsIF91dGlscy50b3VjaENvb3Jkcykoc3RhcnRFdmVudCk7XHJcbiAgICBjb25zdCBjdXJyZW50ID0gKDAsIF91dGlscy50b3VjaENvb3JkcykoZXZlbnQpO1xyXG4gICAgY29uc3QgdGltZUVsYXBzZWQgPSBEYXRlLm5vdygpIC0gdGhpcy5vblRvdWNoU3RhcnRBdDtcclxuICAgIGNvbnN0IGRpc3RhbmNlVHJhdmVsbGVkID0gKDAsIF91dGlscy5kaXN0YW5jZSkoc3RhcnQucGFnZVgsIHN0YXJ0LnBhZ2VZLCBjdXJyZW50LnBhZ2VYLCBjdXJyZW50LnBhZ2VZKTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGN1cnJlbnQpO1xyXG5cclxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRhcFRpbWVvdXQpO1xyXG5cclxuICAgIGlmICh0aW1lRWxhcHNlZCA8IGRlbGF5LnRvdWNoKSB7XHJcbiAgICAgIC8vIG1vdmVkIGR1cmluZyBkZWxheVxyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2VUcmF2ZWxsZWQgPj0gZGlzdGFuY2UpIHtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcbiAgICAgIHRoaXNbc3RhcnREcmFnXSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgbW92ZSBoYW5kbGVyIHdoaWxlIGRyYWdnaW5nXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRvdWNoIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25Ub3VjaE1vdmVdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBwYWdlWCwgcGFnZVkgfSA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKGV2ZW50KTtcclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQocGFnZVggLSB3aW5kb3cuc2Nyb2xsWCwgcGFnZVkgLSB3aW5kb3cuc2Nyb2xsWSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ01vdmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ01vdmVTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IHBhZ2VYLFxyXG4gICAgICBjbGllbnRZOiBwYWdlWSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVG91Y2ggZW5kIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVG91Y2ggZW5kIGV2ZW50XHJcbiAgICovXHJcbiAgW29uVG91Y2hFbmRdKGV2ZW50KSB7XHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy50YXBUaW1lb3V0KTtcclxuICAgIHByZXZlbnRTY3JvbGxpbmcgPSBmYWxzZTtcclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzW29uVG91Y2hFbmRdKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG5cclxuICAgIGlmICh0aGlzLmN1cnJlbnRDb250YWluZXIpIHtcclxuICAgICAgdGhpcy5jdXJyZW50Q29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uVG91Y2hNb3ZlXSk7XHJcblxyXG4gICAgY29uc3QgeyBwYWdlWCwgcGFnZVkgfSA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKGV2ZW50KTtcclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQocGFnZVggLSB3aW5kb3cuc2Nyb2xsWCwgcGFnZVkgLSB3aW5kb3cuc2Nyb2xsWSk7XHJcblxyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RvcFNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogcGFnZVgsXHJcbiAgICAgIGNsaWVudFk6IHBhZ2VZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBUb3VjaFNlbnNvcjtcclxuZnVuY3Rpb24gb25Db250ZXh0TWVudShldmVudCkge1xyXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0NSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfVG91Y2hTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcclxuXHJcbnZhciBfVG91Y2hTZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVG91Y2hTZW5zb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Ub3VjaFNlbnNvcjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0NiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5EcmFnUHJlc3N1cmVTZW5zb3JFdmVudCA9IGV4cG9ydHMuRHJhZ1N0b3BTZW5zb3JFdmVudCA9IGV4cG9ydHMuRHJhZ01vdmVTZW5zb3JFdmVudCA9IGV4cG9ydHMuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQgPSBleHBvcnRzLlNlbnNvckV2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKipcclxuICogQmFzZSBzZW5zb3IgZXZlbnRcclxuICogQGNsYXNzIFNlbnNvckV2ZW50XHJcbiAqIEBtb2R1bGUgU2Vuc29yRXZlbnRcclxuICogQGV4dGVuZHMgQWJzdHJhY3RFdmVudFxyXG4gKi9cclxuY2xhc3MgU2Vuc29yRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgYnJvd3NlciBldmVudCB0aGF0IHRyaWdnZXJlZCBhIHNlbnNvclxyXG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbEV2ZW50XHJcbiAgICogQHR5cGUge0V2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvcmlnaW5hbEV2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vcmlnaW5hbEV2ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplZCBjbGllbnRYIGZvciBib3RoIHRvdWNoIGFuZCBtb3VzZSBldmVudHNcclxuICAgKiBAcHJvcGVydHkgY2xpZW50WFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGNsaWVudFgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNsaWVudFg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOb3JtYWxpemVkIGNsaWVudFkgZm9yIGJvdGggdG91Y2ggYW5kIG1vdXNlIGV2ZW50c1xyXG4gICAqIEBwcm9wZXJ0eSBjbGllbnRZXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgY2xpZW50WSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuY2xpZW50WTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZWQgdGFyZ2V0IGZvciBib3RoIHRvdWNoIGFuZCBtb3VzZSBldmVudHNcclxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IHRoYXQgaXMgYmVoaW5kIGN1cnNvciBvciB0b3VjaCBwb2ludGVyXHJcbiAgICogQHByb3BlcnR5IHRhcmdldFxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgdGFyZ2V0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS50YXJnZXQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb250YWluZXIgdGhhdCBpbml0aWF0ZWQgdGhlIHNlbnNvclxyXG4gICAqIEBwcm9wZXJ0eSBjb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuY29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhY2twYWQgcHJlc3N1cmVcclxuICAgKiBAcHJvcGVydHkgcHJlc3N1cmVcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBwcmVzc3VyZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEucHJlc3N1cmU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLlNlbnNvckV2ZW50ID0gU2Vuc29yRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgc3RhcnQgc2Vuc29yIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdTdGFydFNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnU3RhcnRTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5jbGFzcyBEcmFnU3RhcnRTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdTdGFydFNlbnNvckV2ZW50ID0gRHJhZ1N0YXJ0U2Vuc29yRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgbW92ZSBzZW5zb3IgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ01vdmVTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ01vdmVTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnU3RhcnRTZW5zb3JFdmVudC50eXBlID0gJ2RyYWc6c3RhcnQnO1xyXG5jbGFzcyBEcmFnTW92ZVNlbnNvckV2ZW50IGV4dGVuZHMgU2Vuc29yRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ01vdmVTZW5zb3JFdmVudCA9IERyYWdNb3ZlU2Vuc29yRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHN0b3Agc2Vuc29yIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RvcFNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1N0b3BTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdNb3ZlU2Vuc29yRXZlbnQudHlwZSA9ICdkcmFnOm1vdmUnO1xyXG5jbGFzcyBEcmFnU3RvcFNlbnNvckV2ZW50IGV4dGVuZHMgU2Vuc29yRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ1N0b3BTZW5zb3JFdmVudCA9IERyYWdTdG9wU2Vuc29yRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHByZXNzdXJlIHNlbnNvciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnUHJlc3N1cmVTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdTdG9wU2Vuc29yRXZlbnQudHlwZSA9ICdkcmFnOnN0b3AnO1xyXG5jbGFzcyBEcmFnUHJlc3N1cmVTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XHJcbmV4cG9ydHMuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQgPSBEcmFnUHJlc3N1cmVTZW5zb3JFdmVudDtcclxuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQudHlwZSA9ICdkcmFnOnByZXNzdXJlJztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0NyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nID0gU3ltYm9sKCdvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZycpO1xyXG5jb25zdCBvbk1vdXNlRG93biA9IFN5bWJvbCgnb25Nb3VzZURvd24nKTtcclxuY29uc3Qgb25Nb3VzZU1vdmUgPSBTeW1ib2woJ29uTW91c2VNb3ZlJyk7XHJcbmNvbnN0IG9uTW91c2VVcCA9IFN5bWJvbCgnb25Nb3VzZVVwJyk7XHJcbmNvbnN0IHN0YXJ0RHJhZyA9IFN5bWJvbCgnc3RhcnREcmFnJyk7XHJcbmNvbnN0IG9uRGlzdGFuY2VDaGFuZ2UgPSBTeW1ib2woJ29uRGlzdGFuY2VDaGFuZ2UnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHNlbnNvciBwaWNrcyB1cCBuYXRpdmUgYnJvd3NlciBtb3VzZSBldmVudHMgYW5kIGRpY3RhdGVzIGRyYWcgb3BlcmF0aW9uc1xyXG4gKiBAY2xhc3MgTW91c2VTZW5zb3JcclxuICogQG1vZHVsZSBNb3VzZVNlbnNvclxyXG4gKiBAZXh0ZW5kcyBTZW5zb3JcclxuICovXHJcbmNsYXNzIE1vdXNlU2Vuc29yIGV4dGVuZHMgX1NlbnNvcjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogTW91c2VTZW5zb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgTW91c2VTZW5zb3JcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lcnMsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgZG93biB0aW1lciB3aGljaCB3aWxsIGVuZCB1cCB0cmlnZ2VyaW5nIHRoZSBkcmFnIHN0YXJ0IG9wZXJhdGlvblxyXG4gICAgICogQHByb3BlcnR5IG1vdXNlRG93blRpbWVvdXRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubW91c2VEb3duVGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTYXZlIHBhZ2VYIGNvb3JkaW5hdGVzIGZvciBkZWxheSBkcmFnXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJyZX0gcGFnZVhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFnZVggPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2F2ZSBwYWdlWSBjb29yZGluYXRlcyBmb3IgZGVsYXkgZHJhZ1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1icmV9IHBhZ2VZXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBhZ2VZID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXSA9IHRoaXNbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VEb3duXSA9IHRoaXNbb25Nb3VzZURvd25dLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VNb3ZlXSA9IHRoaXNbb25Nb3VzZU1vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VVcF0gPSB0aGlzW29uTW91c2VVcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbc3RhcnREcmFnXSA9IHRoaXNbc3RhcnREcmFnXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSA9IHRoaXNbb25EaXN0YW5jZUNoYW5nZV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZG93biBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGRvd24gZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZURvd25dKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb250YWluZXIgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGV2ZW50LnRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcclxuXHJcbiAgICBpZiAoIWNvbnRhaW5lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBkZWxheSB9ID0gdGhpcztcclxuICAgIGNvbnN0IHsgcGFnZVgsIHBhZ2VZIH0gPSBldmVudDtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgcGFnZVgsIHBhZ2VZIH0pO1xyXG4gICAgdGhpcy5vbk1vdXNlRG93bkF0ID0gRGF0ZS5ub3coKTtcclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IGV2ZW50O1xyXG5cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0pO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgcHJldmVudE5hdGl2ZURyYWdTdGFydCk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuXHJcbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0oeyBwYWdlWDogdGhpcy5wYWdlWCwgcGFnZVk6IHRoaXMucGFnZVkgfSk7XHJcbiAgICB9LCBkZWxheS5tb3VzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCB0aGUgZHJhZ1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW3N0YXJ0RHJhZ10oKSB7XHJcbiAgICBjb25zdCBzdGFydEV2ZW50ID0gdGhpcy5zdGFydEV2ZW50O1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jdXJyZW50Q29udGFpbmVyO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RhcnRTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IHN0YXJ0RXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogc3RhcnRFdmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQ6IHN0YXJ0RXZlbnQudGFyZ2V0LFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IHN0YXJ0RXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCk7XHJcblxyXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXSwgdHJ1ZSk7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25Nb3VzZU1vdmVdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVjdCBjaGFuZ2UgaW4gZGlzdGFuY2UsIHN0YXJ0aW5nIGRyYWcgd2hlbiBib3RoXHJcbiAgICogZGVsYXkgYW5kIGRpc3RhbmNlIHJlcXVpcmVtZW50cyBhcmUgbWV0XHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25EaXN0YW5jZUNoYW5nZV0oZXZlbnQpIHtcclxuICAgIGNvbnN0IHsgcGFnZVgsIHBhZ2VZIH0gPSBldmVudDtcclxuICAgIGNvbnN0IHsgZGlzdGFuY2UgfSA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IHsgc3RhcnRFdmVudCwgZGVsYXkgfSA9IHRoaXM7XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IHBhZ2VYLCBwYWdlWSB9KTtcclxuXHJcbiAgICBpZiAoIXRoaXMuY3VycmVudENvbnRhaW5lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGltZUVsYXBzZWQgPSBEYXRlLm5vdygpIC0gdGhpcy5vbk1vdXNlRG93bkF0O1xyXG4gICAgY29uc3QgZGlzdGFuY2VUcmF2ZWxsZWQgPSAoMCwgX3V0aWxzLmRpc3RhbmNlKShzdGFydEV2ZW50LnBhZ2VYLCBzdGFydEV2ZW50LnBhZ2VZLCBwYWdlWCwgcGFnZVkpIHx8IDA7XHJcblxyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XHJcblxyXG4gICAgaWYgKHRpbWVFbGFwc2VkIDwgZGVsYXkubW91c2UpIHtcclxuICAgICAgLy8gbW92ZWQgZHVyaW5nIGRlbGF5XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZVRyYXZlbGxlZCA+PSBkaXN0YW5jZSkge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuICAgICAgdGhpc1tzdGFydERyYWddKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgbW92ZSBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlTW92ZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuXHJcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnTW92ZVNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgdXAgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlVXBdKGV2ZW50KSB7XHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy5tb3VzZURvd25UaW1lb3V0KTtcclxuXHJcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHByZXZlbnROYXRpdmVEcmFnU3RhcnQpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcblxyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdG9wU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uTW91c2VNb3ZlXSk7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb250ZXh0IG1lbnUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBDb250ZXh0IG1lbnUgZXZlbnRcclxuICAgKi9cclxuICBbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddKGV2ZW50KSB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gTW91c2VTZW5zb3I7XHJcbmZ1bmN0aW9uIHByZXZlbnROYXRpdmVEcmFnU3RhcnQoZXZlbnQpIHtcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX01vdXNlU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XHJcblxyXG52YXIgX01vdXNlU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vdXNlU2Vuc29yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfTW91c2VTZW5zb3IyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxuY29uc3QgZGVmYXVsdERlYWx5ID0ge1xyXG4gIG1vdXNlOiAwLFxyXG4gIGRyYWc6IDAsXHJcbiAgdG91Y2g6IDEwMFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEJhc2Ugc2Vuc29yIGNsYXNzLiBFeHRlbmQgZnJvbSB0aGlzIGNsYXNzIHRvIGNyZWF0ZSBhIG5ldyBvciBjdXN0b20gc2Vuc29yXHJcbiAqIEBjbGFzcyBTZW5zb3JcclxuICogQG1vZHVsZSBTZW5zb3JcclxuICovXHJcbmNsYXNzIFNlbnNvciB7XHJcbiAgLyoqXHJcbiAgICogU2Vuc29yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFNlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGNvbnRhaW5lcnNcclxuICAgICAqIEBwcm9wZXJ0eSBjb250YWluZXJzXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb250YWluZXJzID0gWy4uLmNvbnRhaW5lcnNdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBkcmFnIHN0YXRlXHJcbiAgICAgKiBAcHJvcGVydHkgZHJhZ2dpbmdcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGNvbnRhaW5lclxyXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRDb250YWluZXJcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBldmVudCBvZiB0aGUgaW5pdGlhbCBzZW5zb3IgZG93blxyXG4gICAgICogQHByb3BlcnR5IHN0YXJ0RXZlbnRcclxuICAgICAqIEB0eXBlIHtFdmVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGFydEV2ZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWxheSBvZiBlYWNoIHNlbnNvclxyXG4gICAgICogQHByb3BlcnR5IGRlbGF5XHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlbGF5ID0gY2FsY0RlbGF5KG9wdGlvbnMuZGVsYXkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqIEByZXR1cm4ge1NlbnNvcn1cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKiBAcmV0dXJuIHtTZW5zb3J9XHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGNvbnRhaW5lciB0byB0aGlzIHNlbnNvciBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7Li4uSFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzIHlvdSB3YW50IHRvIGFkZCB0byB0aGlzIHNlbnNvclxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5hZGRDb250YWluZXIoZG9jdW1lbnQuYm9keSlcclxuICAgKi9cclxuICBhZGRDb250YWluZXIoLi4uY29udGFpbmVycykge1xyXG4gICAgdGhpcy5jb250YWluZXJzID0gWy4uLnRoaXMuY29udGFpbmVycywgLi4uY29udGFpbmVyc107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGNvbnRhaW5lciBmcm9tIHRoaXMgc2Vuc29yIGluc3RhbmNlXHJcbiAgICogQHBhcmFtIHsuLi5IVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnMgeW91IHdhbnQgdG8gcmVtb3ZlIGZyb20gdGhpcyBzZW5zb3JcclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUucmVtb3ZlQ29udGFpbmVyKGRvY3VtZW50LmJvZHkpXHJcbiAgICovXHJcbiAgcmVtb3ZlQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcclxuICAgIHRoaXMuY29udGFpbmVycyA9IHRoaXMuY29udGFpbmVycy5maWx0ZXIoY29udGFpbmVyID0+ICFjb250YWluZXJzLmluY2x1ZGVzKGNvbnRhaW5lcikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlcnMgZXZlbnQgb24gdGFyZ2V0IGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byB0cmlnZ2VyIGV2ZW50IG9uXHJcbiAgICogQHBhcmFtIHtTZW5zb3JFdmVudH0gc2Vuc29yRXZlbnQgLSBTZW5zb3IgZXZlbnQgdG8gdHJpZ2dlclxyXG4gICAqL1xyXG4gIHRyaWdnZXIoZWxlbWVudCwgc2Vuc29yRXZlbnQpIHtcclxuICAgIGNvbnN0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbiAgICBldmVudC5kZXRhaWwgPSBzZW5zb3JFdmVudDtcclxuICAgIGV2ZW50LmluaXRFdmVudChzZW5zb3JFdmVudC50eXBlLCB0cnVlLCB0cnVlKTtcclxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB0aGlzLmxhc3RFdmVudCA9IHNlbnNvckV2ZW50O1xyXG5cclxuICAgIHJldHVybiBzZW5zb3JFdmVudDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNlbnNvcjsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBkZWxheSBvZiBlYWNoIHNlbnNvciB0aHJvdWdoIHRoZSBkZWxheSBpbiB0aGUgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfE51bWJlcnxPYmplY3R9IG9wdGlvbnNEZWxheSAtIHRoZSBkZWxheSBpbiB0aGUgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmZ1bmN0aW9uIGNhbGNEZWxheShvcHRpb25zRGVsYXkpIHtcclxuICBjb25zdCBkZWxheSA9IHt9O1xyXG5cclxuICBpZiAob3B0aW9uc0RlbGF5ID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGVmYXVsdERlYWx5KTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2Ygb3B0aW9uc0RlbGF5ID09PSAnbnVtYmVyJykge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdERlYWx5KSB7XHJcbiAgICAgIGlmIChkZWZhdWx0RGVhbHkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgIGRlbGF5W2tleV0gPSBvcHRpb25zRGVsYXk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkZWxheTtcclxuICB9XHJcblxyXG4gIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHREZWFseSkge1xyXG4gICAgaWYgKGRlZmF1bHREZWFseS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgIGlmIChvcHRpb25zRGVsYXlba2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZGVsYXlba2V5XSA9IGRlZmF1bHREZWFseVtrZXldO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRlbGF5W2tleV0gPSBvcHRpb25zRGVsYXlba2V5XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRlbGF5O1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNTAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHRvdWNoQ29vcmRzO1xyXG4vKipcclxuICogUmV0dXJucyB0aGUgZmlyc3QgdG91Y2ggZXZlbnQgZm91bmQgaW4gdG91Y2hlcyBvciBjaGFuZ2VkVG91Y2hlcyBvZiBhIHRvdWNoIGV2ZW50cy5cclxuICogQHBhcmFtIHtUb3VjaEV2ZW50fSBldmVudCBhIHRvdWNoIGV2ZW50XHJcbiAqIEByZXR1cm4ge1RvdWNofSBhIHRvdWNoIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gdG91Y2hDb29yZHMoZXZlbnQgPSB7fSkge1xyXG4gIGNvbnN0IHsgdG91Y2hlcywgY2hhbmdlZFRvdWNoZXMgfSA9IGV2ZW50O1xyXG4gIHJldHVybiB0b3VjaGVzICYmIHRvdWNoZXNbMF0gfHwgY2hhbmdlZFRvdWNoZXMgJiYgY2hhbmdlZFRvdWNoZXNbMF07XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdG91Y2hDb29yZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcclxuXHJcbnZhciBfdG91Y2hDb29yZHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG91Y2hDb29yZHMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF90b3VjaENvb3JkczIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gZGlzdGFuY2U7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcclxuICogQHBhcmFtICB7TnVtYmVyfSB4MSBUaGUgWCBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnRcclxuICogQHBhcmFtICB7TnVtYmVyfSB5MSBUaGUgWSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnRcclxuICogQHBhcmFtICB7TnVtYmVyfSB4MiBUaGUgWCBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50XHJcbiAqIEBwYXJhbSAge051bWJlcn0geTIgVGhlIFkgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xyXG4gIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICoqIDIgKyAoeTIgLSB5MSkgKiogMik7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1MyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZGlzdGFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcclxuXHJcbnZhciBfZGlzdGFuY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzdGFuY2UpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9kaXN0YW5jZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1NCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZTtcclxuZnVuY3Rpb24gcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xyXG4gIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDU1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCk7XHJcblxyXG52YXIgX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNTYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb3Nlc3Q7XHJcbmNvbnN0IG1hdGNoRnVuY3Rpb24gPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3I7XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjbG9zZXN0IHBhcmVudCBlbGVtZW50IG9mIGEgZ2l2ZW4gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuXHJcbiAqIHNlbGVjdG9yIHN0cmluZyBvciBtYXRjaGluZyBmdW5jdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGNoaWxkIGVsZW1lbnQgdG8gZmluZCBhIHBhcmVudCBvZlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgVGhlIHN0cmluZyBvciBmdW5jdGlvbiB0byB1c2UgdG8gbWF0Y2hcclxuICogICAgIHRoZSBwYXJlbnQgZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtFbGVtZW50fG51bGx9XHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9zZXN0KGVsZW1lbnQsIHZhbHVlKSB7XHJcbiAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNlbGVjdG9yID0gdmFsdWU7XHJcbiAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZTtcclxuICBjb25zdCBub2RlTGlzdCA9IHZhbHVlO1xyXG4gIGNvbnN0IHNpbmdsZUVsZW1lbnQgPSB2YWx1ZTtcclxuXHJcbiAgY29uc3QgaXNTZWxlY3RvciA9IEJvb2xlYW4odHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyk7XHJcbiAgY29uc3QgaXNGdW5jdGlvbiA9IEJvb2xlYW4odHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKTtcclxuICBjb25zdCBpc05vZGVMaXN0ID0gQm9vbGVhbih2YWx1ZSBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpO1xyXG4gIGNvbnN0IGlzRWxlbWVudCA9IEJvb2xlYW4odmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCk7XHJcblxyXG4gIGZ1bmN0aW9uIGNvbmRpdGlvbkZuKGN1cnJlbnRFbGVtZW50KSB7XHJcbiAgICBpZiAoIWN1cnJlbnRFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcclxuICAgIH0gZWxzZSBpZiAoaXNTZWxlY3Rvcikge1xyXG4gICAgICByZXR1cm4gbWF0Y2hGdW5jdGlvbi5jYWxsKGN1cnJlbnRFbGVtZW50LCBzZWxlY3Rvcik7XHJcbiAgICB9IGVsc2UgaWYgKGlzTm9kZUxpc3QpIHtcclxuICAgICAgcmV0dXJuIFsuLi5ub2RlTGlzdF0uaW5jbHVkZXMoY3VycmVudEVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIGlmIChpc0VsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIHNpbmdsZUVsZW1lbnQgPT09IGN1cnJlbnRFbGVtZW50O1xyXG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKSB7XHJcbiAgICAgIHJldHVybiBjYWxsYmFjayhjdXJyZW50RWxlbWVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxldCBjdXJyZW50ID0gZWxlbWVudDtcclxuXHJcbiAgZG8ge1xyXG4gICAgY3VycmVudCA9IGN1cnJlbnQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQgfHwgY3VycmVudC5jb3JyZXNwb25kaW5nRWxlbWVudCB8fCBjdXJyZW50O1xyXG5cclxuICAgIGlmIChjb25kaXRpb25GbihjdXJyZW50KSkge1xyXG4gICAgICByZXR1cm4gY3VycmVudDtcclxuICAgIH1cclxuXHJcbiAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xyXG4gIH0gd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBjdXJyZW50ICE9PSBkb2N1bWVudCk7XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNTcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2Nsb3Nlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcclxuXHJcbnZhciBfY2xvc2VzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9zZXN0KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfY2xvc2VzdDIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1OCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuc2Nyb2xsID0gZXhwb3J0cy5vbkRyYWdTdG9wID0gZXhwb3J0cy5vbkRyYWdNb3ZlID0gZXhwb3J0cy5vbkRyYWdTdGFydCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25EcmFnU3RhcnQgPSBleHBvcnRzLm9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdNb3ZlID0gZXhwb3J0cy5vbkRyYWdNb3ZlID0gU3ltYm9sKCdvbkRyYWdNb3ZlJyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBleHBvcnRzLm9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3Qgc2Nyb2xsID0gZXhwb3J0cy5zY3JvbGwgPSBTeW1ib2woJ3Njcm9sbCcpO1xyXG5cclxuLyoqXHJcbiAqIFNjcm9sbGFibGUgZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMuc3BlZWRcclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLnNlbnNpdGl2aXR5XHJcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnRbXX0gZGVmYXVsdE9wdGlvbnMuc2Nyb2xsYWJsZUVsZW1lbnRzXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgc3BlZWQ6IDYsXHJcbiAgc2Vuc2l0aXZpdHk6IDUwLFxyXG4gIHNjcm9sbGFibGVFbGVtZW50czogW11cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTY3JvbGxhYmxlIHBsdWdpbiB3aGljaCBzY3JvbGxzIHRoZSBjbG9zZXN0IHNjcm9sbGFibGUgcGFyZW50XHJcbiAqIEBjbGFzcyBTY3JvbGxhYmxlXHJcbiAqIEBtb2R1bGUgU2Nyb2xsYWJsZVxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgU2Nyb2xsYWJsZSBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsYWJsZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBTY3JvbGxhYmxlXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjcm9sbGFibGUgb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBvcHRpb25zLnNwZWVkXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gb3B0aW9ucy5zZW5zaXRpdml0eVxyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudFtdfSBvcHRpb25zLnNjcm9sbGFibGVFbGVtZW50c1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZWVwcyBjdXJyZW50IG1vdXNlIHBvc2l0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gY3VycmVudE1vdXNlUG9zaXRpb25cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRYXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY3VycmVudE1vdXNlUG9zaXRpb24uY2xpZW50WVxyXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjcm9sbCBhbmltYXRpb24gZnJhbWVcclxuICAgICAqIEBwcm9wZXJ0eSBzY3JvbGxBbmltYXRpb25GcmFtZVxyXG4gICAgICogQHR5cGUge051bWJlcnxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb3Nlc3Qgc2Nyb2xsYWJsZSBlbGVtZW50XHJcbiAgICAgKiBAcHJvcGVydHkgc2Nyb2xsYWJsZUVsZW1lbnRcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuaW1hdGlvbiBmcmFtZSBsb29raW5nIGZvciB0aGUgY2xvc2VzdCBzY3JvbGxhYmxlIGVsZW1lbnRcclxuICAgICAqIEBwcm9wZXJ0eSBmaW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZVxyXG4gICAgICogQHR5cGUge051bWJlcnxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbc2Nyb2xsXSA9IHRoaXNbc2Nyb2xsXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBvcHRpb25zIHBhc3NlZCB0aHJvdWdoIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuc2Nyb2xsYWJsZSB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY2xvc2VzdCBzY3JvbGxhYmxlIGVsZW1lbnRzIGJ5IGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgKi9cclxuICBnZXRTY3JvbGxhYmxlRWxlbWVudCh0YXJnZXQpIHtcclxuICAgIGlmICh0aGlzLmhhc0RlZmluZWRTY3JvbGxhYmxlRWxlbWVudHMoKSkge1xyXG4gICAgICByZXR1cm4gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIHRoaXMub3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHMpIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBjbG9zZXN0U2Nyb2xsYWJsZUVsZW1lbnQodGFyZ2V0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgc2Nyb2xsYWJsZSBlbGVtZW50IGhhdmUgYmVlbiBkZWZpbmVkIHZpYSBvcHRpb25zXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBoYXNEZWZpbmVkU2Nyb2xsYWJsZUVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5vcHRpb25zLnNjcm9sbGFibGVFbGVtZW50cy5sZW5ndGggIT09IDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdGFydCBoYW5kbGVyLiBGaW5kcyBjbG9zZXN0IHNjcm9sbGFibGUgcGFyZW50IGluIHNlcGFyYXRlIGZyYW1lXHJcbiAgICogQHBhcmFtIHtEcmFnU3RhcnRFdmVudH0gZHJhZ0V2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25EcmFnU3RhcnRdKGRyYWdFdmVudCkge1xyXG4gICAgdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSB0aGlzLmdldFNjcm9sbGFibGVFbGVtZW50KGRyYWdFdmVudC5zb3VyY2UpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG1vdmUgaGFuZGxlci4gUmVtZW1iZXJzIG1vdXNlIHBvc2l0aW9uIGFuZCBpbml0aWF0ZXMgc2Nyb2xsaW5nXHJcbiAgICogQHBhcmFtIHtEcmFnTW92ZUV2ZW50fSBkcmFnRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkRyYWdNb3ZlXShkcmFnRXZlbnQpIHtcclxuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gdGhpcy5nZXRTY3JvbGxhYmxlRWxlbWVudChkcmFnRXZlbnQuc2Vuc29yRXZlbnQudGFyZ2V0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghdGhpcy5zY3JvbGxhYmxlRWxlbWVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBkcmFnRXZlbnQuc2Vuc29yRXZlbnQ7XHJcbiAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XHJcbiAgICAgIHNjcm9sbE9mZnNldC55ID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgMDtcclxuICAgICAgc2Nyb2xsT2Zmc2V0LnggPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0IHx8IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbiA9IHtcclxuICAgICAgY2xpZW50WDogc2Vuc29yRXZlbnQuY2xpZW50WCAtIHNjcm9sbE9mZnNldC54LFxyXG4gICAgICBjbGllbnRZOiBzZW5zb3JFdmVudC5jbGllbnRZIC0gc2Nyb2xsT2Zmc2V0LnlcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzW3Njcm9sbF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdG9wIGhhbmRsZXIuIENhbmNlbHMgc2Nyb2xsIGFuaW1hdGlvbnMgYW5kIHJlc2V0cyBzdGF0ZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRHJhZ1N0b3BdKCkge1xyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSk7XHJcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lKTtcclxuXHJcbiAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gbnVsbDtcclxuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUgPSBudWxsO1xyXG4gICAgdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSA9IG51bGw7XHJcbiAgICB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjcm9sbCBmdW5jdGlvbiB0aGF0IGRvZXMgdGhlIGhlYXZ5bGlmdGluZ1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW3Njcm9sbF0oKSB7XHJcbiAgICBpZiAoIXRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgfHwgIXRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUpO1xyXG5cclxuICAgIGNvbnN0IHsgc3BlZWQsIHNlbnNpdGl2aXR5IH0gPSB0aGlzLm9wdGlvbnM7XHJcblxyXG4gICAgY29uc3QgcmVjdCA9IHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBjb25zdCBib3R0b21DdXRPZmYgPSByZWN0LmJvdHRvbSA+IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgIGNvbnN0IHRvcEN1dE9mZiA9IHJlY3QudG9wIDwgMDtcclxuICAgIGNvbnN0IGN1dE9mZiA9IHRvcEN1dE9mZiB8fCBib3R0b21DdXRPZmY7XHJcblxyXG4gICAgY29uc3QgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50ID0gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCk7XHJcbiAgICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9IHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQ7XHJcbiAgICBjb25zdCBjbGllbnRYID0gdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRYO1xyXG4gICAgY29uc3QgY2xpZW50WSA9IHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24uY2xpZW50WTtcclxuXHJcbiAgICBpZiAoc2Nyb2xsYWJsZUVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgc2Nyb2xsYWJsZUVsZW1lbnQgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhY3V0T2ZmKSB7XHJcbiAgICAgIGNvbnN0IHsgb2Zmc2V0SGVpZ2h0LCBvZmZzZXRXaWR0aCB9ID0gc2Nyb2xsYWJsZUVsZW1lbnQ7XHJcblxyXG4gICAgICBpZiAocmVjdC50b3AgKyBvZmZzZXRIZWlnaHQgLSBjbGllbnRZIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUb3AgKz0gc3BlZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50WSAtIHJlY3QudG9wIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUb3AgLT0gc3BlZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZWN0LmxlZnQgKyBvZmZzZXRXaWR0aCAtIGNsaWVudFggPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbExlZnQgKz0gc3BlZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50WCAtIHJlY3QubGVmdCA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsTGVmdCAtPSBzcGVlZDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgeyBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCB9ID0gd2luZG93O1xyXG5cclxuICAgICAgaWYgKGNsaWVudFkgPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgLT0gc3BlZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoaW5uZXJIZWlnaHQgLSBjbGllbnRZIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wICs9IHNwZWVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2xpZW50WCA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgLT0gc3BlZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoaW5uZXJXaWR0aCAtIGNsaWVudFggPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0ICs9IHNwZWVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzW3Njcm9sbF0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gU2Nyb2xsYWJsZTsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIGVsZW1lbnQgaGFzIG92ZXJmbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5mdW5jdGlvbiBoYXNPdmVyZmxvdyhlbGVtZW50KSB7XHJcbiAgY29uc3Qgb3ZlcmZsb3dSZWdleCA9IC8oYXV0b3xzY3JvbGwpLztcclxuICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XHJcblxyXG4gIGNvbnN0IG92ZXJmbG93ID0gY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cnKSArIGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXknKSArIGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXgnKTtcclxuXHJcbiAgcmV0dXJuIG92ZXJmbG93UmVnZXgudGVzdChvdmVyZmxvdyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCBlbGVtZW50IGlzIHN0YXRpY2FsbHkgcG9zaXRpb25lZFxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1N0YXRpY2FsbHlQb3NpdGlvbmVkKGVsZW1lbnQpIHtcclxuICBjb25zdCBwb3NpdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKTtcclxuICByZXR1cm4gcG9zaXRpb24gPT09ICdzdGF0aWMnO1xyXG59XHJcblxyXG4vKipcclxuICogRmluZHMgY2xvc2VzdCBzY3JvbGxhYmxlIGVsZW1lbnRcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNsb3Nlc3RTY3JvbGxhYmxlRWxlbWVudChlbGVtZW50KSB7XHJcbiAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBwb3NpdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKTtcclxuICBjb25zdCBleGNsdWRlU3RhdGljUGFyZW50cyA9IHBvc2l0aW9uID09PSAnYWJzb2x1dGUnO1xyXG5cclxuICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZWxlbWVudCwgcGFyZW50ID0+IHtcclxuICAgIGlmIChleGNsdWRlU3RhdGljUGFyZW50cyAmJiBpc1N0YXRpY2FsbHlQb3NpdGlvbmVkKHBhcmVudCkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc092ZXJmbG93KHBhcmVudCk7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChwb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCAhc2Nyb2xsYWJsZUVsZW1lbnQpIHtcclxuICAgIHJldHVybiBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHNjcm9sbGFibGVFbGVtZW50O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgZWxlbWVudCB0aGF0IHNjcm9sbHMgZG9jdW1lbnRcclxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKSB7XHJcbiAgcmV0dXJuIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNTkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX1Njcm9sbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcclxuXHJcbnZhciBfU2Nyb2xsYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TY3JvbGxhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfU2Nyb2xsYWJsZTIuZGVmYXVsdDtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IF9TY3JvbGxhYmxlLmRlZmF1bHRPcHRpb25zO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDYwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLk1pcnJvckRlc3Ryb3lFdmVudCA9IGV4cG9ydHMuTWlycm9yTW92ZUV2ZW50ID0gZXhwb3J0cy5NaXJyb3JBdHRhY2hlZEV2ZW50ID0gZXhwb3J0cy5NaXJyb3JDcmVhdGVkRXZlbnQgPSBleHBvcnRzLk1pcnJvckNyZWF0ZUV2ZW50ID0gZXhwb3J0cy5NaXJyb3JFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgbWlycm9yIGV2ZW50XHJcbiAqIEBjbGFzcyBNaXJyb3JFdmVudFxyXG4gKiBAbW9kdWxlIE1pcnJvckV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIE1pcnJvckV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgc291cmNlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgc291cmNlXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzb3VyY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgb3JpZ2luYWwgc291cmNlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxTb3VyY2VcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9yaWdpbmFsU291cmNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vcmlnaW5hbFNvdXJjZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgc291cmNlIGNvbnRhaW5lciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IHNvdXJjZUNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc291cmNlQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2VDb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5zb3IgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgc2Vuc29yRXZlbnRcclxuICAgKiBAdHlwZSB7U2Vuc29yRXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNlbnNvckV2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zZW5zb3JFdmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgZHJhZ0V2ZW50XHJcbiAgICogQHR5cGUge0RyYWdFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ0V2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBldmVudCB0aGF0IHRyaWdnZXJlZCBzZW5zb3IgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxFdmVudFxyXG4gICAqIEB0eXBlIHtFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3JpZ2luYWxFdmVudCgpIHtcclxuICAgIGlmICh0aGlzLnNlbnNvckV2ZW50KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLk1pcnJvckV2ZW50ID0gTWlycm9yRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1pcnJvciBjcmVhdGUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgTWlycm9yQ3JlYXRlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIE1pcnJvckNyZWF0ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgTWlycm9yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmNsYXNzIE1pcnJvckNyZWF0ZUV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge31cclxuXHJcbmV4cG9ydHMuTWlycm9yQ3JlYXRlRXZlbnQgPSBNaXJyb3JDcmVhdGVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWlycm9yIGNyZWF0ZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgTWlycm9yQ3JlYXRlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JDcmVhdGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBNaXJyb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuTWlycm9yQ3JlYXRlRXZlbnQudHlwZSA9ICdtaXJyb3I6Y3JlYXRlJztcclxuY2xhc3MgTWlycm9yQ3JlYXRlZEV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG1pcnJvclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbWlycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLk1pcnJvckNyZWF0ZWRFdmVudCA9IE1pcnJvckNyZWF0ZWRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNaXJyb3IgYXR0YWNoZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBNaXJyb3JBdHRhY2hlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIE1pcnJvckF0dGFjaGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIE1pcnJvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbk1pcnJvckNyZWF0ZWRFdmVudC50eXBlID0gJ21pcnJvcjpjcmVhdGVkJztcclxuY2xhc3MgTWlycm9yQXR0YWNoZWRFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBtaXJyb3IgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG1pcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5NaXJyb3JBdHRhY2hlZEV2ZW50ID0gTWlycm9yQXR0YWNoZWRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1pcnJvciBtb3ZlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBNaXJyb3JNb3ZlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JNb3ZlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgTWlycm9yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5NaXJyb3JBdHRhY2hlZEV2ZW50LnR5cGUgPSAnbWlycm9yOmF0dGFjaGVkJztcclxuY2xhc3MgTWlycm9yTW92ZUV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG1pcnJvclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbWlycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5zb3IgaGFzIGV4Y2VlZGVkIG1pcnJvcidzIHRocmVzaG9sZCBvbiB4IGF4aXNcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcGFzc2VkVGhyZXNoWCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEucGFzc2VkVGhyZXNoWDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbnNvciBoYXMgZXhjZWVkZWQgbWlycm9yJ3MgdGhyZXNob2xkIG9uIHkgYXhpc1xyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBwYXNzZWRUaHJlc2hZKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wYXNzZWRUaHJlc2hZO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5NaXJyb3JNb3ZlRXZlbnQgPSBNaXJyb3JNb3ZlRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWlycm9yIGRlc3Ryb3kgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBNaXJyb3JEZXN0cm95RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgTWlycm9yRGVzdHJveUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBNaXJyb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5NaXJyb3JNb3ZlRXZlbnQudHlwZSA9ICdtaXJyb3I6bW92ZSc7XHJcbk1pcnJvck1vdmVFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgTWlycm9yRGVzdHJveUV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG1pcnJvclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbWlycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuTWlycm9yRGVzdHJveUV2ZW50ID0gTWlycm9yRGVzdHJveUV2ZW50O1xyXG5NaXJyb3JEZXN0cm95RXZlbnQudHlwZSA9ICdtaXJyb3I6ZGVzdHJveSc7XHJcbk1pcnJvckRlc3Ryb3lFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfTWlycm9yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcclxuXHJcbk9iamVjdC5rZXlzKF9NaXJyb3JFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9NaXJyb3JFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZ2V0QXBwZW5kYWJsZUNvbnRhaW5lciA9IGV4cG9ydHMub25TY3JvbGwgPSBleHBvcnRzLm9uTWlycm9yTW92ZSA9IGV4cG9ydHMub25NaXJyb3JDcmVhdGVkID0gZXhwb3J0cy5vbkRyYWdTdG9wID0gZXhwb3J0cy5vbkRyYWdNb3ZlID0gZXhwb3J0cy5vbkRyYWdTdGFydCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxudmFyIF9NaXJyb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cclxuXHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gZXhwb3J0cy5vbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcclxuY29uc3Qgb25EcmFnTW92ZSA9IGV4cG9ydHMub25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xyXG5jb25zdCBvbkRyYWdTdG9wID0gZXhwb3J0cy5vbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XHJcbmNvbnN0IG9uTWlycm9yQ3JlYXRlZCA9IGV4cG9ydHMub25NaXJyb3JDcmVhdGVkID0gU3ltYm9sKCdvbk1pcnJvckNyZWF0ZWQnKTtcclxuY29uc3Qgb25NaXJyb3JNb3ZlID0gZXhwb3J0cy5vbk1pcnJvck1vdmUgPSBTeW1ib2woJ29uTWlycm9yTW92ZScpO1xyXG5jb25zdCBvblNjcm9sbCA9IGV4cG9ydHMub25TY3JvbGwgPSBTeW1ib2woJ29uU2Nyb2xsJyk7XHJcbmNvbnN0IGdldEFwcGVuZGFibGVDb250YWluZXIgPSBleHBvcnRzLmdldEFwcGVuZGFibGVDb250YWluZXIgPSBTeW1ib2woJ2dldEFwcGVuZGFibGVDb250YWluZXInKTtcclxuXHJcbi8qKlxyXG4gKiBNaXJyb3IgZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRlZmF1bHRPcHRpb25zLmNvbnN0cmFpbkRpbWVuc2lvbnNcclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkZWZhdWx0T3B0aW9ucy54QXhpc1xyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRlZmF1bHRPcHRpb25zLnlBeGlzXHJcbiAqIEBwcm9wZXJ0eSB7bnVsbH0gZGVmYXVsdE9wdGlvbnMuY3Vyc29yT2Zmc2V0WFxyXG4gKiBAcHJvcGVydHkge251bGx9IGRlZmF1bHRPcHRpb25zLmN1cnNvck9mZnNldFlcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcclxuICBjb25zdHJhaW5EaW1lbnNpb25zOiBmYWxzZSxcclxuICB4QXhpczogdHJ1ZSxcclxuICB5QXhpczogdHJ1ZSxcclxuICBjdXJzb3JPZmZzZXRYOiBudWxsLFxyXG4gIGN1cnNvck9mZnNldFk6IG51bGwsXHJcbiAgdGhyZXNob2xkWDogbnVsbCxcclxuICB0aHJlc2hvbGRZOiBudWxsXHJcbn07XHJcblxyXG4vKipcclxuICogTWlycm9yIHBsdWdpbiB3aGljaCBjb250cm9scyB0aGUgbWlycm9yIHBvc2l0aW9uaW5nIHdoaWxlIGRyYWdnaW5nXHJcbiAqIEBjbGFzcyBNaXJyb3JcclxuICogQG1vZHVsZSBNaXJyb3JcclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIE1pcnJvciBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogTWlycm9yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIE1pcnJvclxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNaXJyb3Igb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gb3B0aW9ucy5jb25zdHJhaW5EaW1lbnNpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG9wdGlvbnMueEF4aXNcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gb3B0aW9ucy55QXhpc1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8bnVsbH0gb3B0aW9ucy5jdXJzb3JPZmZzZXRYXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxudWxsfSBvcHRpb25zLmN1cnNvck9mZnNldFlcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufSBvcHRpb25zLmFwcGVuZFRvXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIHRoaXMuZ2V0T3B0aW9ucygpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjcm9sbCBvZmZzZXQgZm9yIHRvdWNoIGRldmljZXMgYmVjYXVzZSB0aGUgbWlycm9yIGlzIHBvc2l0aW9uZWQgZml4ZWRcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzY3JvbGxPZmZzZXRcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY3JvbGxPZmZzZXQueFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjcm9sbE9mZnNldC55XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsIHNjcm9sbCBvZmZzZXQgZm9yIHRvdWNoIGRldmljZXMgYmVjYXVzZSB0aGUgbWlycm9yIGlzIHBvc2l0aW9uZWQgZml4ZWRcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzY3JvbGxPZmZzZXRcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY3JvbGxPZmZzZXQueFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjcm9sbE9mZnNldC55XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldCA9IHtcclxuICAgICAgeDogd2luZG93LnNjcm9sbFgsXHJcbiAgICAgIHk6IHdpbmRvdy5zY3JvbGxZXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnTW92ZV0gPSB0aGlzW29uRHJhZ01vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1pcnJvckNyZWF0ZWRdID0gdGhpc1tvbk1pcnJvckNyZWF0ZWRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTWlycm9yTW92ZV0gPSB0aGlzW29uTWlycm9yTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25TY3JvbGxdID0gdGhpc1tvblNjcm9sbF0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKS5vbignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9uKCdtaXJyb3I6bW92ZScsIHRoaXNbb25NaXJyb3JNb3ZlXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vZmYoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSkub2ZmKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub2ZmKCdtaXJyb3I6bW92ZScsIHRoaXNbb25NaXJyb3JNb3ZlXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5taXJyb3IgfHwge307XHJcbiAgfVxyXG5cclxuICBbb25EcmFnU3RhcnRdKGRyYWdFdmVudCkge1xyXG4gICAgaWYgKGRyYWdFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXNbb25TY3JvbGxdLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQgPSB7XHJcbiAgICAgIHg6IHdpbmRvdy5zY3JvbGxYLFxyXG4gICAgICB5OiB3aW5kb3cuc2Nyb2xsWVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCB7IHNvdXJjZSwgb3JpZ2luYWxTb3VyY2UsIHNvdXJjZUNvbnRhaW5lciwgc2Vuc29yRXZlbnQgfSA9IGRyYWdFdmVudDtcclxuXHJcbiAgICAvLyBMYXN0IHNlbnNvciBwb3NpdGlvbiBvZiBtaXJyb3IgbW92ZVxyXG4gICAgdGhpcy5sYXN0TWlycm9yTW92ZWRDbGllbnQgPSB7XHJcbiAgICAgIHg6IHNlbnNvckV2ZW50LmNsaWVudFgsXHJcbiAgICAgIHk6IHNlbnNvckV2ZW50LmNsaWVudFlcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgbWlycm9yQ3JlYXRlRXZlbnQgPSBuZXcgX01pcnJvckV2ZW50Lk1pcnJvckNyZWF0ZUV2ZW50KHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgZHJhZ0V2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckNyZWF0ZUV2ZW50KTtcclxuXHJcbiAgICBpZiAoaXNOYXRpdmVEcmFnRXZlbnQoc2Vuc29yRXZlbnQpIHx8IG1pcnJvckNyZWF0ZUV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFwcGVuZGFibGVDb250YWluZXIgPSB0aGlzW2dldEFwcGVuZGFibGVDb250YWluZXJdKHNvdXJjZSkgfHwgc291cmNlQ29udGFpbmVyO1xyXG4gICAgdGhpcy5taXJyb3IgPSBzb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xyXG5cclxuICAgIGNvbnN0IG1pcnJvckNyZWF0ZWRFdmVudCA9IG5ldyBfTWlycm9yRXZlbnQuTWlycm9yQ3JlYXRlZEV2ZW50KHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgZHJhZ0V2ZW50LFxyXG4gICAgICBtaXJyb3I6IHRoaXMubWlycm9yXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBtaXJyb3JBdHRhY2hlZEV2ZW50ID0gbmV3IF9NaXJyb3JFdmVudC5NaXJyb3JBdHRhY2hlZEV2ZW50KHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgZHJhZ0V2ZW50LFxyXG4gICAgICBtaXJyb3I6IHRoaXMubWlycm9yXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckNyZWF0ZWRFdmVudCk7XHJcbiAgICBhcHBlbmRhYmxlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubWlycm9yKTtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yQXR0YWNoZWRFdmVudCk7XHJcbiAgfVxyXG5cclxuICBbb25EcmFnTW92ZV0oZHJhZ0V2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMubWlycm9yIHx8IGRyYWdFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHNvdXJjZSwgb3JpZ2luYWxTb3VyY2UsIHNvdXJjZUNvbnRhaW5lciwgc2Vuc29yRXZlbnQgfSA9IGRyYWdFdmVudDtcclxuXHJcbiAgICBsZXQgcGFzc2VkVGhyZXNoWCA9IHRydWU7XHJcbiAgICBsZXQgcGFzc2VkVGhyZXNoWSA9IHRydWU7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy50aHJlc2hvbGRYIHx8IHRoaXMub3B0aW9ucy50aHJlc2hvbGRZKSB7XHJcbiAgICAgIGNvbnN0IHsgeDogbGFzdFgsIHk6IGxhc3RZIH0gPSB0aGlzLmxhc3RNaXJyb3JNb3ZlZENsaWVudDtcclxuXHJcbiAgICAgIGlmIChNYXRoLmFicyhsYXN0WCAtIHNlbnNvckV2ZW50LmNsaWVudFgpIDwgdGhpcy5vcHRpb25zLnRocmVzaG9sZFgpIHtcclxuICAgICAgICBwYXNzZWRUaHJlc2hYID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sYXN0TWlycm9yTW92ZWRDbGllbnQueCA9IHNlbnNvckV2ZW50LmNsaWVudFg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChNYXRoLmFicyhsYXN0WSAtIHNlbnNvckV2ZW50LmNsaWVudFkpIDwgdGhpcy5vcHRpb25zLnRocmVzaG9sZFkpIHtcclxuICAgICAgICBwYXNzZWRUaHJlc2hZID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sYXN0TWlycm9yTW92ZWRDbGllbnQueSA9IHNlbnNvckV2ZW50LmNsaWVudFk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcGFzc2VkVGhyZXNoWCAmJiAhcGFzc2VkVGhyZXNoWSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1pcnJvck1vdmVFdmVudCA9IG5ldyBfTWlycm9yRXZlbnQuTWlycm9yTW92ZUV2ZW50KHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgZHJhZ0V2ZW50LFxyXG4gICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxyXG4gICAgICBwYXNzZWRUaHJlc2hYLFxyXG4gICAgICBwYXNzZWRUaHJlc2hZXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvck1vdmVFdmVudCk7XHJcbiAgfVxyXG5cclxuICBbb25EcmFnU3RvcF0oZHJhZ0V2ZW50KSB7XHJcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXNbb25TY3JvbGxdLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcblxyXG4gICAgaWYgKCF0aGlzLm1pcnJvcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBzb3VyY2UsIHNvdXJjZUNvbnRhaW5lciwgc2Vuc29yRXZlbnQgfSA9IGRyYWdFdmVudDtcclxuXHJcbiAgICBjb25zdCBtaXJyb3JEZXN0cm95RXZlbnQgPSBuZXcgX01pcnJvckV2ZW50Lk1pcnJvckRlc3Ryb3lFdmVudCh7XHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcclxuICAgICAgc291cmNlQ29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgZHJhZ0V2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckRlc3Ryb3lFdmVudCk7XHJcblxyXG4gICAgaWYgKCFtaXJyb3JEZXN0cm95RXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICB0aGlzLm1pcnJvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubWlycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIFtvblNjcm9sbF0oKSB7XHJcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHtcclxuICAgICAgeDogd2luZG93LnNjcm9sbFggLSB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQueCxcclxuICAgICAgeTogd2luZG93LnNjcm9sbFkgLSB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQueVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1pcnJvciBjcmVhdGVkIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge01pcnJvckNyZWF0ZWRFdmVudH0gbWlycm9yRXZlbnRcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uTWlycm9yQ3JlYXRlZF0oeyBtaXJyb3IsIHNvdXJjZSwgc2Vuc29yRXZlbnQgfSkge1xyXG4gICAgY29uc3QgbWlycm9yQ2xhc3NlcyA9IHRoaXMuZHJhZ2dhYmxlLmdldENsYXNzTmFtZXNGb3IoJ21pcnJvcicpO1xyXG5cclxuICAgIGNvbnN0IHNldFN0YXRlID0gKF9yZWYpID0+IHtcclxuICAgICAgbGV0IHsgbWlycm9yT2Zmc2V0LCBpbml0aWFsWCwgaW5pdGlhbFkgfSA9IF9yZWYsXHJcbiAgICAgICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnbWlycm9yT2Zmc2V0JywgJ2luaXRpYWxYJywgJ2luaXRpYWxZJ10pO1xyXG5cclxuICAgICAgdGhpcy5taXJyb3JPZmZzZXQgPSBtaXJyb3JPZmZzZXQ7XHJcbiAgICAgIHRoaXMuaW5pdGlhbFggPSBpbml0aWFsWDtcclxuICAgICAgdGhpcy5pbml0aWFsWSA9IGluaXRpYWxZO1xyXG4gICAgICB0aGlzLmxhc3RNb3ZlZFggPSBpbml0aWFsWDtcclxuICAgICAgdGhpcy5sYXN0TW92ZWRZID0gaW5pdGlhbFk7XHJcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7IG1pcnJvck9mZnNldCwgaW5pdGlhbFgsIGluaXRpYWxZIH0sIGFyZ3MpO1xyXG4gICAgfTtcclxuXHJcbiAgICBtaXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHJcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSB7XHJcbiAgICAgIG1pcnJvcixcclxuICAgICAgc291cmNlLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgbWlycm9yQ2xhc3NlcyxcclxuICAgICAgc2Nyb2xsT2Zmc2V0OiB0aGlzLnNjcm9sbE9mZnNldCxcclxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxyXG4gICAgICBwYXNzZWRUaHJlc2hYOiB0cnVlLFxyXG4gICAgICBwYXNzZWRUaHJlc2hZOiB0cnVlXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW5pdGlhbFN0YXRlKVxyXG4gICAgLy8gRml4IHJlZmxvdyBoZXJlXHJcbiAgICAudGhlbihjb21wdXRlTWlycm9yRGltZW5zaW9ucykudGhlbihjYWxjdWxhdGVNaXJyb3JPZmZzZXQpLnRoZW4ocmVzZXRNaXJyb3IpLnRoZW4oYWRkTWlycm9yQ2xhc3NlcykudGhlbihwb3NpdGlvbk1pcnJvcih7IGluaXRpYWw6IHRydWUgfSkpLnRoZW4ocmVtb3ZlTWlycm9ySUQpLnRoZW4oc2V0U3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlycm9yIG1vdmUgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7TWlycm9yTW92ZUV2ZW50fSBtaXJyb3JFdmVudFxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V8bnVsbH1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbk1pcnJvck1vdmVdKG1pcnJvckV2ZW50KSB7XHJcbiAgICBpZiAobWlycm9yRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZXRTdGF0ZSA9IChfcmVmMikgPT4ge1xyXG4gICAgICBsZXQgeyBsYXN0TW92ZWRYLCBsYXN0TW92ZWRZIH0gPSBfcmVmMixcclxuICAgICAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnbGFzdE1vdmVkWCcsICdsYXN0TW92ZWRZJ10pO1xyXG5cclxuICAgICAgdGhpcy5sYXN0TW92ZWRYID0gbGFzdE1vdmVkWDtcclxuICAgICAgdGhpcy5sYXN0TW92ZWRZID0gbGFzdE1vdmVkWTtcclxuXHJcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7IGxhc3RNb3ZlZFgsIGxhc3RNb3ZlZFkgfSwgYXJncyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcclxuICAgICAgbWlycm9yOiBtaXJyb3JFdmVudC5taXJyb3IsXHJcbiAgICAgIHNlbnNvckV2ZW50OiBtaXJyb3JFdmVudC5zZW5zb3JFdmVudCxcclxuICAgICAgbWlycm9yT2Zmc2V0OiB0aGlzLm1pcnJvck9mZnNldCxcclxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxyXG4gICAgICBpbml0aWFsWDogdGhpcy5pbml0aWFsWCxcclxuICAgICAgaW5pdGlhbFk6IHRoaXMuaW5pdGlhbFksXHJcbiAgICAgIHNjcm9sbE9mZnNldDogdGhpcy5zY3JvbGxPZmZzZXQsXHJcbiAgICAgIHBhc3NlZFRocmVzaFg6IG1pcnJvckV2ZW50LnBhc3NlZFRocmVzaFgsXHJcbiAgICAgIHBhc3NlZFRocmVzaFk6IG1pcnJvckV2ZW50LnBhc3NlZFRocmVzaFksXHJcbiAgICAgIGxhc3RNb3ZlZFg6IHRoaXMubGFzdE1vdmVkWCxcclxuICAgICAgbGFzdE1vdmVkWTogdGhpcy5sYXN0TW92ZWRZXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW5pdGlhbFN0YXRlKS50aGVuKHBvc2l0aW9uTWlycm9yKHsgcmFmOiB0cnVlIH0pKS50aGVuKHNldFN0YXRlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYXBwZW5kYWJsZSBjb250YWluZXIgZm9yIG1pcnJvciBiYXNlZCBvbiB0aGUgYXBwZW5kVG8gb3B0aW9uXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMuc291cmNlIC0gQ3VycmVudCBzb3VyY2VcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgKi9cclxuICBbZ2V0QXBwZW5kYWJsZUNvbnRhaW5lcl0oc291cmNlKSB7XHJcbiAgICBjb25zdCBhcHBlbmRUbyA9IHRoaXMub3B0aW9ucy5hcHBlbmRUbztcclxuXHJcbiAgICBpZiAodHlwZW9mIGFwcGVuZFRvID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcHBlbmRUbyk7XHJcbiAgICB9IGVsc2UgaWYgKGFwcGVuZFRvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGFwcGVuZFRvO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXBwZW5kVG8gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIGFwcGVuZFRvKHNvdXJjZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gc291cmNlLnBhcmVudE5vZGU7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBNaXJyb3I7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbXB1dGVzIG1pcnJvciBkaW1lbnNpb25zIGJhc2VkIG9uIHRoZSBzb3VyY2UgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFkZHMgc291cmNlUmVjdCB0byBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLnNvdXJjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmZ1bmN0aW9uIGNvbXB1dGVNaXJyb3JEaW1lbnNpb25zKF9yZWYzKSB7XHJcbiAgbGV0IHsgc291cmNlIH0gPSBfcmVmMyxcclxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMywgWydzb3VyY2UnXSk7XHJcblxyXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIGNvbnN0IHNvdXJjZVJlY3QgPSBzb3VyY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICByZXNvbHZlKF9leHRlbmRzKHsgc291cmNlLCBzb3VyY2VSZWN0IH0sIGFyZ3MpKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgbWlycm9yIG9mZnNldFxyXG4gKiBBZGRzIG1pcnJvck9mZnNldCB0byBzdGF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcclxuICogQHBhcmFtIHtTZW5zb3JFdmVudH0gc3RhdGUuc2Vuc29yRXZlbnRcclxuICogQHBhcmFtIHtET01SZWN0fSBzdGF0ZS5zb3VyY2VSZWN0XHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVNaXJyb3JPZmZzZXQoX3JlZjQpIHtcclxuICBsZXQgeyBzZW5zb3JFdmVudCwgc291cmNlUmVjdCwgb3B0aW9ucyB9ID0gX3JlZjQsXHJcbiAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjQsIFsnc2Vuc29yRXZlbnQnLCAnc291cmNlUmVjdCcsICdvcHRpb25zJ10pO1xyXG5cclxuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBjb25zdCB0b3AgPSBvcHRpb25zLmN1cnNvck9mZnNldFkgPT09IG51bGwgPyBzZW5zb3JFdmVudC5jbGllbnRZIC0gc291cmNlUmVjdC50b3AgOiBvcHRpb25zLmN1cnNvck9mZnNldFk7XHJcbiAgICBjb25zdCBsZWZ0ID0gb3B0aW9ucy5jdXJzb3JPZmZzZXRYID09PSBudWxsID8gc2Vuc29yRXZlbnQuY2xpZW50WCAtIHNvdXJjZVJlY3QubGVmdCA6IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WDtcclxuXHJcbiAgICBjb25zdCBtaXJyb3JPZmZzZXQgPSB7IHRvcCwgbGVmdCB9O1xyXG5cclxuICAgIHJlc29sdmUoX2V4dGVuZHMoeyBzZW5zb3JFdmVudCwgc291cmNlUmVjdCwgbWlycm9yT2Zmc2V0LCBvcHRpb25zIH0sIGFyZ3MpKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGx5cyBtaXJyb3Igc3R5bGVzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5taXJyb3JcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUuc291cmNlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZS5vcHRpb25zXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNldE1pcnJvcihfcmVmNSkge1xyXG4gIGxldCB7IG1pcnJvciwgc291cmNlLCBvcHRpb25zIH0gPSBfcmVmNSxcclxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNSwgWydtaXJyb3InLCAnc291cmNlJywgJ29wdGlvbnMnXSk7XHJcblxyXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIGxldCBvZmZzZXRIZWlnaHQ7XHJcbiAgICBsZXQgb2Zmc2V0V2lkdGg7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9ucykge1xyXG4gICAgICBjb25zdCBjb21wdXRlZFNvdXJjZVN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoc291cmNlKTtcclxuICAgICAgb2Zmc2V0SGVpZ2h0ID0gY29tcHV0ZWRTb3VyY2VTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0Jyk7XHJcbiAgICAgIG9mZnNldFdpZHRoID0gY29tcHV0ZWRTb3VyY2VTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKTtcclxuICAgIH1cclxuXHJcbiAgICBtaXJyb3Iuc3R5bGUuZGlzcGxheSA9IG51bGw7XHJcbiAgICBtaXJyb3Iuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xyXG4gICAgbWlycm9yLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcbiAgICBtaXJyb3Iuc3R5bGUudG9wID0gMDtcclxuICAgIG1pcnJvci5zdHlsZS5sZWZ0ID0gMDtcclxuICAgIG1pcnJvci5zdHlsZS5tYXJnaW4gPSAwO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmNvbnN0cmFpbkRpbWVuc2lvbnMpIHtcclxuICAgICAgbWlycm9yLnN0eWxlLmhlaWdodCA9IG9mZnNldEhlaWdodDtcclxuICAgICAgbWlycm9yLnN0eWxlLndpZHRoID0gb2Zmc2V0V2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzb2x2ZShfZXh0ZW5kcyh7IG1pcnJvciwgc291cmNlLCBvcHRpb25zIH0sIGFyZ3MpKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGx5cyBtaXJyb3IgY2xhc3Mgb24gbWlycm9yIGVsZW1lbnRcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLm1pcnJvclxyXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBzdGF0ZS5taXJyb3JDbGFzc2VzXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRNaXJyb3JDbGFzc2VzKF9yZWY2KSB7XHJcbiAgbGV0IHsgbWlycm9yLCBtaXJyb3JDbGFzc2VzIH0gPSBfcmVmNixcclxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNiwgWydtaXJyb3InLCAnbWlycm9yQ2xhc3NlcyddKTtcclxuXHJcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgbWlycm9yLmNsYXNzTGlzdC5hZGQoLi4ubWlycm9yQ2xhc3Nlcyk7XHJcbiAgICByZXNvbHZlKF9leHRlbmRzKHsgbWlycm9yLCBtaXJyb3JDbGFzc2VzIH0sIGFyZ3MpKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgc291cmNlIElEIGZyb20gY2xvbmVkIG1pcnJvciBlbGVtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5taXJyb3JcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZU1pcnJvcklEKF9yZWY3KSB7XHJcbiAgbGV0IHsgbWlycm9yIH0gPSBfcmVmNyxcclxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNywgWydtaXJyb3InXSk7XHJcblxyXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIG1pcnJvci5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XHJcbiAgICBkZWxldGUgbWlycm9yLmlkO1xyXG4gICAgcmVzb2x2ZShfZXh0ZW5kcyh7IG1pcnJvciB9LCBhcmdzKSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQb3NpdGlvbnMgbWlycm9yIHdpdGggdHJhbnNsYXRlM2RcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLm1pcnJvclxyXG4gKiBAcGFyYW0ge1NlbnNvckV2ZW50fSBzdGF0ZS5zZW5zb3JFdmVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUubWlycm9yT2Zmc2V0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0ZS5pbml0aWFsWVxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdGUuaW5pdGlhbFhcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlLm9wdGlvbnNcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHBvc2l0aW9uTWlycm9yKHsgd2l0aEZyYW1lID0gZmFsc2UsIGluaXRpYWwgPSBmYWxzZSB9ID0ge30pIHtcclxuICByZXR1cm4gKF9yZWY4KSA9PiB7XHJcbiAgICBsZXQge1xyXG4gICAgICBtaXJyb3IsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBtaXJyb3JPZmZzZXQsXHJcbiAgICAgIGluaXRpYWxZLFxyXG4gICAgICBpbml0aWFsWCxcclxuICAgICAgc2Nyb2xsT2Zmc2V0LFxyXG4gICAgICBvcHRpb25zLFxyXG4gICAgICBwYXNzZWRUaHJlc2hYLFxyXG4gICAgICBwYXNzZWRUaHJlc2hZLFxyXG4gICAgICBsYXN0TW92ZWRYLFxyXG4gICAgICBsYXN0TW92ZWRZXHJcbiAgICB9ID0gX3JlZjgsXHJcbiAgICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmOCwgWydtaXJyb3InLCAnc2Vuc29yRXZlbnQnLCAnbWlycm9yT2Zmc2V0JywgJ2luaXRpYWxZJywgJ2luaXRpYWxYJywgJ3Njcm9sbE9mZnNldCcsICdvcHRpb25zJywgJ3Bhc3NlZFRocmVzaFgnLCAncGFzc2VkVGhyZXNoWScsICdsYXN0TW92ZWRYJywgJ2xhc3RNb3ZlZFknXSk7XHJcblxyXG4gICAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBfZXh0ZW5kcyh7XHJcbiAgICAgICAgbWlycm9yLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG1pcnJvck9mZnNldCxcclxuICAgICAgICBvcHRpb25zXHJcbiAgICAgIH0sIGFyZ3MpO1xyXG5cclxuICAgICAgaWYgKG1pcnJvck9mZnNldCkge1xyXG4gICAgICAgIGNvbnN0IHggPSBwYXNzZWRUaHJlc2hYID8gTWF0aC5yb3VuZCgoc2Vuc29yRXZlbnQuY2xpZW50WCAtIG1pcnJvck9mZnNldC5sZWZ0IC0gc2Nyb2xsT2Zmc2V0LngpIC8gKG9wdGlvbnMudGhyZXNob2xkWCB8fCAxKSkgKiAob3B0aW9ucy50aHJlc2hvbGRYIHx8IDEpIDogTWF0aC5yb3VuZChsYXN0TW92ZWRYKTtcclxuICAgICAgICBjb25zdCB5ID0gcGFzc2VkVGhyZXNoWSA/IE1hdGgucm91bmQoKHNlbnNvckV2ZW50LmNsaWVudFkgLSBtaXJyb3JPZmZzZXQudG9wIC0gc2Nyb2xsT2Zmc2V0LnkpIC8gKG9wdGlvbnMudGhyZXNob2xkWSB8fCAxKSkgKiAob3B0aW9ucy50aHJlc2hvbGRZIHx8IDEpIDogTWF0aC5yb3VuZChsYXN0TW92ZWRZKTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMueEF4aXMgJiYgb3B0aW9ucy55QXhpcyB8fCBpbml0aWFsKSB7XHJcbiAgICAgICAgICBtaXJyb3Iuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7eH1weCwgJHt5fXB4LCAwKWA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnhBeGlzICYmICFvcHRpb25zLnlBeGlzKSB7XHJcbiAgICAgICAgICBtaXJyb3Iuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7eH1weCwgJHtpbml0aWFsWX1weCwgMClgO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy55QXhpcyAmJiAhb3B0aW9ucy54QXhpcykge1xyXG4gICAgICAgICAgbWlycm9yLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke2luaXRpYWxYfXB4LCAke3l9cHgsIDApYDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpbml0aWFsKSB7XHJcbiAgICAgICAgICByZXN1bHQuaW5pdGlhbFggPSB4O1xyXG4gICAgICAgICAgcmVzdWx0LmluaXRpYWxZID0geTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdC5sYXN0TW92ZWRYID0geDtcclxuICAgICAgICByZXN1bHQubGFzdE1vdmVkWSA9IHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgIH0sIHsgZnJhbWU6IHdpdGhGcmFtZSB9KTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogV3JhcHMgZnVuY3Rpb25zIGluIHByb21pc2Ugd2l0aCBwb3RlbnRpYWwgYW5pbWF0aW9uIGZyYW1lIG9wdGlvblxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMucmFmXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoUHJvbWlzZShjYWxsYmFjaywgeyByYWYgPSBmYWxzZSB9ID0ge30pIHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgaWYgKHJhZikge1xyXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIGNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2Vuc29yIGV2ZW50IHdhcyB0cmlnZ2VyZWQgYnkgYSBuYXRpdmUgYnJvd3NlciBkcmFnIGV2ZW50XHJcbiAqIEBwYXJhbSB7U2Vuc29yRXZlbnR9IHNlbnNvckV2ZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpc05hdGl2ZURyYWdFdmVudChzZW5zb3JFdmVudCkge1xyXG4gIHJldHVybiAoL15kcmFnLy50ZXN0KHNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQudHlwZSlcclxuICApO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNjMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX01pcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xyXG5cclxudmFyIF9NaXJyb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWlycm9yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfTWlycm9yMi5kZWZhdWx0O1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gX01pcnJvci5kZWZhdWx0T3B0aW9ucztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2NCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uSW5pdGlhbGl6ZSA9IFN5bWJvbCgnb25Jbml0aWFsaXplJyk7XHJcbmNvbnN0IG9uRGVzdHJveSA9IFN5bWJvbCgnb25EZXN0cm95Jyk7XHJcblxyXG4vKipcclxuICogRm9jdXNhYmxlIGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge307XHJcblxyXG4vKipcclxuICogRm9jdXNhYmxlIHBsdWdpblxyXG4gKiBAY2xhc3MgRm9jdXNhYmxlXHJcbiAqIEBtb2R1bGUgRm9jdXNhYmxlXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBGb2N1c2FibGUgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIEZvY3VzYWJsZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBGb2N1c2FibGVcclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9jdXNhYmxlIG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIHRoaXMuZ2V0T3B0aW9ucygpKTtcclxuXHJcbiAgICB0aGlzW29uSW5pdGlhbGl6ZV0gPSB0aGlzW29uSW5pdGlhbGl6ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EZXN0cm95XSA9IHRoaXNbb25EZXN0cm95XS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgbGlzdGVuZXJzIHRvIGRyYWdnYWJsZVxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnZ2FibGU6aW5pdGlhbGl6ZScsIHRoaXNbb25Jbml0aWFsaXplXSkub24oJ2RyYWdnYWJsZTpkZXN0cm95JywgdGhpc1tvbkRlc3Ryb3ldKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIGxpc3RlbmVycyBmcm9tIGRyYWdnYWJsZVxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZ2dhYmxlOmluaXRpYWxpemUnLCB0aGlzW29uSW5pdGlhbGl6ZV0pLm9mZignZHJhZ2dhYmxlOmRlc3Ryb3knLCB0aGlzW29uRGVzdHJveV0pO1xyXG5cclxuICAgIC8vIFJlbW92ZSBtb2RpZmllZCBlbGVtZW50cyB3aGVuIGRldGFjaFxyXG4gICAgdGhpc1tvbkRlc3Ryb3ldKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5mb2N1c2FibGUgfHwge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGRyYWdnYWJsZSBjb250YWluZXJzIGFuZCBlbGVtZW50c1xyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XHJcbiAgICovXHJcbiAgZ2V0RWxlbWVudHMoKSB7XHJcbiAgICByZXR1cm4gWy4uLnRoaXMuZHJhZ2dhYmxlLmNvbnRhaW5lcnMsIC4uLnRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzKCldO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW50aWFsaXplIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkluaXRpYWxpemVdKCkge1xyXG4gICAgLy8gQ2FuIHdhaXQgdW50aWwgdGhlIG5leHQgYmVzdCBmcmFtZSBpcyBhdmFpbGFibGVcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMuZ2V0RWxlbWVudHMoKS5mb3JFYWNoKGVsZW1lbnQgPT4gZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzdHJveSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25EZXN0cm95XSgpIHtcclxuICAgIC8vIENhbiB3YWl0IHVudGlsIHRoZSBuZXh0IGJlc3QgZnJhbWUgaXMgYXZhaWxhYmxlXHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB0aGlzLmdldEVsZW1lbnRzKCkuZm9yRWFjaChlbGVtZW50ID0+IHN0cmlwRWxlbWVudChlbGVtZW50KSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IEZvY3VzYWJsZTsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBtaXNzaW5nIHRhYmluZGV4IGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBzbyB0aGV5IGNhbiBiZSByZXNldCB3aGVuIGRyYWdnYWJsZSBnZXRzIGRlc3Ryb3llZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjb25zdCB7SFRNTEVsZW1lbnRbXX0gZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5jb25zdCBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXggPSBbXTtcclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0ZXMgZWxlbWVudCB3aXRoIHRhYmluZGV4IGF0dHJpYnV0ZXNcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCkge1xyXG4gIGNvbnN0IGhhc01pc3NpbmdUYWJJbmRleCA9IEJvb2xlYW4oIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpICYmIGVsZW1lbnQudGFiSW5kZXggPT09IC0xKTtcclxuXHJcbiAgaWYgKGhhc01pc3NpbmdUYWJJbmRleCkge1xyXG4gICAgZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4LnB1c2goZWxlbWVudCk7XHJcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gMDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGVsZW1lbnRzIHRhYmluZGV4IGF0dHJpYnV0ZXNcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaXBFbGVtZW50KGVsZW1lbnQpIHtcclxuICBjb25zdCB0YWJJbmRleEVsZW1lbnRQb3NpdGlvbiA9IGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleC5pbmRleE9mKGVsZW1lbnQpO1xyXG5cclxuICBpZiAodGFiSW5kZXhFbGVtZW50UG9zaXRpb24gIT09IC0xKSB7XHJcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gLTE7XHJcbiAgICBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXguc3BsaWNlKHRhYkluZGV4RWxlbWVudFBvc2l0aW9uLCAxKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2NSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRm9jdXNhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XHJcblxyXG52YXIgX0ZvY3VzYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Gb2N1c2FibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Gb2N1c2FibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNjYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbi8qKlxyXG4gKiBBbGwgZHJhZ2dhYmxlIHBsdWdpbnMgaW5oZXJpdCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAY2xhc3MgQWJzdHJhY3RQbHVnaW5cclxuICogQG1vZHVsZSBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgQWJzdHJhY3RQbHVnaW4ge1xyXG4gIC8qKlxyXG4gICAqIEFic3RyYWN0UGx1Z2luIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIEFic3RyYWN0UGx1Z2luXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgICAqIEBwcm9wZXJ0eSBkcmFnZ2FibGVcclxuICAgICAqIEB0eXBlIHtEcmFnZ2FibGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3ZlcnJpZGUgdG8gYWRkIGxpc3RlbmVyc1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPdmVycmlkZSB0byByZW1vdmUgbGlzdGVuZXJzXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gQWJzdHJhY3RQbHVnaW47XHJcblxyXG4vKioqLyB9KSxcclxuLyogNjcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkluaXRpYWxpemUgPSBTeW1ib2woJ29uSW5pdGlhbGl6ZScpO1xyXG5jb25zdCBvbkRlc3Ryb3kgPSBTeW1ib2woJ29uRGVzdHJveScpO1xyXG5jb25zdCBhbm5vdW5jZUV2ZW50ID0gU3ltYm9sKCdhbm5vdW5jZUV2ZW50Jyk7XHJcbmNvbnN0IGFubm91bmNlTWVzc2FnZSA9IFN5bWJvbCgnYW5ub3VuY2VNZXNzYWdlJyk7XHJcblxyXG5jb25zdCBBUklBX1JFTEVWQU5UID0gJ2FyaWEtcmVsZXZhbnQnO1xyXG5jb25zdCBBUklBX0FUT01JQyA9ICdhcmlhLWF0b21pYyc7XHJcbmNvbnN0IEFSSUFfTElWRSA9ICdhcmlhLWxpdmUnO1xyXG5jb25zdCBST0xFID0gJ3JvbGUnO1xyXG5cclxuLyoqXHJcbiAqIEFubm91bmNlbWVudCBkZWZhdWx0IG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWZhdWx0T3B0aW9ucy5leHBpcmVcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcclxuICBleHBpcmU6IDcwMDBcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbm5vdW5jZW1lbnQgcGx1Z2luXHJcbiAqIEBjbGFzcyBBbm5vdW5jZW1lbnRcclxuICogQG1vZHVsZSBBbm5vdW5jZW1lbnRcclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIEFubm91bmNlbWVudCBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogQW5ub3VuY2VtZW50IGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIEFubm91bmNlbWVudFxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQbHVnaW4gb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3JpZ2luYWwgZHJhZ2dhYmxlIHRyaWdnZXIgbWV0aG9kLiBIYWNrIHVudGlsIHdlIGhhdmUgb25BbGwgb3Igb24oJ2FsbCcpXHJcbiAgICAgKiBAcHJvcGVydHkgb3JpZ2luYWxUcmlnZ2VyTWV0aG9kXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kID0gdGhpcy5kcmFnZ2FibGUudHJpZ2dlcjtcclxuXHJcbiAgICB0aGlzW29uSW5pdGlhbGl6ZV0gPSB0aGlzW29uSW5pdGlhbGl6ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EZXN0cm95XSA9IHRoaXNbb25EZXN0cm95XS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgbGlzdGVuZXJzIHRvIGRyYWdnYWJsZVxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnZ2FibGU6aW5pdGlhbGl6ZScsIHRoaXNbb25Jbml0aWFsaXplXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBsaXN0ZW5lcnMgZnJvbSBkcmFnZ2FibGVcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWdnYWJsZTpkZXN0cm95JywgdGhpc1tvbkRlc3Ryb3ldKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgcGFzc2VkIGluIG9wdGlvbnNcclxuICAgKi9cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuYW5ub3VuY2VtZW50cyB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFubm91bmNlcyBldmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtBYnN0cmFjdEV2ZW50fSBldmVudFxyXG4gICAqL1xyXG4gIFthbm5vdW5jZUV2ZW50XShldmVudCkge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMub3B0aW9uc1tldmVudC50eXBlXTtcclxuXHJcbiAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhpc1thbm5vdW5jZU1lc3NhZ2VdKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtZXNzYWdlICYmIHR5cGVvZiBtZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRoaXNbYW5ub3VuY2VNZXNzYWdlXShtZXNzYWdlKGV2ZW50KSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbm5vdW5jZXMgbWVzc2FnZSB0byBzY3JlZW4gcmVhZGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxyXG4gICAqL1xyXG4gIFthbm5vdW5jZU1lc3NhZ2VdKG1lc3NhZ2UpIHtcclxuICAgIGFubm91bmNlKG1lc3NhZ2UsIHsgZXhwaXJlOiB0aGlzLm9wdGlvbnMuZXhwaXJlIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBoYW5kZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkluaXRpYWxpemVdKCkge1xyXG4gICAgLy8gSGFjayB1bnRpbCB0aGVyZSBpcyBhbiBhcGkgZm9yIGxpc3RlbmluZyBmb3IgYWxsIGV2ZW50c1xyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlciA9IGV2ZW50ID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aGlzW2Fubm91bmNlRXZlbnRdKGV2ZW50KTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBvcmlnaW5hbCB0cmlnZ2VyIGlzIGNhbGxlZFxyXG4gICAgICAgIHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kLmNhbGwodGhpcy5kcmFnZ2FibGUsIGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgaGFuZGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25EZXN0cm95XSgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIgPSB0aGlzLm9yaWdpbmFsVHJpZ2dlck1ldGhvZDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFubm91bmNlbWVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0IHtIVE1MRWxlbWVudH0gbGl2ZVJlZ2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuY29uc3QgbGl2ZVJlZ2lvbiA9IGNyZWF0ZVJlZ2lvbigpO1xyXG5cclxuLyoqXHJcbiAqIEFubm91bmNlcyBtZXNzYWdlIHZpYSBsaXZlIHJlZ2lvblxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5leHBpcmVcclxuICovXHJcbmZ1bmN0aW9uIGFubm91bmNlKG1lc3NhZ2UsIHsgZXhwaXJlIH0pIHtcclxuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG4gIGVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xyXG4gIGxpdmVSZWdpb24uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XHJcblxyXG4gIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgIGxpdmVSZWdpb24ucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XHJcbiAgfSwgZXhwaXJlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgcmVnaW9uIGVsZW1lbnRcclxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZWdpb24oKSB7XHJcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCAnZHJhZ2dhYmxlLWxpdmUtcmVnaW9uJyk7XHJcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoQVJJQV9SRUxFVkFOVCwgJ2FkZGl0aW9ucycpO1xyXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKEFSSUFfQVRPTUlDLCAndHJ1ZScpO1xyXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKEFSSUFfTElWRSwgJ2Fzc2VydGl2ZScpO1xyXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKFJPTEUsICdsb2cnKTtcclxuXHJcbiAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XHJcbiAgZWxlbWVudC5zdHlsZS53aWR0aCA9ICcxcHgnO1xyXG4gIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzFweCc7XHJcbiAgZWxlbWVudC5zdHlsZS50b3AgPSAnLTFweCc7XHJcbiAgZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG5cclxuICByZXR1cm4gZWxlbWVudDtcclxufVxyXG5cclxuLy8gQXBwZW5kIGxpdmUgcmVnaW9uIGVsZW1lbnQgYXMgZWFybHkgYXMgcG9zc2libGVcclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcclxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpdmVSZWdpb24pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2OCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQW5ub3VuY2VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XHJcblxyXG52YXIgX0Fubm91bmNlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Bbm5vdW5jZW1lbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Bbm5vdW5jZW1lbnQyLmRlZmF1bHQ7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfQW5ub3VuY2VtZW50LmRlZmF1bHRPcHRpb25zO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDY5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkRyYWdnYWJsZURlc3Ryb3lFdmVudCA9IGV4cG9ydHMuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCA9IGV4cG9ydHMuRHJhZ2dhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIGRyYWdnYWJsZSBldmVudFxyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlRXZlbnRcclxuICogQG1vZHVsZSBEcmFnZ2FibGVFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBEcmFnZ2FibGVFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICogQHByb3BlcnR5IGRyYWdnYWJsZVxyXG4gICAqIEB0eXBlIHtEcmFnZ2FibGV9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyYWdnYWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ2dhYmxlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnZ2FibGVFdmVudCA9IERyYWdnYWJsZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnZ2FibGUgaW5pdGlhbGl6ZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdnYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnZ2FibGVFdmVudC50eXBlID0gJ2RyYWdnYWJsZSc7XHJcbmNsYXNzIERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQgZXh0ZW5kcyBEcmFnZ2FibGVFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5EcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50ID0gRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWdnYWJsZSBkZXN0b3J5IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ2dhYmxlRGVzdHJveUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdnYWJsZURlc3Ryb3lFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQudHlwZSA9ICdkcmFnZ2FibGU6aW5pdGlhbGl6ZSc7XHJcbmNsYXNzIERyYWdnYWJsZURlc3Ryb3lFdmVudCBleHRlbmRzIERyYWdnYWJsZUV2ZW50IHt9XHJcbmV4cG9ydHMuRHJhZ2dhYmxlRGVzdHJveUV2ZW50ID0gRHJhZ2dhYmxlRGVzdHJveUV2ZW50O1xyXG5EcmFnZ2FibGVEZXN0cm95RXZlbnQudHlwZSA9ICdkcmFnZ2FibGU6ZGVzdHJveSc7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNzAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxuY29uc3QgY2FuY2VsZWQgPSBTeW1ib2woJ2NhbmNlbGVkJyk7XHJcblxyXG4vKipcclxuICogQWxsIGV2ZW50cyBmaXJlZCBieSBkcmFnZ2FibGUgaW5oZXJpdCB0aGlzIGNsYXNzLiBZb3UgY2FuIGNhbGwgYGNhbmNlbCgpYCB0b1xyXG4gKiBjYW5jZWwgYSBzcGVjaWZpYyBldmVudCBvciB5b3UgY2FuIGNoZWNrIGlmIGFuIGV2ZW50IGhhcyBiZWVuIGNhbmNlbGVkIGJ5XHJcbiAqIGNhbGxpbmcgYGNhbmNlbGVkKClgLlxyXG4gKiBAYWJzdHJhY3RcclxuICogQGNsYXNzIEFic3RyYWN0RXZlbnRcclxuICogQG1vZHVsZSBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBBYnN0cmFjdEV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3RFdmVudCBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBBYnN0cmFjdEV2ZW50XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBFdmVudCBkYXRhXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW50IHR5cGVcclxuICAgKiBAc3RhdGljXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHByb3BlcnR5IHR5cGVcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcclxuICAgIHRoaXNbY2FuY2VsZWRdID0gZmFsc2U7XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZC1vbmx5IHR5cGVcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBFdmVudCBjYW5jZWxhYmxlXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHR5cGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50eXBlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZC1vbmx5IGNhbmNlbGFibGVcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBjYW5jZWxhYmxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY2FuY2VsYWJsZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbmNlbHMgdGhlIGV2ZW50IGluc3RhbmNlXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcbiAgY2FuY2VsKCkge1xyXG4gICAgdGhpc1tjYW5jZWxlZF0gPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgZXZlbnQgaGFzIGJlZW4gY2FuY2VsZWRcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGNhbmNlbGVkKCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4odGhpc1tjYW5jZWxlZF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBuZXcgZXZlbnQgaW5zdGFuY2Ugd2l0aCBleGlzdGluZyBldmVudCBkYXRhLlxyXG4gICAqIFRoaXMgbWV0aG9kIGFsbG93cyBmb3Igb3ZlcnJpZGluZyBvZiBldmVudCBkYXRhLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcbiAgICogQHJldHVybiB7QWJzdHJhY3RFdmVudH1cclxuICAgKi9cclxuICBjbG9uZShkYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoX2V4dGVuZHMoe30sIHRoaXMuZGF0YSwgZGF0YSkpO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdEV2ZW50O1xyXG5BYnN0cmFjdEV2ZW50LnR5cGUgPSAnZXZlbnQnO1xyXG5BYnN0cmFjdEV2ZW50LmNhbmNlbGFibGUgPSBmYWxzZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5EcmFnU3RvcHBlZEV2ZW50ID0gZXhwb3J0cy5EcmFnU3RvcEV2ZW50ID0gZXhwb3J0cy5EcmFnUHJlc3N1cmVFdmVudCA9IGV4cG9ydHMuRHJhZ091dENvbnRhaW5lckV2ZW50ID0gZXhwb3J0cy5EcmFnT3ZlckNvbnRhaW5lckV2ZW50ID0gZXhwb3J0cy5EcmFnT3V0RXZlbnQgPSBleHBvcnRzLkRyYWdPdmVyRXZlbnQgPSBleHBvcnRzLkRyYWdNb3ZlRXZlbnQgPSBleHBvcnRzLkRyYWdTdGFydEV2ZW50ID0gZXhwb3J0cy5EcmFnRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIGRyYWcgZXZlbnRcclxuICogQGNsYXNzIERyYWdFdmVudFxyXG4gKiBAbW9kdWxlIERyYWdFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBEcmFnRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgc291cmNlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgc291cmNlXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzb3VyY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgb3JpZ2luYWwgc291cmNlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxTb3VyY2VcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9yaWdpbmFsU291cmNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vcmlnaW5hbFNvdXJjZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgbWlycm9yIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbWlycm9yXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBtaXJyb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgc291cmNlIGNvbnRhaW5lciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IHNvdXJjZUNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc291cmNlQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2VDb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5zb3IgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgc2Vuc29yRXZlbnRcclxuICAgKiBAdHlwZSB7U2Vuc29yRXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNlbnNvckV2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zZW5zb3JFdmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9yaWdpbmFsIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHNlbnNvciBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbEV2ZW50XHJcbiAgICogQHR5cGUge0V2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvcmlnaW5hbEV2ZW50KCkge1xyXG4gICAgaWYgKHRoaXMuc2Vuc29yRXZlbnQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2Vuc29yRXZlbnQub3JpZ2luYWxFdmVudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ0V2ZW50ID0gRHJhZ0V2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgc3RhcnQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RhcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnU3RhcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdFdmVudC50eXBlID0gJ2RyYWcnO1xyXG5jbGFzcyBEcmFnU3RhcnRFdmVudCBleHRlbmRzIERyYWdFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5EcmFnU3RhcnRFdmVudCA9IERyYWdTdGFydEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG1vdmUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ01vdmVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ01vdmVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ1N0YXJ0RXZlbnQudHlwZSA9ICdkcmFnOnN0YXJ0JztcclxuRHJhZ1N0YXJ0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIERyYWdNb3ZlRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ01vdmVFdmVudCA9IERyYWdNb3ZlRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG92ZXIgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdPdmVyRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnT3ZlckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdNb3ZlRXZlbnQudHlwZSA9ICdkcmFnOm1vdmUnO1xyXG5jbGFzcyBEcmFnT3ZlckV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciB5b3UgYXJlIG92ZXJcclxuICAgKiBAcHJvcGVydHkgb3ZlckNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBlbGVtZW50IHlvdSBhcmUgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnT3ZlckV2ZW50ID0gRHJhZ092ZXJFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgb3V0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnT3V0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnT3V0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ092ZXJFdmVudC50eXBlID0gJ2RyYWc6b3Zlcic7XHJcbkRyYWdPdmVyRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIERyYWdPdXRFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBjb250YWluZXIgeW91IGFyZSBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgZWxlbWVudCB5b3UgbGVmdFxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnT3V0RXZlbnQgPSBEcmFnT3V0RXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBvdmVyIGNvbnRhaW5lciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdPdmVyQ29udGFpbmVyRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ092ZXJDb250YWluZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdPdXRFdmVudC50eXBlID0gJ2RyYWc6b3V0JztcclxuY2xhc3MgRHJhZ092ZXJDb250YWluZXJFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBjb250YWluZXIgeW91IGFyZSBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdPdmVyQ29udGFpbmVyRXZlbnQgPSBEcmFnT3ZlckNvbnRhaW5lckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBvdXQgY29udGFpbmVyIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnT3V0Q29udGFpbmVyRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnT3V0Q29udGFpbmVyRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ092ZXJDb250YWluZXJFdmVudC50eXBlID0gJ2RyYWc6b3Zlcjpjb250YWluZXInO1xyXG5jbGFzcyBEcmFnT3V0Q29udGFpbmVyRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIHlvdSBsZWZ0XHJcbiAgICogQHByb3BlcnR5IG92ZXJDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdPdXRDb250YWluZXJFdmVudCA9IERyYWdPdXRDb250YWluZXJFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHByZXNzdXJlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1ByZXNzdXJlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1ByZXNzdXJlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnT3V0Q29udGFpbmVyRXZlbnQudHlwZSA9ICdkcmFnOm91dDpjb250YWluZXInO1xyXG5jbGFzcyBEcmFnUHJlc3N1cmVFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZXNzdXJlIGFwcGxpZWQgb24gZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgcHJlc3N1cmVcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBwcmVzc3VyZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEucHJlc3N1cmU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdQcmVzc3VyZUV2ZW50ID0gRHJhZ1ByZXNzdXJlRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgc3RvcCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RvcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnU3RvcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnUHJlc3N1cmVFdmVudC50eXBlID0gJ2RyYWc6cHJlc3N1cmUnO1xyXG5jbGFzcyBEcmFnU3RvcEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdTdG9wRXZlbnQgPSBEcmFnU3RvcEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdG9wcGVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RvcHBlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1N0b3BwZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnU3RvcEV2ZW50LnR5cGUgPSAnZHJhZzpzdG9wJztcclxuY2xhc3MgRHJhZ1N0b3BwZWRFdmVudCBleHRlbmRzIERyYWdFdmVudCB7fVxyXG5leHBvcnRzLkRyYWdTdG9wcGVkRXZlbnQgPSBEcmFnU3RvcHBlZEV2ZW50O1xyXG5EcmFnU3RvcHBlZEV2ZW50LnR5cGUgPSAnZHJhZzpzdG9wcGVkJztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5QbHVnaW5zID0gZXhwb3J0cy5TZW5zb3JzID0gZXhwb3J0cy5Tb3J0YWJsZSA9IGV4cG9ydHMuU3dhcHBhYmxlID0gZXhwb3J0cy5Ecm9wcGFibGUgPSBleHBvcnRzLkRyYWdnYWJsZSA9IGV4cG9ydHMuQmFzZVBsdWdpbiA9IGV4cG9ydHMuQmFzZUV2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9EcmFnZ2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdEcmFnZ2FibGUnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnZ2FibGUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfRHJvcHBhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Ryb3BwYWJsZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Ryb3BwYWJsZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Td2FwcGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU3dhcHBhYmxlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3dhcHBhYmxlKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1NvcnRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1NvcnRhYmxlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU29ydGFibGUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxudmFyIF9TZW5zb3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcbnZhciBTZW5zb3JzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX1NlbnNvcnMpO1xyXG5cclxudmFyIF9QbHVnaW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XHJcblxyXG52YXIgUGx1Z2lucyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9QbHVnaW5zKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5CYXNlRXZlbnQgPSBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdDtcclxuZXhwb3J0cy5CYXNlUGx1Z2luID0gX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0O1xyXG5leHBvcnRzLlNlbnNvcnMgPSBTZW5zb3JzO1xyXG5leHBvcnRzLlBsdWdpbnMgPSBQbHVnaW5zO1xyXG5cclxuLyoqKi8gfSlcclxuLyoqKioqKi8gXSk7XHJcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@shopify/draggable/lib/draggable.bundle.js\n");

/***/ }),

/***/ "./node_modules/@shopify/draggable/lib/draggable.bundle.legacy.js":
/*!************************************************************************!*\
  !*** ./node_modules/@shopify/draggable/lib/draggable.bundle.legacy.js ***!
  \************************************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(true)\r\n\t\tmodule.exports = factory();\r\n\telse {}\r\n})(window, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __nested_webpack_require_571__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId]) {\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_571__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__nested_webpack_require_571__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__nested_webpack_require_571__.c = installedModules;\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__nested_webpack_require_571__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__nested_webpack_require_571__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// define __esModule on exports\r\n/******/ \t__nested_webpack_require_571__.r = function(exports) {\r\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\r\n/******/ \t\t}\r\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\r\n/******/ \t};\r\n/******/\r\n/******/ \t// create a fake namespace object\r\n/******/ \t// mode & 1: value is a module id, require it\r\n/******/ \t// mode & 2: merge all properties of value into the ns\r\n/******/ \t// mode & 4: return value when already ns object\r\n/******/ \t// mode & 8|1: behave like require\r\n/******/ \t__nested_webpack_require_571__.t = function(value, mode) {\r\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_571__(value);\r\n/******/ \t\tif(mode & 8) return value;\r\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\r\n/******/ \t\tvar ns = Object.create(null);\r\n/******/ \t\t__nested_webpack_require_571__.r(ns);\r\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\r\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_571__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\r\n/******/ \t\treturn ns;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__nested_webpack_require_571__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__nested_webpack_require_571__.d(getter, 'a', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__nested_webpack_require_571__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__nested_webpack_require_571__.p = \"\";\r\n/******/\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __nested_webpack_require_571__(__nested_webpack_require_571__.s = 160);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __nested_webpack_require_4120__) {\r\n\r\nvar store = __nested_webpack_require_4120__(36)('wks');\r\nvar uid = __nested_webpack_require_4120__(22);\r\nvar Symbol = __nested_webpack_require_4120__(1).Symbol;\r\nvar USE_SYMBOL = typeof Symbol == 'function';\r\n\r\nvar $exports = module.exports = function (name) {\r\n  return store[name] || (store[name] =\r\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\r\n};\r\n\r\n$exports.store = store;\r\n\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports) {\r\n\r\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\r\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\r\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\r\n  // eslint-disable-next-line no-new-func\r\n  : Function('return this')();\r\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\r\n\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports) {\r\n\r\nvar core = module.exports = { version: '2.5.7' };\r\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\r\n\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports, __nested_webpack_require_5206__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_5206__(117);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractPlugin2.default;\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports, __nested_webpack_require_5638__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractEvent = __nested_webpack_require_5638__(118);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractEvent2.default;\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports, __nested_webpack_require_6066__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_6066__(113);\r\n\r\nObject.defineProperty(exports, 'closest', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_closest).default;\r\n  }\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_6066__(111);\r\n\r\nObject.defineProperty(exports, 'requestNextAnimationFrame', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_requestNextAnimationFrame).default;\r\n  }\r\n});\r\n\r\nvar _distance = __nested_webpack_require_6066__(109);\r\n\r\nObject.defineProperty(exports, 'distance', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_distance).default;\r\n  }\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_6066__(107);\r\n\r\nObject.defineProperty(exports, 'touchCoords', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_touchCoords).default;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports, __nested_webpack_require_7194__) {\r\n\r\nvar isObject = __nested_webpack_require_7194__(8);\r\nmodule.exports = function (it) {\r\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\r\n  return it;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports, __nested_webpack_require_7435__) {\r\n\r\n// to indexed object, toObject with fallback for non-array-like ES3 strings\r\nvar IObject = __nested_webpack_require_7435__(58);\r\nvar defined = __nested_webpack_require_7435__(35);\r\nmodule.exports = function (it) {\r\n  return IObject(defined(it));\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = function (it) {\r\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ (function(module, exports, __nested_webpack_require_7920__) {\r\n\r\nvar anObject = __nested_webpack_require_7920__(6);\r\nvar IE8_DOM_DEFINE = __nested_webpack_require_7920__(61);\r\nvar toPrimitive = __nested_webpack_require_7920__(37);\r\nvar dP = Object.defineProperty;\r\n\r\nexports.f = __nested_webpack_require_7920__(11) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\r\n  anObject(O);\r\n  P = toPrimitive(P, true);\r\n  anObject(Attributes);\r\n  if (IE8_DOM_DEFINE) try {\r\n    return dP(O, P, Attributes);\r\n  } catch (e) { /* empty */ }\r\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\r\n  if ('value' in Attributes) O[P] = Attributes.value;\r\n  return O;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ (function(module, exports, __nested_webpack_require_8609__) {\r\n\r\nvar dP = __nested_webpack_require_8609__(9);\r\nvar createDesc = __nested_webpack_require_8609__(28);\r\nmodule.exports = __nested_webpack_require_8609__(11) ? function (object, key, value) {\r\n  return dP.f(object, key, createDesc(1, value));\r\n} : function (object, key, value) {\r\n  object[key] = value;\r\n  return object;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ (function(module, exports, __nested_webpack_require_8980__) {\r\n\r\n// Thank's IE8 for his funny defineProperty\r\nmodule.exports = !__nested_webpack_require_8980__(23)(function () {\r\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\r\n});\r\n\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ (function(module, exports) {\r\n\r\nvar hasOwnProperty = {}.hasOwnProperty;\r\nmodule.exports = function (it, key) {\r\n  return hasOwnProperty.call(it, key);\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 13 */\r\n/***/ (function(module, exports, __nested_webpack_require_9443__) {\r\n\r\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\r\nvar $keys = __nested_webpack_require_9443__(59);\r\nvar enumBugKeys = __nested_webpack_require_9443__(32);\r\n\r\nmodule.exports = Object.keys || function keys(O) {\r\n  return $keys(O, enumBugKeys);\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 14 */\r\n/***/ (function(module, exports, __nested_webpack_require_9741__) {\r\n\r\nvar global = __nested_webpack_require_9741__(1);\r\nvar hide = __nested_webpack_require_9741__(10);\r\nvar has = __nested_webpack_require_9741__(12);\r\nvar SRC = __nested_webpack_require_9741__(22)('src');\r\nvar TO_STRING = 'toString';\r\nvar $toString = Function[TO_STRING];\r\nvar TPL = ('' + $toString).split(TO_STRING);\r\n\r\n__nested_webpack_require_9741__(2).inspectSource = function (it) {\r\n  return $toString.call(it);\r\n};\r\n\r\n(module.exports = function (O, key, val, safe) {\r\n  var isFunction = typeof val == 'function';\r\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\r\n  if (O[key] === val) return;\r\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\r\n  if (O === global) {\r\n    O[key] = val;\r\n  } else if (!safe) {\r\n    delete O[key];\r\n    hide(O, key, val);\r\n  } else if (O[key]) {\r\n    O[key] = val;\r\n  } else {\r\n    hide(O, key, val);\r\n  }\r\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\r\n})(Function.prototype, TO_STRING, function toString() {\r\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\r\n});\r\n\r\n\r\n/***/ }),\r\n/* 15 */\r\n/***/ (function(module, exports, __nested_webpack_require_10916__) {\r\n\r\nvar global = __nested_webpack_require_10916__(1);\r\nvar core = __nested_webpack_require_10916__(2);\r\nvar hide = __nested_webpack_require_10916__(10);\r\nvar redefine = __nested_webpack_require_10916__(14);\r\nvar ctx = __nested_webpack_require_10916__(27);\r\nvar PROTOTYPE = 'prototype';\r\n\r\nvar $export = function (type, name, source) {\r\n  var IS_FORCED = type & $export.F;\r\n  var IS_GLOBAL = type & $export.G;\r\n  var IS_STATIC = type & $export.S;\r\n  var IS_PROTO = type & $export.P;\r\n  var IS_BIND = type & $export.B;\r\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\r\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\r\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\r\n  var key, own, out, exp;\r\n  if (IS_GLOBAL) source = name;\r\n  for (key in source) {\r\n    // contains in native\r\n    own = !IS_FORCED && target && target[key] !== undefined;\r\n    // export native or passed\r\n    out = (own ? target : source)[key];\r\n    // bind timers to global for call from export context\r\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\r\n    // extend global\r\n    if (target) redefine(target, key, out, type & $export.U);\r\n    // export\r\n    if (exports[key] != out) hide(exports, key, exp);\r\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\r\n  }\r\n};\r\nglobal.core = core;\r\n// type bitmap\r\n$export.F = 1;   // forced\r\n$export.G = 2;   // global\r\n$export.S = 4;   // static\r\n$export.P = 8;   // proto\r\n$export.B = 16;  // bind\r\n$export.W = 32;  // wrap\r\n$export.U = 64;  // safe\r\n$export.R = 128; // real proto method for `library`\r\nmodule.exports = $export;\r\n\r\n\r\n/***/ }),\r\n/* 16 */\r\n/***/ (function(module, exports, __nested_webpack_require_12662__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SensorEvent = __nested_webpack_require_12662__(105);\r\n\r\nObject.keys(_SensorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SensorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 17 */\r\n/***/ (function(module, exports, __nested_webpack_require_13131__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_13131__(116);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Sensor2.default;\r\n\r\n/***/ }),\r\n/* 18 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = {};\r\n\r\n\r\n/***/ }),\r\n/* 19 */\r\n/***/ (function(module, exports) {\r\n\r\nexports.f = {}.propertyIsEnumerable;\r\n\r\n\r\n/***/ }),\r\n/* 20 */\r\n/***/ (function(module, exports) {\r\n\r\nvar toString = {}.toString;\r\n\r\nmodule.exports = function (it) {\r\n  return toString.call(it).slice(8, -1);\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 21 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = false;\r\n\r\n\r\n/***/ }),\r\n/* 22 */\r\n/***/ (function(module, exports) {\r\n\r\nvar id = 0;\r\nvar px = Math.random();\r\nmodule.exports = function (key) {\r\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 23 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = function (exec) {\r\n  try {\r\n    return !!exec();\r\n  } catch (e) {\r\n    return true;\r\n  }\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 24 */\r\n/***/ (function(module, exports, __nested_webpack_require_14384__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragEvent = __nested_webpack_require_14384__(44);\r\n\r\nObject.keys(_DragEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DragEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _DraggableEvent = __nested_webpack_require_14384__(43);\r\n\r\nObject.keys(_DraggableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DraggableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Plugins = __nested_webpack_require_14384__(42);\r\n\r\nObject.keys(_Plugins).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _Plugins[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Sensors = __nested_webpack_require_14384__(29);\r\n\r\nObject.keys(_Sensors).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _Sensors[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Draggable = __nested_webpack_require_14384__(73);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Draggable2.default;\r\n\r\n/***/ }),\r\n/* 25 */\r\n/***/ (function(module, exports, __nested_webpack_require_15971__) {\r\n\r\nvar def = __nested_webpack_require_15971__(9).f;\r\nvar has = __nested_webpack_require_15971__(12);\r\nvar TAG = __nested_webpack_require_15971__(0)('toStringTag');\r\n\r\nmodule.exports = function (it, tag, stat) {\r\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 26 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = function (it) {\r\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\r\n  return it;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 27 */\r\n/***/ (function(module, exports, __nested_webpack_require_16526__) {\r\n\r\n// optional / simple context binding\r\nvar aFunction = __nested_webpack_require_16526__(26);\r\nmodule.exports = function (fn, that, length) {\r\n  aFunction(fn);\r\n  if (that === undefined) return fn;\r\n  switch (length) {\r\n    case 1: return function (a) {\r\n      return fn.call(that, a);\r\n    };\r\n    case 2: return function (a, b) {\r\n      return fn.call(that, a, b);\r\n    };\r\n    case 3: return function (a, b, c) {\r\n      return fn.call(that, a, b, c);\r\n    };\r\n  }\r\n  return function (/* ...args */) {\r\n    return fn.apply(that, arguments);\r\n  };\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 28 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = function (bitmap, value) {\r\n  return {\r\n    enumerable: !(bitmap & 1),\r\n    configurable: !(bitmap & 2),\r\n    writable: !(bitmap & 4),\r\n    value: value\r\n  };\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 29 */\r\n/***/ (function(module, exports, __nested_webpack_require_17393__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_17393__(17);\r\n\r\nObject.defineProperty(exports, 'Sensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Sensor).default;\r\n  }\r\n});\r\n\r\nvar _MouseSensor = __nested_webpack_require_17393__(115);\r\n\r\nObject.defineProperty(exports, 'MouseSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_MouseSensor).default;\r\n  }\r\n});\r\n\r\nvar _TouchSensor = __nested_webpack_require_17393__(104);\r\n\r\nObject.defineProperty(exports, 'TouchSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_TouchSensor).default;\r\n  }\r\n});\r\n\r\nvar _DragSensor = __nested_webpack_require_17393__(102);\r\n\r\nObject.defineProperty(exports, 'DragSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_DragSensor).default;\r\n  }\r\n});\r\n\r\nvar _ForceTouchSensor = __nested_webpack_require_17393__(100);\r\n\r\nObject.defineProperty(exports, 'ForceTouchSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_ForceTouchSensor).default;\r\n  }\r\n});\r\n\r\nvar _SensorEvent = __nested_webpack_require_17393__(16);\r\n\r\nObject.keys(_SensorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SensorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 30 */\r\n/***/ (function(module, exports, __nested_webpack_require_19006__) {\r\n\r\n// getting tag from 19.1.3.6 Object.prototype.toString()\r\nvar cof = __nested_webpack_require_19006__(20);\r\nvar TAG = __nested_webpack_require_19006__(0)('toStringTag');\r\n// ES3 wrong here\r\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\r\n\r\n// fallback for IE11 Script Access Denied error\r\nvar tryGet = function (it, key) {\r\n  try {\r\n    return it[key];\r\n  } catch (e) { /* empty */ }\r\n};\r\n\r\nmodule.exports = function (it) {\r\n  var O, T, B;\r\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\r\n    // @@toStringTag case\r\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\r\n    // builtinTag case\r\n    : ARG ? cof(O)\r\n    // ES3 arguments fallback\r\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 31 */\r\n/***/ (function(module, exports) {\r\n\r\nexports.f = Object.getOwnPropertySymbols;\r\n\r\n\r\n/***/ }),\r\n/* 32 */\r\n/***/ (function(module, exports) {\r\n\r\n// IE 8- don't enum bug keys\r\nmodule.exports = (\r\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\r\n).split(',');\r\n\r\n\r\n/***/ }),\r\n/* 33 */\r\n/***/ (function(module, exports, __nested_webpack_require_20175__) {\r\n\r\nvar shared = __nested_webpack_require_20175__(36)('keys');\r\nvar uid = __nested_webpack_require_20175__(22);\r\nmodule.exports = function (key) {\r\n  return shared[key] || (shared[key] = uid(key));\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 34 */\r\n/***/ (function(module, exports) {\r\n\r\n// 7.1.4 ToInteger\r\nvar ceil = Math.ceil;\r\nvar floor = Math.floor;\r\nmodule.exports = function (it) {\r\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 35 */\r\n/***/ (function(module, exports) {\r\n\r\n// 7.2.1 RequireObjectCoercible(argument)\r\nmodule.exports = function (it) {\r\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\r\n  return it;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 36 */\r\n/***/ (function(module, exports, __nested_webpack_require_20892__) {\r\n\r\nvar core = __nested_webpack_require_20892__(2);\r\nvar global = __nested_webpack_require_20892__(1);\r\nvar SHARED = '__core-js_shared__';\r\nvar store = global[SHARED] || (global[SHARED] = {});\r\n\r\n(module.exports = function (key, value) {\r\n  return store[key] || (store[key] = value !== undefined ? value : {});\r\n})('versions', []).push({\r\n  version: core.version,\r\n  mode: __nested_webpack_require_20892__(21) ? 'pure' : 'global',\r\n  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'\r\n});\r\n\r\n\r\n/***/ }),\r\n/* 37 */\r\n/***/ (function(module, exports, __nested_webpack_require_21423__) {\r\n\r\n// 7.1.1 ToPrimitive(input [, PreferredType])\r\nvar isObject = __nested_webpack_require_21423__(8);\r\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\r\n// and the second argument - flag - preferred type is a string\r\nmodule.exports = function (it, S) {\r\n  if (!isObject(it)) return it;\r\n  var fn, val;\r\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\r\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\r\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\r\n  throw TypeError(\"Can't convert object to primitive value\");\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 38 */\r\n/***/ (function(module, exports, __nested_webpack_require_22173__) {\r\n\r\nvar isObject = __nested_webpack_require_22173__(8);\r\nvar document = __nested_webpack_require_22173__(1).document;\r\n// typeof document.createElement is 'object' in old IE\r\nvar is = isObject(document) && isObject(document.createElement);\r\nmodule.exports = function (it) {\r\n  return is ? document.createElement(it) : {};\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 39 */\r\n/***/ (function(module, exports, __nested_webpack_require_22554__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SortableEvent = __nested_webpack_require_22554__(63);\r\n\r\nObject.keys(_SortableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SortableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 40 */\r\n/***/ (function(module, exports, __nested_webpack_require_23028__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SwappableEvent = __nested_webpack_require_23028__(66);\r\n\r\nObject.keys(_SwappableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SwappableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 41 */\r\n/***/ (function(module, exports, __nested_webpack_require_23505__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DroppableEvent = __nested_webpack_require_23505__(69);\r\n\r\nObject.keys(_DroppableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DroppableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 42 */\r\n/***/ (function(module, exports, __nested_webpack_require_23982__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Announcement = __nested_webpack_require_23982__(83);\r\n\r\nObject.defineProperty(exports, 'Announcement', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Announcement).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultAnnouncementOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Announcement.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Focusable = __nested_webpack_require_23982__(81);\r\n\r\nObject.defineProperty(exports, 'Focusable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Focusable).default;\r\n  }\r\n});\r\n\r\nvar _Mirror = __nested_webpack_require_23982__(79);\r\n\r\nObject.defineProperty(exports, 'Mirror', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Mirror).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultMirrorOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Mirror.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Scrollable = __nested_webpack_require_23982__(75);\r\n\r\nObject.defineProperty(exports, 'Scrollable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Scrollable).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultScrollableOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Scrollable.defaultOptions;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 43 */\r\n/***/ (function(module, exports, __nested_webpack_require_25526__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DraggableEvent = __nested_webpack_require_25526__(84);\r\n\r\nObject.keys(_DraggableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DraggableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 44 */\r\n/***/ (function(module, exports, __nested_webpack_require_26003__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragEvent = __nested_webpack_require_26003__(85);\r\n\r\nObject.keys(_DragEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DragEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 45 */\r\n/***/ (function(module, exports, __nested_webpack_require_26465__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SnappableEvent = __nested_webpack_require_26465__(91);\r\n\r\nObject.keys(_SnappableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SnappableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 46 */\r\n/***/ (function(module, exports, __nested_webpack_require_26942__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _CollidableEvent = __nested_webpack_require_26942__(96);\r\n\r\nObject.keys(_CollidableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _CollidableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 47 */\r\n/***/ (function(module, exports, __nested_webpack_require_27422__) {\r\n\r\n\"use strict\";\r\n\r\n// 25.4.1.5 NewPromiseCapability(C)\r\nvar aFunction = __nested_webpack_require_27422__(26);\r\n\r\nfunction PromiseCapability(C) {\r\n  var resolve, reject;\r\n  this.promise = new C(function ($$resolve, $$reject) {\r\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\r\n    resolve = $$resolve;\r\n    reject = $$reject;\r\n  });\r\n  this.resolve = aFunction(resolve);\r\n  this.reject = aFunction(reject);\r\n}\r\n\r\nmodule.exports.f = function (C) {\r\n  return new PromiseCapability(C);\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 48 */\r\n/***/ (function(module, exports, __nested_webpack_require_28029__) {\r\n\r\nvar ctx = __nested_webpack_require_28029__(27);\r\nvar invoke = __nested_webpack_require_28029__(134);\r\nvar html = __nested_webpack_require_28029__(54);\r\nvar cel = __nested_webpack_require_28029__(38);\r\nvar global = __nested_webpack_require_28029__(1);\r\nvar process = global.process;\r\nvar setTask = global.setImmediate;\r\nvar clearTask = global.clearImmediate;\r\nvar MessageChannel = global.MessageChannel;\r\nvar Dispatch = global.Dispatch;\r\nvar counter = 0;\r\nvar queue = {};\r\nvar ONREADYSTATECHANGE = 'onreadystatechange';\r\nvar defer, channel, port;\r\nvar run = function () {\r\n  var id = +this;\r\n  // eslint-disable-next-line no-prototype-builtins\r\n  if (queue.hasOwnProperty(id)) {\r\n    var fn = queue[id];\r\n    delete queue[id];\r\n    fn();\r\n  }\r\n};\r\nvar listener = function (event) {\r\n  run.call(event.data);\r\n};\r\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\r\nif (!setTask || !clearTask) {\r\n  setTask = function setImmediate(fn) {\r\n    var args = [];\r\n    var i = 1;\r\n    while (arguments.length > i) args.push(arguments[i++]);\r\n    queue[++counter] = function () {\r\n      // eslint-disable-next-line no-new-func\r\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\r\n    };\r\n    defer(counter);\r\n    return counter;\r\n  };\r\n  clearTask = function clearImmediate(id) {\r\n    delete queue[id];\r\n  };\r\n  // Node.js 0.8-\r\n  if (__nested_webpack_require_28029__(20)(process) == 'process') {\r\n    defer = function (id) {\r\n      process.nextTick(ctx(run, id, 1));\r\n    };\r\n  // Sphere (JS game engine) Dispatch API\r\n  } else if (Dispatch && Dispatch.now) {\r\n    defer = function (id) {\r\n      Dispatch.now(ctx(run, id, 1));\r\n    };\r\n  // Browsers with MessageChannel, includes WebWorkers\r\n  } else if (MessageChannel) {\r\n    channel = new MessageChannel();\r\n    port = channel.port2;\r\n    channel.port1.onmessage = listener;\r\n    defer = ctx(port.postMessage, port, 1);\r\n  // Browsers with postMessage, skip WebWorkers\r\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\r\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\r\n    defer = function (id) {\r\n      global.postMessage(id + '', '*');\r\n    };\r\n    global.addEventListener('message', listener, false);\r\n  // IE8-\r\n  } else if (ONREADYSTATECHANGE in cel('script')) {\r\n    defer = function (id) {\r\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\r\n        html.removeChild(this);\r\n        run.call(id);\r\n      };\r\n    };\r\n  // Rest old browsers\r\n  } else {\r\n    defer = function (id) {\r\n      setTimeout(ctx(run, id, 1), 0);\r\n    };\r\n  }\r\n}\r\nmodule.exports = {\r\n  set: setTask,\r\n  clear: clearTask\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 49 */\r\n/***/ (function(module, exports, __nested_webpack_require_30703__) {\r\n\r\n// 22.1.3.31 Array.prototype[@@unscopables]\r\nvar UNSCOPABLES = __nested_webpack_require_30703__(0)('unscopables');\r\nvar ArrayProto = Array.prototype;\r\nif (ArrayProto[UNSCOPABLES] == undefined) __nested_webpack_require_30703__(10)(ArrayProto, UNSCOPABLES, {});\r\nmodule.exports = function (key) {\r\n  ArrayProto[UNSCOPABLES][key] = true;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 50 */\r\n/***/ (function(module, exports, __nested_webpack_require_31101__) {\r\n\r\n// 7.1.13 ToObject(argument)\r\nvar defined = __nested_webpack_require_31101__(35);\r\nmodule.exports = function (it) {\r\n  return Object(defined(it));\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 51 */\r\n/***/ (function(module, exports, __nested_webpack_require_31324__) {\r\n\r\n\"use strict\";\r\n\r\nvar LIBRARY = __nested_webpack_require_31324__(21);\r\nvar $export = __nested_webpack_require_31324__(15);\r\nvar redefine = __nested_webpack_require_31324__(14);\r\nvar hide = __nested_webpack_require_31324__(10);\r\nvar Iterators = __nested_webpack_require_31324__(18);\r\nvar $iterCreate = __nested_webpack_require_31324__(146);\r\nvar setToStringTag = __nested_webpack_require_31324__(25);\r\nvar getPrototypeOf = __nested_webpack_require_31324__(145);\r\nvar ITERATOR = __nested_webpack_require_31324__(0)('iterator');\r\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\r\nvar FF_ITERATOR = '@@iterator';\r\nvar KEYS = 'keys';\r\nvar VALUES = 'values';\r\n\r\nvar returnThis = function () { return this; };\r\n\r\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\r\n  $iterCreate(Constructor, NAME, next);\r\n  var getMethod = function (kind) {\r\n    if (!BUGGY && kind in proto) return proto[kind];\r\n    switch (kind) {\r\n      case KEYS: return function keys() { return new Constructor(this, kind); };\r\n      case VALUES: return function values() { return new Constructor(this, kind); };\r\n    } return function entries() { return new Constructor(this, kind); };\r\n  };\r\n  var TAG = NAME + ' Iterator';\r\n  var DEF_VALUES = DEFAULT == VALUES;\r\n  var VALUES_BUG = false;\r\n  var proto = Base.prototype;\r\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\r\n  var $default = $native || getMethod(DEFAULT);\r\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\r\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\r\n  var methods, key, IteratorPrototype;\r\n  // Fix native\r\n  if ($anyNative) {\r\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\r\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\r\n      // Set @@toStringTag to native iterators\r\n      setToStringTag(IteratorPrototype, TAG, true);\r\n      // fix for some old engines\r\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\r\n    }\r\n  }\r\n  // fix Array#{values, @@iterator}.name in V8 / FF\r\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\r\n    VALUES_BUG = true;\r\n    $default = function values() { return $native.call(this); };\r\n  }\r\n  // Define iterator\r\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\r\n    hide(proto, ITERATOR, $default);\r\n  }\r\n  // Plug for library\r\n  Iterators[NAME] = $default;\r\n  Iterators[TAG] = returnThis;\r\n  if (DEFAULT) {\r\n    methods = {\r\n      values: DEF_VALUES ? $default : getMethod(VALUES),\r\n      keys: IS_SET ? $default : getMethod(KEYS),\r\n      entries: $entries\r\n    };\r\n    if (FORCED) for (key in methods) {\r\n      if (!(key in proto)) redefine(proto, key, methods[key]);\r\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\r\n  }\r\n  return methods;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 52 */\r\n/***/ (function(module, exports, __nested_webpack_require_34265__) {\r\n\r\n\"use strict\";\r\n\r\n// 19.1.3.6 Object.prototype.toString()\r\nvar classof = __nested_webpack_require_34265__(30);\r\nvar test = {};\r\ntest[__nested_webpack_require_34265__(0)('toStringTag')] = 'z';\r\nif (test + '' != '[object z]') {\r\n  __nested_webpack_require_34265__(14)(Object.prototype, 'toString', function toString() {\r\n    return '[object ' + classof(this) + ']';\r\n  }, true);\r\n}\r\n\r\n\r\n/***/ }),\r\n/* 53 */\r\n/***/ (function(module, exports, __nested_webpack_require_34690__) {\r\n\r\n// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\r\nvar $keys = __nested_webpack_require_34690__(59);\r\nvar hiddenKeys = __nested_webpack_require_34690__(32).concat('length', 'prototype');\r\n\r\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\r\n  return $keys(O, hiddenKeys);\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 54 */\r\n/***/ (function(module, exports, __nested_webpack_require_35054__) {\r\n\r\nvar document = __nested_webpack_require_35054__(1).document;\r\nmodule.exports = document && document.documentElement;\r\n\r\n\r\n/***/ }),\r\n/* 55 */\r\n/***/ (function(module, exports, __nested_webpack_require_35243__) {\r\n\r\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\r\nvar anObject = __nested_webpack_require_35243__(6);\r\nvar dPs = __nested_webpack_require_35243__(152);\r\nvar enumBugKeys = __nested_webpack_require_35243__(32);\r\nvar IE_PROTO = __nested_webpack_require_35243__(33)('IE_PROTO');\r\nvar Empty = function () { /* empty */ };\r\nvar PROTOTYPE = 'prototype';\r\n\r\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\r\nvar createDict = function () {\r\n  // Thrash, waste and sodomy: IE GC bug\r\n  var iframe = __nested_webpack_require_35243__(38)('iframe');\r\n  var i = enumBugKeys.length;\r\n  var lt = '<';\r\n  var gt = '>';\r\n  var iframeDocument;\r\n  iframe.style.display = 'none';\r\n  __nested_webpack_require_35243__(54).appendChild(iframe);\r\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\r\n  // createDict = iframe.contentWindow.Object;\r\n  // html.removeChild(iframe);\r\n  iframeDocument = iframe.contentWindow.document;\r\n  iframeDocument.open();\r\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\r\n  iframeDocument.close();\r\n  createDict = iframeDocument.F;\r\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\r\n  return createDict();\r\n};\r\n\r\nmodule.exports = Object.create || function create(O, Properties) {\r\n  var result;\r\n  if (O !== null) {\r\n    Empty[PROTOTYPE] = anObject(O);\r\n    result = new Empty();\r\n    Empty[PROTOTYPE] = null;\r\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\r\n    result[IE_PROTO] = O;\r\n  } else result = createDict();\r\n  return Properties === undefined ? result : dPs(result, Properties);\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 56 */\r\n/***/ (function(module, exports, __nested_webpack_require_36871__) {\r\n\r\n// 7.1.15 ToLength\r\nvar toInteger = __nested_webpack_require_36871__(34);\r\nvar min = Math.min;\r\nmodule.exports = function (it) {\r\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 57 */\r\n/***/ (function(module, exports, __nested_webpack_require_37175__) {\r\n\r\n// false -> Array#indexOf\r\n// true  -> Array#includes\r\nvar toIObject = __nested_webpack_require_37175__(7);\r\nvar toLength = __nested_webpack_require_37175__(56);\r\nvar toAbsoluteIndex = __nested_webpack_require_37175__(154);\r\nmodule.exports = function (IS_INCLUDES) {\r\n  return function ($this, el, fromIndex) {\r\n    var O = toIObject($this);\r\n    var length = toLength(O.length);\r\n    var index = toAbsoluteIndex(fromIndex, length);\r\n    var value;\r\n    // Array#includes uses SameValueZero equality algorithm\r\n    // eslint-disable-next-line no-self-compare\r\n    if (IS_INCLUDES && el != el) while (length > index) {\r\n      value = O[index++];\r\n      // eslint-disable-next-line no-self-compare\r\n      if (value != value) return true;\r\n    // Array#indexOf ignores holes, Array#includes - not\r\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\r\n      if (O[index] === el) return IS_INCLUDES || index || 0;\r\n    } return !IS_INCLUDES && -1;\r\n  };\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 58 */\r\n/***/ (function(module, exports, __nested_webpack_require_38197__) {\r\n\r\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\r\nvar cof = __nested_webpack_require_38197__(20);\r\n// eslint-disable-next-line no-prototype-builtins\r\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\r\n  return cof(it) == 'String' ? it.split('') : Object(it);\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 59 */\r\n/***/ (function(module, exports, __nested_webpack_require_38582__) {\r\n\r\nvar has = __nested_webpack_require_38582__(12);\r\nvar toIObject = __nested_webpack_require_38582__(7);\r\nvar arrayIndexOf = __nested_webpack_require_38582__(57)(false);\r\nvar IE_PROTO = __nested_webpack_require_38582__(33)('IE_PROTO');\r\n\r\nmodule.exports = function (object, names) {\r\n  var O = toIObject(object);\r\n  var i = 0;\r\n  var result = [];\r\n  var key;\r\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\r\n  // Don't enum bug & hidden keys\r\n  while (names.length > i) if (has(O, key = names[i++])) {\r\n    ~arrayIndexOf(result, key) || result.push(key);\r\n  }\r\n  return result;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 60 */\r\n/***/ (function(module, exports, __nested_webpack_require_39218__) {\r\n\r\nexports.f = __nested_webpack_require_39218__(0);\r\n\r\n\r\n/***/ }),\r\n/* 61 */\r\n/***/ (function(module, exports, __nested_webpack_require_39339__) {\r\n\r\nmodule.exports = !__nested_webpack_require_39339__(11) && !__nested_webpack_require_39339__(23)(function () {\r\n  return Object.defineProperty(__nested_webpack_require_39339__(38)('div'), 'a', { get: function () { return 7; } }).a != 7;\r\n});\r\n\r\n\r\n/***/ }),\r\n/* 62 */\r\n/***/ (function(module, exports, __nested_webpack_require_39626__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _Draggable = __nested_webpack_require_39626__(24);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nvar _SortableEvent = __nested_webpack_require_39626__(39);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragOverContainer = Symbol('onDragOverContainer');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragStop = Symbol('onDragStop');\r\n\r\n/**\r\n * Returns announcement message when a Draggable element has been sorted with another Draggable element\r\n * or moved into a new container\r\n * @param {SortableSortedEvent} sortableEvent\r\n * @return {String}\r\n */\r\nfunction onSortableSortedDefaultAnnouncement({ dragEvent }) {\r\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'sortable element';\r\n\r\n  if (dragEvent.over) {\r\n    const overText = dragEvent.over.textContent.trim() || dragEvent.over.id || 'sortable element';\r\n    const isFollowing = dragEvent.source.compareDocumentPosition(dragEvent.over) & Node.DOCUMENT_POSITION_FOLLOWING;\r\n\r\n    if (isFollowing) {\r\n      return `Placed ${sourceText} after ${overText}`;\r\n    } else {\r\n      return `Placed ${sourceText} before ${overText}`;\r\n    }\r\n  } else {\r\n    // need to figure out how to compute container name\r\n    return `Placed ${sourceText} into a different container`;\r\n  }\r\n}\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['sortable:sorted']\r\n */\r\nconst defaultAnnouncements = {\r\n  'sortable:sorted': onSortableSortedDefaultAnnouncement\r\n};\r\n\r\n/**\r\n * Sortable is built on top of Draggable and allows sorting of draggable elements. Sortable will keep\r\n * track of the original index and emits the new index as you drag over draggable elements.\r\n * @class Sortable\r\n * @module Sortable\r\n * @extends Draggable\r\n */\r\nclass Sortable extends _Draggable2.default {\r\n  /**\r\n   * Sortable constructor.\r\n   * @constructs Sortable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Sortable containers\r\n   * @param {Object} options - Options for Sortable\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, _extends({}, options, {\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {})\r\n    }));\r\n\r\n    /**\r\n     * start index of source on drag start\r\n     * @property startIndex\r\n     * @type {Number}\r\n     */\r\n    this.startIndex = null;\r\n\r\n    /**\r\n     * start container on drag start\r\n     * @property startContainer\r\n     * @type {HTMLElement}\r\n     * @default null\r\n     */\r\n    this.startContainer = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragOverContainer] = this[onDragOverContainer].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n\r\n    this.on('drag:start', this[onDragStart]).on('drag:over:container', this[onDragOverContainer]).on('drag:over', this[onDragOver]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Destroys Sortable instance.\r\n   */\r\n  destroy() {\r\n    super.destroy();\r\n\r\n    this.off('drag:start', this[onDragStart]).off('drag:over:container', this[onDragOverContainer]).off('drag:over', this[onDragOver]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Returns true index of element within its container during drag operation, i.e. excluding mirror and original source\r\n   * @param {HTMLElement} element - An element\r\n   * @return {Number}\r\n   */\r\n  index(element) {\r\n    return this.getSortableElementsForContainer(element.parentNode).indexOf(element);\r\n  }\r\n\r\n  /**\r\n   * Returns sortable elements for a given container, excluding the mirror and\r\n   * original source element if present\r\n   * @param {HTMLElement} container\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getSortableElementsForContainer(container) {\r\n    const allSortableElements = container.querySelectorAll(this.options.draggable);\r\n\r\n    return [...allSortableElements].filter(childElement => {\r\n      return childElement !== this.originalSource && childElement !== this.mirror && childElement.parentNode === container;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {DragStartEvent} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    this.startContainer = event.source.parentNode;\r\n    this.startIndex = this.index(event.source);\r\n\r\n    const sortableStartEvent = new _SortableEvent.SortableStartEvent({\r\n      dragEvent: event,\r\n      startIndex: this.startIndex,\r\n      startContainer: this.startContainer\r\n    });\r\n\r\n    this.trigger(sortableStartEvent);\r\n\r\n    if (sortableStartEvent.canceled()) {\r\n      event.cancel();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag over container handler\r\n   * @private\r\n   * @param {DragOverContainerEvent} event - Drag over container event\r\n   */\r\n  [onDragOverContainer](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const { source, over, overContainer } = event;\r\n    const oldIndex = this.index(source);\r\n\r\n    const sortableSortEvent = new _SortableEvent.SortableSortEvent({\r\n      dragEvent: event,\r\n      currentIndex: oldIndex,\r\n      source,\r\n      over\r\n    });\r\n\r\n    this.trigger(sortableSortEvent);\r\n\r\n    if (sortableSortEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const children = this.getSortableElementsForContainer(overContainer);\r\n    const moves = move({ source, over, overContainer, children });\r\n\r\n    if (!moves) {\r\n      return;\r\n    }\r\n\r\n    const { oldContainer, newContainer } = moves;\r\n    const newIndex = this.index(event.source);\r\n\r\n    const sortableSortedEvent = new _SortableEvent.SortableSortedEvent({\r\n      dragEvent: event,\r\n      oldIndex,\r\n      newIndex,\r\n      oldContainer,\r\n      newContainer\r\n    });\r\n\r\n    this.trigger(sortableSortedEvent);\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {DragOverEvent} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (event.over === event.originalSource || event.over === event.source) {\r\n      return;\r\n    }\r\n\r\n    const { source, over, overContainer } = event;\r\n    const oldIndex = this.index(source);\r\n\r\n    const sortableSortEvent = new _SortableEvent.SortableSortEvent({\r\n      dragEvent: event,\r\n      currentIndex: oldIndex,\r\n      source,\r\n      over\r\n    });\r\n\r\n    this.trigger(sortableSortEvent);\r\n\r\n    if (sortableSortEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const children = this.getDraggableElementsForContainer(overContainer);\r\n    const moves = move({ source, over, overContainer, children });\r\n\r\n    if (!moves) {\r\n      return;\r\n    }\r\n\r\n    const { oldContainer, newContainer } = moves;\r\n    const newIndex = this.index(source);\r\n\r\n    const sortableSortedEvent = new _SortableEvent.SortableSortedEvent({\r\n      dragEvent: event,\r\n      oldIndex,\r\n      newIndex,\r\n      oldContainer,\r\n      newContainer\r\n    });\r\n\r\n    this.trigger(sortableSortedEvent);\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop](event) {\r\n    const sortableStopEvent = new _SortableEvent.SortableStopEvent({\r\n      dragEvent: event,\r\n      oldIndex: this.startIndex,\r\n      newIndex: this.index(event.source),\r\n      oldContainer: this.startContainer,\r\n      newContainer: event.source.parentNode\r\n    });\r\n\r\n    this.trigger(sortableStopEvent);\r\n\r\n    this.startIndex = null;\r\n    this.startContainer = null;\r\n  }\r\n}\r\n\r\nexports.default = Sortable;\r\nfunction index(element) {\r\n  return Array.prototype.indexOf.call(element.parentNode.children, element);\r\n}\r\n\r\nfunction move({ source, over, overContainer, children }) {\r\n  const emptyOverContainer = !children.length;\r\n  const differentContainer = source.parentNode !== overContainer;\r\n  const sameContainer = over && source.parentNode === over.parentNode;\r\n\r\n  if (emptyOverContainer) {\r\n    return moveInsideEmptyContainer(source, overContainer);\r\n  } else if (sameContainer) {\r\n    return moveWithinContainer(source, over);\r\n  } else if (differentContainer) {\r\n    return moveOutsideContainer(source, over, overContainer);\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\nfunction moveInsideEmptyContainer(source, overContainer) {\r\n  const oldContainer = source.parentNode;\r\n\r\n  overContainer.appendChild(source);\r\n\r\n  return { oldContainer, newContainer: overContainer };\r\n}\r\n\r\nfunction moveWithinContainer(source, over) {\r\n  const oldIndex = index(source);\r\n  const newIndex = index(over);\r\n\r\n  if (oldIndex < newIndex) {\r\n    source.parentNode.insertBefore(source, over.nextElementSibling);\r\n  } else {\r\n    source.parentNode.insertBefore(source, over);\r\n  }\r\n\r\n  return { oldContainer: source.parentNode, newContainer: source.parentNode };\r\n}\r\n\r\nfunction moveOutsideContainer(source, over, overContainer) {\r\n  const oldContainer = source.parentNode;\r\n\r\n  if (over) {\r\n    over.parentNode.insertBefore(source, over);\r\n  } else {\r\n    // need to figure out proper position\r\n    overContainer.appendChild(source);\r\n  }\r\n\r\n  return { oldContainer, newContainer: source.parentNode };\r\n}\r\n\r\n/***/ }),\r\n/* 63 */\r\n/***/ (function(module, exports, __nested_webpack_require_49098__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.SortableStopEvent = exports.SortableSortedEvent = exports.SortableSortEvent = exports.SortableStartEvent = exports.SortableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_49098__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base sortable event\r\n * @class SortableEvent\r\n * @module SortableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SortableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Original drag event that triggered this sortable event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n}\r\n\r\nexports.SortableEvent = SortableEvent; /**\r\n                                        * Sortable start event\r\n                                        * @class SortableStartEvent\r\n                                        * @module SortableStartEvent\r\n                                        * @extends SortableEvent\r\n                                        */\r\n\r\nSortableEvent.type = 'sortable';\r\nclass SortableStartEvent extends SortableEvent {\r\n\r\n  /**\r\n   * Start index of source on sortable start\r\n   * @property startIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get startIndex() {\r\n    return this.data.startIndex;\r\n  }\r\n\r\n  /**\r\n   * Start container on sortable start\r\n   * @property startContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get startContainer() {\r\n    return this.data.startContainer;\r\n  }\r\n}\r\n\r\nexports.SortableStartEvent = SortableStartEvent; /**\r\n                                                  * Sortable sort event\r\n                                                  * @class SortableSortEvent\r\n                                                  * @module SortableSortEvent\r\n                                                  * @extends SortableEvent\r\n                                                  */\r\n\r\nSortableStartEvent.type = 'sortable:start';\r\nSortableStartEvent.cancelable = true;\r\nclass SortableSortEvent extends SortableEvent {\r\n\r\n  /**\r\n   * Index of current draggable element\r\n   * @property currentIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get currentIndex() {\r\n    return this.data.currentIndex;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you are hovering over\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n\r\n  /**\r\n   * Draggable container element you are hovering over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.dragEvent.overContainer;\r\n  }\r\n}\r\n\r\nexports.SortableSortEvent = SortableSortEvent; /**\r\n                                                * Sortable sorted event\r\n                                                * @class SortableSortedEvent\r\n                                                * @module SortableSortedEvent\r\n                                                * @extends SortableEvent\r\n                                                */\r\n\r\nSortableSortEvent.type = 'sortable:sort';\r\nSortableSortEvent.cancelable = true;\r\nclass SortableSortedEvent extends SortableEvent {\r\n\r\n  /**\r\n   * Index of last sorted event\r\n   * @property oldIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get oldIndex() {\r\n    return this.data.oldIndex;\r\n  }\r\n\r\n  /**\r\n   * New index of this sorted event\r\n   * @property newIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get newIndex() {\r\n    return this.data.newIndex;\r\n  }\r\n\r\n  /**\r\n   * Old container of draggable element\r\n   * @property oldContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get oldContainer() {\r\n    return this.data.oldContainer;\r\n  }\r\n\r\n  /**\r\n   * New container of draggable element\r\n   * @property newContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get newContainer() {\r\n    return this.data.newContainer;\r\n  }\r\n}\r\n\r\nexports.SortableSortedEvent = SortableSortedEvent; /**\r\n                                                    * Sortable stop event\r\n                                                    * @class SortableStopEvent\r\n                                                    * @module SortableStopEvent\r\n                                                    * @extends SortableEvent\r\n                                                    */\r\n\r\nSortableSortedEvent.type = 'sortable:sorted';\r\nclass SortableStopEvent extends SortableEvent {\r\n\r\n  /**\r\n   * Original index on sortable start\r\n   * @property oldIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get oldIndex() {\r\n    return this.data.oldIndex;\r\n  }\r\n\r\n  /**\r\n   * New index of draggable element\r\n   * @property newIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get newIndex() {\r\n    return this.data.newIndex;\r\n  }\r\n\r\n  /**\r\n   * Original container of draggable element\r\n   * @property oldContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get oldContainer() {\r\n    return this.data.oldContainer;\r\n  }\r\n\r\n  /**\r\n   * New container of draggable element\r\n   * @property newContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get newContainer() {\r\n    return this.data.newContainer;\r\n  }\r\n}\r\nexports.SortableStopEvent = SortableStopEvent;\r\nSortableStopEvent.type = 'sortable:stop';\r\n\r\n/***/ }),\r\n/* 64 */\r\n/***/ (function(module, exports, __nested_webpack_require_54604__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SortableEvent = __nested_webpack_require_54604__(39);\r\n\r\nObject.keys(_SortableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SortableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Sortable = __nested_webpack_require_54604__(62);\r\n\r\nvar _Sortable2 = _interopRequireDefault(_Sortable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Sortable2.default;\r\n\r\n/***/ }),\r\n/* 65 */\r\n/***/ (function(module, exports, __nested_webpack_require_55317__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _Draggable = __nested_webpack_require_55317__(24);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nvar _SwappableEvent = __nested_webpack_require_55317__(40);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragStop = Symbol('onDragStop');\r\n\r\n/**\r\n * Returns an announcement message when the Draggable element is swapped with another draggable element\r\n * @param {SwappableSwappedEvent} swappableEvent\r\n * @return {String}\r\n */\r\nfunction onSwappableSwappedDefaultAnnouncement({ dragEvent, swappedElement }) {\r\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'swappable element';\r\n  const overText = swappedElement.textContent.trim() || swappedElement.id || 'swappable element';\r\n\r\n  return `Swapped ${sourceText} with ${overText}`;\r\n}\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['swappabled:swapped']\r\n */\r\nconst defaultAnnouncements = {\r\n  'swappabled:swapped': onSwappableSwappedDefaultAnnouncement\r\n};\r\n\r\n/**\r\n * Swappable is built on top of Draggable and allows swapping of draggable elements.\r\n * Order is irrelevant to Swappable.\r\n * @class Swappable\r\n * @module Swappable\r\n * @extends Draggable\r\n */\r\nclass Swappable extends _Draggable2.default {\r\n  /**\r\n   * Swappable constructor.\r\n   * @constructs Swappable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Swappable containers\r\n   * @param {Object} options - Options for Swappable\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, _extends({}, options, {\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {})\r\n    }));\r\n\r\n    /**\r\n     * Last draggable element that was dragged over\r\n     * @property lastOver\r\n     * @type {HTMLElement}\r\n     */\r\n    this.lastOver = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n\r\n    this.on('drag:start', this[onDragStart]).on('drag:over', this[onDragOver]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Destroys Swappable instance.\r\n   */\r\n  destroy() {\r\n    super.destroy();\r\n\r\n    this.off('drag:start', this._onDragStart).off('drag:over', this._onDragOver).off('drag:stop', this._onDragStop);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {DragStartEvent} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    const swappableStartEvent = new _SwappableEvent.SwappableStartEvent({\r\n      dragEvent: event\r\n    });\r\n\r\n    this.trigger(swappableStartEvent);\r\n\r\n    if (swappableStartEvent.canceled()) {\r\n      event.cancel();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {DragOverEvent} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (event.over === event.originalSource || event.over === event.source || event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const swappableSwapEvent = new _SwappableEvent.SwappableSwapEvent({\r\n      dragEvent: event,\r\n      over: event.over,\r\n      overContainer: event.overContainer\r\n    });\r\n\r\n    this.trigger(swappableSwapEvent);\r\n\r\n    if (swappableSwapEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    // swap originally swapped element back\r\n    if (this.lastOver && this.lastOver !== event.over) {\r\n      swap(this.lastOver, event.source);\r\n    }\r\n\r\n    if (this.lastOver === event.over) {\r\n      this.lastOver = null;\r\n    } else {\r\n      this.lastOver = event.over;\r\n    }\r\n\r\n    swap(event.source, event.over);\r\n\r\n    const swappableSwappedEvent = new _SwappableEvent.SwappableSwappedEvent({\r\n      dragEvent: event,\r\n      swappedElement: event.over\r\n    });\r\n\r\n    this.trigger(swappableSwappedEvent);\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop](event) {\r\n    const swappableStopEvent = new _SwappableEvent.SwappableStopEvent({\r\n      dragEvent: event\r\n    });\r\n\r\n    this.trigger(swappableStopEvent);\r\n    this.lastOver = null;\r\n  }\r\n}\r\n\r\nexports.default = Swappable;\r\nfunction withTempElement(callback) {\r\n  const tmpElement = document.createElement('div');\r\n  callback(tmpElement);\r\n  tmpElement.parentNode.removeChild(tmpElement);\r\n}\r\n\r\nfunction swap(source, over) {\r\n  const overParent = over.parentNode;\r\n  const sourceParent = source.parentNode;\r\n\r\n  withTempElement(tmpElement => {\r\n    sourceParent.insertBefore(tmpElement, source);\r\n    overParent.insertBefore(source, over);\r\n    sourceParent.insertBefore(over, tmpElement);\r\n  });\r\n}\r\n\r\n/***/ }),\r\n/* 66 */\r\n/***/ (function(module, exports, __nested_webpack_require_60424__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.SwappableStopEvent = exports.SwappableSwappedEvent = exports.SwappableSwapEvent = exports.SwappableStartEvent = exports.SwappableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_60424__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base swappable event\r\n * @class SwappableEvent\r\n * @module SwappableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SwappableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Original drag event that triggered this swappable event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n}\r\n\r\nexports.SwappableEvent = SwappableEvent; /**\r\n                                          * Swappable start event\r\n                                          * @class SwappableStartEvent\r\n                                          * @module SwappableStartEvent\r\n                                          * @extends SwappableEvent\r\n                                          */\r\n\r\nSwappableEvent.type = 'swappable';\r\nclass SwappableStartEvent extends SwappableEvent {}\r\n\r\nexports.SwappableStartEvent = SwappableStartEvent; /**\r\n                                                    * Swappable swap event\r\n                                                    * @class SwappableSwapEvent\r\n                                                    * @module SwappableSwapEvent\r\n                                                    * @extends SwappableEvent\r\n                                                    */\r\n\r\nSwappableStartEvent.type = 'swappable:start';\r\nSwappableStartEvent.cancelable = true;\r\nclass SwappableSwapEvent extends SwappableEvent {\r\n\r\n  /**\r\n   * Draggable element you are over\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.SwappableSwapEvent = SwappableSwapEvent; /**\r\n                                                  * Swappable swapped event\r\n                                                  * @class SwappableSwappedEvent\r\n                                                  * @module SwappableSwappedEvent\r\n                                                  * @extends SwappableEvent\r\n                                                  */\r\n\r\nSwappableSwapEvent.type = 'swappable:swap';\r\nSwappableSwapEvent.cancelable = true;\r\nclass SwappableSwappedEvent extends SwappableEvent {\r\n\r\n  /**\r\n   * The draggable element that you swapped with\r\n   * @property swappedElement\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get swappedElement() {\r\n    return this.data.swappedElement;\r\n  }\r\n}\r\n\r\nexports.SwappableSwappedEvent = SwappableSwappedEvent; /**\r\n                                                        * Swappable stop event\r\n                                                        * @class SwappableStopEvent\r\n                                                        * @module SwappableStopEvent\r\n                                                        * @extends SwappableEvent\r\n                                                        */\r\n\r\nSwappableSwappedEvent.type = 'swappable:swapped';\r\nclass SwappableStopEvent extends SwappableEvent {}\r\nexports.SwappableStopEvent = SwappableStopEvent;\r\nSwappableStopEvent.type = 'swappable:stop';\r\n\r\n/***/ }),\r\n/* 67 */\r\n/***/ (function(module, exports, __nested_webpack_require_64177__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SwappableEvent = __nested_webpack_require_64177__(40);\r\n\r\nObject.keys(_SwappableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SwappableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Swappable = __nested_webpack_require_64177__(65);\r\n\r\nvar _Swappable2 = _interopRequireDefault(_Swappable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Swappable2.default;\r\n\r\n/***/ }),\r\n/* 68 */\r\n/***/ (function(module, exports, __nested_webpack_require_64897__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _utils = __nested_webpack_require_64897__(5);\r\n\r\nvar _Draggable = __nested_webpack_require_64897__(24);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nvar _DroppableEvent = __nested_webpack_require_64897__(41);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragMove = Symbol('onDragMove');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst dropInDropzone = Symbol('dropInDropZone');\r\nconst returnToOriginalDropzone = Symbol('returnToOriginalDropzone');\r\nconst closestDropzone = Symbol('closestDropzone');\r\nconst getDropzones = Symbol('getDropzones');\r\n\r\n/**\r\n * Returns an announcement message when the Draggable element is dropped into a dropzone element\r\n * @param {DroppableDroppedEvent} droppableEvent\r\n * @return {String}\r\n */\r\nfunction onDroppableDroppedDefaultAnnouncement({ dragEvent, dropzone }) {\r\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'draggable element';\r\n  const dropzoneText = dropzone.textContent.trim() || dropzone.id || 'droppable element';\r\n\r\n  return `Dropped ${sourceText} into ${dropzoneText}`;\r\n}\r\n\r\n/**\r\n * Returns an announcement message when the Draggable element has returned to its original dropzone element\r\n * @param {DroppableReturnedEvent} droppableEvent\r\n * @return {String}\r\n */\r\nfunction onDroppableReturnedDefaultAnnouncement({ dragEvent, dropzone }) {\r\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'draggable element';\r\n  const dropzoneText = dropzone.textContent.trim() || dropzone.id || 'droppable element';\r\n\r\n  return `Returned ${sourceText} from ${dropzoneText}`;\r\n}\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['droppable:dropped']\r\n * @const {Function} defaultAnnouncements['droppable:returned']\r\n */\r\nconst defaultAnnouncements = {\r\n  'droppable:dropped': onDroppableDroppedDefaultAnnouncement,\r\n  'droppable:returned': onDroppableReturnedDefaultAnnouncement\r\n};\r\n\r\nconst defaultClasses = {\r\n  'droppable:active': 'draggable-dropzone--active',\r\n  'droppable:occupied': 'draggable-dropzone--occupied'\r\n};\r\n\r\nconst defaultOptions = {\r\n  dropzone: '.draggable-droppable'\r\n};\r\n\r\n/**\r\n * Droppable is built on top of Draggable and allows dropping draggable elements\r\n * into dropzone element\r\n * @class Droppable\r\n * @module Droppable\r\n * @extends Draggable\r\n */\r\nclass Droppable extends _Draggable2.default {\r\n  /**\r\n   * Droppable constructor.\r\n   * @constructs Droppable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Droppable containers\r\n   * @param {Object} options - Options for Droppable\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, _extends({}, defaultOptions, options, {\r\n      classes: _extends({}, defaultClasses, options.classes || {}),\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {})\r\n    }));\r\n\r\n    /**\r\n     * All dropzone elements on drag start\r\n     * @property dropzones\r\n     * @type {HTMLElement[]}\r\n     */\r\n    this.dropzones = null;\r\n\r\n    /**\r\n     * Last dropzone element that the source was dropped into\r\n     * @property lastDropzone\r\n     * @type {HTMLElement}\r\n     */\r\n    this.lastDropzone = null;\r\n\r\n    /**\r\n     * Initial dropzone element that the source was drag from\r\n     * @property initialDropzone\r\n     * @type {HTMLElement}\r\n     */\r\n    this.initialDropzone = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n\r\n    this.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Destroys Droppable instance.\r\n   */\r\n  destroy() {\r\n    super.destroy();\r\n\r\n    this.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {DragStartEvent} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    this.dropzones = [...this[getDropzones]()];\r\n    const dropzone = (0, _utils.closest)(event.sensorEvent.target, this.options.dropzone);\r\n\r\n    if (!dropzone) {\r\n      event.cancel();\r\n      return;\r\n    }\r\n\r\n    const droppableStartEvent = new _DroppableEvent.DroppableStartEvent({\r\n      dragEvent: event,\r\n      dropzone\r\n    });\r\n\r\n    this.trigger(droppableStartEvent);\r\n\r\n    if (droppableStartEvent.canceled()) {\r\n      event.cancel();\r\n      return;\r\n    }\r\n\r\n    this.initialDropzone = dropzone;\r\n\r\n    for (const dropzoneElement of this.dropzones) {\r\n      if (dropzoneElement.classList.contains(this.getClassNameFor('droppable:occupied'))) {\r\n        continue;\r\n      }\r\n\r\n      dropzoneElement.classList.add(...this.getClassNamesFor('droppable:active'));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag move handler\r\n   * @private\r\n   * @param {DragMoveEvent} event - Drag move event\r\n   */\r\n  [onDragMove](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const dropzone = this[closestDropzone](event.sensorEvent.target);\r\n    const overEmptyDropzone = dropzone && !dropzone.classList.contains(this.getClassNameFor('droppable:occupied'));\r\n\r\n    if (overEmptyDropzone && this[dropInDropzone](event, dropzone)) {\r\n      this.lastDropzone = dropzone;\r\n    } else if ((!dropzone || dropzone === this.initialDropzone) && this.lastDropzone) {\r\n      this[returnToOriginalDropzone](event);\r\n      this.lastDropzone = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop](event) {\r\n    const droppableStopEvent = new _DroppableEvent.DroppableStopEvent({\r\n      dragEvent: event,\r\n      dropzone: this.lastDropzone || this.initialDropzone\r\n    });\r\n\r\n    this.trigger(droppableStopEvent);\r\n\r\n    const occupiedClasses = this.getClassNamesFor('droppable:occupied');\r\n\r\n    for (const dropzone of this.dropzones) {\r\n      dropzone.classList.remove(...this.getClassNamesFor('droppable:active'));\r\n    }\r\n\r\n    if (this.lastDropzone && this.lastDropzone !== this.initialDropzone) {\r\n      this.initialDropzone.classList.remove(...occupiedClasses);\r\n    }\r\n\r\n    this.dropzones = null;\r\n    this.lastDropzone = null;\r\n    this.initialDropzone = null;\r\n  }\r\n\r\n  /**\r\n   * Drops a draggable element into a dropzone element\r\n   * @private\r\n   * @param {DragMoveEvent} event - Drag move event\r\n   * @param {HTMLElement} dropzone - Dropzone element to drop draggable into\r\n   */\r\n  [dropInDropzone](event, dropzone) {\r\n    const droppableDroppedEvent = new _DroppableEvent.DroppableDroppedEvent({\r\n      dragEvent: event,\r\n      dropzone\r\n    });\r\n\r\n    this.trigger(droppableDroppedEvent);\r\n\r\n    if (droppableDroppedEvent.canceled()) {\r\n      return false;\r\n    }\r\n\r\n    const occupiedClasses = this.getClassNamesFor('droppable:occupied');\r\n\r\n    if (this.lastDropzone) {\r\n      this.lastDropzone.classList.remove(...occupiedClasses);\r\n    }\r\n\r\n    dropzone.appendChild(event.source);\r\n    dropzone.classList.add(...occupiedClasses);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Moves the previously dropped element back into its original dropzone\r\n   * @private\r\n   * @param {DragMoveEvent} event - Drag move event\r\n   */\r\n  [returnToOriginalDropzone](event) {\r\n    const droppableReturnedEvent = new _DroppableEvent.DroppableReturnedEvent({\r\n      dragEvent: event,\r\n      dropzone: this.lastDropzone\r\n    });\r\n\r\n    this.trigger(droppableReturnedEvent);\r\n\r\n    if (droppableReturnedEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    this.initialDropzone.appendChild(event.source);\r\n    this.lastDropzone.classList.remove(...this.getClassNamesFor('droppable:occupied'));\r\n  }\r\n\r\n  /**\r\n   * Returns closest dropzone element for even target\r\n   * @private\r\n   * @param {HTMLElement} target - Event target\r\n   * @return {HTMLElement|null}\r\n   */\r\n  [closestDropzone](target) {\r\n    if (!this.dropzones) {\r\n      return null;\r\n    }\r\n\r\n    return (0, _utils.closest)(target, this.dropzones);\r\n  }\r\n\r\n  /**\r\n   * Returns all current dropzone elements for this draggable instance\r\n   * @private\r\n   * @return {NodeList|HTMLElement[]|Array}\r\n   */\r\n  [getDropzones]() {\r\n    const dropzone = this.options.dropzone;\r\n\r\n    if (typeof dropzone === 'string') {\r\n      return document.querySelectorAll(dropzone);\r\n    } else if (dropzone instanceof NodeList || dropzone instanceof Array) {\r\n      return dropzone;\r\n    } else if (typeof dropzone === 'function') {\r\n      return dropzone();\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n}\r\nexports.default = Droppable;\r\n\r\n/***/ }),\r\n/* 69 */\r\n/***/ (function(module, exports, __nested_webpack_require_74010__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DroppableStopEvent = exports.DroppableReturnedEvent = exports.DroppableDroppedEvent = exports.DroppableStartEvent = exports.DroppableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_74010__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base droppable event\r\n * @class DroppableEvent\r\n * @module DroppableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DroppableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Original drag event that triggered this droppable event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n}\r\n\r\nexports.DroppableEvent = DroppableEvent; /**\r\n                                          * Droppable start event\r\n                                          * @class DroppableStartEvent\r\n                                          * @module DroppableStartEvent\r\n                                          * @extends DroppableEvent\r\n                                          */\r\n\r\nDroppableEvent.type = 'droppable';\r\nclass DroppableStartEvent extends DroppableEvent {\r\n\r\n  /**\r\n   * The initial dropzone element of the currently dragging draggable element\r\n   * @property dropzone\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get dropzone() {\r\n    return this.data.dropzone;\r\n  }\r\n}\r\n\r\nexports.DroppableStartEvent = DroppableStartEvent; /**\r\n                                                    * Droppable dropped event\r\n                                                    * @class DroppableDroppedEvent\r\n                                                    * @module DroppableDroppedEvent\r\n                                                    * @extends DroppableEvent\r\n                                                    */\r\n\r\nDroppableStartEvent.type = 'droppable:start';\r\nDroppableStartEvent.cancelable = true;\r\nclass DroppableDroppedEvent extends DroppableEvent {\r\n\r\n  /**\r\n   * The dropzone element you dropped the draggable element into\r\n   * @property dropzone\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get dropzone() {\r\n    return this.data.dropzone;\r\n  }\r\n}\r\n\r\nexports.DroppableDroppedEvent = DroppableDroppedEvent; /**\r\n                                                        * Droppable returned event\r\n                                                        * @class DroppableReturnedEvent\r\n                                                        * @module DroppableReturnedEvent\r\n                                                        * @extends DroppableEvent\r\n                                                        */\r\n\r\nDroppableDroppedEvent.type = 'droppable:dropped';\r\nDroppableDroppedEvent.cancelable = true;\r\nclass DroppableReturnedEvent extends DroppableEvent {\r\n\r\n  /**\r\n   * The dropzone element you dragged away from\r\n   * @property dropzone\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get dropzone() {\r\n    return this.data.dropzone;\r\n  }\r\n}\r\n\r\nexports.DroppableReturnedEvent = DroppableReturnedEvent; /**\r\n                                                          * Droppable stop event\r\n                                                          * @class DroppableStopEvent\r\n                                                          * @module DroppableStopEvent\r\n                                                          * @extends DroppableEvent\r\n                                                          */\r\n\r\nDroppableReturnedEvent.type = 'droppable:returned';\r\nDroppableReturnedEvent.cancelable = true;\r\nclass DroppableStopEvent extends DroppableEvent {\r\n\r\n  /**\r\n   * The final dropzone element of the draggable element\r\n   * @property dropzone\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get dropzone() {\r\n    return this.data.dropzone;\r\n  }\r\n}\r\nexports.DroppableStopEvent = DroppableStopEvent;\r\nDroppableStopEvent.type = 'droppable:stop';\r\nDroppableStopEvent.cancelable = true;\r\n\r\n/***/ }),\r\n/* 70 */\r\n/***/ (function(module, exports, __nested_webpack_require_78173__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DroppableEvent = __nested_webpack_require_78173__(41);\r\n\r\nObject.keys(_DroppableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DroppableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Droppable = __nested_webpack_require_78173__(68);\r\n\r\nvar _Droppable2 = _interopRequireDefault(_Droppable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Droppable2.default;\r\n\r\n/***/ }),\r\n/* 71 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * The Emitter is a simple emitter class that provides you with `on()`, `off()` and `trigger()` methods\r\n * @class Emitter\r\n * @module Emitter\r\n */\r\nclass Emitter {\r\n  constructor() {\r\n    this.callbacks = {};\r\n  }\r\n\r\n  /**\r\n   * Registers callbacks by event name\r\n   * @param {String} type\r\n   * @param {...Function} callbacks\r\n   */\r\n  on(type, ...callbacks) {\r\n    if (!this.callbacks[type]) {\r\n      this.callbacks[type] = [];\r\n    }\r\n\r\n    this.callbacks[type].push(...callbacks);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Unregisters callbacks by event name\r\n   * @param {String} type\r\n   * @param {Function} callback\r\n   */\r\n  off(type, callback) {\r\n    if (!this.callbacks[type]) {\r\n      return null;\r\n    }\r\n\r\n    const copy = this.callbacks[type].slice(0);\r\n\r\n    for (let i = 0; i < copy.length; i++) {\r\n      if (callback === copy[i]) {\r\n        this.callbacks[type].splice(i, 1);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Triggers event callbacks by event object\r\n   * @param {AbstractEvent} event\r\n   */\r\n  trigger(event) {\r\n    if (!this.callbacks[event.type]) {\r\n      return null;\r\n    }\r\n\r\n    const callbacks = [...this.callbacks[event.type]];\r\n    const caughtErrors = [];\r\n\r\n    for (let i = callbacks.length - 1; i >= 0; i--) {\r\n      const callback = callbacks[i];\r\n\r\n      try {\r\n        callback(event);\r\n      } catch (error) {\r\n        caughtErrors.push(error);\r\n      }\r\n    }\r\n\r\n    if (caughtErrors.length) {\r\n      /* eslint-disable no-console */\r\n      console.error(`Draggable caught errors while triggering '${event.type}'`, caughtErrors);\r\n      /* eslint-disable no-console */\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\nexports.default = Emitter;\r\n\r\n/***/ }),\r\n/* 72 */\r\n/***/ (function(module, exports, __nested_webpack_require_80757__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Emitter = __nested_webpack_require_80757__(71);\r\n\r\nvar _Emitter2 = _interopRequireDefault(_Emitter);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Emitter2.default;\r\n\r\n/***/ }),\r\n/* 73 */\r\n/***/ (function(module, exports, __nested_webpack_require_81161__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _utils = __nested_webpack_require_81161__(5);\r\n\r\nvar _Plugins = __nested_webpack_require_81161__(42);\r\n\r\nvar _Emitter = __nested_webpack_require_81161__(72);\r\n\r\nvar _Emitter2 = _interopRequireDefault(_Emitter);\r\n\r\nvar _Sensors = __nested_webpack_require_81161__(29);\r\n\r\nvar _DraggableEvent = __nested_webpack_require_81161__(43);\r\n\r\nvar _DragEvent = __nested_webpack_require_81161__(44);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragMove = Symbol('onDragMove');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst onDragPressure = Symbol('onDragPressure');\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['drag:start']\r\n * @const {Function} defaultAnnouncements['drag:stop']\r\n */\r\nconst defaultAnnouncements = {\r\n  'drag:start': event => `Picked up ${event.source.textContent.trim() || event.source.id || 'draggable element'}`,\r\n  'drag:stop': event => `Released ${event.source.textContent.trim() || event.source.id || 'draggable element'}`\r\n};\r\n\r\nconst defaultClasses = {\r\n  'container:dragging': 'draggable-container--is-dragging',\r\n  'source:dragging': 'draggable-source--is-dragging',\r\n  'source:placed': 'draggable-source--placed',\r\n  'container:placed': 'draggable-container--placed',\r\n  'body:dragging': 'draggable--is-dragging',\r\n  'draggable:over': 'draggable--over',\r\n  'container:over': 'draggable-container--over',\r\n  'source:original': 'draggable--original',\r\n  mirror: 'draggable-mirror'\r\n};\r\n\r\nconst defaultOptions = exports.defaultOptions = {\r\n  draggable: '.draggable-source',\r\n  handle: null,\r\n  delay: {},\r\n  distance: 0,\r\n  placedTimeout: 800,\r\n  plugins: [],\r\n  sensors: [],\r\n  exclude: {\r\n    plugins: [],\r\n    sensors: []\r\n  }\r\n};\r\n\r\n/**\r\n * This is the core draggable library that does the heavy lifting\r\n * @class Draggable\r\n * @module Draggable\r\n */\r\nclass Draggable {\r\n\r\n  /**\r\n   * Draggable constructor.\r\n   * @constructs Draggable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Draggable containers\r\n   * @param {Object} options - Options for draggable\r\n   */\r\n\r\n  /**\r\n   * Default plugins draggable uses\r\n   * @static\r\n   * @property {Object} Plugins\r\n   * @property {Announcement} Plugins.Announcement\r\n   * @property {Focusable} Plugins.Focusable\r\n   * @property {Mirror} Plugins.Mirror\r\n   * @property {Scrollable} Plugins.Scrollable\r\n   * @type {Object}\r\n   */\r\n  constructor(containers = [document.body], options = {}) {\r\n    /**\r\n     * Draggable containers\r\n     * @property containers\r\n     * @type {HTMLElement[]}\r\n     */\r\n    if (containers instanceof NodeList || containers instanceof Array) {\r\n      this.containers = [...containers];\r\n    } else if (containers instanceof HTMLElement) {\r\n      this.containers = [containers];\r\n    } else {\r\n      throw new Error('Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`');\r\n    }\r\n\r\n    this.options = _extends({}, defaultOptions, options, {\r\n      classes: _extends({}, defaultClasses, options.classes || {}),\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {}),\r\n      exclude: {\r\n        plugins: options.exclude && options.exclude.plugins || [],\r\n        sensors: options.exclude && options.exclude.sensors || []\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Draggables event emitter\r\n     * @property emitter\r\n     * @type {Emitter}\r\n     */\r\n    this.emitter = new _Emitter2.default();\r\n\r\n    /**\r\n     * Current drag state\r\n     * @property dragging\r\n     * @type {Boolean}\r\n     */\r\n    this.dragging = false;\r\n\r\n    /**\r\n     * Active plugins\r\n     * @property plugins\r\n     * @type {Plugin[]}\r\n     */\r\n    this.plugins = [];\r\n\r\n    /**\r\n     * Active sensors\r\n     * @property sensors\r\n     * @type {Sensor[]}\r\n     */\r\n    this.sensors = [];\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onDragPressure] = this[onDragPressure].bind(this);\r\n\r\n    document.addEventListener('drag:start', this[onDragStart], true);\r\n    document.addEventListener('drag:move', this[onDragMove], true);\r\n    document.addEventListener('drag:stop', this[onDragStop], true);\r\n    document.addEventListener('drag:pressure', this[onDragPressure], true);\r\n\r\n    const defaultPlugins = Object.values(Draggable.Plugins).filter(Plugin => !this.options.exclude.plugins.includes(Plugin));\r\n    const defaultSensors = Object.values(Draggable.Sensors).filter(sensor => !this.options.exclude.sensors.includes(sensor));\r\n\r\n    this.addPlugin(...[...defaultPlugins, ...this.options.plugins]);\r\n    this.addSensor(...[...defaultSensors, ...this.options.sensors]);\r\n\r\n    const draggableInitializedEvent = new _DraggableEvent.DraggableInitializedEvent({\r\n      draggable: this\r\n    });\r\n\r\n    this.on('mirror:created', ({ mirror }) => this.mirror = mirror);\r\n    this.on('mirror:destroy', () => this.mirror = null);\r\n\r\n    this.trigger(draggableInitializedEvent);\r\n  }\r\n\r\n  /**\r\n   * Destroys Draggable instance. This removes all internal event listeners and\r\n   * deactivates sensors and plugins\r\n   */\r\n\r\n\r\n  /**\r\n   * Default sensors draggable uses\r\n   * @static\r\n   * @property {Object} Sensors\r\n   * @property {MouseSensor} Sensors.MouseSensor\r\n   * @property {TouchSensor} Sensors.TouchSensor\r\n   * @type {Object}\r\n   */\r\n  destroy() {\r\n    document.removeEventListener('drag:start', this[onDragStart], true);\r\n    document.removeEventListener('drag:move', this[onDragMove], true);\r\n    document.removeEventListener('drag:stop', this[onDragStop], true);\r\n    document.removeEventListener('drag:pressure', this[onDragPressure], true);\r\n\r\n    const draggableDestroyEvent = new _DraggableEvent.DraggableDestroyEvent({\r\n      draggable: this\r\n    });\r\n\r\n    this.trigger(draggableDestroyEvent);\r\n\r\n    this.removePlugin(...this.plugins.map(plugin => plugin.constructor));\r\n    this.removeSensor(...this.sensors.map(sensor => sensor.constructor));\r\n  }\r\n\r\n  /**\r\n   * Adds plugin to this draggable instance. This will end up calling the attach method of the plugin\r\n   * @param {...typeof Plugin} plugins - Plugins that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addPlugin(CustomA11yPlugin, CustomMirrorPlugin)\r\n   */\r\n  addPlugin(...plugins) {\r\n    const activePlugins = plugins.map(Plugin => new Plugin(this));\r\n\r\n    activePlugins.forEach(plugin => plugin.attach());\r\n    this.plugins = [...this.plugins, ...activePlugins];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes plugins that are already attached to this draggable instance. This will end up calling\r\n   * the detach method of the plugin\r\n   * @param {...typeof Plugin} plugins - Plugins that you want detached from draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removePlugin(MirrorPlugin, CustomMirrorPlugin)\r\n   */\r\n  removePlugin(...plugins) {\r\n    const removedPlugins = this.plugins.filter(plugin => plugins.includes(plugin.constructor));\r\n\r\n    removedPlugins.forEach(plugin => plugin.detach());\r\n    this.plugins = this.plugins.filter(plugin => !plugins.includes(plugin.constructor));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds sensors to this draggable instance. This will end up calling the attach method of the sensor\r\n   * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addSensor(ForceTouchSensor, CustomSensor)\r\n   */\r\n  addSensor(...sensors) {\r\n    const activeSensors = sensors.map(Sensor => new Sensor(this.containers, this.options));\r\n\r\n    activeSensors.forEach(sensor => sensor.attach());\r\n    this.sensors = [...this.sensors, ...activeSensors];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes sensors that are already attached to this draggable instance. This will end up calling\r\n   * the detach method of the sensor\r\n   * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removeSensor(TouchSensor, DragSensor)\r\n   */\r\n  removeSensor(...sensors) {\r\n    const removedSensors = this.sensors.filter(sensor => sensors.includes(sensor.constructor));\r\n\r\n    removedSensors.forEach(sensor => sensor.detach());\r\n    this.sensors = this.sensors.filter(sensor => !sensors.includes(sensor.constructor));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds container to this draggable instance\r\n   * @param {...HTMLElement} containers - Containers you want to add to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addContainer(document.body)\r\n   */\r\n  addContainer(...containers) {\r\n    this.containers = [...this.containers, ...containers];\r\n    this.sensors.forEach(sensor => sensor.addContainer(...containers));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes container from this draggable instance\r\n   * @param {...HTMLElement} containers - Containers you want to remove from draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removeContainer(document.body)\r\n   */\r\n  removeContainer(...containers) {\r\n    this.containers = this.containers.filter(container => !containers.includes(container));\r\n    this.sensors.forEach(sensor => sensor.removeContainer(...containers));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds listener for draggable events\r\n   * @param {String} type - Event name\r\n   * @param {...Function} callbacks - Event callbacks\r\n   * @return {Draggable}\r\n   * @example draggable.on('drag:start', (dragEvent) => dragEvent.cancel());\r\n   */\r\n  on(type, ...callbacks) {\r\n    this.emitter.on(type, ...callbacks);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes listener from draggable\r\n   * @param {String} type - Event name\r\n   * @param {Function} callback - Event callback\r\n   * @return {Draggable}\r\n   * @example draggable.off('drag:start', handlerFunction);\r\n   */\r\n  off(type, callback) {\r\n    this.emitter.off(type, callback);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Triggers draggable event\r\n   * @param {AbstractEvent} event - Event instance\r\n   * @return {Draggable}\r\n   * @example draggable.trigger(event);\r\n   */\r\n  trigger(event) {\r\n    this.emitter.trigger(event);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns class name for class identifier\r\n   * @param {String} name - Name of class identifier\r\n   * @return {String|null}\r\n   */\r\n  getClassNameFor(name) {\r\n    return this.getClassNamesFor(name)[0];\r\n  }\r\n\r\n  /**\r\n   * Returns class names for class identifier\r\n   * @return {String[]}\r\n   */\r\n  getClassNamesFor(name) {\r\n    const classNames = this.options.classes[name];\r\n\r\n    if (classNames instanceof Array) {\r\n      return classNames;\r\n    } else if (typeof classNames === 'string' || classNames instanceof String) {\r\n      return [classNames];\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if this draggable instance is currently dragging\r\n   * @return {Boolean}\r\n   */\r\n  isDragging() {\r\n    return Boolean(this.dragging);\r\n  }\r\n\r\n  /**\r\n   * Returns all draggable elements\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getDraggableElements() {\r\n    return this.containers.reduce((current, container) => {\r\n      return [...current, ...this.getDraggableElementsForContainer(container)];\r\n    }, []);\r\n  }\r\n\r\n  /**\r\n   * Returns draggable elements for a given container, excluding the mirror and\r\n   * original source element if present\r\n   * @param {HTMLElement} container\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getDraggableElementsForContainer(container) {\r\n    const allDraggableElements = container.querySelectorAll(this.options.draggable);\r\n\r\n    return [...allDraggableElements].filter(childElement => {\r\n      return childElement !== this.originalSource && childElement !== this.mirror;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragStart](event) {\r\n    const sensorEvent = getSensorEvent(event);\r\n    const { target, container } = sensorEvent;\r\n\r\n    if (!this.containers.includes(container)) {\r\n      return;\r\n    }\r\n\r\n    if (this.options.handle && target && !(0, _utils.closest)(target, this.options.handle)) {\r\n      sensorEvent.cancel();\r\n      return;\r\n    }\r\n\r\n    // Find draggable source element\r\n    this.originalSource = (0, _utils.closest)(target, this.options.draggable);\r\n    this.sourceContainer = container;\r\n\r\n    if (!this.originalSource) {\r\n      sensorEvent.cancel();\r\n      return;\r\n    }\r\n\r\n    if (this.lastPlacedSource && this.lastPlacedContainer) {\r\n      clearTimeout(this.placedTimeoutID);\r\n      this.lastPlacedSource.classList.remove(...this.getClassNamesFor('source:placed'));\r\n      this.lastPlacedContainer.classList.remove(...this.getClassNamesFor('container:placed'));\r\n    }\r\n\r\n    this.source = this.originalSource.cloneNode(true);\r\n    this.originalSource.parentNode.insertBefore(this.source, this.originalSource);\r\n    this.originalSource.style.display = 'none';\r\n\r\n    const dragEvent = new _DragEvent.DragStartEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sourceContainer: container,\r\n      sensorEvent\r\n    });\r\n\r\n    this.trigger(dragEvent);\r\n\r\n    this.dragging = !dragEvent.canceled();\r\n\r\n    if (dragEvent.canceled()) {\r\n      this.source.parentNode.removeChild(this.source);\r\n      this.originalSource.style.display = null;\r\n      return;\r\n    }\r\n\r\n    this.originalSource.classList.add(...this.getClassNamesFor('source:original'));\r\n    this.source.classList.add(...this.getClassNamesFor('source:dragging'));\r\n    this.sourceContainer.classList.add(...this.getClassNamesFor('container:dragging'));\r\n    document.body.classList.add(...this.getClassNamesFor('body:dragging'));\r\n    applyUserSelect(document.body, 'none');\r\n\r\n    requestAnimationFrame(() => {\r\n      const oldSensorEvent = getSensorEvent(event);\r\n      const newSensorEvent = oldSensorEvent.clone({ target: this.source });\r\n\r\n      this[onDragMove](_extends({}, event, {\r\n        detail: newSensorEvent\r\n      }));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag move handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = getSensorEvent(event);\r\n    const { container } = sensorEvent;\r\n    let target = sensorEvent.target;\r\n\r\n    const dragMoveEvent = new _DragEvent.DragMoveEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sourceContainer: container,\r\n      sensorEvent\r\n    });\r\n\r\n    this.trigger(dragMoveEvent);\r\n\r\n    if (dragMoveEvent.canceled()) {\r\n      sensorEvent.cancel();\r\n    }\r\n\r\n    target = (0, _utils.closest)(target, this.options.draggable);\r\n    const withinCorrectContainer = (0, _utils.closest)(sensorEvent.target, this.containers);\r\n    const overContainer = sensorEvent.overContainer || withinCorrectContainer;\r\n    const isLeavingContainer = this.currentOverContainer && overContainer !== this.currentOverContainer;\r\n    const isLeavingDraggable = this.currentOver && target !== this.currentOver;\r\n    const isOverContainer = overContainer && this.currentOverContainer !== overContainer;\r\n    const isOverDraggable = withinCorrectContainer && target && this.currentOver !== target;\r\n\r\n    if (isLeavingDraggable) {\r\n      const dragOutEvent = new _DragEvent.DragOutEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        over: this.currentOver,\r\n        overContainer: this.currentOverContainer\r\n      });\r\n\r\n      this.currentOver.classList.remove(...this.getClassNamesFor('draggable:over'));\r\n      this.currentOver = null;\r\n\r\n      this.trigger(dragOutEvent);\r\n    }\r\n\r\n    if (isLeavingContainer) {\r\n      const dragOutContainerEvent = new _DragEvent.DragOutContainerEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer: this.currentOverContainer\r\n      });\r\n\r\n      this.currentOverContainer.classList.remove(...this.getClassNamesFor('container:over'));\r\n      this.currentOverContainer = null;\r\n\r\n      this.trigger(dragOutContainerEvent);\r\n    }\r\n\r\n    if (isOverContainer) {\r\n      overContainer.classList.add(...this.getClassNamesFor('container:over'));\r\n\r\n      const dragOverContainerEvent = new _DragEvent.DragOverContainerEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer\r\n      });\r\n\r\n      this.currentOverContainer = overContainer;\r\n\r\n      this.trigger(dragOverContainerEvent);\r\n    }\r\n\r\n    if (isOverDraggable) {\r\n      target.classList.add(...this.getClassNamesFor('draggable:over'));\r\n\r\n      const dragOverEvent = new _DragEvent.DragOverEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer,\r\n        over: target\r\n      });\r\n\r\n      this.currentOver = target;\r\n\r\n      this.trigger(dragOverEvent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragStop](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    this.dragging = false;\r\n\r\n    const dragStopEvent = new _DragEvent.DragStopEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sensorEvent: event.sensorEvent,\r\n      sourceContainer: this.sourceContainer\r\n    });\r\n\r\n    this.trigger(dragStopEvent);\r\n\r\n    this.source.parentNode.insertBefore(this.originalSource, this.source);\r\n    this.source.parentNode.removeChild(this.source);\r\n    this.originalSource.style.display = '';\r\n\r\n    this.source.classList.remove(...this.getClassNamesFor('source:dragging'));\r\n    this.originalSource.classList.remove(...this.getClassNamesFor('source:original'));\r\n    this.originalSource.classList.add(...this.getClassNamesFor('source:placed'));\r\n    this.sourceContainer.classList.add(...this.getClassNamesFor('container:placed'));\r\n    this.sourceContainer.classList.remove(...this.getClassNamesFor('container:dragging'));\r\n    document.body.classList.remove(...this.getClassNamesFor('body:dragging'));\r\n    applyUserSelect(document.body, '');\r\n\r\n    if (this.currentOver) {\r\n      this.currentOver.classList.remove(...this.getClassNamesFor('draggable:over'));\r\n    }\r\n\r\n    if (this.currentOverContainer) {\r\n      this.currentOverContainer.classList.remove(...this.getClassNamesFor('container:over'));\r\n    }\r\n\r\n    this.lastPlacedSource = this.originalSource;\r\n    this.lastPlacedContainer = this.sourceContainer;\r\n\r\n    this.placedTimeoutID = setTimeout(() => {\r\n      if (this.lastPlacedSource) {\r\n        this.lastPlacedSource.classList.remove(...this.getClassNamesFor('source:placed'));\r\n      }\r\n\r\n      if (this.lastPlacedContainer) {\r\n        this.lastPlacedContainer.classList.remove(...this.getClassNamesFor('container:placed'));\r\n      }\r\n\r\n      this.lastPlacedSource = null;\r\n      this.lastPlacedContainer = null;\r\n    }, this.options.placedTimeout);\r\n\r\n    const dragStoppedEvent = new _DragEvent.DragStoppedEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sensorEvent: event.sensorEvent,\r\n      sourceContainer: this.sourceContainer\r\n    });\r\n\r\n    this.trigger(dragStoppedEvent);\r\n\r\n    this.source = null;\r\n    this.originalSource = null;\r\n    this.currentOverContainer = null;\r\n    this.currentOver = null;\r\n    this.sourceContainer = null;\r\n  }\r\n\r\n  /**\r\n   * Drag pressure handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragPressure](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = getSensorEvent(event);\r\n    const source = this.source || (0, _utils.closest)(sensorEvent.originalEvent.target, this.options.draggable);\r\n\r\n    const dragPressureEvent = new _DragEvent.DragPressureEvent({\r\n      sensorEvent,\r\n      source,\r\n      pressure: sensorEvent.pressure\r\n    });\r\n\r\n    this.trigger(dragPressureEvent);\r\n  }\r\n}\r\n\r\nexports.default = Draggable;\r\nDraggable.Plugins = { Announcement: _Plugins.Announcement, Focusable: _Plugins.Focusable, Mirror: _Plugins.Mirror, Scrollable: _Plugins.Scrollable };\r\nDraggable.Sensors = { MouseSensor: _Sensors.MouseSensor, TouchSensor: _Sensors.TouchSensor };\r\nfunction getSensorEvent(event) {\r\n  return event.detail;\r\n}\r\n\r\nfunction applyUserSelect(element, value) {\r\n  element.style.webkitUserSelect = value;\r\n  element.style.mozUserSelect = value;\r\n  element.style.msUserSelect = value;\r\n  element.style.oUserSelect = value;\r\n  element.style.userSelect = value;\r\n}\r\n\r\n/***/ }),\r\n/* 74 */\r\n/***/ (function(module, exports, __nested_webpack_require_102298__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = exports.scroll = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_102298__(3);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _utils = __nested_webpack_require_102298__(5);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = exports.onDragStart = Symbol('onDragStart');\r\nconst onDragMove = exports.onDragMove = Symbol('onDragMove');\r\nconst onDragStop = exports.onDragStop = Symbol('onDragStop');\r\nconst scroll = exports.scroll = Symbol('scroll');\r\n\r\n/**\r\n * Scrollable default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.speed\r\n * @property {Number} defaultOptions.sensitivity\r\n * @property {HTMLElement[]} defaultOptions.scrollableElements\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  speed: 6,\r\n  sensitivity: 50,\r\n  scrollableElements: []\r\n};\r\n\r\n/**\r\n * Scrollable plugin which scrolls the closest scrollable parent\r\n * @class Scrollable\r\n * @module Scrollable\r\n * @extends AbstractPlugin\r\n */\r\nclass Scrollable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Scrollable constructor.\r\n   * @constructs Scrollable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Scrollable options\r\n     * @property {Object} options\r\n     * @property {Number} options.speed\r\n     * @property {Number} options.sensitivity\r\n     * @property {HTMLElement[]} options.scrollableElements\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Keeps current mouse position\r\n     * @property {Object} currentMousePosition\r\n     * @property {Number} currentMousePosition.clientX\r\n     * @property {Number} currentMousePosition.clientY\r\n     * @type {Object|null}\r\n     */\r\n    this.currentMousePosition = null;\r\n\r\n    /**\r\n     * Scroll animation frame\r\n     * @property scrollAnimationFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.scrollAnimationFrame = null;\r\n\r\n    /**\r\n     * Closest scrollable element\r\n     * @property scrollableElement\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.scrollableElement = null;\r\n\r\n    /**\r\n     * Animation frame looking for the closest scrollable element\r\n     * @property findScrollableElementFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.findScrollableElementFrame = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[scroll] = this[scroll].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.scrollable || {};\r\n  }\r\n\r\n  /**\r\n   * Returns closest scrollable elements by element\r\n   * @param {HTMLElement} target\r\n   * @return {HTMLElement}\r\n   */\r\n  getScrollableElement(target) {\r\n    if (this.hasDefinedScrollableElements()) {\r\n      return (0, _utils.closest)(target, this.options.scrollableElements) || document.documentElement;\r\n    } else {\r\n      return closestScrollableElement(target);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if at least one scrollable element have been defined via options\r\n   * @param {HTMLElement} target\r\n   * @return {Boolean}\r\n   */\r\n  hasDefinedScrollableElements() {\r\n    return Boolean(this.options.scrollableElements.length !== 0);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler. Finds closest scrollable parent in separate frame\r\n   * @param {DragStartEvent} dragEvent\r\n   * @private\r\n   */\r\n  [onDragStart](dragEvent) {\r\n    this.findScrollableElementFrame = requestAnimationFrame(() => {\r\n      this.scrollableElement = this.getScrollableElement(dragEvent.source);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag move handler. Remembers mouse position and initiates scrolling\r\n   * @param {DragMoveEvent} dragEvent\r\n   * @private\r\n   */\r\n  [onDragMove](dragEvent) {\r\n    this.findScrollableElementFrame = requestAnimationFrame(() => {\r\n      this.scrollableElement = this.getScrollableElement(dragEvent.sensorEvent.target);\r\n    });\r\n\r\n    if (!this.scrollableElement) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = dragEvent.sensorEvent;\r\n    const scrollOffset = { x: 0, y: 0 };\r\n\r\n    if ('ontouchstart' in window) {\r\n      scrollOffset.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\r\n      scrollOffset.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;\r\n    }\r\n\r\n    this.currentMousePosition = {\r\n      clientX: sensorEvent.clientX - scrollOffset.x,\r\n      clientY: sensorEvent.clientY - scrollOffset.y\r\n    };\r\n\r\n    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler. Cancels scroll animations and resets state\r\n   * @private\r\n   */\r\n  [onDragStop]() {\r\n    cancelAnimationFrame(this.scrollAnimationFrame);\r\n    cancelAnimationFrame(this.findScrollableElementFrame);\r\n\r\n    this.scrollableElement = null;\r\n    this.scrollAnimationFrame = null;\r\n    this.findScrollableElementFrame = null;\r\n    this.currentMousePosition = null;\r\n  }\r\n\r\n  /**\r\n   * Scroll function that does the heavylifting\r\n   * @private\r\n   */\r\n  [scroll]() {\r\n    if (!this.scrollableElement || !this.currentMousePosition) {\r\n      return;\r\n    }\r\n\r\n    cancelAnimationFrame(this.scrollAnimationFrame);\r\n\r\n    const { speed, sensitivity } = this.options;\r\n\r\n    const rect = this.scrollableElement.getBoundingClientRect();\r\n    const bottomCutOff = rect.bottom > window.innerHeight;\r\n    const topCutOff = rect.top < 0;\r\n    const cutOff = topCutOff || bottomCutOff;\r\n\r\n    const documentScrollingElement = getDocumentScrollingElement();\r\n    const scrollableElement = this.scrollableElement;\r\n    const clientX = this.currentMousePosition.clientX;\r\n    const clientY = this.currentMousePosition.clientY;\r\n\r\n    if (scrollableElement !== document.body && scrollableElement !== document.documentElement && !cutOff) {\r\n      const { offsetHeight, offsetWidth } = scrollableElement;\r\n\r\n      if (rect.top + offsetHeight - clientY < sensitivity) {\r\n        scrollableElement.scrollTop += speed;\r\n      } else if (clientY - rect.top < sensitivity) {\r\n        scrollableElement.scrollTop -= speed;\r\n      }\r\n\r\n      if (rect.left + offsetWidth - clientX < sensitivity) {\r\n        scrollableElement.scrollLeft += speed;\r\n      } else if (clientX - rect.left < sensitivity) {\r\n        scrollableElement.scrollLeft -= speed;\r\n      }\r\n    } else {\r\n      const { innerHeight, innerWidth } = window;\r\n\r\n      if (clientY < sensitivity) {\r\n        documentScrollingElement.scrollTop -= speed;\r\n      } else if (innerHeight - clientY < sensitivity) {\r\n        documentScrollingElement.scrollTop += speed;\r\n      }\r\n\r\n      if (clientX < sensitivity) {\r\n        documentScrollingElement.scrollLeft -= speed;\r\n      } else if (innerWidth - clientX < sensitivity) {\r\n        documentScrollingElement.scrollLeft += speed;\r\n      }\r\n    }\r\n\r\n    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\r\n  }\r\n}\r\n\r\nexports.default = Scrollable; /**\r\n                               * Returns true if the passed element has overflow\r\n                               * @param {HTMLElement} element\r\n                               * @return {Boolean}\r\n                               * @private\r\n                               */\r\n\r\nfunction hasOverflow(element) {\r\n  const overflowRegex = /(auto|scroll)/;\r\n  const computedStyles = getComputedStyle(element, null);\r\n\r\n  const overflow = computedStyles.getPropertyValue('overflow') + computedStyles.getPropertyValue('overflow-y') + computedStyles.getPropertyValue('overflow-x');\r\n\r\n  return overflowRegex.test(overflow);\r\n}\r\n\r\n/**\r\n * Returns true if the passed element is statically positioned\r\n * @param {HTMLElement} element\r\n * @return {Boolean}\r\n * @private\r\n */\r\nfunction isStaticallyPositioned(element) {\r\n  const position = getComputedStyle(element).getPropertyValue('position');\r\n  return position === 'static';\r\n}\r\n\r\n/**\r\n * Finds closest scrollable element\r\n * @param {HTMLElement} element\r\n * @return {HTMLElement}\r\n * @private\r\n */\r\nfunction closestScrollableElement(element) {\r\n  if (!element) {\r\n    return getDocumentScrollingElement();\r\n  }\r\n\r\n  const position = getComputedStyle(element).getPropertyValue('position');\r\n  const excludeStaticParents = position === 'absolute';\r\n\r\n  const scrollableElement = (0, _utils.closest)(element, parent => {\r\n    if (excludeStaticParents && isStaticallyPositioned(parent)) {\r\n      return false;\r\n    }\r\n    return hasOverflow(parent);\r\n  });\r\n\r\n  if (position === 'fixed' || !scrollableElement) {\r\n    return getDocumentScrollingElement();\r\n  } else {\r\n    return scrollableElement;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns element that scrolls document\r\n * @return {HTMLElement}\r\n * @private\r\n */\r\nfunction getDocumentScrollingElement() {\r\n  return document.scrollingElement || document.documentElement;\r\n}\r\n\r\n/***/ }),\r\n/* 75 */\r\n/***/ (function(module, exports, __nested_webpack_require_112220__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Scrollable = __nested_webpack_require_112220__(74);\r\n\r\nvar _Scrollable2 = _interopRequireDefault(_Scrollable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Scrollable2.default;\r\nexports.defaultOptions = _Scrollable.defaultOptions;\r\n\r\n/***/ }),\r\n/* 76 */\r\n/***/ (function(module, exports, __nested_webpack_require_112727__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.MirrorDestroyEvent = exports.MirrorMoveEvent = exports.MirrorAttachedEvent = exports.MirrorCreatedEvent = exports.MirrorCreateEvent = exports.MirrorEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_112727__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base mirror event\r\n * @class MirrorEvent\r\n * @module MirrorEvent\r\n * @extends AbstractEvent\r\n */\r\nclass MirrorEvent extends _AbstractEvent2.default {\r\n  /**\r\n   * Draggables source element\r\n   * @property source\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get source() {\r\n    return this.data.source;\r\n  }\r\n\r\n  /**\r\n   * Draggables original source element\r\n   * @property originalSource\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get originalSource() {\r\n    return this.data.originalSource;\r\n  }\r\n\r\n  /**\r\n   * Draggables source container element\r\n   * @property sourceContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get sourceContainer() {\r\n    return this.data.sourceContainer;\r\n  }\r\n\r\n  /**\r\n   * Sensor event\r\n   * @property sensorEvent\r\n   * @type {SensorEvent}\r\n   * @readonly\r\n   */\r\n  get sensorEvent() {\r\n    return this.data.sensorEvent;\r\n  }\r\n\r\n  /**\r\n   * Drag event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n\r\n  /**\r\n   * Original event that triggered sensor event\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    if (this.sensorEvent) {\r\n      return this.sensorEvent.originalEvent;\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexports.MirrorEvent = MirrorEvent; /**\r\n                                    * Mirror create event\r\n                                    * @class MirrorCreateEvent\r\n                                    * @module MirrorCreateEvent\r\n                                    * @extends MirrorEvent\r\n                                    */\r\n\r\nclass MirrorCreateEvent extends MirrorEvent {}\r\n\r\nexports.MirrorCreateEvent = MirrorCreateEvent; /**\r\n                                                * Mirror created event\r\n                                                * @class MirrorCreatedEvent\r\n                                                * @module MirrorCreatedEvent\r\n                                                * @extends MirrorEvent\r\n                                                */\r\n\r\nMirrorCreateEvent.type = 'mirror:create';\r\nclass MirrorCreatedEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\n\r\nexports.MirrorCreatedEvent = MirrorCreatedEvent; /**\r\n                                                  * Mirror attached event\r\n                                                  * @class MirrorAttachedEvent\r\n                                                  * @module MirrorAttachedEvent\r\n                                                  * @extends MirrorEvent\r\n                                                  */\r\n\r\nMirrorCreatedEvent.type = 'mirror:created';\r\nclass MirrorAttachedEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\n\r\nexports.MirrorAttachedEvent = MirrorAttachedEvent; /**\r\n                                                    * Mirror move event\r\n                                                    * @class MirrorMoveEvent\r\n                                                    * @module MirrorMoveEvent\r\n                                                    * @extends MirrorEvent\r\n                                                    */\r\n\r\nMirrorAttachedEvent.type = 'mirror:attached';\r\nclass MirrorMoveEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n\r\n  /**\r\n   * Sensor has exceeded mirror's threshold on x axis\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  get passedThreshX() {\r\n    return this.data.passedThreshX;\r\n  }\r\n\r\n  /**\r\n   * Sensor has exceeded mirror's threshold on y axis\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  get passedThreshY() {\r\n    return this.data.passedThreshY;\r\n  }\r\n}\r\n\r\nexports.MirrorMoveEvent = MirrorMoveEvent; /**\r\n                                            * Mirror destroy event\r\n                                            * @class MirrorDestroyEvent\r\n                                            * @module MirrorDestroyEvent\r\n                                            * @extends MirrorEvent\r\n                                            */\r\n\r\nMirrorMoveEvent.type = 'mirror:move';\r\nMirrorMoveEvent.cancelable = true;\r\nclass MirrorDestroyEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\nexports.MirrorDestroyEvent = MirrorDestroyEvent;\r\nMirrorDestroyEvent.type = 'mirror:destroy';\r\nMirrorDestroyEvent.cancelable = true;\r\n\r\n/***/ }),\r\n/* 77 */\r\n/***/ (function(module, exports, __nested_webpack_require_118179__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _MirrorEvent = __nested_webpack_require_118179__(76);\r\n\r\nObject.keys(_MirrorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _MirrorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 78 */\r\n/***/ (function(module, exports, __nested_webpack_require_118647__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = exports.getAppendableContainer = exports.onScroll = exports.onMirrorMove = exports.onMirrorCreated = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_118647__(3);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _MirrorEvent = __nested_webpack_require_118647__(77);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\r\n\r\nconst onDragStart = exports.onDragStart = Symbol('onDragStart');\r\nconst onDragMove = exports.onDragMove = Symbol('onDragMove');\r\nconst onDragStop = exports.onDragStop = Symbol('onDragStop');\r\nconst onMirrorCreated = exports.onMirrorCreated = Symbol('onMirrorCreated');\r\nconst onMirrorMove = exports.onMirrorMove = Symbol('onMirrorMove');\r\nconst onScroll = exports.onScroll = Symbol('onScroll');\r\nconst getAppendableContainer = exports.getAppendableContainer = Symbol('getAppendableContainer');\r\n\r\n/**\r\n * Mirror default options\r\n * @property {Object} defaultOptions\r\n * @property {Boolean} defaultOptions.constrainDimensions\r\n * @property {Boolean} defaultOptions.xAxis\r\n * @property {Boolean} defaultOptions.yAxis\r\n * @property {null} defaultOptions.cursorOffsetX\r\n * @property {null} defaultOptions.cursorOffsetY\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  constrainDimensions: false,\r\n  xAxis: true,\r\n  yAxis: true,\r\n  cursorOffsetX: null,\r\n  cursorOffsetY: null,\r\n  thresholdX: null,\r\n  thresholdY: null\r\n};\r\n\r\n/**\r\n * Mirror plugin which controls the mirror positioning while dragging\r\n * @class Mirror\r\n * @module Mirror\r\n * @extends AbstractPlugin\r\n */\r\nclass Mirror extends _AbstractPlugin2.default {\r\n  /**\r\n   * Mirror constructor.\r\n   * @constructs Mirror\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Mirror options\r\n     * @property {Object} options\r\n     * @property {Boolean} options.constrainDimensions\r\n     * @property {Boolean} options.xAxis\r\n     * @property {Boolean} options.yAxis\r\n     * @property {Number|null} options.cursorOffsetX\r\n     * @property {Number|null} options.cursorOffsetY\r\n     * @property {String|HTMLElement|Function} options.appendTo\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Scroll offset for touch devices because the mirror is positioned fixed\r\n     * @property {Object} scrollOffset\r\n     * @property {Number} scrollOffset.x\r\n     * @property {Number} scrollOffset.y\r\n     */\r\n    this.scrollOffset = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Initial scroll offset for touch devices because the mirror is positioned fixed\r\n     * @property {Object} scrollOffset\r\n     * @property {Number} scrollOffset.x\r\n     * @property {Number} scrollOffset.y\r\n     */\r\n    this.initialScrollOffset = {\r\n      x: window.scrollX,\r\n      y: window.scrollY\r\n    };\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\r\n    this[onMirrorMove] = this[onMirrorMove].bind(this);\r\n    this[onScroll] = this[onScroll].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]).on('mirror:created', this[onMirrorCreated]).on('mirror:move', this[onMirrorMove]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]).off('mirror:created', this[onMirrorCreated]).off('mirror:move', this[onMirrorMove]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.mirror || {};\r\n  }\r\n\r\n  [onDragStart](dragEvent) {\r\n    if (dragEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    if ('ontouchstart' in window) {\r\n      document.addEventListener('scroll', this[onScroll], true);\r\n    }\r\n\r\n    this.initialScrollOffset = {\r\n      x: window.scrollX,\r\n      y: window.scrollY\r\n    };\r\n\r\n    const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    // Last sensor position of mirror move\r\n    this.lastMirrorMovedClient = {\r\n      x: sensorEvent.clientX,\r\n      y: sensorEvent.clientY\r\n    };\r\n\r\n    const mirrorCreateEvent = new _MirrorEvent.MirrorCreateEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent\r\n    });\r\n\r\n    this.draggable.trigger(mirrorCreateEvent);\r\n\r\n    if (isNativeDragEvent(sensorEvent) || mirrorCreateEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const appendableContainer = this[getAppendableContainer](source) || sourceContainer;\r\n    this.mirror = source.cloneNode(true);\r\n\r\n    const mirrorCreatedEvent = new _MirrorEvent.MirrorCreatedEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror\r\n    });\r\n\r\n    const mirrorAttachedEvent = new _MirrorEvent.MirrorAttachedEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror\r\n    });\r\n\r\n    this.draggable.trigger(mirrorCreatedEvent);\r\n    appendableContainer.appendChild(this.mirror);\r\n    this.draggable.trigger(mirrorAttachedEvent);\r\n  }\r\n\r\n  [onDragMove](dragEvent) {\r\n    if (!this.mirror || dragEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    let passedThreshX = true;\r\n    let passedThreshY = true;\r\n\r\n    if (this.options.thresholdX || this.options.thresholdY) {\r\n      const { x: lastX, y: lastY } = this.lastMirrorMovedClient;\r\n\r\n      if (Math.abs(lastX - sensorEvent.clientX) < this.options.thresholdX) {\r\n        passedThreshX = false;\r\n      } else {\r\n        this.lastMirrorMovedClient.x = sensorEvent.clientX;\r\n      }\r\n\r\n      if (Math.abs(lastY - sensorEvent.clientY) < this.options.thresholdY) {\r\n        passedThreshY = false;\r\n      } else {\r\n        this.lastMirrorMovedClient.y = sensorEvent.clientY;\r\n      }\r\n\r\n      if (!passedThreshX && !passedThreshY) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const mirrorMoveEvent = new _MirrorEvent.MirrorMoveEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror,\r\n      passedThreshX,\r\n      passedThreshY\r\n    });\r\n\r\n    this.draggable.trigger(mirrorMoveEvent);\r\n  }\r\n\r\n  [onDragStop](dragEvent) {\r\n    if ('ontouchstart' in window) {\r\n      document.removeEventListener('scroll', this[onScroll], true);\r\n    }\r\n\r\n    this.initialScrollOffset = { x: 0, y: 0 };\r\n    this.scrollOffset = { x: 0, y: 0 };\r\n\r\n    if (!this.mirror) {\r\n      return;\r\n    }\r\n\r\n    const { source, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    const mirrorDestroyEvent = new _MirrorEvent.MirrorDestroyEvent({\r\n      source,\r\n      mirror: this.mirror,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent\r\n    });\r\n\r\n    this.draggable.trigger(mirrorDestroyEvent);\r\n\r\n    if (!mirrorDestroyEvent.canceled()) {\r\n      this.mirror.parentNode.removeChild(this.mirror);\r\n    }\r\n  }\r\n\r\n  [onScroll]() {\r\n    this.scrollOffset = {\r\n      x: window.scrollX - this.initialScrollOffset.x,\r\n      y: window.scrollY - this.initialScrollOffset.y\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Mirror created handler\r\n   * @param {MirrorCreatedEvent} mirrorEvent\r\n   * @return {Promise}\r\n   * @private\r\n   */\r\n  [onMirrorCreated]({ mirror, source, sensorEvent }) {\r\n    const mirrorClasses = this.draggable.getClassNamesFor('mirror');\r\n\r\n    const setState = (_ref) => {\r\n      let { mirrorOffset, initialX, initialY } = _ref,\r\n          args = _objectWithoutProperties(_ref, ['mirrorOffset', 'initialX', 'initialY']);\r\n\r\n      this.mirrorOffset = mirrorOffset;\r\n      this.initialX = initialX;\r\n      this.initialY = initialY;\r\n      this.lastMovedX = initialX;\r\n      this.lastMovedY = initialY;\r\n      return _extends({ mirrorOffset, initialX, initialY }, args);\r\n    };\r\n\r\n    mirror.style.display = 'none';\r\n\r\n    const initialState = {\r\n      mirror,\r\n      source,\r\n      sensorEvent,\r\n      mirrorClasses,\r\n      scrollOffset: this.scrollOffset,\r\n      options: this.options,\r\n      passedThreshX: true,\r\n      passedThreshY: true\r\n    };\r\n\r\n    return Promise.resolve(initialState)\r\n    // Fix reflow here\r\n    .then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({ initial: true })).then(removeMirrorID).then(setState);\r\n  }\r\n\r\n  /**\r\n   * Mirror move handler\r\n   * @param {MirrorMoveEvent} mirrorEvent\r\n   * @return {Promise|null}\r\n   * @private\r\n   */\r\n  [onMirrorMove](mirrorEvent) {\r\n    if (mirrorEvent.canceled()) {\r\n      return null;\r\n    }\r\n\r\n    const setState = (_ref2) => {\r\n      let { lastMovedX, lastMovedY } = _ref2,\r\n          args = _objectWithoutProperties(_ref2, ['lastMovedX', 'lastMovedY']);\r\n\r\n      this.lastMovedX = lastMovedX;\r\n      this.lastMovedY = lastMovedY;\r\n\r\n      return _extends({ lastMovedX, lastMovedY }, args);\r\n    };\r\n\r\n    const initialState = {\r\n      mirror: mirrorEvent.mirror,\r\n      sensorEvent: mirrorEvent.sensorEvent,\r\n      mirrorOffset: this.mirrorOffset,\r\n      options: this.options,\r\n      initialX: this.initialX,\r\n      initialY: this.initialY,\r\n      scrollOffset: this.scrollOffset,\r\n      passedThreshX: mirrorEvent.passedThreshX,\r\n      passedThreshY: mirrorEvent.passedThreshY,\r\n      lastMovedX: this.lastMovedX,\r\n      lastMovedY: this.lastMovedY\r\n    };\r\n\r\n    return Promise.resolve(initialState).then(positionMirror({ raf: true })).then(setState);\r\n  }\r\n\r\n  /**\r\n   * Returns appendable container for mirror based on the appendTo option\r\n   * @private\r\n   * @param {Object} options\r\n   * @param {HTMLElement} options.source - Current source\r\n   * @return {HTMLElement}\r\n   */\r\n  [getAppendableContainer](source) {\r\n    const appendTo = this.options.appendTo;\r\n\r\n    if (typeof appendTo === 'string') {\r\n      return document.querySelector(appendTo);\r\n    } else if (appendTo instanceof HTMLElement) {\r\n      return appendTo;\r\n    } else if (typeof appendTo === 'function') {\r\n      return appendTo(source);\r\n    } else {\r\n      return source.parentNode;\r\n    }\r\n  }\r\n}\r\n\r\nexports.default = Mirror; /**\r\n                           * Computes mirror dimensions based on the source element\r\n                           * Adds sourceRect to state\r\n                           * @param {Object} state\r\n                           * @param {HTMLElement} state.source\r\n                           * @return {Promise}\r\n                           * @private\r\n                           */\r\n\r\nfunction computeMirrorDimensions(_ref3) {\r\n  let { source } = _ref3,\r\n      args = _objectWithoutProperties(_ref3, ['source']);\r\n\r\n  return withPromise(resolve => {\r\n    const sourceRect = source.getBoundingClientRect();\r\n    resolve(_extends({ source, sourceRect }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Calculates mirror offset\r\n * Adds mirrorOffset to state\r\n * @param {Object} state\r\n * @param {SensorEvent} state.sensorEvent\r\n * @param {DOMRect} state.sourceRect\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction calculateMirrorOffset(_ref4) {\r\n  let { sensorEvent, sourceRect, options } = _ref4,\r\n      args = _objectWithoutProperties(_ref4, ['sensorEvent', 'sourceRect', 'options']);\r\n\r\n  return withPromise(resolve => {\r\n    const top = options.cursorOffsetY === null ? sensorEvent.clientY - sourceRect.top : options.cursorOffsetY;\r\n    const left = options.cursorOffsetX === null ? sensorEvent.clientX - sourceRect.left : options.cursorOffsetX;\r\n\r\n    const mirrorOffset = { top, left };\r\n\r\n    resolve(_extends({ sensorEvent, sourceRect, mirrorOffset, options }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Applys mirror styles\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {HTMLElement} state.source\r\n * @param {Object} state.options\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction resetMirror(_ref5) {\r\n  let { mirror, source, options } = _ref5,\r\n      args = _objectWithoutProperties(_ref5, ['mirror', 'source', 'options']);\r\n\r\n  return withPromise(resolve => {\r\n    let offsetHeight;\r\n    let offsetWidth;\r\n\r\n    if (options.constrainDimensions) {\r\n      const computedSourceStyles = getComputedStyle(source);\r\n      offsetHeight = computedSourceStyles.getPropertyValue('height');\r\n      offsetWidth = computedSourceStyles.getPropertyValue('width');\r\n    }\r\n\r\n    mirror.style.display = null;\r\n    mirror.style.position = 'fixed';\r\n    mirror.style.pointerEvents = 'none';\r\n    mirror.style.top = 0;\r\n    mirror.style.left = 0;\r\n    mirror.style.margin = 0;\r\n\r\n    if (options.constrainDimensions) {\r\n      mirror.style.height = offsetHeight;\r\n      mirror.style.width = offsetWidth;\r\n    }\r\n\r\n    resolve(_extends({ mirror, source, options }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Applys mirror class on mirror element\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {String[]} state.mirrorClasses\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction addMirrorClasses(_ref6) {\r\n  let { mirror, mirrorClasses } = _ref6,\r\n      args = _objectWithoutProperties(_ref6, ['mirror', 'mirrorClasses']);\r\n\r\n  return withPromise(resolve => {\r\n    mirror.classList.add(...mirrorClasses);\r\n    resolve(_extends({ mirror, mirrorClasses }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Removes source ID from cloned mirror element\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction removeMirrorID(_ref7) {\r\n  let { mirror } = _ref7,\r\n      args = _objectWithoutProperties(_ref7, ['mirror']);\r\n\r\n  return withPromise(resolve => {\r\n    mirror.removeAttribute('id');\r\n    delete mirror.id;\r\n    resolve(_extends({ mirror }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Positions mirror with translate3d\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {SensorEvent} state.sensorEvent\r\n * @param {Object} state.mirrorOffset\r\n * @param {Number} state.initialY\r\n * @param {Number} state.initialX\r\n * @param {Object} state.options\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction positionMirror({ withFrame = false, initial = false } = {}) {\r\n  return (_ref8) => {\r\n    let {\r\n      mirror,\r\n      sensorEvent,\r\n      mirrorOffset,\r\n      initialY,\r\n      initialX,\r\n      scrollOffset,\r\n      options,\r\n      passedThreshX,\r\n      passedThreshY,\r\n      lastMovedX,\r\n      lastMovedY\r\n    } = _ref8,\r\n        args = _objectWithoutProperties(_ref8, ['mirror', 'sensorEvent', 'mirrorOffset', 'initialY', 'initialX', 'scrollOffset', 'options', 'passedThreshX', 'passedThreshY', 'lastMovedX', 'lastMovedY']);\r\n\r\n    return withPromise(resolve => {\r\n      const result = _extends({\r\n        mirror,\r\n        sensorEvent,\r\n        mirrorOffset,\r\n        options\r\n      }, args);\r\n\r\n      if (mirrorOffset) {\r\n        const x = passedThreshX ? Math.round((sensorEvent.clientX - mirrorOffset.left - scrollOffset.x) / (options.thresholdX || 1)) * (options.thresholdX || 1) : Math.round(lastMovedX);\r\n        const y = passedThreshY ? Math.round((sensorEvent.clientY - mirrorOffset.top - scrollOffset.y) / (options.thresholdY || 1)) * (options.thresholdY || 1) : Math.round(lastMovedY);\r\n\r\n        if (options.xAxis && options.yAxis || initial) {\r\n          mirror.style.transform = `translate3d(${x}px, ${y}px, 0)`;\r\n        } else if (options.xAxis && !options.yAxis) {\r\n          mirror.style.transform = `translate3d(${x}px, ${initialY}px, 0)`;\r\n        } else if (options.yAxis && !options.xAxis) {\r\n          mirror.style.transform = `translate3d(${initialX}px, ${y}px, 0)`;\r\n        }\r\n\r\n        if (initial) {\r\n          result.initialX = x;\r\n          result.initialY = y;\r\n        }\r\n\r\n        result.lastMovedX = x;\r\n        result.lastMovedY = y;\r\n      }\r\n\r\n      resolve(result);\r\n    }, { frame: withFrame });\r\n  };\r\n}\r\n\r\n/**\r\n * Wraps functions in promise with potential animation frame option\r\n * @param {Function} callback\r\n * @param {Object} options\r\n * @param {Boolean} options.raf\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction withPromise(callback, { raf = false } = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    if (raf) {\r\n      requestAnimationFrame(() => {\r\n        callback(resolve, reject);\r\n      });\r\n    } else {\r\n      callback(resolve, reject);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Returns true if the sensor event was triggered by a native browser drag event\r\n * @param {SensorEvent} sensorEvent\r\n */\r\nfunction isNativeDragEvent(sensorEvent) {\r\n  return (/^drag/.test(sensorEvent.originalEvent.type)\r\n  );\r\n}\r\n\r\n/***/ }),\r\n/* 79 */\r\n/***/ (function(module, exports, __nested_webpack_require_136161__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Mirror = __nested_webpack_require_136161__(78);\r\n\r\nvar _Mirror2 = _interopRequireDefault(_Mirror);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Mirror2.default;\r\nexports.defaultOptions = _Mirror.defaultOptions;\r\n\r\n/***/ }),\r\n/* 80 */\r\n/***/ (function(module, exports, __nested_webpack_require_136648__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_136648__(3);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onInitialize = Symbol('onInitialize');\r\nconst onDestroy = Symbol('onDestroy');\r\n\r\n/**\r\n * Focusable default options\r\n * @property {Object} defaultOptions\r\n * @type {Object}\r\n */\r\nconst defaultOptions = {};\r\n\r\n/**\r\n * Focusable plugin\r\n * @class Focusable\r\n * @module Focusable\r\n * @extends AbstractPlugin\r\n */\r\nclass Focusable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Focusable constructor.\r\n   * @constructs Focusable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Focusable options\r\n     * @property {Object} options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    this[onInitialize] = this[onInitialize].bind(this);\r\n    this[onDestroy] = this[onDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches listeners to draggable\r\n   */\r\n  attach() {\r\n    this.draggable.on('draggable:initialize', this[onInitialize]).on('draggable:destroy', this[onDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Detaches listeners from draggable\r\n   */\r\n  detach() {\r\n    this.draggable.off('draggable:initialize', this[onInitialize]).off('draggable:destroy', this[onDestroy]);\r\n\r\n    // Remove modified elements when detach\r\n    this[onDestroy]();\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.focusable || {};\r\n  }\r\n\r\n  /**\r\n   * Returns draggable containers and elements\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getElements() {\r\n    return [...this.draggable.containers, ...this.draggable.getDraggableElements()];\r\n  }\r\n\r\n  /**\r\n   * Intialize handler\r\n   * @private\r\n   */\r\n  [onInitialize]() {\r\n    // Can wait until the next best frame is available\r\n    requestAnimationFrame(() => {\r\n      this.getElements().forEach(element => decorateElement(element));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Destroy handler\r\n   * @private\r\n   */\r\n  [onDestroy]() {\r\n    // Can wait until the next best frame is available\r\n    requestAnimationFrame(() => {\r\n      this.getElements().forEach(element => stripElement(element));\r\n    });\r\n  }\r\n}\r\n\r\nexports.default = Focusable; /**\r\n                              * Keeps track of all the elements that are missing tabindex attributes\r\n                              * so they can be reset when draggable gets destroyed\r\n                              * @const {HTMLElement[]} elementsWithMissingTabIndex\r\n                              */\r\n\r\nconst elementsWithMissingTabIndex = [];\r\n\r\n/**\r\n * Decorates element with tabindex attributes\r\n * @param {HTMLElement} element\r\n * @return {Object}\r\n * @private\r\n */\r\nfunction decorateElement(element) {\r\n  const hasMissingTabIndex = Boolean(!element.getAttribute('tabindex') && element.tabIndex === -1);\r\n\r\n  if (hasMissingTabIndex) {\r\n    elementsWithMissingTabIndex.push(element);\r\n    element.tabIndex = 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Removes elements tabindex attributes\r\n * @param {HTMLElement} element\r\n * @private\r\n */\r\nfunction stripElement(element) {\r\n  const tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);\r\n\r\n  if (tabIndexElementPosition !== -1) {\r\n    element.tabIndex = -1;\r\n    elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);\r\n  }\r\n}\r\n\r\n/***/ }),\r\n/* 81 */\r\n/***/ (function(module, exports, __nested_webpack_require_140560__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Focusable = __nested_webpack_require_140560__(80);\r\n\r\nvar _Focusable2 = _interopRequireDefault(_Focusable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Focusable2.default;\r\n\r\n/***/ }),\r\n/* 82 */\r\n/***/ (function(module, exports, __nested_webpack_require_140972__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_140972__(3);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onInitialize = Symbol('onInitialize');\r\nconst onDestroy = Symbol('onDestroy');\r\nconst announceEvent = Symbol('announceEvent');\r\nconst announceMessage = Symbol('announceMessage');\r\n\r\nconst ARIA_RELEVANT = 'aria-relevant';\r\nconst ARIA_ATOMIC = 'aria-atomic';\r\nconst ARIA_LIVE = 'aria-live';\r\nconst ROLE = 'role';\r\n\r\n/**\r\n * Announcement default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.expire\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  expire: 7000\r\n};\r\n\r\n/**\r\n * Announcement plugin\r\n * @class Announcement\r\n * @module Announcement\r\n * @extends AbstractPlugin\r\n */\r\nclass Announcement extends _AbstractPlugin2.default {\r\n  /**\r\n   * Announcement constructor.\r\n   * @constructs Announcement\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Plugin options\r\n     * @property options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Original draggable trigger method. Hack until we have onAll or on('all')\r\n     * @property originalTriggerMethod\r\n     * @type {Function}\r\n     */\r\n    this.originalTriggerMethod = this.draggable.trigger;\r\n\r\n    this[onInitialize] = this[onInitialize].bind(this);\r\n    this[onDestroy] = this[onDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches listeners to draggable\r\n   */\r\n  attach() {\r\n    this.draggable.on('draggable:initialize', this[onInitialize]);\r\n  }\r\n\r\n  /**\r\n   * Detaches listeners from draggable\r\n   */\r\n  detach() {\r\n    this.draggable.off('draggable:destroy', this[onDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Returns passed in options\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.announcements || {};\r\n  }\r\n\r\n  /**\r\n   * Announces event\r\n   * @private\r\n   * @param {AbstractEvent} event\r\n   */\r\n  [announceEvent](event) {\r\n    const message = this.options[event.type];\r\n\r\n    if (message && typeof message === 'string') {\r\n      this[announceMessage](message);\r\n    }\r\n\r\n    if (message && typeof message === 'function') {\r\n      this[announceMessage](message(event));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Announces message to screen reader\r\n   * @private\r\n   * @param {String} message\r\n   */\r\n  [announceMessage](message) {\r\n    announce(message, { expire: this.options.expire });\r\n  }\r\n\r\n  /**\r\n   * Initialize hander\r\n   * @private\r\n   */\r\n  [onInitialize]() {\r\n    // Hack until there is an api for listening for all events\r\n    this.draggable.trigger = event => {\r\n      try {\r\n        this[announceEvent](event);\r\n      } finally {\r\n        // Ensure that original trigger is called\r\n        this.originalTriggerMethod.call(this.draggable, event);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Destroy hander\r\n   * @private\r\n   */\r\n  [onDestroy]() {\r\n    this.draggable.trigger = this.originalTriggerMethod;\r\n  }\r\n}\r\n\r\nexports.default = Announcement; /**\r\n                                 * @const {HTMLElement} liveRegion\r\n                                 */\r\n\r\nconst liveRegion = createRegion();\r\n\r\n/**\r\n * Announces message via live region\r\n * @param {String} message\r\n * @param {Object} options\r\n * @param {Number} options.expire\r\n */\r\nfunction announce(message, { expire }) {\r\n  const element = document.createElement('div');\r\n\r\n  element.textContent = message;\r\n  liveRegion.appendChild(element);\r\n\r\n  return setTimeout(() => {\r\n    liveRegion.removeChild(element);\r\n  }, expire);\r\n}\r\n\r\n/**\r\n * Creates region element\r\n * @return {HTMLElement}\r\n */\r\nfunction createRegion() {\r\n  const element = document.createElement('div');\r\n\r\n  element.setAttribute('id', 'draggable-live-region');\r\n  element.setAttribute(ARIA_RELEVANT, 'additions');\r\n  element.setAttribute(ARIA_ATOMIC, 'true');\r\n  element.setAttribute(ARIA_LIVE, 'assertive');\r\n  element.setAttribute(ROLE, 'log');\r\n\r\n  element.style.position = 'fixed';\r\n  element.style.width = '1px';\r\n  element.style.height = '1px';\r\n  element.style.top = '-1px';\r\n  element.style.overflow = 'hidden';\r\n\r\n  return element;\r\n}\r\n\r\n// Append live region element as early as possible\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  document.body.appendChild(liveRegion);\r\n});\r\n\r\n/***/ }),\r\n/* 83 */\r\n/***/ (function(module, exports, __nested_webpack_require_145860__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Announcement = __nested_webpack_require_145860__(82);\r\n\r\nvar _Announcement2 = _interopRequireDefault(_Announcement);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Announcement2.default;\r\nexports.defaultOptions = _Announcement.defaultOptions;\r\n\r\n/***/ }),\r\n/* 84 */\r\n/***/ (function(module, exports, __nested_webpack_require_146377__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DraggableDestroyEvent = exports.DraggableInitializedEvent = exports.DraggableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_146377__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base draggable event\r\n * @class DraggableEvent\r\n * @module DraggableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DraggableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Draggable instance\r\n   * @property draggable\r\n   * @type {Draggable}\r\n   * @readonly\r\n   */\r\n  get draggable() {\r\n    return this.data.draggable;\r\n  }\r\n}\r\n\r\nexports.DraggableEvent = DraggableEvent; /**\r\n                                          * Draggable initialized event\r\n                                          * @class DraggableInitializedEvent\r\n                                          * @module DraggableInitializedEvent\r\n                                          * @extends DraggableEvent\r\n                                          */\r\n\r\nDraggableEvent.type = 'draggable';\r\nclass DraggableInitializedEvent extends DraggableEvent {}\r\n\r\nexports.DraggableInitializedEvent = DraggableInitializedEvent; /**\r\n                                                                * Draggable destory event\r\n                                                                * @class DraggableInitializedEvent\r\n                                                                * @module DraggableDestroyEvent\r\n                                                                * @extends DraggableDestroyEvent\r\n                                                                */\r\n\r\nDraggableInitializedEvent.type = 'draggable:initialize';\r\nclass DraggableDestroyEvent extends DraggableEvent {}\r\nexports.DraggableDestroyEvent = DraggableDestroyEvent;\r\nDraggableDestroyEvent.type = 'draggable:destroy';\r\n\r\n/***/ }),\r\n/* 85 */\r\n/***/ (function(module, exports, __nested_webpack_require_148441__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DragStoppedEvent = exports.DragStopEvent = exports.DragPressureEvent = exports.DragOutContainerEvent = exports.DragOverContainerEvent = exports.DragOutEvent = exports.DragOverEvent = exports.DragMoveEvent = exports.DragStartEvent = exports.DragEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_148441__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base drag event\r\n * @class DragEvent\r\n * @module DragEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DragEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Draggables source element\r\n   * @property source\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get source() {\r\n    return this.data.source;\r\n  }\r\n\r\n  /**\r\n   * Draggables original source element\r\n   * @property originalSource\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get originalSource() {\r\n    return this.data.originalSource;\r\n  }\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n\r\n  /**\r\n   * Draggables source container element\r\n   * @property sourceContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get sourceContainer() {\r\n    return this.data.sourceContainer;\r\n  }\r\n\r\n  /**\r\n   * Sensor event\r\n   * @property sensorEvent\r\n   * @type {SensorEvent}\r\n   * @readonly\r\n   */\r\n  get sensorEvent() {\r\n    return this.data.sensorEvent;\r\n  }\r\n\r\n  /**\r\n   * Original event that triggered sensor event\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    if (this.sensorEvent) {\r\n      return this.sensorEvent.originalEvent;\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexports.DragEvent = DragEvent; /**\r\n                                * Drag start event\r\n                                * @class DragStartEvent\r\n                                * @module DragStartEvent\r\n                                * @extends DragEvent\r\n                                */\r\n\r\nDragEvent.type = 'drag';\r\nclass DragStartEvent extends DragEvent {}\r\n\r\nexports.DragStartEvent = DragStartEvent; /**\r\n                                          * Drag move event\r\n                                          * @class DragMoveEvent\r\n                                          * @module DragMoveEvent\r\n                                          * @extends DragEvent\r\n                                          */\r\n\r\nDragStartEvent.type = 'drag:start';\r\nDragStartEvent.cancelable = true;\r\nclass DragMoveEvent extends DragEvent {}\r\n\r\nexports.DragMoveEvent = DragMoveEvent; /**\r\n                                        * Drag over event\r\n                                        * @class DragOverEvent\r\n                                        * @module DragOverEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragMoveEvent.type = 'drag:move';\r\nclass DragOverEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you are over\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n}\r\n\r\nexports.DragOverEvent = DragOverEvent; /**\r\n                                        * Drag out event\r\n                                        * @class DragOutEvent\r\n                                        * @module DragOutEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragOverEvent.type = 'drag:over';\r\nDragOverEvent.cancelable = true;\r\nclass DragOutEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you left\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n}\r\n\r\nexports.DragOutEvent = DragOutEvent; /**\r\n                                      * Drag over container event\r\n                                      * @class DragOverContainerEvent\r\n                                      * @module DragOverContainerEvent\r\n                                      * @extends DragEvent\r\n                                      */\r\n\r\nDragOutEvent.type = 'drag:out';\r\nclass DragOverContainerEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.DragOverContainerEvent = DragOverContainerEvent; /**\r\n                                                          * Drag out container event\r\n                                                          * @class DragOutContainerEvent\r\n                                                          * @module DragOutContainerEvent\r\n                                                          * @extends DragEvent\r\n                                                          */\r\n\r\nDragOverContainerEvent.type = 'drag:over:container';\r\nclass DragOutContainerEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you left\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.DragOutContainerEvent = DragOutContainerEvent; /**\r\n                                                        * Drag pressure event\r\n                                                        * @class DragPressureEvent\r\n                                                        * @module DragPressureEvent\r\n                                                        * @extends DragEvent\r\n                                                        */\r\n\r\nDragOutContainerEvent.type = 'drag:out:container';\r\nclass DragPressureEvent extends DragEvent {\r\n\r\n  /**\r\n   * Pressure applied on draggable element\r\n   * @property pressure\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get pressure() {\r\n    return this.data.pressure;\r\n  }\r\n}\r\n\r\nexports.DragPressureEvent = DragPressureEvent; /**\r\n                                                * Drag stop event\r\n                                                * @class DragStopEvent\r\n                                                * @module DragStopEvent\r\n                                                * @extends DragEvent\r\n                                                */\r\n\r\nDragPressureEvent.type = 'drag:pressure';\r\nclass DragStopEvent extends DragEvent {}\r\n\r\nexports.DragStopEvent = DragStopEvent; /**\r\n                                        * Drag stopped event\r\n                                        * @class DragStoppedEvent\r\n                                        * @module DragStoppedEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragStopEvent.type = 'drag:stop';\r\nclass DragStoppedEvent extends DragEvent {}\r\nexports.DragStoppedEvent = DragStoppedEvent;\r\nDragStoppedEvent.type = 'drag:stopped';\r\n\r\n/***/ }),\r\n/* 86 */\r\n/***/ (function(module, exports, __nested_webpack_require_155966__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_155966__(3);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onSortableSorted = Symbol('onSortableSorted');\r\nconst onSortableSort = Symbol('onSortableSort');\r\n\r\n/**\r\n * SortAnimation default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.duration\r\n * @property {String} defaultOptions.easingFunction\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  duration: 150,\r\n  easingFunction: 'ease-in-out'\r\n};\r\n\r\n/**\r\n * SortAnimation plugin adds sort animation for sortable\r\n * @class SortAnimation\r\n * @module SortAnimation\r\n * @extends AbstractPlugin\r\n */\r\nclass SortAnimation extends _AbstractPlugin2.default {\r\n  /**\r\n   * SortAnimation constructor.\r\n   * @constructs SortAnimation\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * SortAnimation options\r\n     * @property {Object} options\r\n     * @property {Number} defaultOptions.duration\r\n     * @property {String} defaultOptions.easingFunction\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Last animation frame\r\n     * @property {Number} lastAnimationFrame\r\n     * @type {Number}\r\n     */\r\n    this.lastAnimationFrame = null;\r\n    this.lastElements = [];\r\n\r\n    this[onSortableSorted] = this[onSortableSorted].bind(this);\r\n    this[onSortableSort] = this[onSortableSort].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('sortable:sort', this[onSortableSort]);\r\n    this.draggable.on('sortable:sorted', this[onSortableSorted]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('sortable:sort', this[onSortableSort]);\r\n    this.draggable.off('sortable:sorted', this[onSortableSorted]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.sortAnimation || {};\r\n  }\r\n\r\n  /**\r\n   * Sortable sort handler\r\n   * @param {SortableSortEvent} sortableEvent\r\n   * @private\r\n   */\r\n  [onSortableSort]({ dragEvent }) {\r\n    const { sourceContainer } = dragEvent;\r\n    const elements = this.draggable.getDraggableElementsForContainer(sourceContainer);\r\n    this.lastElements = Array.from(elements).map(el => {\r\n      return {\r\n        domEl: el,\r\n        offsetTop: el.offsetTop,\r\n        offsetLeft: el.offsetLeft\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sortable sorted handler\r\n   * @param {SortableSortedEvent} sortableEvent\r\n   * @private\r\n   */\r\n  [onSortableSorted]({ oldIndex, newIndex }) {\r\n    if (oldIndex === newIndex) {\r\n      return;\r\n    }\r\n\r\n    const effectedElements = [];\r\n    let start;\r\n    let end;\r\n    let num;\r\n    if (oldIndex > newIndex) {\r\n      start = newIndex;\r\n      end = oldIndex - 1;\r\n      num = 1;\r\n    } else {\r\n      start = oldIndex + 1;\r\n      end = newIndex;\r\n      num = -1;\r\n    }\r\n\r\n    for (let i = start; i <= end; i++) {\r\n      const from = this.lastElements[i];\r\n      const to = this.lastElements[i + num];\r\n      effectedElements.push({ from, to });\r\n    }\r\n    cancelAnimationFrame(this.lastAnimationFrame);\r\n\r\n    // Can be done in a separate frame\r\n    this.lastAnimationFrame = requestAnimationFrame(() => {\r\n      effectedElements.forEach(element => animate(element, this.options));\r\n    });\r\n  }\r\n}\r\n\r\nexports.default = SortAnimation; /**\r\n                                  * Animates two elements\r\n                                  * @param {Object} element\r\n                                  * @param {Object} element.from\r\n                                  * @param {Object} element.to\r\n                                  * @param {Object} options\r\n                                  * @param {Number} options.duration\r\n                                  * @param {String} options.easingFunction\r\n                                  * @private\r\n                                  */\r\n\r\nfunction animate({ from, to }, { duration, easingFunction }) {\r\n  const domEl = from.domEl;\r\n  const x = from.offsetLeft - to.offsetLeft;\r\n  const y = from.offsetTop - to.offsetTop;\r\n\r\n  domEl.style.pointerEvents = 'none';\r\n  domEl.style.transform = `translate3d(${x}px, ${y}px, 0)`;\r\n\r\n  requestAnimationFrame(() => {\r\n    domEl.addEventListener('transitionend', resetElementOnTransitionEnd);\r\n    domEl.style.transition = `transform ${duration}ms ${easingFunction}`;\r\n    domEl.style.transform = '';\r\n  });\r\n}\r\n\r\n/**\r\n * Resets animation style properties after animation has completed\r\n * @param {Event} event\r\n * @private\r\n */\r\nfunction resetElementOnTransitionEnd(event) {\r\n  event.target.style.transition = '';\r\n  event.target.style.pointerEvents = '';\r\n  event.target.removeEventListener('transitionend', resetElementOnTransitionEnd);\r\n}\r\n\r\n/***/ }),\r\n/* 87 */\r\n/***/ (function(module, exports, __nested_webpack_require_161436__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _SortAnimation = __nested_webpack_require_161436__(86);\r\n\r\nvar _SortAnimation2 = _interopRequireDefault(_SortAnimation);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _SortAnimation2.default;\r\nexports.defaultOptions = _SortAnimation.defaultOptions;\r\n\r\n/***/ }),\r\n/* 88 */\r\n/***/ (function(module, exports, __nested_webpack_require_161958__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_161958__(3);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onSortableSorted = Symbol('onSortableSorted');\r\n\r\n/**\r\n * SwapAnimation default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.duration\r\n * @property {String} defaultOptions.easingFunction\r\n * @property {Boolean} defaultOptions.horizontal\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  duration: 150,\r\n  easingFunction: 'ease-in-out',\r\n  horizontal: false\r\n};\r\n\r\n/**\r\n * SwapAnimation plugin adds swap animations for sortable\r\n * @class SwapAnimation\r\n * @module SwapAnimation\r\n * @extends AbstractPlugin\r\n */\r\nclass SwapAnimation extends _AbstractPlugin2.default {\r\n  /**\r\n   * SwapAnimation constructor.\r\n   * @constructs SwapAnimation\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * SwapAnimation options\r\n     * @property {Object} options\r\n     * @property {Number} defaultOptions.duration\r\n     * @property {String} defaultOptions.easingFunction\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Last animation frame\r\n     * @property {Number} lastAnimationFrame\r\n     * @type {Number}\r\n     */\r\n    this.lastAnimationFrame = null;\r\n\r\n    this[onSortableSorted] = this[onSortableSorted].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('sortable:sorted', this[onSortableSorted]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('sortable:sorted', this[onSortableSorted]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.swapAnimation || {};\r\n  }\r\n\r\n  /**\r\n   * Sortable sorted handler\r\n   * @param {SortableSortedEvent} sortableEvent\r\n   * @private\r\n   */\r\n  [onSortableSorted]({ oldIndex, newIndex, dragEvent }) {\r\n    const { source, over } = dragEvent;\r\n\r\n    cancelAnimationFrame(this.lastAnimationFrame);\r\n\r\n    // Can be done in a separate frame\r\n    this.lastAnimationFrame = requestAnimationFrame(() => {\r\n      if (oldIndex >= newIndex) {\r\n        animate(source, over, this.options);\r\n      } else {\r\n        animate(over, source, this.options);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexports.default = SwapAnimation; /**\r\n                                  * Animates two elements\r\n                                  * @param {HTMLElement} from\r\n                                  * @param {HTMLElement} to\r\n                                  * @param {Object} options\r\n                                  * @param {Number} options.duration\r\n                                  * @param {String} options.easingFunction\r\n                                  * @param {String} options.horizontal\r\n                                  * @private\r\n                                  */\r\n\r\nfunction animate(from, to, { duration, easingFunction, horizontal }) {\r\n  for (const element of [from, to]) {\r\n    element.style.pointerEvents = 'none';\r\n  }\r\n\r\n  if (horizontal) {\r\n    const width = from.offsetWidth;\r\n    from.style.transform = `translate3d(${width}px, 0, 0)`;\r\n    to.style.transform = `translate3d(-${width}px, 0, 0)`;\r\n  } else {\r\n    const height = from.offsetHeight;\r\n    from.style.transform = `translate3d(0, ${height}px, 0)`;\r\n    to.style.transform = `translate3d(0, -${height}px, 0)`;\r\n  }\r\n\r\n  requestAnimationFrame(() => {\r\n    for (const element of [from, to]) {\r\n      element.addEventListener('transitionend', resetElementOnTransitionEnd);\r\n      element.style.transition = `transform ${duration}ms ${easingFunction}`;\r\n      element.style.transform = '';\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Resets animation style properties after animation has completed\r\n * @param {Event} event\r\n * @private\r\n */\r\nfunction resetElementOnTransitionEnd(event) {\r\n  event.target.style.transition = '';\r\n  event.target.style.pointerEvents = '';\r\n  event.target.removeEventListener('transitionend', resetElementOnTransitionEnd);\r\n}\r\n\r\n/***/ }),\r\n/* 89 */\r\n/***/ (function(module, exports, __nested_webpack_require_166692__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _SwapAnimation = __nested_webpack_require_166692__(88);\r\n\r\nvar _SwapAnimation2 = _interopRequireDefault(_SwapAnimation);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _SwapAnimation2.default;\r\nexports.defaultOptions = _SwapAnimation.defaultOptions;\r\n\r\n/***/ }),\r\n/* 90 */\r\n/***/ (function(module, exports, __nested_webpack_require_167214__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_167214__(3);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _SnappableEvent = __nested_webpack_require_167214__(45);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragOut = Symbol('onDragOut');\r\nconst onMirrorCreated = Symbol('onMirrorCreated');\r\nconst onMirrorDestroy = Symbol('onMirrorDestroy');\r\n\r\n/**\r\n * Snappable plugin which snaps draggable elements into place\r\n * @class Snappable\r\n * @module Snappable\r\n * @extends AbstractPlugin\r\n */\r\nclass Snappable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Snappable constructor.\r\n   * @constructs Snappable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Keeps track of the first source element\r\n     * @property {HTMLElement|null} firstSource\r\n     */\r\n    this.firstSource = null;\r\n\r\n    /**\r\n     * Keeps track of the mirror element\r\n     * @property {HTMLElement} mirror\r\n     */\r\n    this.mirror = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragOut] = this[onDragOut].bind(this);\r\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\r\n    this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:stop', this[onDragStop]).on('drag:over', this[onDragOver]).on('drag:out', this[onDragOut]).on('droppable:over', this[onDragOver]).on('droppable:out', this[onDragOut]).on('mirror:created', this[onMirrorCreated]).on('mirror:destroy', this[onMirrorDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:stop', this[onDragStop]).off('drag:over', this[onDragOver]).off('drag:out', this[onDragOut]).off('droppable:over', this[onDragOver]).off('droppable:out', this[onDragOut]).off('mirror:created', this[onMirrorCreated]).off('mirror:destroy', this[onMirrorDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {DragStartEvent} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    this.firstSource = event.source;\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop]() {\r\n    this.firstSource = null;\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {DragOverEvent|DroppableOverEvent} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const source = event.source || event.dragEvent.source;\r\n\r\n    if (source === this.firstSource) {\r\n      this.firstSource = null;\r\n      return;\r\n    }\r\n\r\n    const snapInEvent = new _SnappableEvent.SnapInEvent({\r\n      dragEvent: event,\r\n      snappable: event.over || event.droppable\r\n    });\r\n\r\n    this.draggable.trigger(snapInEvent);\r\n\r\n    if (snapInEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    if (this.mirror) {\r\n      this.mirror.style.display = 'none';\r\n    }\r\n\r\n    source.classList.remove(...this.draggable.getClassNamesFor('source:dragging'));\r\n    source.classList.add(...this.draggable.getClassNamesFor('source:placed'));\r\n\r\n    // Need to cancel this in drag out\r\n    setTimeout(() => {\r\n      source.classList.remove(...this.draggable.getClassNamesFor('source:placed'));\r\n    }, this.draggable.options.placedTimeout);\r\n  }\r\n\r\n  /**\r\n   * Drag out handler\r\n   * @private\r\n   * @param {DragOutEvent|DroppableOutEvent} event - Drag out event\r\n   */\r\n  [onDragOut](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const source = event.source || event.dragEvent.source;\r\n\r\n    const snapOutEvent = new _SnappableEvent.SnapOutEvent({\r\n      dragEvent: event,\r\n      snappable: event.over || event.droppable\r\n    });\r\n\r\n    this.draggable.trigger(snapOutEvent);\r\n\r\n    if (snapOutEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    if (this.mirror) {\r\n      this.mirror.style.display = '';\r\n    }\r\n\r\n    source.classList.add(...this.draggable.getClassNamesFor('source:dragging'));\r\n  }\r\n\r\n  /**\r\n   * Mirror created handler\r\n   * @param {MirrorCreatedEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorCreated]({ mirror }) {\r\n    this.mirror = mirror;\r\n  }\r\n\r\n  /**\r\n   * Mirror destroy handler\r\n   * @param {MirrorDestroyEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorDestroy]() {\r\n    this.mirror = null;\r\n  }\r\n}\r\nexports.default = Snappable;\r\n\r\n/***/ }),\r\n/* 91 */\r\n/***/ (function(module, exports, __nested_webpack_require_172201__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.SnapOutEvent = exports.SnapInEvent = exports.SnapEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_172201__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base snap event\r\n * @class SnapEvent\r\n * @module SnapEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SnapEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Drag event that triggered this snap event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n\r\n  /**\r\n   * Snappable element\r\n   * @property snappable\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get snappable() {\r\n    return this.data.snappable;\r\n  }\r\n}\r\n\r\nexports.SnapEvent = SnapEvent; /**\r\n                                * Snap in event\r\n                                * @class SnapInEvent\r\n                                * @module SnapInEvent\r\n                                * @extends SnapEvent\r\n                                */\r\n\r\nSnapEvent.type = 'snap';\r\nclass SnapInEvent extends SnapEvent {}\r\n\r\nexports.SnapInEvent = SnapInEvent; /**\r\n                                    * Snap out event\r\n                                    * @class SnapOutEvent\r\n                                    * @module SnapOutEvent\r\n                                    * @extends SnapEvent\r\n                                    */\r\n\r\nSnapInEvent.type = 'snap:in';\r\nSnapInEvent.cancelable = true;\r\nclass SnapOutEvent extends SnapEvent {}\r\nexports.SnapOutEvent = SnapOutEvent;\r\nSnapOutEvent.type = 'snap:out';\r\nSnapOutEvent.cancelable = true;\r\n\r\n/***/ }),\r\n/* 92 */\r\n/***/ (function(module, exports, __nested_webpack_require_174048__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SnappableEvent = __nested_webpack_require_174048__(45);\r\n\r\nObject.keys(_SnappableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SnappableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Snappable = __nested_webpack_require_174048__(90);\r\n\r\nvar _Snappable2 = _interopRequireDefault(_Snappable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Snappable2.default;\r\n\r\n/***/ }),\r\n/* 93 */\r\n/***/ (function(module, exports, __nested_webpack_require_174768__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_174768__(3);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _utils = __nested_webpack_require_174768__(5);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMirrorCreated = Symbol('onMirrorCreated');\r\nconst onMirrorDestroy = Symbol('onMirrorDestroy');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst resize = Symbol('resize');\r\n\r\n/**\r\n * ResizeMirror default options\r\n * @property {Object} defaultOptions\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {};\r\n\r\n/**\r\n * The ResizeMirror plugin resizes the mirror element to the dimensions of the draggable element that the mirror is hovering over\r\n * @class ResizeMirror\r\n * @module ResizeMirror\r\n * @extends AbstractPlugin\r\n */\r\nclass ResizeMirror extends _AbstractPlugin2.default {\r\n  /**\r\n   * ResizeMirror constructor.\r\n   * @constructs ResizeMirror\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * ResizeMirror options\r\n     * @property {Object} options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * ResizeMirror remembers the last width when resizing the mirror\r\n     * to avoid additional writes to the DOM\r\n     * @property {number} lastWidth\r\n     */\r\n    this.lastWidth = 0;\r\n\r\n    /**\r\n     * ResizeMirror remembers the last height when resizing the mirror\r\n     * to avoid additional writes to the DOM\r\n     * @property {number} lastHeight\r\n     */\r\n    this.lastHeight = 0;\r\n\r\n    /**\r\n     * Keeps track of the mirror element\r\n     * @property {HTMLElement} mirror\r\n     */\r\n    this.mirror = null;\r\n\r\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\r\n    this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('mirror:created', this[onMirrorCreated]).on('drag:over', this[onDragOver]).on('drag:over:container', this[onDragOver]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('mirror:created', this[onMirrorCreated]).off('mirror:destroy', this[onMirrorDestroy]).off('drag:over', this[onDragOver]).off('drag:over:container', this[onDragOver]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.resizeMirror || {};\r\n  }\r\n\r\n  /**\r\n   * Mirror created handler\r\n   * @param {MirrorCreatedEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorCreated]({ mirror }) {\r\n    this.mirror = mirror;\r\n  }\r\n\r\n  /**\r\n   * Mirror destroy handler\r\n   * @param {MirrorDestroyEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorDestroy]() {\r\n    this.mirror = null;\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @param {DragOverEvent | DragOverContainer} dragEvent\r\n   * @private\r\n   */\r\n  [onDragOver](dragEvent) {\r\n    this[resize](dragEvent);\r\n  }\r\n\r\n  /**\r\n   * Resize function for\r\n   * @param {DragOverEvent | DragOverContainer} dragEvent\r\n   * @private\r\n   */\r\n  [resize]({ overContainer, over }) {\r\n    requestAnimationFrame(() => {\r\n      if (!this.mirror.parentNode) {\r\n        return;\r\n      }\r\n\r\n      if (this.mirror.parentNode !== overContainer) {\r\n        overContainer.appendChild(this.mirror);\r\n      }\r\n\r\n      const overElement = over || this.draggable.getDraggableElementsForContainer(overContainer)[0];\r\n\r\n      if (!overElement) {\r\n        return;\r\n      }\r\n\r\n      (0, _utils.requestNextAnimationFrame)(() => {\r\n        const overRect = overElement.getBoundingClientRect();\r\n\r\n        if (this.lastHeight === overRect.height && this.lastWidth === overRect.width) {\r\n          return;\r\n        }\r\n\r\n        this.mirror.style.width = `${overRect.width}px`;\r\n        this.mirror.style.height = `${overRect.height}px`;\r\n\r\n        this.lastWidth = overRect.width;\r\n        this.lastHeight = overRect.height;\r\n      });\r\n    });\r\n  }\r\n}\r\nexports.default = ResizeMirror;\r\n\r\n/***/ }),\r\n/* 94 */\r\n/***/ (function(module, exports, __nested_webpack_require_179369__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _ResizeMirror = __nested_webpack_require_179369__(93);\r\n\r\nvar _ResizeMirror2 = _interopRequireDefault(_ResizeMirror);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _ResizeMirror2.default;\r\nexports.defaultOptions = _ResizeMirror.defaultOptions;\r\n\r\n/***/ }),\r\n/* 95 */\r\n/***/ (function(module, exports, __nested_webpack_require_179886__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_179886__(3);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _utils = __nested_webpack_require_179886__(5);\r\n\r\nvar _CollidableEvent = __nested_webpack_require_179886__(46);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragMove = Symbol('onDragMove');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst onRequestAnimationFrame = Symbol('onRequestAnimationFrame');\r\n\r\n/**\r\n * Collidable plugin which detects colliding elements while dragging\r\n * @class Collidable\r\n * @module Collidable\r\n * @extends AbstractPlugin\r\n */\r\nclass Collidable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Collidable constructor.\r\n   * @constructs Collidable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Keeps track of currently colliding elements\r\n     * @property {HTMLElement|null} currentlyCollidingElement\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.currentlyCollidingElement = null;\r\n\r\n    /**\r\n     * Keeps track of currently colliding elements\r\n     * @property {HTMLElement|null} lastCollidingElement\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.lastCollidingElement = null;\r\n\r\n    /**\r\n     * Animation frame for finding colliding elements\r\n     * @property {Number|null} currentAnimationFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.currentAnimationFrame = null;\r\n\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onRequestAnimationFrame] = this[onRequestAnimationFrame].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Returns current collidables based on `collidables` option\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getCollidables() {\r\n    const collidables = this.draggable.options.collidables;\r\n\r\n    if (typeof collidables === 'string') {\r\n      return Array.prototype.slice.call(document.querySelectorAll(collidables));\r\n    } else if (collidables instanceof NodeList || collidables instanceof Array) {\r\n      return Array.prototype.slice.call(collidables);\r\n    } else if (collidables instanceof HTMLElement) {\r\n      return [collidables];\r\n    } else if (typeof collidables === 'function') {\r\n      return collidables();\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag move handler\r\n   * @private\r\n   * @param {DragMoveEvent} event - Drag move event\r\n   */\r\n  [onDragMove](event) {\r\n    const target = event.sensorEvent.target;\r\n\r\n    this.currentAnimationFrame = requestAnimationFrame(this[onRequestAnimationFrame](target));\r\n\r\n    if (this.currentlyCollidingElement) {\r\n      event.cancel();\r\n    }\r\n\r\n    const collidableInEvent = new _CollidableEvent.CollidableInEvent({\r\n      dragEvent: event,\r\n      collidingElement: this.currentlyCollidingElement\r\n    });\r\n\r\n    const collidableOutEvent = new _CollidableEvent.CollidableOutEvent({\r\n      dragEvent: event,\r\n      collidingElement: this.lastCollidingElement\r\n    });\r\n\r\n    const enteringCollidable = Boolean(this.currentlyCollidingElement && this.lastCollidingElement !== this.currentlyCollidingElement);\r\n    const leavingCollidable = Boolean(!this.currentlyCollidingElement && this.lastCollidingElement);\r\n\r\n    if (enteringCollidable) {\r\n      if (this.lastCollidingElement) {\r\n        this.draggable.trigger(collidableOutEvent);\r\n      }\r\n\r\n      this.draggable.trigger(collidableInEvent);\r\n    } else if (leavingCollidable) {\r\n      this.draggable.trigger(collidableOutEvent);\r\n    }\r\n\r\n    this.lastCollidingElement = this.currentlyCollidingElement;\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop](event) {\r\n    const lastCollidingElement = this.currentlyCollidingElement || this.lastCollidingElement;\r\n    const collidableOutEvent = new _CollidableEvent.CollidableOutEvent({\r\n      dragEvent: event,\r\n      collidingElement: lastCollidingElement\r\n    });\r\n\r\n    if (lastCollidingElement) {\r\n      this.draggable.trigger(collidableOutEvent);\r\n    }\r\n\r\n    this.lastCollidingElement = null;\r\n    this.currentlyCollidingElement = null;\r\n  }\r\n\r\n  /**\r\n   * Animation frame function\r\n   * @private\r\n   * @param {HTMLElement} target - Current move target\r\n   * @return {Function}\r\n   */\r\n  [onRequestAnimationFrame](target) {\r\n    return () => {\r\n      const collidables = this.getCollidables();\r\n      this.currentlyCollidingElement = (0, _utils.closest)(target, element => collidables.includes(element));\r\n    };\r\n  }\r\n}\r\nexports.default = Collidable;\r\n\r\n/***/ }),\r\n/* 96 */\r\n/***/ (function(module, exports, __nested_webpack_require_184949__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.CollidableOutEvent = exports.CollidableInEvent = exports.CollidableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_184949__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base collidable event\r\n * @class CollidableEvent\r\n * @module CollidableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass CollidableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Drag event that triggered this colliable event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n}\r\n\r\nexports.CollidableEvent = CollidableEvent; /**\r\n                                            * Collidable in event\r\n                                            * @class CollidableInEvent\r\n                                            * @module CollidableInEvent\r\n                                            * @extends CollidableEvent\r\n                                            */\r\n\r\nCollidableEvent.type = 'collidable';\r\nclass CollidableInEvent extends CollidableEvent {\r\n\r\n  /**\r\n   * Element you are currently colliding with\r\n   * @property collidingElement\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get collidingElement() {\r\n    return this.data.collidingElement;\r\n  }\r\n}\r\n\r\nexports.CollidableInEvent = CollidableInEvent; /**\r\n                                                * Collidable out event\r\n                                                * @class CollidableOutEvent\r\n                                                * @module CollidableOutEvent\r\n                                                * @extends CollidableEvent\r\n                                                */\r\n\r\nCollidableInEvent.type = 'collidable:in';\r\nclass CollidableOutEvent extends CollidableEvent {\r\n\r\n  /**\r\n   * Element you were previously colliding with\r\n   * @property collidingElement\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get collidingElement() {\r\n    return this.data.collidingElement;\r\n  }\r\n}\r\nexports.CollidableOutEvent = CollidableOutEvent;\r\nCollidableOutEvent.type = 'collidable:out';\r\n\r\n/***/ }),\r\n/* 97 */\r\n/***/ (function(module, exports, __nested_webpack_require_187303__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _CollidableEvent = __nested_webpack_require_187303__(46);\r\n\r\nObject.keys(_CollidableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _CollidableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Collidable = __nested_webpack_require_187303__(95);\r\n\r\nvar _Collidable2 = _interopRequireDefault(_Collidable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Collidable2.default;\r\n\r\n/***/ }),\r\n/* 98 */\r\n/***/ (function(module, exports, __nested_webpack_require_188030__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Collidable = __nested_webpack_require_188030__(97);\r\n\r\nObject.defineProperty(exports, 'Collidable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Collidable).default;\r\n  }\r\n});\r\n\r\nvar _ResizeMirror = __nested_webpack_require_188030__(94);\r\n\r\nObject.defineProperty(exports, 'ResizeMirror', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_ResizeMirror).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultResizeMirrorOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _ResizeMirror.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Snappable = __nested_webpack_require_188030__(92);\r\n\r\nObject.defineProperty(exports, 'Snappable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Snappable).default;\r\n  }\r\n});\r\n\r\nvar _SwapAnimation = __nested_webpack_require_188030__(89);\r\n\r\nObject.defineProperty(exports, 'SwapAnimation', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_SwapAnimation).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultSwapAnimationOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _SwapAnimation.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _SortAnimation = __nested_webpack_require_188030__(87);\r\n\r\nObject.defineProperty(exports, 'SortAnimation', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_SortAnimation).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultSortAnimationOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _SortAnimation.defaultOptions;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 99 */\r\n/***/ (function(module, exports, __nested_webpack_require_189830__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_189830__(17);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_189830__(16);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMouseForceWillBegin = Symbol('onMouseForceWillBegin');\r\nconst onMouseForceDown = Symbol('onMouseForceDown');\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseForceChange = Symbol('onMouseForceChange');\r\nconst onMouseMove = Symbol('onMouseMove');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst onMouseForceGlobalChange = Symbol('onMouseForceGlobalChange');\r\n\r\n/**\r\n * This sensor picks up native force touch events and dictates drag operations\r\n * @class ForceTouchSensor\r\n * @module ForceTouchSensor\r\n * @extends Sensor\r\n */\r\nclass ForceTouchSensor extends _Sensor2.default {\r\n  /**\r\n   * ForceTouchSensor constructor.\r\n   * @constructs ForceTouchSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed\r\n     * @property mightDrag\r\n     * @type {Boolean}\r\n     */\r\n    this.mightDrag = false;\r\n\r\n    this[onMouseForceWillBegin] = this[onMouseForceWillBegin].bind(this);\r\n    this[onMouseForceDown] = this[onMouseForceDown].bind(this);\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseForceChange] = this[onMouseForceChange].bind(this);\r\n    this[onMouseMove] = this[onMouseMove].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    for (const container of this.containers) {\r\n      container.addEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\r\n      container.addEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\r\n      container.addEventListener('mousedown', this[onMouseDown], true);\r\n      container.addEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\r\n    }\r\n\r\n    document.addEventListener('mousemove', this[onMouseMove]);\r\n    document.addEventListener('mouseup', this[onMouseUp]);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    for (const container of this.containers) {\r\n      container.removeEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\r\n      container.removeEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\r\n      container.removeEventListener('mousedown', this[onMouseDown], true);\r\n      container.removeEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\r\n    }\r\n\r\n    document.removeEventListener('mousemove', this[onMouseMove]);\r\n    document.removeEventListener('mouseup', this[onMouseUp]);\r\n  }\r\n\r\n  /**\r\n   * Mouse force will begin handler\r\n   * @private\r\n   * @param {Event} event - Mouse force will begin event\r\n   */\r\n  [onMouseForceWillBegin](event) {\r\n    event.preventDefault();\r\n    this.mightDrag = true;\r\n  }\r\n\r\n  /**\r\n   * Mouse force down handler\r\n   * @private\r\n   * @param {Event} event - Mouse force down event\r\n   */\r\n  [onMouseForceDown](event) {\r\n    if (this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = event.currentTarget;\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragStartEvent);\r\n\r\n    this.currentContainer = container;\r\n    this.dragging = !dragStartEvent.canceled();\r\n    this.mightDrag = false;\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target: null,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.mightDrag = false;\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    if (!this.mightDrag) {\r\n      return;\r\n    }\r\n\r\n    // Need workaround for real click\r\n    // Cancel potential drag events\r\n    event.stopPropagation();\r\n    event.stopImmediatePropagation();\r\n    event.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler\r\n   * @private\r\n   * @param {Event} event - Mouse force will begin event\r\n   */\r\n  [onMouseMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse force change handler\r\n   * @private\r\n   * @param {Event} event - Mouse force change event\r\n   */\r\n  [onMouseForceChange](event) {\r\n    if (this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = event.target;\r\n    const container = event.currentTarget;\r\n\r\n    const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({\r\n      pressure: event.webkitForce,\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragPressureEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse force global change handler\r\n   * @private\r\n   * @param {Event} event - Mouse force global change event\r\n   */\r\n  [onMouseForceGlobalChange](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = event.target;\r\n\r\n    const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({\r\n      pressure: event.webkitForce,\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragPressureEvent);\r\n  }\r\n}\r\nexports.default = ForceTouchSensor;\r\n\r\n/***/ }),\r\n/* 100 */\r\n/***/ (function(module, exports, __nested_webpack_require_196573__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _ForceTouchSensor = __nested_webpack_require_196573__(99);\r\n\r\nvar _ForceTouchSensor2 = _interopRequireDefault(_ForceTouchSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _ForceTouchSensor2.default;\r\n\r\n/***/ }),\r\n/* 101 */\r\n/***/ (function(module, exports, __nested_webpack_require_197014__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_197014__(5);\r\n\r\nvar _Sensor = __nested_webpack_require_197014__(17);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_197014__(16);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragEnd = Symbol('onDragEnd');\r\nconst onDrop = Symbol('onDrop');\r\nconst reset = Symbol('reset');\r\n\r\n/**\r\n * This sensor picks up native browser drag events and dictates drag operations\r\n * @class DragSensor\r\n * @module DragSensor\r\n * @extends Sensor\r\n */\r\nclass DragSensor extends _Sensor2.default {\r\n  /**\r\n   * DragSensor constructor.\r\n   * @constructs DragSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Mouse down timer which will end up setting the draggable attribute, unless canceled\r\n     * @property mouseDownTimeout\r\n     * @type {Number}\r\n     */\r\n    this.mouseDownTimeout = null;\r\n\r\n    /**\r\n     * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed\r\n     * @property draggableElement\r\n     * @type {HTMLElement}\r\n     */\r\n    this.draggableElement = null;\r\n\r\n    /**\r\n     * Native draggable element could be links or images, their draggable state will be disabled during drag operation\r\n     * @property nativeDraggableElement\r\n     * @type {HTMLElement}\r\n     */\r\n    this.nativeDraggableElement = null;\r\n\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragEnd] = this[onDragEnd].bind(this);\r\n    this[onDrop] = this[onDrop].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {Event} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    // Need for firefox. \"text\" key is needed for IE\r\n    event.dataTransfer.setData('text', '');\r\n    event.dataTransfer.effectAllowed = this.options.type;\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    this.currentContainer = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!this.currentContainer) {\r\n      return;\r\n    }\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    // Workaround\r\n    setTimeout(() => {\r\n      this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n      if (dragStartEvent.canceled()) {\r\n        this.dragging = false;\r\n      } else {\r\n        this.dragging = true;\r\n      }\r\n    }, 0);\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {Event} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = this.currentContainer;\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragMoveEvent);\r\n\r\n    if (!dragMoveEvent.canceled()) {\r\n      event.preventDefault();\r\n      event.dataTransfer.dropEffect = this.options.type;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag end handler\r\n   * @private\r\n   * @param {Event} event - Drag end event\r\n   */\r\n  [onDragEnd](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp], true);\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = this.currentContainer;\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragStopEvent);\r\n\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n\r\n    this[reset]();\r\n  }\r\n\r\n  /**\r\n   * Drop handler\r\n   * @private\r\n   * @param {Event} event - Drop event\r\n   */\r\n  [onDrop](event) {\r\n    // eslint-disable-line class-methods-use-this\r\n    event.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    // Firefox bug for inputs within draggables https://bugzilla.mozilla.org/show_bug.cgi?id=739071\r\n    if (event.target && (event.target.form || event.target.contenteditable)) {\r\n      return;\r\n    }\r\n\r\n    const nativeDraggableElement = (0, _utils.closest)(event.target, element => element.draggable);\r\n\r\n    if (nativeDraggableElement) {\r\n      nativeDraggableElement.draggable = false;\r\n      this.nativeDraggableElement = nativeDraggableElement;\r\n    }\r\n\r\n    document.addEventListener('mouseup', this[onMouseUp], true);\r\n    document.addEventListener('dragstart', this[onDragStart], false);\r\n    document.addEventListener('dragover', this[onDragOver], false);\r\n    document.addEventListener('dragend', this[onDragEnd], false);\r\n    document.addEventListener('drop', this[onDrop], false);\r\n\r\n    const target = (0, _utils.closest)(event.target, this.options.draggable);\r\n\r\n    if (!target) {\r\n      return;\r\n    }\r\n\r\n    this.startEvent = event;\r\n\r\n    this.mouseDownTimeout = setTimeout(() => {\r\n      target.draggable = true;\r\n      this.draggableElement = target;\r\n    }, this.delay.drag);\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp]() {\r\n    this[reset]();\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [reset]() {\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp], true);\r\n    document.removeEventListener('dragstart', this[onDragStart], false);\r\n    document.removeEventListener('dragover', this[onDragOver], false);\r\n    document.removeEventListener('dragend', this[onDragEnd], false);\r\n    document.removeEventListener('drop', this[onDrop], false);\r\n\r\n    if (this.nativeDraggableElement) {\r\n      this.nativeDraggableElement.draggable = true;\r\n      this.nativeDraggableElement = null;\r\n    }\r\n\r\n    if (this.draggableElement) {\r\n      this.draggableElement.draggable = false;\r\n      this.draggableElement = null;\r\n    }\r\n  }\r\n}\r\nexports.default = DragSensor;\r\n\r\n/***/ }),\r\n/* 102 */\r\n/***/ (function(module, exports, __nested_webpack_require_204290__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragSensor = __nested_webpack_require_204290__(101);\r\n\r\nvar _DragSensor2 = _interopRequireDefault(_DragSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _DragSensor2.default;\r\n\r\n/***/ }),\r\n/* 103 */\r\n/***/ (function(module, exports, __nested_webpack_require_204708__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_204708__(5);\r\n\r\nvar _Sensor = __nested_webpack_require_204708__(17);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_204708__(16);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onTouchStart = Symbol('onTouchStart');\r\nconst onTouchEnd = Symbol('onTouchEnd');\r\nconst onTouchMove = Symbol('onTouchMove');\r\nconst startDrag = Symbol('startDrag');\r\nconst onDistanceChange = Symbol('onDistanceChange');\r\n\r\n/**\r\n * Prevents scrolling when set to true\r\n * @var {Boolean} preventScrolling\r\n */\r\nlet preventScrolling = false;\r\n\r\n// WebKit requires cancelable `touchmove` events to be added as early as possible\r\nwindow.addEventListener('touchmove', event => {\r\n  if (!preventScrolling) {\r\n    return;\r\n  }\r\n\r\n  // Prevent scrolling\r\n  event.preventDefault();\r\n}, { passive: false });\r\n\r\n/**\r\n * This sensor picks up native browser touch events and dictates drag operations\r\n * @class TouchSensor\r\n * @module TouchSensor\r\n * @extends Sensor\r\n */\r\nclass TouchSensor extends _Sensor2.default {\r\n  /**\r\n   * TouchSensor constructor.\r\n   * @constructs TouchSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Closest scrollable container so accidental scroll can cancel long touch\r\n     * @property currentScrollableParent\r\n     * @type {HTMLElement}\r\n     */\r\n    this.currentScrollableParent = null;\r\n\r\n    /**\r\n     * TimeoutID for managing delay\r\n     * @property tapTimeout\r\n     * @type {Number}\r\n     */\r\n    this.tapTimeout = null;\r\n\r\n    /**\r\n     * touchMoved indicates if touch has moved during tapTimeout\r\n     * @property touchMoved\r\n     * @type {Boolean}\r\n     */\r\n    this.touchMoved = false;\r\n\r\n    /**\r\n     * Save pageX coordinates for delay drag\r\n     * @property {Numbre} pageX\r\n     * @private\r\n     */\r\n    this.pageX = null;\r\n\r\n    /**\r\n     * Save pageY coordinates for delay drag\r\n     * @property {Numbre} pageY\r\n     * @private\r\n     */\r\n    this.pageY = null;\r\n\r\n    this[onTouchStart] = this[onTouchStart].bind(this);\r\n    this[onTouchEnd] = this[onTouchEnd].bind(this);\r\n    this[onTouchMove] = this[onTouchMove].bind(this);\r\n    this[startDrag] = this[startDrag].bind(this);\r\n    this[onDistanceChange] = this[onDistanceChange].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('touchstart', this[onTouchStart]);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('touchstart', this[onTouchStart]);\r\n  }\r\n\r\n  /**\r\n   * Touch start handler\r\n   * @private\r\n   * @param {Event} event - Touch start event\r\n   */\r\n  [onTouchStart](event) {\r\n    const container = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!container) {\r\n      return;\r\n    }\r\n    const { distance = 0 } = this.options;\r\n    const { delay } = this;\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n    this.onTouchStartAt = Date.now();\r\n    this.startEvent = event;\r\n    this.currentContainer = container;\r\n\r\n    document.addEventListener('touchend', this[onTouchEnd]);\r\n    document.addEventListener('touchcancel', this[onTouchEnd]);\r\n    document.addEventListener('touchmove', this[onDistanceChange]);\r\n    container.addEventListener('contextmenu', onContextMenu);\r\n\r\n    if (distance) {\r\n      preventScrolling = true;\r\n    }\r\n\r\n    this.tapTimeout = window.setTimeout(() => {\r\n      this[onDistanceChange]({ touches: [{ pageX: this.pageX, pageY: this.pageY }] });\r\n    }, delay.touch);\r\n  }\r\n\r\n  /**\r\n   * Start the drag\r\n   * @private\r\n   */\r\n  [startDrag]() {\r\n    const startEvent = this.startEvent;\r\n    const container = this.currentContainer;\r\n    const touch = (0, _utils.touchCoords)(startEvent);\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: touch.pageX,\r\n      clientY: touch.pageY,\r\n      target: startEvent.target,\r\n      container,\r\n      originalEvent: startEvent\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n    this.dragging = !dragStartEvent.canceled();\r\n\r\n    if (this.dragging) {\r\n      document.addEventListener('touchmove', this[onTouchMove]);\r\n    }\r\n    preventScrolling = this.dragging;\r\n  }\r\n\r\n  /**\r\n   * Touch move handler prior to drag start.\r\n   * @private\r\n   * @param {Event} event - Touch move event\r\n   */\r\n  [onDistanceChange](event) {\r\n    const { distance } = this.options;\r\n    const { startEvent, delay } = this;\r\n    const start = (0, _utils.touchCoords)(startEvent);\r\n    const current = (0, _utils.touchCoords)(event);\r\n    const timeElapsed = Date.now() - this.onTouchStartAt;\r\n    const distanceTravelled = (0, _utils.distance)(start.pageX, start.pageY, current.pageX, current.pageY);\r\n\r\n    Object.assign(this, current);\r\n\r\n    clearTimeout(this.tapTimeout);\r\n\r\n    if (timeElapsed < delay.touch) {\r\n      // moved during delay\r\n      document.removeEventListener('touchmove', this[onDistanceChange]);\r\n    } else if (distanceTravelled >= distance) {\r\n      document.removeEventListener('touchmove', this[onDistanceChange]);\r\n      this[startDrag]();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler while dragging\r\n   * @private\r\n   * @param {Event} event - Touch move event\r\n   */\r\n  [onTouchMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n    const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: pageX,\r\n      clientY: pageY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Touch end handler\r\n   * @private\r\n   * @param {Event} event - Touch end event\r\n   */\r\n  [onTouchEnd](event) {\r\n    clearTimeout(this.tapTimeout);\r\n    preventScrolling = false;\r\n\r\n    document.removeEventListener('touchend', this[onTouchEnd]);\r\n    document.removeEventListener('touchcancel', this[onTouchEnd]);\r\n    document.removeEventListener('touchmove', this[onDistanceChange]);\r\n\r\n    if (this.currentContainer) {\r\n      this.currentContainer.removeEventListener('contextmenu', onContextMenu);\r\n    }\r\n\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('touchmove', this[onTouchMove]);\r\n\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n    const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);\r\n\r\n    event.preventDefault();\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: pageX,\r\n      clientY: pageY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n  }\r\n}\r\n\r\nexports.default = TouchSensor;\r\nfunction onContextMenu(event) {\r\n  event.preventDefault();\r\n  event.stopPropagation();\r\n}\r\n\r\n/***/ }),\r\n/* 104 */\r\n/***/ (function(module, exports, __nested_webpack_require_212191__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _TouchSensor = __nested_webpack_require_212191__(103);\r\n\r\nvar _TouchSensor2 = _interopRequireDefault(_TouchSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _TouchSensor2.default;\r\n\r\n/***/ }),\r\n/* 105 */\r\n/***/ (function(module, exports, __nested_webpack_require_212613__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DragPressureSensorEvent = exports.DragStopSensorEvent = exports.DragMoveSensorEvent = exports.DragStartSensorEvent = exports.SensorEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_212613__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base sensor event\r\n * @class SensorEvent\r\n * @module SensorEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SensorEvent extends _AbstractEvent2.default {\r\n  /**\r\n   * Original browser event that triggered a sensor\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    return this.data.originalEvent;\r\n  }\r\n\r\n  /**\r\n   * Normalized clientX for both touch and mouse events\r\n   * @property clientX\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get clientX() {\r\n    return this.data.clientX;\r\n  }\r\n\r\n  /**\r\n   * Normalized clientY for both touch and mouse events\r\n   * @property clientY\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get clientY() {\r\n    return this.data.clientY;\r\n  }\r\n\r\n  /**\r\n   * Normalized target for both touch and mouse events\r\n   * Returns the element that is behind cursor or touch pointer\r\n   * @property target\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get target() {\r\n    return this.data.target;\r\n  }\r\n\r\n  /**\r\n   * Container that initiated the sensor\r\n   * @property container\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get container() {\r\n    return this.data.container;\r\n  }\r\n\r\n  /**\r\n   * Trackpad pressure\r\n   * @property pressure\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get pressure() {\r\n    return this.data.pressure;\r\n  }\r\n}\r\n\r\nexports.SensorEvent = SensorEvent; /**\r\n                                    * Drag start sensor event\r\n                                    * @class DragStartSensorEvent\r\n                                    * @module DragStartSensorEvent\r\n                                    * @extends SensorEvent\r\n                                    */\r\n\r\nclass DragStartSensorEvent extends SensorEvent {}\r\n\r\nexports.DragStartSensorEvent = DragStartSensorEvent; /**\r\n                                                      * Drag move sensor event\r\n                                                      * @class DragMoveSensorEvent\r\n                                                      * @module DragMoveSensorEvent\r\n                                                      * @extends SensorEvent\r\n                                                      */\r\n\r\nDragStartSensorEvent.type = 'drag:start';\r\nclass DragMoveSensorEvent extends SensorEvent {}\r\n\r\nexports.DragMoveSensorEvent = DragMoveSensorEvent; /**\r\n                                                    * Drag stop sensor event\r\n                                                    * @class DragStopSensorEvent\r\n                                                    * @module DragStopSensorEvent\r\n                                                    * @extends SensorEvent\r\n                                                    */\r\n\r\nDragMoveSensorEvent.type = 'drag:move';\r\nclass DragStopSensorEvent extends SensorEvent {}\r\n\r\nexports.DragStopSensorEvent = DragStopSensorEvent; /**\r\n                                                    * Drag pressure sensor event\r\n                                                    * @class DragPressureSensorEvent\r\n                                                    * @module DragPressureSensorEvent\r\n                                                    * @extends SensorEvent\r\n                                                    */\r\n\r\nDragStopSensorEvent.type = 'drag:stop';\r\nclass DragPressureSensorEvent extends SensorEvent {}\r\nexports.DragPressureSensorEvent = DragPressureSensorEvent;\r\nDragPressureSensorEvent.type = 'drag:pressure';\r\n\r\n/***/ }),\r\n/* 106 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = touchCoords;\r\n/**\r\n * Returns the first touch event found in touches or changedTouches of a touch events.\r\n * @param {TouchEvent} event a touch event\r\n * @return {Touch} a touch object\r\n */\r\nfunction touchCoords(event = {}) {\r\n  const { touches, changedTouches } = event;\r\n  return touches && touches[0] || changedTouches && changedTouches[0];\r\n}\r\n\r\n/***/ }),\r\n/* 107 */\r\n/***/ (function(module, exports, __nested_webpack_require_217141__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_217141__(106);\r\n\r\nvar _touchCoords2 = _interopRequireDefault(_touchCoords);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _touchCoords2.default;\r\n\r\n/***/ }),\r\n/* 108 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = distance;\r\n/**\r\n * Returns the distance between two points\r\n * @param  {Number} x1 The X position of the first point\r\n * @param  {Number} y1 The Y position of the first point\r\n * @param  {Number} x2 The X position of the second point\r\n * @param  {Number} y2 The Y position of the second point\r\n * @return {Number}\r\n */\r\nfunction distance(x1, y1, x2, y2) {\r\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\r\n}\r\n\r\n/***/ }),\r\n/* 109 */\r\n/***/ (function(module, exports, __nested_webpack_require_218165__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _distance = __nested_webpack_require_218165__(108);\r\n\r\nvar _distance2 = _interopRequireDefault(_distance);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _distance2.default;\r\n\r\n/***/ }),\r\n/* 110 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = requestNextAnimationFrame;\r\nfunction requestNextAnimationFrame(callback) {\r\n  return requestAnimationFrame(() => {\r\n    requestAnimationFrame(callback);\r\n  });\r\n}\r\n\r\n/***/ }),\r\n/* 111 */\r\n/***/ (function(module, exports, __nested_webpack_require_218927__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_218927__(110);\r\n\r\nvar _requestNextAnimationFrame2 = _interopRequireDefault(_requestNextAnimationFrame);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _requestNextAnimationFrame2.default;\r\n\r\n/***/ }),\r\n/* 112 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = closest;\r\nconst matchFunction = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector;\r\n\r\n/**\r\n * Get the closest parent element of a given element that matches the given\r\n * selector string or matching function\r\n *\r\n * @param {Element} element The child element to find a parent of\r\n * @param {String|Function} selector The string or function to use to match\r\n *     the parent element\r\n * @return {Element|null}\r\n */\r\nfunction closest(element, value) {\r\n  if (!element) {\r\n    return null;\r\n  }\r\n\r\n  const selector = value;\r\n  const callback = value;\r\n  const nodeList = value;\r\n  const singleElement = value;\r\n\r\n  const isSelector = Boolean(typeof value === 'string');\r\n  const isFunction = Boolean(typeof value === 'function');\r\n  const isNodeList = Boolean(value instanceof NodeList || value instanceof Array);\r\n  const isElement = Boolean(value instanceof HTMLElement);\r\n\r\n  function conditionFn(currentElement) {\r\n    if (!currentElement) {\r\n      return currentElement;\r\n    } else if (isSelector) {\r\n      return matchFunction.call(currentElement, selector);\r\n    } else if (isNodeList) {\r\n      return [...nodeList].includes(currentElement);\r\n    } else if (isElement) {\r\n      return singleElement === currentElement;\r\n    } else if (isFunction) {\r\n      return callback(currentElement);\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  let current = element;\r\n\r\n  do {\r\n    current = current.correspondingUseElement || current.correspondingElement || current;\r\n\r\n    if (conditionFn(current)) {\r\n      return current;\r\n    }\r\n\r\n    current = current.parentNode;\r\n  } while (current && current !== document.body && current !== document);\r\n\r\n  return null;\r\n}\r\n\r\n/***/ }),\r\n/* 113 */\r\n/***/ (function(module, exports, __nested_webpack_require_221360__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_221360__(112);\r\n\r\nvar _closest2 = _interopRequireDefault(_closest);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _closest2.default;\r\n\r\n/***/ }),\r\n/* 114 */\r\n/***/ (function(module, exports, __nested_webpack_require_221766__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_221766__(5);\r\n\r\nvar _Sensor = __nested_webpack_require_221766__(17);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_221766__(16);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onContextMenuWhileDragging = Symbol('onContextMenuWhileDragging');\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseMove = Symbol('onMouseMove');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst startDrag = Symbol('startDrag');\r\nconst onDistanceChange = Symbol('onDistanceChange');\r\n\r\n/**\r\n * This sensor picks up native browser mouse events and dictates drag operations\r\n * @class MouseSensor\r\n * @module MouseSensor\r\n * @extends Sensor\r\n */\r\nclass MouseSensor extends _Sensor2.default {\r\n  /**\r\n   * MouseSensor constructor.\r\n   * @constructs MouseSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Mouse down timer which will end up triggering the drag start operation\r\n     * @property mouseDownTimeout\r\n     * @type {Number}\r\n     */\r\n    this.mouseDownTimeout = null;\r\n\r\n    /**\r\n     * Save pageX coordinates for delay drag\r\n     * @property {Numbre} pageX\r\n     * @private\r\n     */\r\n    this.pageX = null;\r\n\r\n    /**\r\n     * Save pageY coordinates for delay drag\r\n     * @property {Numbre} pageY\r\n     * @private\r\n     */\r\n    this.pageY = null;\r\n\r\n    this[onContextMenuWhileDragging] = this[onContextMenuWhileDragging].bind(this);\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseMove] = this[onMouseMove].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n    this[startDrag] = this[startDrag].bind(this);\r\n    this[onDistanceChange] = this[onDistanceChange].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    if (event.button !== 0 || event.ctrlKey || event.metaKey) {\r\n      return;\r\n    }\r\n    const container = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!container) {\r\n      return;\r\n    }\r\n\r\n    const { delay } = this;\r\n    const { pageX, pageY } = event;\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n    this.onMouseDownAt = Date.now();\r\n    this.startEvent = event;\r\n\r\n    this.currentContainer = container;\r\n    document.addEventListener('mouseup', this[onMouseUp]);\r\n    document.addEventListener('dragstart', preventNativeDragStart);\r\n    document.addEventListener('mousemove', this[onDistanceChange]);\r\n\r\n    this.mouseDownTimeout = window.setTimeout(() => {\r\n      this[onDistanceChange]({ pageX: this.pageX, pageY: this.pageY });\r\n    }, delay.mouse);\r\n  }\r\n\r\n  /**\r\n   * Start the drag\r\n   * @private\r\n   */\r\n  [startDrag]() {\r\n    const startEvent = this.startEvent;\r\n    const container = this.currentContainer;\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: startEvent.clientX,\r\n      clientY: startEvent.clientY,\r\n      target: startEvent.target,\r\n      container,\r\n      originalEvent: startEvent\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n    this.dragging = !dragStartEvent.canceled();\r\n\r\n    if (this.dragging) {\r\n      document.addEventListener('contextmenu', this[onContextMenuWhileDragging], true);\r\n      document.addEventListener('mousemove', this[onMouseMove]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect change in distance, starting drag when both\r\n   * delay and distance requirements are met\r\n   * @private\r\n   * @param {Event} event - Mouse move event\r\n   */\r\n  [onDistanceChange](event) {\r\n    const { pageX, pageY } = event;\r\n    const { distance } = this.options;\r\n    const { startEvent, delay } = this;\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n\r\n    if (!this.currentContainer) {\r\n      return;\r\n    }\r\n\r\n    const timeElapsed = Date.now() - this.onMouseDownAt;\r\n    const distanceTravelled = (0, _utils.distance)(startEvent.pageX, startEvent.pageY, pageX, pageY) || 0;\r\n\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    if (timeElapsed < delay.mouse) {\r\n      // moved during delay\r\n      document.removeEventListener('mousemove', this[onDistanceChange]);\r\n    } else if (distanceTravelled >= distance) {\r\n      document.removeEventListener('mousemove', this[onDistanceChange]);\r\n      this[startDrag]();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler\r\n   * @private\r\n   * @param {Event} event - Mouse move event\r\n   */\r\n  [onMouseMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp](event) {\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    if (event.button !== 0) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp]);\r\n    document.removeEventListener('dragstart', preventNativeDragStart);\r\n    document.removeEventListener('mousemove', this[onDistanceChange]);\r\n\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    document.removeEventListener('contextmenu', this[onContextMenuWhileDragging], true);\r\n    document.removeEventListener('mousemove', this[onMouseMove]);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n  }\r\n\r\n  /**\r\n   * Context menu handler\r\n   * @private\r\n   * @param {Event} event - Context menu event\r\n   */\r\n  [onContextMenuWhileDragging](event) {\r\n    event.preventDefault();\r\n  }\r\n}\r\n\r\nexports.default = MouseSensor;\r\nfunction preventNativeDragStart(event) {\r\n  event.preventDefault();\r\n}\r\n\r\n/***/ }),\r\n/* 115 */\r\n/***/ (function(module, exports, __nested_webpack_require_228641__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _MouseSensor = __nested_webpack_require_228641__(114);\r\n\r\nvar _MouseSensor2 = _interopRequireDefault(_MouseSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _MouseSensor2.default;\r\n\r\n/***/ }),\r\n/* 116 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst defaultDealy = {\r\n  mouse: 0,\r\n  drag: 0,\r\n  touch: 100\r\n};\r\n\r\n/**\r\n * Base sensor class. Extend from this class to create a new or custom sensor\r\n * @class Sensor\r\n * @module Sensor\r\n */\r\nclass Sensor {\r\n  /**\r\n   * Sensor constructor.\r\n   * @constructs Sensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    /**\r\n     * Current containers\r\n     * @property containers\r\n     * @type {HTMLElement[]}\r\n     */\r\n    this.containers = [...containers];\r\n\r\n    /**\r\n     * Current options\r\n     * @property options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, options);\r\n\r\n    /**\r\n     * Current drag state\r\n     * @property dragging\r\n     * @type {Boolean}\r\n     */\r\n    this.dragging = false;\r\n\r\n    /**\r\n     * Current container\r\n     * @property currentContainer\r\n     * @type {HTMLElement}\r\n     */\r\n    this.currentContainer = null;\r\n\r\n    /**\r\n     * The event of the initial sensor down\r\n     * @property startEvent\r\n     * @type {Event}\r\n     */\r\n    this.startEvent = null;\r\n\r\n    /**\r\n     * The delay of each sensor\r\n     * @property delay\r\n     * @type {Object}\r\n     */\r\n    this.delay = calcDelay(options.delay);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   * @return {Sensor}\r\n   */\r\n  attach() {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   * @return {Sensor}\r\n   */\r\n  detach() {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds container to this sensor instance\r\n   * @param {...HTMLElement} containers - Containers you want to add to this sensor\r\n   * @example draggable.addContainer(document.body)\r\n   */\r\n  addContainer(...containers) {\r\n    this.containers = [...this.containers, ...containers];\r\n  }\r\n\r\n  /**\r\n   * Removes container from this sensor instance\r\n   * @param {...HTMLElement} containers - Containers you want to remove from this sensor\r\n   * @example draggable.removeContainer(document.body)\r\n   */\r\n  removeContainer(...containers) {\r\n    this.containers = this.containers.filter(container => !containers.includes(container));\r\n  }\r\n\r\n  /**\r\n   * Triggers event on target element\r\n   * @param {HTMLElement} element - Element to trigger event on\r\n   * @param {SensorEvent} sensorEvent - Sensor event to trigger\r\n   */\r\n  trigger(element, sensorEvent) {\r\n    const event = document.createEvent('Event');\r\n    event.detail = sensorEvent;\r\n    event.initEvent(sensorEvent.type, true, true);\r\n    element.dispatchEvent(event);\r\n    this.lastEvent = sensorEvent;\r\n\r\n    return sensorEvent;\r\n  }\r\n}\r\n\r\nexports.default = Sensor; /**\r\n                           * Calculate the delay of each sensor through the delay in the options\r\n                           * @param {undefined|Number|Object} optionsDelay - the delay in the options\r\n                           * @return {Object}\r\n                           */\r\n\r\nfunction calcDelay(optionsDelay) {\r\n  const delay = {};\r\n\r\n  if (optionsDelay === undefined) {\r\n    return _extends({}, defaultDealy);\r\n  }\r\n\r\n  if (typeof optionsDelay === 'number') {\r\n    for (const key in defaultDealy) {\r\n      if (defaultDealy.hasOwnProperty(key)) {\r\n        delay[key] = optionsDelay;\r\n      }\r\n    }\r\n    return delay;\r\n  }\r\n\r\n  for (const key in defaultDealy) {\r\n    if (defaultDealy.hasOwnProperty(key)) {\r\n      if (optionsDelay[key] === undefined) {\r\n        delay[key] = defaultDealy[key];\r\n      } else {\r\n        delay[key] = optionsDelay[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  return delay;\r\n}\r\n\r\n/***/ }),\r\n/* 117 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * All draggable plugins inherit from this class.\r\n * @abstract\r\n * @class AbstractPlugin\r\n * @module AbstractPlugin\r\n */\r\nclass AbstractPlugin {\r\n  /**\r\n   * AbstractPlugin constructor.\r\n   * @constructs AbstractPlugin\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    /**\r\n     * Draggable instance\r\n     * @property draggable\r\n     * @type {Draggable}\r\n     */\r\n    this.draggable = draggable;\r\n  }\r\n\r\n  /**\r\n   * Override to add listeners\r\n   * @abstract\r\n   */\r\n  attach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n\r\n  /**\r\n   * Override to remove listeners\r\n   * @abstract\r\n   */\r\n  detach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n}\r\nexports.default = AbstractPlugin;\r\n\r\n/***/ }),\r\n/* 118 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst canceled = Symbol('canceled');\r\n\r\n/**\r\n * All events fired by draggable inherit this class. You can call `cancel()` to\r\n * cancel a specific event or you can check if an event has been canceled by\r\n * calling `canceled()`.\r\n * @abstract\r\n * @class AbstractEvent\r\n * @module AbstractEvent\r\n */\r\nclass AbstractEvent {\r\n\r\n  /**\r\n   * AbstractEvent constructor.\r\n   * @constructs AbstractEvent\r\n   * @param {object} data - Event data\r\n   */\r\n\r\n  /**\r\n   * Event type\r\n   * @static\r\n   * @abstract\r\n   * @property type\r\n   * @type {String}\r\n   */\r\n  constructor(data) {\r\n    this[canceled] = false;\r\n    this.data = data;\r\n  }\r\n\r\n  /**\r\n   * Read-only type\r\n   * @abstract\r\n   * @return {String}\r\n   */\r\n\r\n\r\n  /**\r\n   * Event cancelable\r\n   * @static\r\n   * @abstract\r\n   * @property cancelable\r\n   * @type {Boolean}\r\n   */\r\n  get type() {\r\n    return this.constructor.type;\r\n  }\r\n\r\n  /**\r\n   * Read-only cancelable\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  get cancelable() {\r\n    return this.constructor.cancelable;\r\n  }\r\n\r\n  /**\r\n   * Cancels the event instance\r\n   * @abstract\r\n   */\r\n  cancel() {\r\n    this[canceled] = true;\r\n  }\r\n\r\n  /**\r\n   * Check if event has been canceled\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  canceled() {\r\n    return Boolean(this[canceled]);\r\n  }\r\n\r\n  /**\r\n   * Returns new event instance with existing event data.\r\n   * This method allows for overriding of event data.\r\n   * @param {Object} data\r\n   * @return {AbstractEvent}\r\n   */\r\n  clone(data) {\r\n    return new this.constructor(_extends({}, this.data, data));\r\n  }\r\n}\r\nexports.default = AbstractEvent;\r\nAbstractEvent.type = 'event';\r\nAbstractEvent.cancelable = false;\r\n\r\n/***/ }),\r\n/* 119 */\r\n/***/ (function(module, exports, __nested_webpack_require_236086__) {\r\n\r\n\"use strict\";\r\n\r\n// https://github.com/tc39/Array.prototype.includes\r\nvar $export = __nested_webpack_require_236086__(15);\r\nvar $includes = __nested_webpack_require_236086__(57)(true);\r\n\r\n$export($export.P, 'Array', {\r\n  includes: function includes(el /* , fromIndex = 0 */) {\r\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\r\n  }\r\n});\r\n\r\n__nested_webpack_require_236086__(49)('includes');\r\n\r\n\r\n/***/ }),\r\n/* 120 */\r\n/***/ (function(module, exports, __nested_webpack_require_236553__) {\r\n\r\n__nested_webpack_require_236553__(119);\r\nmodule.exports = __nested_webpack_require_236553__(2).Array.includes;\r\n\r\n\r\n/***/ }),\r\n/* 121 */\r\n/***/ (function(module, exports, __nested_webpack_require_236722__) {\r\n\r\nvar getKeys = __nested_webpack_require_236722__(13);\r\nvar toIObject = __nested_webpack_require_236722__(7);\r\nvar isEnum = __nested_webpack_require_236722__(19).f;\r\nmodule.exports = function (isEntries) {\r\n  return function (it) {\r\n    var O = toIObject(it);\r\n    var keys = getKeys(O);\r\n    var length = keys.length;\r\n    var i = 0;\r\n    var result = [];\r\n    var key;\r\n    while (length > i) if (isEnum.call(O, key = keys[i++])) {\r\n      result.push(isEntries ? [key, O[key]] : O[key]);\r\n    } return result;\r\n  };\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 122 */\r\n/***/ (function(module, exports, __nested_webpack_require_237286__) {\r\n\r\n// https://github.com/tc39/proposal-object-values-entries\r\nvar $export = __nested_webpack_require_237286__(15);\r\nvar $values = __nested_webpack_require_237286__(121)(false);\r\n\r\n$export($export.S, 'Object', {\r\n  values: function values(it) {\r\n    return $values(it);\r\n  }\r\n});\r\n\r\n\r\n/***/ }),\r\n/* 123 */\r\n/***/ (function(module, exports, __nested_webpack_require_237620__) {\r\n\r\n__nested_webpack_require_237620__(122);\r\nmodule.exports = __nested_webpack_require_237620__(2).Object.values;\r\n\r\n\r\n/***/ }),\r\n/* 124 */\r\n/***/ (function(module, exports, __nested_webpack_require_237788__) {\r\n\r\n\"use strict\";\r\n\r\n// 19.1.2.1 Object.assign(target, source, ...)\r\nvar getKeys = __nested_webpack_require_237788__(13);\r\nvar gOPS = __nested_webpack_require_237788__(31);\r\nvar pIE = __nested_webpack_require_237788__(19);\r\nvar toObject = __nested_webpack_require_237788__(50);\r\nvar IObject = __nested_webpack_require_237788__(58);\r\nvar $assign = Object.assign;\r\n\r\n// should work with symbols and should have deterministic property order (V8 bug)\r\nmodule.exports = !$assign || __nested_webpack_require_237788__(23)(function () {\r\n  var A = {};\r\n  var B = {};\r\n  // eslint-disable-next-line no-undef\r\n  var S = Symbol();\r\n  var K = 'abcdefghijklmnopqrst';\r\n  A[S] = 7;\r\n  K.split('').forEach(function (k) { B[k] = k; });\r\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\r\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\r\n  var T = toObject(target);\r\n  var aLen = arguments.length;\r\n  var index = 1;\r\n  var getSymbols = gOPS.f;\r\n  var isEnum = pIE.f;\r\n  while (aLen > index) {\r\n    var S = IObject(arguments[index++]);\r\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\r\n    var length = keys.length;\r\n    var j = 0;\r\n    var key;\r\n    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\r\n  } return T;\r\n} : $assign;\r\n\r\n\r\n/***/ }),\r\n/* 125 */\r\n/***/ (function(module, exports, __nested_webpack_require_239105__) {\r\n\r\n// 19.1.3.1 Object.assign(target, source)\r\nvar $export = __nested_webpack_require_239105__(15);\r\n\r\n$export($export.S + $export.F, 'Object', { assign: __nested_webpack_require_239105__(124) });\r\n\r\n\r\n/***/ }),\r\n/* 126 */\r\n/***/ (function(module, exports, __nested_webpack_require_239356__) {\r\n\r\n__nested_webpack_require_239356__(125);\r\nmodule.exports = __nested_webpack_require_239356__(2).Object.assign;\r\n\r\n\r\n/***/ }),\r\n/* 127 */\r\n/***/ (function(module, exports, __nested_webpack_require_239524__) {\r\n\r\nvar ITERATOR = __nested_webpack_require_239524__(0)('iterator');\r\nvar SAFE_CLOSING = false;\r\n\r\ntry {\r\n  var riter = [7][ITERATOR]();\r\n  riter['return'] = function () { SAFE_CLOSING = true; };\r\n  // eslint-disable-next-line no-throw-literal\r\n  Array.from(riter, function () { throw 2; });\r\n} catch (e) { /* empty */ }\r\n\r\nmodule.exports = function (exec, skipClosing) {\r\n  if (!skipClosing && !SAFE_CLOSING) return false;\r\n  var safe = false;\r\n  try {\r\n    var arr = [7];\r\n    var iter = arr[ITERATOR]();\r\n    iter.next = function () { return { done: safe = true }; };\r\n    arr[ITERATOR] = function () { return iter; };\r\n    exec(arr);\r\n  } catch (e) { /* empty */ }\r\n  return safe;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 128 */\r\n/***/ (function(module, exports, __nested_webpack_require_240281__) {\r\n\r\n\"use strict\";\r\n\r\nvar global = __nested_webpack_require_240281__(1);\r\nvar dP = __nested_webpack_require_240281__(9);\r\nvar DESCRIPTORS = __nested_webpack_require_240281__(11);\r\nvar SPECIES = __nested_webpack_require_240281__(0)('species');\r\n\r\nmodule.exports = function (KEY) {\r\n  var C = global[KEY];\r\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\r\n    configurable: true,\r\n    get: function () { return this; }\r\n  });\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 129 */\r\n/***/ (function(module, exports, __nested_webpack_require_240744__) {\r\n\r\nvar redefine = __nested_webpack_require_240744__(14);\r\nmodule.exports = function (target, src, safe) {\r\n  for (var key in src) redefine(target, key, src[key], safe);\r\n  return target;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 130 */\r\n/***/ (function(module, exports, __nested_webpack_require_241004__) {\r\n\r\nvar anObject = __nested_webpack_require_241004__(6);\r\nvar isObject = __nested_webpack_require_241004__(8);\r\nvar newPromiseCapability = __nested_webpack_require_241004__(47);\r\n\r\nmodule.exports = function (C, x) {\r\n  anObject(C);\r\n  if (isObject(x) && x.constructor === C) return x;\r\n  var promiseCapability = newPromiseCapability.f(C);\r\n  var resolve = promiseCapability.resolve;\r\n  resolve(x);\r\n  return promiseCapability.promise;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 131 */\r\n/***/ (function(module, exports, __nested_webpack_require_241483__) {\r\n\r\nvar global = __nested_webpack_require_241483__(1);\r\nvar navigator = global.navigator;\r\n\r\nmodule.exports = navigator && navigator.userAgent || '';\r\n\r\n\r\n/***/ }),\r\n/* 132 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = function (exec) {\r\n  try {\r\n    return { e: false, v: exec() };\r\n  } catch (e) {\r\n    return { e: true, v: e };\r\n  }\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 133 */\r\n/***/ (function(module, exports, __nested_webpack_require_241904__) {\r\n\r\nvar global = __nested_webpack_require_241904__(1);\r\nvar macrotask = __nested_webpack_require_241904__(48).set;\r\nvar Observer = global.MutationObserver || global.WebKitMutationObserver;\r\nvar process = global.process;\r\nvar Promise = global.Promise;\r\nvar isNode = __nested_webpack_require_241904__(20)(process) == 'process';\r\n\r\nmodule.exports = function () {\r\n  var head, last, notify;\r\n\r\n  var flush = function () {\r\n    var parent, fn;\r\n    if (isNode && (parent = process.domain)) parent.exit();\r\n    while (head) {\r\n      fn = head.fn;\r\n      head = head.next;\r\n      try {\r\n        fn();\r\n      } catch (e) {\r\n        if (head) notify();\r\n        else last = undefined;\r\n        throw e;\r\n      }\r\n    } last = undefined;\r\n    if (parent) parent.enter();\r\n  };\r\n\r\n  // Node.js\r\n  if (isNode) {\r\n    notify = function () {\r\n      process.nextTick(flush);\r\n    };\r\n  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339\r\n  } else if (Observer && !(global.navigator && global.navigator.standalone)) {\r\n    var toggle = true;\r\n    var node = document.createTextNode('');\r\n    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\r\n    notify = function () {\r\n      node.data = toggle = !toggle;\r\n    };\r\n  // environments with maybe non-completely correct, but existent Promise\r\n  } else if (Promise && Promise.resolve) {\r\n    // Promise.resolve without an argument throws an error in LG WebOS 2\r\n    var promise = Promise.resolve(undefined);\r\n    notify = function () {\r\n      promise.then(flush);\r\n    };\r\n  // for other environments - macrotask based on:\r\n  // - setImmediate\r\n  // - MessageChannel\r\n  // - window.postMessag\r\n  // - onreadystatechange\r\n  // - setTimeout\r\n  } else {\r\n    notify = function () {\r\n      // strange IE + webpack dev server bug - use .call(global)\r\n      macrotask.call(global, flush);\r\n    };\r\n  }\r\n\r\n  return function (fn) {\r\n    var task = { fn: fn, next: undefined };\r\n    if (last) last.next = task;\r\n    if (!head) {\r\n      head = task;\r\n      notify();\r\n    } last = task;\r\n  };\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 134 */\r\n/***/ (function(module, exports) {\r\n\r\n// fast apply, http://jsperf.lnkit.com/fast-apply/5\r\nmodule.exports = function (fn, args, that) {\r\n  var un = that === undefined;\r\n  switch (args.length) {\r\n    case 0: return un ? fn()\r\n                      : fn.call(that);\r\n    case 1: return un ? fn(args[0])\r\n                      : fn.call(that, args[0]);\r\n    case 2: return un ? fn(args[0], args[1])\r\n                      : fn.call(that, args[0], args[1]);\r\n    case 3: return un ? fn(args[0], args[1], args[2])\r\n                      : fn.call(that, args[0], args[1], args[2]);\r\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\r\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\r\n  } return fn.apply(that, args);\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 135 */\r\n/***/ (function(module, exports, __nested_webpack_require_244834__) {\r\n\r\n// 7.3.20 SpeciesConstructor(O, defaultConstructor)\r\nvar anObject = __nested_webpack_require_244834__(6);\r\nvar aFunction = __nested_webpack_require_244834__(26);\r\nvar SPECIES = __nested_webpack_require_244834__(0)('species');\r\nmodule.exports = function (O, D) {\r\n  var C = anObject(O).constructor;\r\n  var S;\r\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 136 */\r\n/***/ (function(module, exports, __nested_webpack_require_245279__) {\r\n\r\nvar classof = __nested_webpack_require_245279__(30);\r\nvar ITERATOR = __nested_webpack_require_245279__(0)('iterator');\r\nvar Iterators = __nested_webpack_require_245279__(18);\r\nmodule.exports = __nested_webpack_require_245279__(2).getIteratorMethod = function (it) {\r\n  if (it != undefined) return it[ITERATOR]\r\n    || it['@@iterator']\r\n    || Iterators[classof(it)];\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 137 */\r\n/***/ (function(module, exports, __nested_webpack_require_245680__) {\r\n\r\n// check on default Array iterator\r\nvar Iterators = __nested_webpack_require_245680__(18);\r\nvar ITERATOR = __nested_webpack_require_245680__(0)('iterator');\r\nvar ArrayProto = Array.prototype;\r\n\r\nmodule.exports = function (it) {\r\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 138 */\r\n/***/ (function(module, exports, __nested_webpack_require_246057__) {\r\n\r\n// call something on iterator step with safe closing on error\r\nvar anObject = __nested_webpack_require_246057__(6);\r\nmodule.exports = function (iterator, fn, value, entries) {\r\n  try {\r\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\r\n  // 7.4.6 IteratorClose(iterator, completion)\r\n  } catch (e) {\r\n    var ret = iterator['return'];\r\n    if (ret !== undefined) anObject(ret.call(iterator));\r\n    throw e;\r\n  }\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 139 */\r\n/***/ (function(module, exports, __nested_webpack_require_246563__) {\r\n\r\nvar ctx = __nested_webpack_require_246563__(27);\r\nvar call = __nested_webpack_require_246563__(138);\r\nvar isArrayIter = __nested_webpack_require_246563__(137);\r\nvar anObject = __nested_webpack_require_246563__(6);\r\nvar toLength = __nested_webpack_require_246563__(56);\r\nvar getIterFn = __nested_webpack_require_246563__(136);\r\nvar BREAK = {};\r\nvar RETURN = {};\r\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\r\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\r\n  var f = ctx(fn, that, entries ? 2 : 1);\r\n  var index = 0;\r\n  var length, step, iterator, result;\r\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\r\n  // fast case for arrays with default iterator\r\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\r\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\r\n    if (result === BREAK || result === RETURN) return result;\r\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\r\n    result = call(iterator, f, step.value, entries);\r\n    if (result === BREAK || result === RETURN) return result;\r\n  }\r\n};\r\nexports.BREAK = BREAK;\r\nexports.RETURN = RETURN;\r\n\r\n\r\n/***/ }),\r\n/* 140 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = function (it, Constructor, name, forbiddenField) {\r\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\r\n    throw TypeError(name + ': incorrect invocation!');\r\n  } return it;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 141 */\r\n/***/ (function(module, exports, __nested_webpack_require_248145__) {\r\n\r\n\"use strict\";\r\n\r\nvar LIBRARY = __nested_webpack_require_248145__(21);\r\nvar global = __nested_webpack_require_248145__(1);\r\nvar ctx = __nested_webpack_require_248145__(27);\r\nvar classof = __nested_webpack_require_248145__(30);\r\nvar $export = __nested_webpack_require_248145__(15);\r\nvar isObject = __nested_webpack_require_248145__(8);\r\nvar aFunction = __nested_webpack_require_248145__(26);\r\nvar anInstance = __nested_webpack_require_248145__(140);\r\nvar forOf = __nested_webpack_require_248145__(139);\r\nvar speciesConstructor = __nested_webpack_require_248145__(135);\r\nvar task = __nested_webpack_require_248145__(48).set;\r\nvar microtask = __nested_webpack_require_248145__(133)();\r\nvar newPromiseCapabilityModule = __nested_webpack_require_248145__(47);\r\nvar perform = __nested_webpack_require_248145__(132);\r\nvar userAgent = __nested_webpack_require_248145__(131);\r\nvar promiseResolve = __nested_webpack_require_248145__(130);\r\nvar PROMISE = 'Promise';\r\nvar TypeError = global.TypeError;\r\nvar process = global.process;\r\nvar versions = process && process.versions;\r\nvar v8 = versions && versions.v8 || '';\r\nvar $Promise = global[PROMISE];\r\nvar isNode = classof(process) == 'process';\r\nvar empty = function () { /* empty */ };\r\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\r\nvar newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\r\n\r\nvar USE_NATIVE = !!function () {\r\n  try {\r\n    // correct subclassing with @@species support\r\n    var promise = $Promise.resolve(1);\r\n    var FakePromise = (promise.constructor = {})[__nested_webpack_require_248145__(0)('species')] = function (exec) {\r\n      exec(empty, empty);\r\n    };\r\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\r\n    return (isNode || typeof PromiseRejectionEvent == 'function')\r\n      && promise.then(empty) instanceof FakePromise\r\n      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\r\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\r\n      // we can't detect it synchronously, so just check versions\r\n      && v8.indexOf('6.6') !== 0\r\n      && userAgent.indexOf('Chrome/66') === -1;\r\n  } catch (e) { /* empty */ }\r\n}();\r\n\r\n// helpers\r\nvar isThenable = function (it) {\r\n  var then;\r\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\r\n};\r\nvar notify = function (promise, isReject) {\r\n  if (promise._n) return;\r\n  promise._n = true;\r\n  var chain = promise._c;\r\n  microtask(function () {\r\n    var value = promise._v;\r\n    var ok = promise._s == 1;\r\n    var i = 0;\r\n    var run = function (reaction) {\r\n      var handler = ok ? reaction.ok : reaction.fail;\r\n      var resolve = reaction.resolve;\r\n      var reject = reaction.reject;\r\n      var domain = reaction.domain;\r\n      var result, then, exited;\r\n      try {\r\n        if (handler) {\r\n          if (!ok) {\r\n            if (promise._h == 2) onHandleUnhandled(promise);\r\n            promise._h = 1;\r\n          }\r\n          if (handler === true) result = value;\r\n          else {\r\n            if (domain) domain.enter();\r\n            result = handler(value); // may throw\r\n            if (domain) {\r\n              domain.exit();\r\n              exited = true;\r\n            }\r\n          }\r\n          if (result === reaction.promise) {\r\n            reject(TypeError('Promise-chain cycle'));\r\n          } else if (then = isThenable(result)) {\r\n            then.call(result, resolve, reject);\r\n          } else resolve(result);\r\n        } else reject(value);\r\n      } catch (e) {\r\n        if (domain && !exited) domain.exit();\r\n        reject(e);\r\n      }\r\n    };\r\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\r\n    promise._c = [];\r\n    promise._n = false;\r\n    if (isReject && !promise._h) onUnhandled(promise);\r\n  });\r\n};\r\nvar onUnhandled = function (promise) {\r\n  task.call(global, function () {\r\n    var value = promise._v;\r\n    var unhandled = isUnhandled(promise);\r\n    var result, handler, console;\r\n    if (unhandled) {\r\n      result = perform(function () {\r\n        if (isNode) {\r\n          process.emit('unhandledRejection', value, promise);\r\n        } else if (handler = global.onunhandledrejection) {\r\n          handler({ promise: promise, reason: value });\r\n        } else if ((console = global.console) && console.error) {\r\n          console.error('Unhandled promise rejection', value);\r\n        }\r\n      });\r\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\r\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\r\n    } promise._a = undefined;\r\n    if (unhandled && result.e) throw result.v;\r\n  });\r\n};\r\nvar isUnhandled = function (promise) {\r\n  return promise._h !== 1 && (promise._a || promise._c).length === 0;\r\n};\r\nvar onHandleUnhandled = function (promise) {\r\n  task.call(global, function () {\r\n    var handler;\r\n    if (isNode) {\r\n      process.emit('rejectionHandled', promise);\r\n    } else if (handler = global.onrejectionhandled) {\r\n      handler({ promise: promise, reason: promise._v });\r\n    }\r\n  });\r\n};\r\nvar $reject = function (value) {\r\n  var promise = this;\r\n  if (promise._d) return;\r\n  promise._d = true;\r\n  promise = promise._w || promise; // unwrap\r\n  promise._v = value;\r\n  promise._s = 2;\r\n  if (!promise._a) promise._a = promise._c.slice();\r\n  notify(promise, true);\r\n};\r\nvar $resolve = function (value) {\r\n  var promise = this;\r\n  var then;\r\n  if (promise._d) return;\r\n  promise._d = true;\r\n  promise = promise._w || promise; // unwrap\r\n  try {\r\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\r\n    if (then = isThenable(value)) {\r\n      microtask(function () {\r\n        var wrapper = { _w: promise, _d: false }; // wrap\r\n        try {\r\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\r\n        } catch (e) {\r\n          $reject.call(wrapper, e);\r\n        }\r\n      });\r\n    } else {\r\n      promise._v = value;\r\n      promise._s = 1;\r\n      notify(promise, false);\r\n    }\r\n  } catch (e) {\r\n    $reject.call({ _w: promise, _d: false }, e); // wrap\r\n  }\r\n};\r\n\r\n// constructor polyfill\r\nif (!USE_NATIVE) {\r\n  // 25.4.3.1 Promise(executor)\r\n  $Promise = function Promise(executor) {\r\n    anInstance(this, $Promise, PROMISE, '_h');\r\n    aFunction(executor);\r\n    Internal.call(this);\r\n    try {\r\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\r\n    } catch (err) {\r\n      $reject.call(this, err);\r\n    }\r\n  };\r\n  // eslint-disable-next-line no-unused-vars\r\n  Internal = function Promise(executor) {\r\n    this._c = [];             // <- awaiting reactions\r\n    this._a = undefined;      // <- checked in isUnhandled reactions\r\n    this._s = 0;              // <- state\r\n    this._d = false;          // <- done\r\n    this._v = undefined;      // <- value\r\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\r\n    this._n = false;          // <- notify\r\n  };\r\n  Internal.prototype = __nested_webpack_require_248145__(129)($Promise.prototype, {\r\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\r\n    then: function then(onFulfilled, onRejected) {\r\n      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\r\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\r\n      reaction.fail = typeof onRejected == 'function' && onRejected;\r\n      reaction.domain = isNode ? process.domain : undefined;\r\n      this._c.push(reaction);\r\n      if (this._a) this._a.push(reaction);\r\n      if (this._s) notify(this, false);\r\n      return reaction.promise;\r\n    },\r\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\r\n    'catch': function (onRejected) {\r\n      return this.then(undefined, onRejected);\r\n    }\r\n  });\r\n  OwnPromiseCapability = function () {\r\n    var promise = new Internal();\r\n    this.promise = promise;\r\n    this.resolve = ctx($resolve, promise, 1);\r\n    this.reject = ctx($reject, promise, 1);\r\n  };\r\n  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\r\n    return C === $Promise || C === Wrapper\r\n      ? new OwnPromiseCapability(C)\r\n      : newGenericPromiseCapability(C);\r\n  };\r\n}\r\n\r\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });\r\n__nested_webpack_require_248145__(25)($Promise, PROMISE);\r\n__nested_webpack_require_248145__(128)(PROMISE);\r\nWrapper = __nested_webpack_require_248145__(2)[PROMISE];\r\n\r\n// statics\r\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\r\n  // 25.4.4.5 Promise.reject(r)\r\n  reject: function reject(r) {\r\n    var capability = newPromiseCapability(this);\r\n    var $$reject = capability.reject;\r\n    $$reject(r);\r\n    return capability.promise;\r\n  }\r\n});\r\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\r\n  // 25.4.4.6 Promise.resolve(x)\r\n  resolve: function resolve(x) {\r\n    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);\r\n  }\r\n});\r\n$export($export.S + $export.F * !(USE_NATIVE && __nested_webpack_require_248145__(127)(function (iter) {\r\n  $Promise.all(iter)['catch'](empty);\r\n})), PROMISE, {\r\n  // 25.4.4.1 Promise.all(iterable)\r\n  all: function all(iterable) {\r\n    var C = this;\r\n    var capability = newPromiseCapability(C);\r\n    var resolve = capability.resolve;\r\n    var reject = capability.reject;\r\n    var result = perform(function () {\r\n      var values = [];\r\n      var index = 0;\r\n      var remaining = 1;\r\n      forOf(iterable, false, function (promise) {\r\n        var $index = index++;\r\n        var alreadyCalled = false;\r\n        values.push(undefined);\r\n        remaining++;\r\n        C.resolve(promise).then(function (value) {\r\n          if (alreadyCalled) return;\r\n          alreadyCalled = true;\r\n          values[$index] = value;\r\n          --remaining || resolve(values);\r\n        }, reject);\r\n      });\r\n      --remaining || resolve(values);\r\n    });\r\n    if (result.e) reject(result.v);\r\n    return capability.promise;\r\n  },\r\n  // 25.4.4.4 Promise.race(iterable)\r\n  race: function race(iterable) {\r\n    var C = this;\r\n    var capability = newPromiseCapability(C);\r\n    var reject = capability.reject;\r\n    var result = perform(function () {\r\n      forOf(iterable, false, function (promise) {\r\n        C.resolve(promise).then(capability.resolve, reject);\r\n      });\r\n    });\r\n    if (result.e) reject(result.v);\r\n    return capability.promise;\r\n  }\r\n});\r\n\r\n\r\n/***/ }),\r\n/* 142 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = function (done, value) {\r\n  return { value: value, done: !!done };\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 143 */\r\n/***/ (function(module, exports, __nested_webpack_require_258478__) {\r\n\r\n\"use strict\";\r\n\r\nvar addToUnscopables = __nested_webpack_require_258478__(49);\r\nvar step = __nested_webpack_require_258478__(142);\r\nvar Iterators = __nested_webpack_require_258478__(18);\r\nvar toIObject = __nested_webpack_require_258478__(7);\r\n\r\n// 22.1.3.4 Array.prototype.entries()\r\n// 22.1.3.13 Array.prototype.keys()\r\n// 22.1.3.29 Array.prototype.values()\r\n// 22.1.3.30 Array.prototype[@@iterator]()\r\nmodule.exports = __nested_webpack_require_258478__(51)(Array, 'Array', function (iterated, kind) {\r\n  this._t = toIObject(iterated); // target\r\n  this._i = 0;                   // next index\r\n  this._k = kind;                // kind\r\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\r\n}, function () {\r\n  var O = this._t;\r\n  var kind = this._k;\r\n  var index = this._i++;\r\n  if (!O || index >= O.length) {\r\n    this._t = undefined;\r\n    return step(1);\r\n  }\r\n  if (kind == 'keys') return step(0, index);\r\n  if (kind == 'values') return step(0, O[index]);\r\n  return step(0, [index, O[index]]);\r\n}, 'values');\r\n\r\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\r\nIterators.Arguments = Iterators.Array;\r\n\r\naddToUnscopables('keys');\r\naddToUnscopables('values');\r\naddToUnscopables('entries');\r\n\r\n\r\n/***/ }),\r\n/* 144 */\r\n/***/ (function(module, exports, __nested_webpack_require_259703__) {\r\n\r\nvar $iterators = __nested_webpack_require_259703__(143);\r\nvar getKeys = __nested_webpack_require_259703__(13);\r\nvar redefine = __nested_webpack_require_259703__(14);\r\nvar global = __nested_webpack_require_259703__(1);\r\nvar hide = __nested_webpack_require_259703__(10);\r\nvar Iterators = __nested_webpack_require_259703__(18);\r\nvar wks = __nested_webpack_require_259703__(0);\r\nvar ITERATOR = wks('iterator');\r\nvar TO_STRING_TAG = wks('toStringTag');\r\nvar ArrayValues = Iterators.Array;\r\n\r\nvar DOMIterables = {\r\n  CSSRuleList: true, // TODO: Not spec compliant, should be false.\r\n  CSSStyleDeclaration: false,\r\n  CSSValueList: false,\r\n  ClientRectList: false,\r\n  DOMRectList: false,\r\n  DOMStringList: false,\r\n  DOMTokenList: true,\r\n  DataTransferItemList: false,\r\n  FileList: false,\r\n  HTMLAllCollection: false,\r\n  HTMLCollection: false,\r\n  HTMLFormElement: false,\r\n  HTMLSelectElement: false,\r\n  MediaList: true, // TODO: Not spec compliant, should be false.\r\n  MimeTypeArray: false,\r\n  NamedNodeMap: false,\r\n  NodeList: true,\r\n  PaintRequestList: false,\r\n  Plugin: false,\r\n  PluginArray: false,\r\n  SVGLengthList: false,\r\n  SVGNumberList: false,\r\n  SVGPathSegList: false,\r\n  SVGPointList: false,\r\n  SVGStringList: false,\r\n  SVGTransformList: false,\r\n  SourceBufferList: false,\r\n  StyleSheetList: true, // TODO: Not spec compliant, should be false.\r\n  TextTrackCueList: false,\r\n  TextTrackList: false,\r\n  TouchList: false\r\n};\r\n\r\nfor (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\r\n  var NAME = collections[i];\r\n  var explicit = DOMIterables[NAME];\r\n  var Collection = global[NAME];\r\n  var proto = Collection && Collection.prototype;\r\n  var key;\r\n  if (proto) {\r\n    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\r\n    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\r\n    Iterators[NAME] = ArrayValues;\r\n    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);\r\n  }\r\n}\r\n\r\n\r\n/***/ }),\r\n/* 145 */\r\n/***/ (function(module, exports, __nested_webpack_require_261660__) {\r\n\r\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\r\nvar has = __nested_webpack_require_261660__(12);\r\nvar toObject = __nested_webpack_require_261660__(50);\r\nvar IE_PROTO = __nested_webpack_require_261660__(33)('IE_PROTO');\r\nvar ObjectProto = Object.prototype;\r\n\r\nmodule.exports = Object.getPrototypeOf || function (O) {\r\n  O = toObject(O);\r\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\r\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\r\n    return O.constructor.prototype;\r\n  } return O instanceof Object ? ObjectProto : null;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 146 */\r\n/***/ (function(module, exports, __nested_webpack_require_262256__) {\r\n\r\n\"use strict\";\r\n\r\nvar create = __nested_webpack_require_262256__(55);\r\nvar descriptor = __nested_webpack_require_262256__(28);\r\nvar setToStringTag = __nested_webpack_require_262256__(25);\r\nvar IteratorPrototype = {};\r\n\r\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\r\n__nested_webpack_require_262256__(10)(IteratorPrototype, __nested_webpack_require_262256__(0)('iterator'), function () { return this; });\r\n\r\nmodule.exports = function (Constructor, NAME, next) {\r\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\r\n  setToStringTag(Constructor, NAME + ' Iterator');\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 147 */\r\n/***/ (function(module, exports, __nested_webpack_require_262876__) {\r\n\r\nvar toInteger = __nested_webpack_require_262876__(34);\r\nvar defined = __nested_webpack_require_262876__(35);\r\n// true  -> String#at\r\n// false -> String#codePointAt\r\nmodule.exports = function (TO_STRING) {\r\n  return function (that, pos) {\r\n    var s = String(defined(that));\r\n    var i = toInteger(pos);\r\n    var l = s.length;\r\n    var a, b;\r\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\r\n    a = s.charCodeAt(i);\r\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\r\n      ? TO_STRING ? s.charAt(i) : a\r\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\r\n  };\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 148 */\r\n/***/ (function(module, exports, __nested_webpack_require_263599__) {\r\n\r\n\"use strict\";\r\n\r\nvar $at = __nested_webpack_require_263599__(147)(true);\r\n\r\n// 21.1.3.27 String.prototype[@@iterator]()\r\n__nested_webpack_require_263599__(51)(String, 'String', function (iterated) {\r\n  this._t = String(iterated); // target\r\n  this._i = 0;                // next index\r\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\r\n}, function () {\r\n  var O = this._t;\r\n  var index = this._i;\r\n  var point;\r\n  if (index >= O.length) return { value: undefined, done: true };\r\n  point = $at(O, index);\r\n  this._i += point.length;\r\n  return { value: point, done: false };\r\n});\r\n\r\n\r\n/***/ }),\r\n/* 149 */\r\n/***/ (function(module, exports, __nested_webpack_require_264233__) {\r\n\r\n__nested_webpack_require_264233__(52);\r\n__nested_webpack_require_264233__(148);\r\n__nested_webpack_require_264233__(144);\r\n__nested_webpack_require_264233__(141);\r\nmodule.exports = __nested_webpack_require_264233__(2).Promise;\r\n\r\n\r\n/***/ }),\r\n/* 150 */\r\n/***/ (function(module, exports, __nested_webpack_require_264475__) {\r\n\r\nvar pIE = __nested_webpack_require_264475__(19);\r\nvar createDesc = __nested_webpack_require_264475__(28);\r\nvar toIObject = __nested_webpack_require_264475__(7);\r\nvar toPrimitive = __nested_webpack_require_264475__(37);\r\nvar has = __nested_webpack_require_264475__(12);\r\nvar IE8_DOM_DEFINE = __nested_webpack_require_264475__(61);\r\nvar gOPD = Object.getOwnPropertyDescriptor;\r\n\r\nexports.f = __nested_webpack_require_264475__(11) ? gOPD : function getOwnPropertyDescriptor(O, P) {\r\n  O = toIObject(O);\r\n  P = toPrimitive(P, true);\r\n  if (IE8_DOM_DEFINE) try {\r\n    return gOPD(O, P);\r\n  } catch (e) { /* empty */ }\r\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 151 */\r\n/***/ (function(module, exports, __nested_webpack_require_265142__) {\r\n\r\n// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\r\nvar toIObject = __nested_webpack_require_265142__(7);\r\nvar gOPN = __nested_webpack_require_265142__(53).f;\r\nvar toString = {}.toString;\r\n\r\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\r\n  ? Object.getOwnPropertyNames(window) : [];\r\n\r\nvar getWindowNames = function (it) {\r\n  try {\r\n    return gOPN(it);\r\n  } catch (e) {\r\n    return windowNames.slice();\r\n  }\r\n};\r\n\r\nmodule.exports.f = function getOwnPropertyNames(it) {\r\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 152 */\r\n/***/ (function(module, exports, __nested_webpack_require_265846__) {\r\n\r\nvar dP = __nested_webpack_require_265846__(9);\r\nvar anObject = __nested_webpack_require_265846__(6);\r\nvar getKeys = __nested_webpack_require_265846__(13);\r\n\r\nmodule.exports = __nested_webpack_require_265846__(11) ? Object.defineProperties : function defineProperties(O, Properties) {\r\n  anObject(O);\r\n  var keys = getKeys(Properties);\r\n  var length = keys.length;\r\n  var i = 0;\r\n  var P;\r\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\r\n  return O;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 153 */\r\n/***/ (function(module, exports, __nested_webpack_require_266342__) {\r\n\r\n// 7.2.2 IsArray(argument)\r\nvar cof = __nested_webpack_require_266342__(20);\r\nmodule.exports = Array.isArray || function isArray(arg) {\r\n  return cof(arg) == 'Array';\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 154 */\r\n/***/ (function(module, exports, __nested_webpack_require_266585__) {\r\n\r\nvar toInteger = __nested_webpack_require_266585__(34);\r\nvar max = Math.max;\r\nvar min = Math.min;\r\nmodule.exports = function (index, length) {\r\n  index = toInteger(index);\r\n  return index < 0 ? max(index + length, 0) : min(index, length);\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 155 */\r\n/***/ (function(module, exports, __nested_webpack_require_266899__) {\r\n\r\n// all enumerable object keys, includes symbols\r\nvar getKeys = __nested_webpack_require_266899__(13);\r\nvar gOPS = __nested_webpack_require_266899__(31);\r\nvar pIE = __nested_webpack_require_266899__(19);\r\nmodule.exports = function (it) {\r\n  var result = getKeys(it);\r\n  var getSymbols = gOPS.f;\r\n  if (getSymbols) {\r\n    var symbols = getSymbols(it);\r\n    var isEnum = pIE.f;\r\n    var i = 0;\r\n    var key;\r\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\r\n  } return result;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 156 */\r\n/***/ (function(module, exports, __nested_webpack_require_267463__) {\r\n\r\nvar global = __nested_webpack_require_267463__(1);\r\nvar core = __nested_webpack_require_267463__(2);\r\nvar LIBRARY = __nested_webpack_require_267463__(21);\r\nvar wksExt = __nested_webpack_require_267463__(60);\r\nvar defineProperty = __nested_webpack_require_267463__(9).f;\r\nmodule.exports = function (name) {\r\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\r\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 157 */\r\n/***/ (function(module, exports, __nested_webpack_require_267983__) {\r\n\r\nvar META = __nested_webpack_require_267983__(22)('meta');\r\nvar isObject = __nested_webpack_require_267983__(8);\r\nvar has = __nested_webpack_require_267983__(12);\r\nvar setDesc = __nested_webpack_require_267983__(9).f;\r\nvar id = 0;\r\nvar isExtensible = Object.isExtensible || function () {\r\n  return true;\r\n};\r\nvar FREEZE = !__nested_webpack_require_267983__(23)(function () {\r\n  return isExtensible(Object.preventExtensions({}));\r\n});\r\nvar setMeta = function (it) {\r\n  setDesc(it, META, { value: {\r\n    i: 'O' + ++id, // object ID\r\n    w: {}          // weak collections IDs\r\n  } });\r\n};\r\nvar fastKey = function (it, create) {\r\n  // return primitive with prefix\r\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\r\n  if (!has(it, META)) {\r\n    // can't set metadata to uncaught frozen object\r\n    if (!isExtensible(it)) return 'F';\r\n    // not necessary to add metadata\r\n    if (!create) return 'E';\r\n    // add missing metadata\r\n    setMeta(it);\r\n  // return object ID\r\n  } return it[META].i;\r\n};\r\nvar getWeak = function (it, create) {\r\n  if (!has(it, META)) {\r\n    // can't set metadata to uncaught frozen object\r\n    if (!isExtensible(it)) return true;\r\n    // not necessary to add metadata\r\n    if (!create) return false;\r\n    // add missing metadata\r\n    setMeta(it);\r\n  // return hash weak collections IDs\r\n  } return it[META].w;\r\n};\r\n// add metadata on freeze-family methods calling\r\nvar onFreeze = function (it) {\r\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\r\n  return it;\r\n};\r\nvar meta = module.exports = {\r\n  KEY: META,\r\n  NEED: false,\r\n  fastKey: fastKey,\r\n  getWeak: getWeak,\r\n  onFreeze: onFreeze\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 158 */\r\n/***/ (function(module, exports, __nested_webpack_require_269693__) {\r\n\r\n\"use strict\";\r\n\r\n// ECMAScript 6 symbols shim\r\nvar global = __nested_webpack_require_269693__(1);\r\nvar has = __nested_webpack_require_269693__(12);\r\nvar DESCRIPTORS = __nested_webpack_require_269693__(11);\r\nvar $export = __nested_webpack_require_269693__(15);\r\nvar redefine = __nested_webpack_require_269693__(14);\r\nvar META = __nested_webpack_require_269693__(157).KEY;\r\nvar $fails = __nested_webpack_require_269693__(23);\r\nvar shared = __nested_webpack_require_269693__(36);\r\nvar setToStringTag = __nested_webpack_require_269693__(25);\r\nvar uid = __nested_webpack_require_269693__(22);\r\nvar wks = __nested_webpack_require_269693__(0);\r\nvar wksExt = __nested_webpack_require_269693__(60);\r\nvar wksDefine = __nested_webpack_require_269693__(156);\r\nvar enumKeys = __nested_webpack_require_269693__(155);\r\nvar isArray = __nested_webpack_require_269693__(153);\r\nvar anObject = __nested_webpack_require_269693__(6);\r\nvar isObject = __nested_webpack_require_269693__(8);\r\nvar toIObject = __nested_webpack_require_269693__(7);\r\nvar toPrimitive = __nested_webpack_require_269693__(37);\r\nvar createDesc = __nested_webpack_require_269693__(28);\r\nvar _create = __nested_webpack_require_269693__(55);\r\nvar gOPNExt = __nested_webpack_require_269693__(151);\r\nvar $GOPD = __nested_webpack_require_269693__(150);\r\nvar $DP = __nested_webpack_require_269693__(9);\r\nvar $keys = __nested_webpack_require_269693__(13);\r\nvar gOPD = $GOPD.f;\r\nvar dP = $DP.f;\r\nvar gOPN = gOPNExt.f;\r\nvar $Symbol = global.Symbol;\r\nvar $JSON = global.JSON;\r\nvar _stringify = $JSON && $JSON.stringify;\r\nvar PROTOTYPE = 'prototype';\r\nvar HIDDEN = wks('_hidden');\r\nvar TO_PRIMITIVE = wks('toPrimitive');\r\nvar isEnum = {}.propertyIsEnumerable;\r\nvar SymbolRegistry = shared('symbol-registry');\r\nvar AllSymbols = shared('symbols');\r\nvar OPSymbols = shared('op-symbols');\r\nvar ObjectProto = Object[PROTOTYPE];\r\nvar USE_NATIVE = typeof $Symbol == 'function';\r\nvar QObject = global.QObject;\r\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\r\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\r\n\r\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\r\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\r\n  return _create(dP({}, 'a', {\r\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\r\n  })).a != 7;\r\n}) ? function (it, key, D) {\r\n  var protoDesc = gOPD(ObjectProto, key);\r\n  if (protoDesc) delete ObjectProto[key];\r\n  dP(it, key, D);\r\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\r\n} : dP;\r\n\r\nvar wrap = function (tag) {\r\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\r\n  sym._k = tag;\r\n  return sym;\r\n};\r\n\r\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\r\n  return typeof it == 'symbol';\r\n} : function (it) {\r\n  return it instanceof $Symbol;\r\n};\r\n\r\nvar $defineProperty = function defineProperty(it, key, D) {\r\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\r\n  anObject(it);\r\n  key = toPrimitive(key, true);\r\n  anObject(D);\r\n  if (has(AllSymbols, key)) {\r\n    if (!D.enumerable) {\r\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\r\n      it[HIDDEN][key] = true;\r\n    } else {\r\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\r\n      D = _create(D, { enumerable: createDesc(0, false) });\r\n    } return setSymbolDesc(it, key, D);\r\n  } return dP(it, key, D);\r\n};\r\nvar $defineProperties = function defineProperties(it, P) {\r\n  anObject(it);\r\n  var keys = enumKeys(P = toIObject(P));\r\n  var i = 0;\r\n  var l = keys.length;\r\n  var key;\r\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\r\n  return it;\r\n};\r\nvar $create = function create(it, P) {\r\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\r\n};\r\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\r\n  var E = isEnum.call(this, key = toPrimitive(key, true));\r\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\r\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\r\n};\r\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\r\n  it = toIObject(it);\r\n  key = toPrimitive(key, true);\r\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\r\n  var D = gOPD(it, key);\r\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\r\n  return D;\r\n};\r\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\r\n  var names = gOPN(toIObject(it));\r\n  var result = [];\r\n  var i = 0;\r\n  var key;\r\n  while (names.length > i) {\r\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\r\n  } return result;\r\n};\r\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\r\n  var IS_OP = it === ObjectProto;\r\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\r\n  var result = [];\r\n  var i = 0;\r\n  var key;\r\n  while (names.length > i) {\r\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\r\n  } return result;\r\n};\r\n\r\n// 19.4.1.1 Symbol([description])\r\nif (!USE_NATIVE) {\r\n  $Symbol = function Symbol() {\r\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\r\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\r\n    var $set = function (value) {\r\n      if (this === ObjectProto) $set.call(OPSymbols, value);\r\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\r\n      setSymbolDesc(this, tag, createDesc(1, value));\r\n    };\r\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\r\n    return wrap(tag);\r\n  };\r\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\r\n    return this._k;\r\n  });\r\n\r\n  $GOPD.f = $getOwnPropertyDescriptor;\r\n  $DP.f = $defineProperty;\r\n  __nested_webpack_require_269693__(53).f = gOPNExt.f = $getOwnPropertyNames;\r\n  __nested_webpack_require_269693__(19).f = $propertyIsEnumerable;\r\n  __nested_webpack_require_269693__(31).f = $getOwnPropertySymbols;\r\n\r\n  if (DESCRIPTORS && !__nested_webpack_require_269693__(21)) {\r\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\r\n  }\r\n\r\n  wksExt.f = function (name) {\r\n    return wrap(wks(name));\r\n  };\r\n}\r\n\r\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\r\n\r\nfor (var es6Symbols = (\r\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\r\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\r\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\r\n\r\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\r\n\r\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\r\n  // 19.4.2.1 Symbol.for(key)\r\n  'for': function (key) {\r\n    return has(SymbolRegistry, key += '')\r\n      ? SymbolRegistry[key]\r\n      : SymbolRegistry[key] = $Symbol(key);\r\n  },\r\n  // 19.4.2.5 Symbol.keyFor(sym)\r\n  keyFor: function keyFor(sym) {\r\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\r\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\r\n  },\r\n  useSetter: function () { setter = true; },\r\n  useSimple: function () { setter = false; }\r\n});\r\n\r\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\r\n  // 19.1.2.2 Object.create(O [, Properties])\r\n  create: $create,\r\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\r\n  defineProperty: $defineProperty,\r\n  // 19.1.2.3 Object.defineProperties(O, Properties)\r\n  defineProperties: $defineProperties,\r\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\r\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\r\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\r\n  getOwnPropertyNames: $getOwnPropertyNames,\r\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\r\n  getOwnPropertySymbols: $getOwnPropertySymbols\r\n});\r\n\r\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\r\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\r\n  var S = $Symbol();\r\n  // MS Edge converts symbol values to JSON as {}\r\n  // WebKit converts symbol values to JSON as null\r\n  // V8 throws on boxed symbols\r\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\r\n})), 'JSON', {\r\n  stringify: function stringify(it) {\r\n    var args = [it];\r\n    var i = 1;\r\n    var replacer, $replacer;\r\n    while (arguments.length > i) args.push(arguments[i++]);\r\n    $replacer = replacer = args[1];\r\n    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\r\n    if (!isArray(replacer)) replacer = function (key, value) {\r\n      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\r\n      if (!isSymbol(value)) return value;\r\n    };\r\n    args[1] = replacer;\r\n    return _stringify.apply($JSON, args);\r\n  }\r\n});\r\n\r\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\r\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || __nested_webpack_require_269693__(10)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\r\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\r\nsetToStringTag($Symbol, 'Symbol');\r\n// 20.2.1.9 Math[@@toStringTag]\r\nsetToStringTag(Math, 'Math', true);\r\n// 24.3.3 JSON[@@toStringTag]\r\nsetToStringTag(global.JSON, 'JSON', true);\r\n\r\n\r\n/***/ }),\r\n/* 159 */\r\n/***/ (function(module, exports, __nested_webpack_require_278874__) {\r\n\r\n__nested_webpack_require_278874__(158);\r\n__nested_webpack_require_278874__(52);\r\nmodule.exports = __nested_webpack_require_278874__(2).Symbol;\r\n\r\n\r\n/***/ }),\r\n/* 160 */\r\n/***/ (function(module, exports, __nested_webpack_require_279061__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.Plugins = exports.Sensors = exports.Sortable = exports.Swappable = exports.Droppable = exports.Draggable = exports.BasePlugin = exports.BaseEvent = undefined;\r\n\r\n__nested_webpack_require_279061__(159);\r\n\r\n__nested_webpack_require_279061__(149);\r\n\r\n__nested_webpack_require_279061__(126);\r\n\r\n__nested_webpack_require_279061__(123);\r\n\r\n__nested_webpack_require_279061__(120);\r\n\r\nvar _AbstractEvent = __nested_webpack_require_279061__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_279061__(3);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _Sensors = __nested_webpack_require_279061__(29);\r\n\r\nvar Sensors = _interopRequireWildcard(_Sensors);\r\n\r\nvar _Plugins = __nested_webpack_require_279061__(98);\r\n\r\nvar Plugins = _interopRequireWildcard(_Plugins);\r\n\r\nvar _Draggable = __nested_webpack_require_279061__(24);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nvar _Droppable = __nested_webpack_require_279061__(70);\r\n\r\nvar _Droppable2 = _interopRequireDefault(_Droppable);\r\n\r\nvar _Swappable = __nested_webpack_require_279061__(67);\r\n\r\nvar _Swappable2 = _interopRequireDefault(_Swappable);\r\n\r\nvar _Sortable = __nested_webpack_require_279061__(64);\r\n\r\nvar _Sortable2 = _interopRequireDefault(_Sortable);\r\n\r\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.BaseEvent = _AbstractEvent2.default;\r\nexports.BasePlugin = _AbstractPlugin2.default;\r\nexports.Draggable = _Draggable2.default;\r\nexports.Droppable = _Droppable2.default;\r\nexports.Swappable = _Swappable2.default;\r\nexports.Sortable = _Sortable2.default;\r\nexports.Sensors = Sensors;\r\nexports.Plugins = Plugins;\r\n\r\n/***/ })\r\n/******/ ]);\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9kcmFnZ2FibGUuYnVuZGxlLmxlZ2FjeS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNLEVBSzBCO0FBQ2hDLENBQUM7QUFDRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDhCQUFtQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZUFBZSw4QkFBbUI7QUFDbEMsbURBQW1ELCtCQUErQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0EsaUVBQWlFLGlCQUFpQjtBQUNsRjtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZ0NBQWdDLDhCQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUFtQjtBQUM5QixrREFBa0QsZ0NBQWdDO0FBQ2xGLDBFQUEwRSw4QkFBbUIsNEJBQTRCLG9CQUFvQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRSwwQ0FBMEM7QUFDMUMsV0FBVyw4QkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFB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O0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7QUFDcEQ7QUFDQSxlQUFlLGdDQUFtQjtBQUNsQyxlQUFlLGdDQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUJBQXFCLGdDQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCLGdDQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCLGdDQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0JBQW9CLGdDQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGlCQUFpQixnQ0FBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FB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Q2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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dUMsdUNBQXVDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JD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QTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksZUFBZTtBQUMzQjtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQ0FBc0M7QUFDckUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksV0FBVztBQUN2QixZQUFZLG9CQUFvQjtBQUNoQztBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtB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LGdGQUFnRixzQkFBc0I7QUFDM1A7QUFDQSx1Q0FBdUMsdUNBQXVDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvbGliL2RyYWdnYWJsZS5idW5kbGUubGVnYWN5LmpzP2JkOGMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuXHRcdGRlZmluZShcIkRyYWdnYWJsZVwiLCBbXSwgZmFjdG9yeSk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcblx0XHRleHBvcnRzW1wiRHJhZ2dhYmxlXCJdID0gZmFjdG9yeSgpO1xyXG5cdGVsc2VcclxuXHRcdHJvb3RbXCJEcmFnZ2FibGVcIl0gPSBmYWN0b3J5KCk7XHJcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XHJcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXHJcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcclxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XHJcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcclxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcclxuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXHJcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxyXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxyXG4vKioqKioqLyBcdFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXHJcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxyXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG4vKioqKioqLyBcdH1cclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xyXG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XHJcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcclxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XHJcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xyXG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XHJcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcclxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNjApO1xyXG4vKioqKioqLyB9KVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKioqKioqLyAoW1xyXG4vKiAwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbnZhciBzdG9yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpKCd3a3MnKTtcclxudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xyXG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5TeW1ib2w7XHJcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xyXG5cclxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxyXG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcclxufTtcclxuXHJcbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcclxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXHJcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcclxuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG52YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjcnIH07XHJcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTcpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOCk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfY2xvc2VzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEzKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY2xvc2VzdCcsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb3Nlc3QpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTExKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncmVxdWVzdE5leHRBbmltYXRpb25GcmFtZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfZGlzdGFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2Rpc3RhbmNlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzdGFuY2UpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfdG91Y2hDb29yZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNyk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3RvdWNoQ29vcmRzJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG91Y2hDb29yZHMpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKioqLyB9KSxcclxuLyogNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xyXG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XHJcbiAgcmV0dXJuIGl0O1xyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xyXG52YXIgSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xyXG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xyXG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xyXG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XHJcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xyXG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XHJcblxyXG5leHBvcnRzLmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcclxuICBhbk9iamVjdChPKTtcclxuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XHJcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XHJcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xyXG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xyXG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxyXG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XHJcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XHJcbiAgcmV0dXJuIE87XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbnZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcbnZhciBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XHJcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSkgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XHJcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcclxufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcclxuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xyXG4gIHJldHVybiBvYmplY3Q7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDExICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcclxubW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXygyMykoZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xyXG59KTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcclxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXHJcbnZhciAka2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xyXG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XHJcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxudmFyIFNSQyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpKCdzcmMnKTtcclxudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XHJcbnZhciAkdG9TdHJpbmcgPSBGdW5jdGlvbltUT19TVFJJTkddO1xyXG52YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xyXG5cclxuX193ZWJwYWNrX3JlcXVpcmVfXygyKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XHJcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcclxufTtcclxuXHJcbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xyXG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xyXG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XHJcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XHJcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xyXG4gIGlmIChPID09PSBnbG9iYWwpIHtcclxuICAgIE9ba2V5XSA9IHZhbDtcclxuICB9IGVsc2UgaWYgKCFzYWZlKSB7XHJcbiAgICBkZWxldGUgT1trZXldO1xyXG4gICAgaGlkZShPLCBrZXksIHZhbCk7XHJcbiAgfSBlbHNlIGlmIChPW2tleV0pIHtcclxuICAgIE9ba2V5XSA9IHZhbDtcclxuICB9IGVsc2Uge1xyXG4gICAgaGlkZShPLCBrZXksIHZhbCk7XHJcbiAgfVxyXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcclxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcclxufSk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG52YXIgY3R4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XHJcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcclxuXHJcbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xyXG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xyXG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xyXG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xyXG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XHJcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xyXG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XHJcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcclxuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcclxuICB2YXIga2V5LCBvd24sIG91dCwgZXhwO1xyXG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XHJcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XHJcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcclxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XHJcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxyXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcclxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XHJcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcclxuICAgIC8vIGV4dGVuZCBnbG9iYWxcclxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xyXG4gICAgLy8gZXhwb3J0XHJcbiAgICBpZiAoZXhwb3J0c1trZXldICE9IG91dCkgaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XHJcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XHJcbiAgfVxyXG59O1xyXG5nbG9iYWwuY29yZSA9IGNvcmU7XHJcbi8vIHR5cGUgYml0bWFwXHJcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXHJcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXHJcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXHJcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cclxuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXHJcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxyXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcclxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXHJcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDUpO1xyXG5cclxuT2JqZWN0LmtleXMoX1NlbnNvckV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1NlbnNvckV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNik7XHJcblxyXG52YXIgX1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9TZW5zb3IyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7fTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcclxuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG52YXIgaWQgPSAwO1xyXG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiAhIWV4ZWMoKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9EcmFnRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcclxuXHJcbk9iamVjdC5rZXlzKF9EcmFnRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfRHJhZ0V2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9EcmFnZ2FibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xyXG5cclxuT2JqZWN0LmtleXMoX0RyYWdnYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX0RyYWdnYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9QbHVnaW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XHJcblxyXG5PYmplY3Qua2V5cyhfUGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9QbHVnaW5zW2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XHJcblxyXG5PYmplY3Qua2V5cyhfU2Vuc29ycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9TZW5zb3JzW2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9EcmFnZ2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcclxuXHJcbnZhciBfRHJhZ2dhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RyYWdnYWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0RyYWdnYWJsZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG52YXIgZGVmID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KS5mO1xyXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciBUQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKCd0b1N0cmluZ1RhZycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xyXG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XHJcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xyXG4gIHJldHVybiBpdDtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMjcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXHJcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xyXG4gIGFGdW5jdGlvbihmbik7XHJcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xyXG4gIHN3aXRjaCAobGVuZ3RoKSB7XHJcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcclxuICAgIH07XHJcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcclxuICAgIH07XHJcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xyXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMjggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxyXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxyXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXHJcbiAgICB2YWx1ZTogdmFsdWVcclxuICB9O1xyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1NlbnNvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Nb3VzZVNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTE1KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTW91c2VTZW5zb3InLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Nb3VzZVNlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Ub3VjaFNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTA0KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnVG91Y2hTZW5zb3InLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ub3VjaFNlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9EcmFnU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDIpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdEcmFnU2Vuc29yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ1NlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Gb3JjZVRvdWNoU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDApO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdGb3JjZVRvdWNoU2Vuc29yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRm9yY2VUb3VjaFNlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG5cclxuT2JqZWN0LmtleXMoX1NlbnNvckV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1NlbnNvckV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4vLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxyXG52YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbnZhciBUQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKCd0b1N0cmluZ1RhZycpO1xyXG4vLyBFUzMgd3JvbmcgaGVyZVxyXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcclxuXHJcbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXHJcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gaXRba2V5XTtcclxuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XHJcbiAgdmFyIE8sIFQsIEI7XHJcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXHJcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcclxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcclxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxyXG4gICAgOiBBUkcgPyBjb2YoTylcclxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcclxuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG4vLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXHJcbm1vZHVsZS5leHBvcnRzID0gKFxyXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXHJcbikuc3BsaXQoJywnKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMzMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpKCdrZXlzJyk7XHJcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMzQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuLy8gNy4xLjQgVG9JbnRlZ2VyXHJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xyXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xyXG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG4vLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xyXG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcclxuICByZXR1cm4gaXQ7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbnZhciBjb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcclxudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xyXG5cclxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcclxufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xyXG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcclxuICBtb2RlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxyXG4gIGNvcHlyaWdodDogJ8KpIDIwMTggRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXHJcbn0pO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4vLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcclxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2VcclxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcclxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xyXG4gIHZhciBmbiwgdmFsO1xyXG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xyXG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xyXG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcclxuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuZG9jdW1lbnQ7XHJcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxyXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XHJcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMzkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NvcnRhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcclxuXHJcbk9iamVjdC5rZXlzKF9Tb3J0YWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1NvcnRhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1N3YXBwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XHJcblxyXG5PYmplY3Qua2V5cyhfU3dhcHBhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfU3dhcHBhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Ryb3BwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XHJcblxyXG5PYmplY3Qua2V5cyhfRHJvcHBhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfRHJvcHBhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fubm91bmNlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oODMpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdBbm5vdW5jZW1lbnQnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Bbm5vdW5jZW1lbnQpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0QW5ub3VuY2VtZW50T3B0aW9ucycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9Bbm5vdW5jZW1lbnQuZGVmYXVsdE9wdGlvbnM7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfRm9jdXNhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0ZvY3VzYWJsZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZvY3VzYWJsZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9NaXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTWlycm9yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWlycm9yKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGVmYXVsdE1pcnJvck9wdGlvbnMnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfTWlycm9yLmRlZmF1bHRPcHRpb25zO1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1Njcm9sbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU2Nyb2xsYWJsZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Njcm9sbGFibGUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0U2Nyb2xsYWJsZU9wdGlvbnMnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfU2Nyb2xsYWJsZS5kZWZhdWx0T3B0aW9ucztcclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0MyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRHJhZ2dhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0KTtcclxuXHJcbk9iamVjdC5rZXlzKF9EcmFnZ2FibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9EcmFnZ2FibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0NCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRHJhZ0V2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NSk7XHJcblxyXG5PYmplY3Qua2V5cyhfRHJhZ0V2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX0RyYWdFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0NSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU25hcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxKTtcclxuXHJcbk9iamVjdC5rZXlzKF9TbmFwcGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9TbmFwcGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0NiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQ29sbGlkYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nik7XHJcblxyXG5PYmplY3Qua2V5cyhfQ29sbGlkYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX0NvbGxpZGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0NyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXHJcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcclxuXHJcbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcclxuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xyXG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XHJcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XHJcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xyXG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XHJcbiAgfSk7XHJcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xyXG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbnZhciBjdHggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcclxudmFyIGludm9rZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTM0KTtcclxudmFyIGh0bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KTtcclxudmFyIGNlbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xyXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcclxudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xyXG52YXIgY2xlYXJUYXNrID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xyXG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XHJcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcclxudmFyIGNvdW50ZXIgPSAwO1xyXG52YXIgcXVldWUgPSB7fTtcclxudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xyXG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XHJcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGlkID0gK3RoaXM7XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xyXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcclxuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcclxuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XHJcbiAgICBmbigpO1xyXG4gIH1cclxufTtcclxudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XHJcbn07XHJcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcclxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcclxuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgdmFyIGkgPSAxO1xyXG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xyXG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXHJcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcclxuICAgIH07XHJcbiAgICBkZWZlcihjb3VudGVyKTtcclxuICAgIHJldHVybiBjb3VudGVyO1xyXG4gIH07XHJcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcclxuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XHJcbiAgfTtcclxuICAvLyBOb2RlLmpzIDAuOC1cclxuICBpZiAoX193ZWJwYWNrX3JlcXVpcmVfXygyMCkocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XHJcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XHJcbiAgICB9O1xyXG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxyXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XHJcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcclxuICAgIH07XHJcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xyXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcclxuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcclxuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xyXG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcclxuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xyXG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xyXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXHJcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcclxuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xyXG4gICAgfTtcclxuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcclxuICAvLyBJRTgtXHJcbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xyXG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBzZXQ6IHNldFRhc2ssXHJcbiAgY2xlYXI6IGNsZWFyVGFza1xyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0OSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4vLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXHJcbnZhciBVTlNDT1BBQkxFUyA9IF9fd2VicGFja19yZXF1aXJlX18oMCkoJ3Vuc2NvcGFibGVzJyk7XHJcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xyXG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNTAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxyXG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xyXG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBMSUJSQVJZID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbnZhciAkaXRlckNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ2KTtcclxudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XHJcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ1KTtcclxudmFyIElURVJBVE9SID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKSgnaXRlcmF0b3InKTtcclxudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXHJcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcclxudmFyIEtFWVMgPSAna2V5cyc7XHJcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcclxuXHJcbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xyXG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcclxuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcclxuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xyXG4gICAgc3dpdGNoIChraW5kKSB7XHJcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XHJcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xyXG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcclxuICB9O1xyXG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XHJcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcclxuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xyXG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xyXG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xyXG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xyXG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XHJcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xyXG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xyXG4gIC8vIEZpeCBuYXRpdmVcclxuICBpZiAoJGFueU5hdGl2ZSkge1xyXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xyXG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcclxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xyXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcclxuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXHJcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxyXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcclxuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xyXG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XHJcbiAgfVxyXG4gIC8vIERlZmluZSBpdGVyYXRvclxyXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xyXG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcclxuICB9XHJcbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxyXG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xyXG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcclxuICBpZiAoREVGQVVMVCkge1xyXG4gICAgbWV0aG9kcyA9IHtcclxuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcclxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXHJcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXHJcbiAgICB9O1xyXG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xyXG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xyXG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcclxuICB9XHJcbiAgcmV0dXJuIG1ldGhvZHM7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDUyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXHJcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XHJcbnZhciB0ZXN0ID0ge307XHJcbnRlc3RbX193ZWJwYWNrX3JlcXVpcmVfXygwKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XHJcbmlmICh0ZXN0ICsgJycgIT0gJ1tvYmplY3Qgel0nKSB7XHJcbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxNCkoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XHJcbiAgfSwgdHJ1ZSk7XHJcbn1cclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNTMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxyXG52YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcclxudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcclxuXHJcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xyXG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNTQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5kb2N1bWVudDtcclxubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDU1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxyXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgZFBzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTIpO1xyXG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcclxudmFyIElFX1BST1RPID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMykoJ0lFX1BST1RPJyk7XHJcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcclxudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xyXG5cclxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxyXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcclxuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xyXG4gIHZhciBpZnJhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KSgnaWZyYW1lJyk7XHJcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XHJcbiAgdmFyIGx0ID0gJzwnO1xyXG4gIHZhciBndCA9ICc+JztcclxuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XHJcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg1NCkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcclxuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXHJcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcclxuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcclxuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XHJcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xyXG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XHJcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XHJcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XHJcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xyXG4gIHZhciByZXN1bHQ7XHJcbiAgaWYgKE8gIT09IG51bGwpIHtcclxuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcclxuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xyXG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XHJcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXHJcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcclxuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xyXG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNTYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuLy8gNy4xLjE1IFRvTGVuZ3RoXHJcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcclxudmFyIG1pbiA9IE1hdGgubWluO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xyXG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDU3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2ZcclxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcclxudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xyXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTQpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcclxuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcclxuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XHJcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xyXG4gICAgdmFyIHZhbHVlO1xyXG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxyXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcclxuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXHJcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XHJcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XHJcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XHJcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xyXG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xyXG4gIH07XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDU4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXHJcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XHJcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1OSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgYXJyYXlJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NykoZmFsc2UpO1xyXG52YXIgSUVfUFJPVE8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKSgnSUVfUFJPVE8nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcclxuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xyXG4gIHZhciBpID0gMDtcclxuICB2YXIgcmVzdWx0ID0gW107XHJcbiAgdmFyIGtleTtcclxuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xyXG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcclxuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xyXG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNjAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXhwb3J0cy5mID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNjEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXygxMSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18oMjMpKGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19yZXF1aXJlX18oMzgpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XHJcbn0pO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0RyYWdnYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xyXG5cclxudmFyIF9EcmFnZ2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ2dhYmxlKTtcclxuXHJcbnZhciBfU29ydGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdPdmVyQ29udGFpbmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyQ29udGFpbmVyJyk7XHJcbmNvbnN0IG9uRHJhZ092ZXIgPSBTeW1ib2woJ29uRHJhZ092ZXInKTtcclxuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW5ub3VuY2VtZW50IG1lc3NhZ2Ugd2hlbiBhIERyYWdnYWJsZSBlbGVtZW50IGhhcyBiZWVuIHNvcnRlZCB3aXRoIGFub3RoZXIgRHJhZ2dhYmxlIGVsZW1lbnRcclxuICogb3IgbW92ZWQgaW50byBhIG5ldyBjb250YWluZXJcclxuICogQHBhcmFtIHtTb3J0YWJsZVNvcnRlZEV2ZW50fSBzb3J0YWJsZUV2ZW50XHJcbiAqIEByZXR1cm4ge1N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIG9uU29ydGFibGVTb3J0ZWREZWZhdWx0QW5ub3VuY2VtZW50KHsgZHJhZ0V2ZW50IH0pIHtcclxuICBjb25zdCBzb3VyY2VUZXh0ID0gZHJhZ0V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50LnNvdXJjZS5pZCB8fCAnc29ydGFibGUgZWxlbWVudCc7XHJcblxyXG4gIGlmIChkcmFnRXZlbnQub3Zlcikge1xyXG4gICAgY29uc3Qgb3ZlclRleHQgPSBkcmFnRXZlbnQub3Zlci50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50Lm92ZXIuaWQgfHwgJ3NvcnRhYmxlIGVsZW1lbnQnO1xyXG4gICAgY29uc3QgaXNGb2xsb3dpbmcgPSBkcmFnRXZlbnQuc291cmNlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGRyYWdFdmVudC5vdmVyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xyXG5cclxuICAgIGlmIChpc0ZvbGxvd2luZykge1xyXG4gICAgICByZXR1cm4gYFBsYWNlZCAke3NvdXJjZVRleHR9IGFmdGVyICR7b3ZlclRleHR9YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBgUGxhY2VkICR7c291cmNlVGV4dH0gYmVmb3JlICR7b3ZlclRleHR9YDtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gbmVlZCB0byBmaWd1cmUgb3V0IGhvdyB0byBjb21wdXRlIGNvbnRhaW5lciBuYW1lXHJcbiAgICByZXR1cm4gYFBsYWNlZCAke3NvdXJjZVRleHR9IGludG8gYSBkaWZmZXJlbnQgY29udGFpbmVyYDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAY29uc3Qge09iamVjdH0gZGVmYXVsdEFubm91bmNlbWVudHNcclxuICogQGNvbnN0IHtGdW5jdGlvbn0gZGVmYXVsdEFubm91bmNlbWVudHNbJ3NvcnRhYmxlOnNvcnRlZCddXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0QW5ub3VuY2VtZW50cyA9IHtcclxuICAnc29ydGFibGU6c29ydGVkJzogb25Tb3J0YWJsZVNvcnRlZERlZmF1bHRBbm5vdW5jZW1lbnRcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTb3J0YWJsZSBpcyBidWlsdCBvbiB0b3Agb2YgRHJhZ2dhYmxlIGFuZCBhbGxvd3Mgc29ydGluZyBvZiBkcmFnZ2FibGUgZWxlbWVudHMuIFNvcnRhYmxlIHdpbGwga2VlcFxyXG4gKiB0cmFjayBvZiB0aGUgb3JpZ2luYWwgaW5kZXggYW5kIGVtaXRzIHRoZSBuZXcgaW5kZXggYXMgeW91IGRyYWcgb3ZlciBkcmFnZ2FibGUgZWxlbWVudHMuXHJcbiAqIEBjbGFzcyBTb3J0YWJsZVxyXG4gKiBAbW9kdWxlIFNvcnRhYmxlXHJcbiAqIEBleHRlbmRzIERyYWdnYWJsZVxyXG4gKi9cclxuY2xhc3MgU29ydGFibGUgZXh0ZW5kcyBfRHJhZ2dhYmxlMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBTb3J0YWJsZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBTb3J0YWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIFNvcnRhYmxlIGNvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIFNvcnRhYmxlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lcnMsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XHJcbiAgICAgIGFubm91bmNlbWVudHM6IF9leHRlbmRzKHt9LCBkZWZhdWx0QW5ub3VuY2VtZW50cywgb3B0aW9ucy5hbm5vdW5jZW1lbnRzIHx8IHt9KVxyXG4gICAgfSkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc3RhcnQgaW5kZXggb2Ygc291cmNlIG9uIGRyYWcgc3RhcnRcclxuICAgICAqIEBwcm9wZXJ0eSBzdGFydEluZGV4XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc3RhcnQgY29udGFpbmVyIG9uIGRyYWcgc3RhcnRcclxuICAgICAqIEBwcm9wZXJ0eSBzdGFydENvbnRhaW5lclxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0YXJ0Q29udGFpbmVyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ092ZXJDb250YWluZXJdID0gdGhpc1tvbkRyYWdPdmVyQ29udGFpbmVyXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzpvdmVyOmNvbnRhaW5lcicsIHRoaXNbb25EcmFnT3ZlckNvbnRhaW5lcl0pLm9uKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95cyBTb3J0YWJsZSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgc3VwZXIuZGVzdHJveSgpO1xyXG5cclxuICAgIHRoaXMub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzpvdmVyOmNvbnRhaW5lcicsIHRoaXNbb25EcmFnT3ZlckNvbnRhaW5lcl0pLm9mZignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpbmRleCBvZiBlbGVtZW50IHdpdGhpbiBpdHMgY29udGFpbmVyIGR1cmluZyBkcmFnIG9wZXJhdGlvbiwgaS5lLiBleGNsdWRpbmcgbWlycm9yIGFuZCBvcmlnaW5hbCBzb3VyY2VcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gQW4gZWxlbWVudFxyXG4gICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgKi9cclxuICBpbmRleChlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRTb3J0YWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKGVsZW1lbnQucGFyZW50Tm9kZSkuaW5kZXhPZihlbGVtZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgc29ydGFibGUgZWxlbWVudHMgZm9yIGEgZ2l2ZW4gY29udGFpbmVyLCBleGNsdWRpbmcgdGhlIG1pcnJvciBhbmRcclxuICAgKiBvcmlnaW5hbCBzb3VyY2UgZWxlbWVudCBpZiBwcmVzZW50XHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnRbXX1cclxuICAgKi9cclxuICBnZXRTb3J0YWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gICAgY29uc3QgYWxsU29ydGFibGVFbGVtZW50cyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xyXG5cclxuICAgIHJldHVybiBbLi4uYWxsU29ydGFibGVFbGVtZW50c10uZmlsdGVyKGNoaWxkRWxlbWVudCA9PiB7XHJcbiAgICAgIHJldHVybiBjaGlsZEVsZW1lbnQgIT09IHRoaXMub3JpZ2luYWxTb3VyY2UgJiYgY2hpbGRFbGVtZW50ICE9PSB0aGlzLm1pcnJvciAmJiBjaGlsZEVsZW1lbnQucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0YXJ0RXZlbnR9IGV2ZW50IC0gRHJhZyBzdGFydCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcclxuICAgIHRoaXMuc3RhcnRDb250YWluZXIgPSBldmVudC5zb3VyY2UucGFyZW50Tm9kZTtcclxuICAgIHRoaXMuc3RhcnRJbmRleCA9IHRoaXMuaW5kZXgoZXZlbnQuc291cmNlKTtcclxuXHJcbiAgICBjb25zdCBzb3J0YWJsZVN0YXJ0RXZlbnQgPSBuZXcgX1NvcnRhYmxlRXZlbnQuU29ydGFibGVTdGFydEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcclxuICAgICAgc3RhcnRJbmRleDogdGhpcy5zdGFydEluZGV4LFxyXG4gICAgICBzdGFydENvbnRhaW5lcjogdGhpcy5zdGFydENvbnRhaW5lclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHNvcnRhYmxlU3RhcnRFdmVudCk7XHJcblxyXG4gICAgaWYgKHNvcnRhYmxlU3RhcnRFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBvdmVyIGNvbnRhaW5lciBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyQ29udGFpbmVyRXZlbnR9IGV2ZW50IC0gRHJhZyBvdmVyIGNvbnRhaW5lciBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdmVyQ29udGFpbmVyXShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyIH0gPSBldmVudDtcclxuICAgIGNvbnN0IG9sZEluZGV4ID0gdGhpcy5pbmRleChzb3VyY2UpO1xyXG5cclxuICAgIGNvbnN0IHNvcnRhYmxlU29ydEV2ZW50ID0gbmV3IF9Tb3J0YWJsZUV2ZW50LlNvcnRhYmxlU29ydEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcclxuICAgICAgY3VycmVudEluZGV4OiBvbGRJbmRleCxcclxuICAgICAgc291cmNlLFxyXG4gICAgICBvdmVyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTb3J0RXZlbnQpO1xyXG5cclxuICAgIGlmIChzb3J0YWJsZVNvcnRFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0U29ydGFibGVFbGVtZW50c0ZvckNvbnRhaW5lcihvdmVyQ29udGFpbmVyKTtcclxuICAgIGNvbnN0IG1vdmVzID0gbW92ZSh7IHNvdXJjZSwgb3Zlciwgb3ZlckNvbnRhaW5lciwgY2hpbGRyZW4gfSk7XHJcblxyXG4gICAgaWYgKCFtb3Zlcykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBvbGRDb250YWluZXIsIG5ld0NvbnRhaW5lciB9ID0gbW92ZXM7XHJcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuaW5kZXgoZXZlbnQuc291cmNlKTtcclxuXHJcbiAgICBjb25zdCBzb3J0YWJsZVNvcnRlZEV2ZW50ID0gbmV3IF9Tb3J0YWJsZUV2ZW50LlNvcnRhYmxlU29ydGVkRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBvbGRJbmRleCxcclxuICAgICAgbmV3SW5kZXgsXHJcbiAgICAgIG9sZENvbnRhaW5lcixcclxuICAgICAgbmV3Q29udGFpbmVyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTb3J0ZWRFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG92ZXIgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnT3ZlckV2ZW50fSBldmVudCAtIERyYWcgb3ZlciBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdmVyXShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50Lm92ZXIgPT09IGV2ZW50Lm9yaWdpbmFsU291cmNlIHx8IGV2ZW50Lm92ZXIgPT09IGV2ZW50LnNvdXJjZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBzb3VyY2UsIG92ZXIsIG92ZXJDb250YWluZXIgfSA9IGV2ZW50O1xyXG4gICAgY29uc3Qgb2xkSW5kZXggPSB0aGlzLmluZGV4KHNvdXJjZSk7XHJcblxyXG4gICAgY29uc3Qgc29ydGFibGVTb3J0RXZlbnQgPSBuZXcgX1NvcnRhYmxlRXZlbnQuU29ydGFibGVTb3J0RXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBjdXJyZW50SW5kZXg6IG9sZEluZGV4LFxyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG92ZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVNvcnRFdmVudCk7XHJcblxyXG4gICAgaWYgKHNvcnRhYmxlU29ydEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihvdmVyQ29udGFpbmVyKTtcclxuICAgIGNvbnN0IG1vdmVzID0gbW92ZSh7IHNvdXJjZSwgb3Zlciwgb3ZlckNvbnRhaW5lciwgY2hpbGRyZW4gfSk7XHJcblxyXG4gICAgaWYgKCFtb3Zlcykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBvbGRDb250YWluZXIsIG5ld0NvbnRhaW5lciB9ID0gbW92ZXM7XHJcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuaW5kZXgoc291cmNlKTtcclxuXHJcbiAgICBjb25zdCBzb3J0YWJsZVNvcnRlZEV2ZW50ID0gbmV3IF9Tb3J0YWJsZUV2ZW50LlNvcnRhYmxlU29ydGVkRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBvbGRJbmRleCxcclxuICAgICAgbmV3SW5kZXgsXHJcbiAgICAgIG9sZENvbnRhaW5lcixcclxuICAgICAgbmV3Q29udGFpbmVyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTb3J0ZWRFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0b3AgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RvcEV2ZW50fSBldmVudCAtIERyYWcgc3RvcCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdG9wXShldmVudCkge1xyXG4gICAgY29uc3Qgc29ydGFibGVTdG9wRXZlbnQgPSBuZXcgX1NvcnRhYmxlRXZlbnQuU29ydGFibGVTdG9wRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBvbGRJbmRleDogdGhpcy5zdGFydEluZGV4LFxyXG4gICAgICBuZXdJbmRleDogdGhpcy5pbmRleChldmVudC5zb3VyY2UpLFxyXG4gICAgICBvbGRDb250YWluZXI6IHRoaXMuc3RhcnRDb250YWluZXIsXHJcbiAgICAgIG5ld0NvbnRhaW5lcjogZXZlbnQuc291cmNlLnBhcmVudE5vZGVcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVN0b3BFdmVudCk7XHJcblxyXG4gICAgdGhpcy5zdGFydEluZGV4ID0gbnVsbDtcclxuICAgIHRoaXMuc3RhcnRDb250YWluZXIgPSBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gU29ydGFibGU7XHJcbmZ1bmN0aW9uIGluZGV4KGVsZW1lbnQpIHtcclxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChlbGVtZW50LnBhcmVudE5vZGUuY2hpbGRyZW4sIGVsZW1lbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtb3ZlKHsgc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyLCBjaGlsZHJlbiB9KSB7XHJcbiAgY29uc3QgZW1wdHlPdmVyQ29udGFpbmVyID0gIWNoaWxkcmVuLmxlbmd0aDtcclxuICBjb25zdCBkaWZmZXJlbnRDb250YWluZXIgPSBzb3VyY2UucGFyZW50Tm9kZSAhPT0gb3ZlckNvbnRhaW5lcjtcclxuICBjb25zdCBzYW1lQ29udGFpbmVyID0gb3ZlciAmJiBzb3VyY2UucGFyZW50Tm9kZSA9PT0gb3Zlci5wYXJlbnROb2RlO1xyXG5cclxuICBpZiAoZW1wdHlPdmVyQ29udGFpbmVyKSB7XHJcbiAgICByZXR1cm4gbW92ZUluc2lkZUVtcHR5Q29udGFpbmVyKHNvdXJjZSwgb3ZlckNvbnRhaW5lcik7XHJcbiAgfSBlbHNlIGlmIChzYW1lQ29udGFpbmVyKSB7XHJcbiAgICByZXR1cm4gbW92ZVdpdGhpbkNvbnRhaW5lcihzb3VyY2UsIG92ZXIpO1xyXG4gIH0gZWxzZSBpZiAoZGlmZmVyZW50Q29udGFpbmVyKSB7XHJcbiAgICByZXR1cm4gbW92ZU91dHNpZGVDb250YWluZXIoc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtb3ZlSW5zaWRlRW1wdHlDb250YWluZXIoc291cmNlLCBvdmVyQ29udGFpbmVyKSB7XHJcbiAgY29uc3Qgb2xkQ29udGFpbmVyID0gc291cmNlLnBhcmVudE5vZGU7XHJcblxyXG4gIG92ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoc291cmNlKTtcclxuXHJcbiAgcmV0dXJuIHsgb2xkQ29udGFpbmVyLCBuZXdDb250YWluZXI6IG92ZXJDb250YWluZXIgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gbW92ZVdpdGhpbkNvbnRhaW5lcihzb3VyY2UsIG92ZXIpIHtcclxuICBjb25zdCBvbGRJbmRleCA9IGluZGV4KHNvdXJjZSk7XHJcbiAgY29uc3QgbmV3SW5kZXggPSBpbmRleChvdmVyKTtcclxuXHJcbiAgaWYgKG9sZEluZGV4IDwgbmV3SW5kZXgpIHtcclxuICAgIHNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzb3VyY2UsIG92ZXIubmV4dEVsZW1lbnRTaWJsaW5nKTtcclxuICB9IGVsc2Uge1xyXG4gICAgc291cmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNvdXJjZSwgb3Zlcik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBvbGRDb250YWluZXI6IHNvdXJjZS5wYXJlbnROb2RlLCBuZXdDb250YWluZXI6IHNvdXJjZS5wYXJlbnROb2RlIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vdmVPdXRzaWRlQ29udGFpbmVyKHNvdXJjZSwgb3Zlciwgb3ZlckNvbnRhaW5lcikge1xyXG4gIGNvbnN0IG9sZENvbnRhaW5lciA9IHNvdXJjZS5wYXJlbnROb2RlO1xyXG5cclxuICBpZiAob3Zlcikge1xyXG4gICAgb3Zlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzb3VyY2UsIG92ZXIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBuZWVkIHRvIGZpZ3VyZSBvdXQgcHJvcGVyIHBvc2l0aW9uXHJcbiAgICBvdmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHNvdXJjZSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBvbGRDb250YWluZXIsIG5ld0NvbnRhaW5lcjogc291cmNlLnBhcmVudE5vZGUgfTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDYzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLlNvcnRhYmxlU3RvcEV2ZW50ID0gZXhwb3J0cy5Tb3J0YWJsZVNvcnRlZEV2ZW50ID0gZXhwb3J0cy5Tb3J0YWJsZVNvcnRFdmVudCA9IGV4cG9ydHMuU29ydGFibGVTdGFydEV2ZW50ID0gZXhwb3J0cy5Tb3J0YWJsZUV2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKipcclxuICogQmFzZSBzb3J0YWJsZSBldmVudFxyXG4gKiBAY2xhc3MgU29ydGFibGVFdmVudFxyXG4gKiBAbW9kdWxlIFNvcnRhYmxlRXZlbnRcclxuICogQGV4dGVuZHMgQWJzdHJhY3RFdmVudFxyXG4gKi9cclxuY2xhc3MgU29ydGFibGVFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgZHJhZyBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIHNvcnRhYmxlIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IGRyYWdFdmVudFxyXG4gICAqIEB0eXBlIHtEcmFnRXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyYWdFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Tb3J0YWJsZUV2ZW50ID0gU29ydGFibGVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNvcnRhYmxlIHN0YXJ0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTb3J0YWJsZVN0YXJ0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBTb3J0YWJsZVN0YXJ0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU29ydGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblNvcnRhYmxlRXZlbnQudHlwZSA9ICdzb3J0YWJsZSc7XHJcbmNsYXNzIFNvcnRhYmxlU3RhcnRFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBpbmRleCBvZiBzb3VyY2Ugb24gc29ydGFibGUgc3RhcnRcclxuICAgKiBAcHJvcGVydHkgc3RhcnRJbmRleFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHN0YXJ0SW5kZXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN0YXJ0SW5kZXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBjb250YWluZXIgb24gc29ydGFibGUgc3RhcnRcclxuICAgKiBAcHJvcGVydHkgc3RhcnRDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHN0YXJ0Q29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zdGFydENvbnRhaW5lcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuU29ydGFibGVTdGFydEV2ZW50ID0gU29ydGFibGVTdGFydEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNvcnRhYmxlIHNvcnQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTb3J0YWJsZVNvcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBTb3J0YWJsZVNvcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU29ydGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Tb3J0YWJsZVN0YXJ0RXZlbnQudHlwZSA9ICdzb3J0YWJsZTpzdGFydCc7XHJcblNvcnRhYmxlU3RhcnRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgU29ydGFibGVTb3J0RXZlbnQgZXh0ZW5kcyBTb3J0YWJsZUV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogSW5kZXggb2YgY3VycmVudCBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBjdXJyZW50SW5kZXhcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50SW5kZXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmN1cnJlbnRJbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBlbGVtZW50IHlvdSBhcmUgaG92ZXJpbmcgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciBlbGVtZW50IHlvdSBhcmUgaG92ZXJpbmcgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQub3ZlckNvbnRhaW5lcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuU29ydGFibGVTb3J0RXZlbnQgPSBTb3J0YWJsZVNvcnRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU29ydGFibGUgc29ydGVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFNvcnRhYmxlU29ydGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNvcnRhYmxlU29ydGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTb3J0YWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Tb3J0YWJsZVNvcnRFdmVudC50eXBlID0gJ3NvcnRhYmxlOnNvcnQnO1xyXG5Tb3J0YWJsZVNvcnRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgU29ydGFibGVTb3J0ZWRFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBJbmRleCBvZiBsYXN0IHNvcnRlZCBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBvbGRJbmRleFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9sZEluZGV4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vbGRJbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5ldyBpbmRleCBvZiB0aGlzIHNvcnRlZCBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBuZXdJbmRleFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG5ld0luZGV4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5uZXdJbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9sZCBjb250YWluZXIgb2YgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgb2xkQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvbGRDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9sZENvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5ldyBjb250YWluZXIgb2YgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbmV3Q29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBuZXdDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0NvbnRhaW5lcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuU29ydGFibGVTb3J0ZWRFdmVudCA9IFNvcnRhYmxlU29ydGVkRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTb3J0YWJsZSBzdG9wIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTb3J0YWJsZVN0b3BFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNvcnRhYmxlU3RvcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNvcnRhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Tb3J0YWJsZVNvcnRlZEV2ZW50LnR5cGUgPSAnc29ydGFibGU6c29ydGVkJztcclxuY2xhc3MgU29ydGFibGVTdG9wRXZlbnQgZXh0ZW5kcyBTb3J0YWJsZUV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgaW5kZXggb24gc29ydGFibGUgc3RhcnRcclxuICAgKiBAcHJvcGVydHkgb2xkSW5kZXhcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvbGRJbmRleCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub2xkSW5kZXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOZXcgaW5kZXggb2YgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbmV3SW5kZXhcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBuZXdJbmRleCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubmV3SW5kZXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBjb250YWluZXIgb2YgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgb2xkQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvbGRDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9sZENvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5ldyBjb250YWluZXIgb2YgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbmV3Q29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBuZXdDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0NvbnRhaW5lcjtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5Tb3J0YWJsZVN0b3BFdmVudCA9IFNvcnRhYmxlU3RvcEV2ZW50O1xyXG5Tb3J0YWJsZVN0b3BFdmVudC50eXBlID0gJ3NvcnRhYmxlOnN0b3AnO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDY0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Tb3J0YWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XHJcblxyXG5PYmplY3Qua2V5cyhfU29ydGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9Tb3J0YWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9Tb3J0YWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xyXG5cclxudmFyIF9Tb3J0YWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Tb3J0YWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX1NvcnRhYmxlMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDY1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfRHJhZ2dhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XHJcblxyXG52YXIgX0RyYWdnYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnZ2FibGUpO1xyXG5cclxudmFyIF9Td2FwcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdPdmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyJyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGFubm91bmNlbWVudCBtZXNzYWdlIHdoZW4gdGhlIERyYWdnYWJsZSBlbGVtZW50IGlzIHN3YXBwZWQgd2l0aCBhbm90aGVyIGRyYWdnYWJsZSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7U3dhcHBhYmxlU3dhcHBlZEV2ZW50fSBzd2FwcGFibGVFdmVudFxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBvblN3YXBwYWJsZVN3YXBwZWREZWZhdWx0QW5ub3VuY2VtZW50KHsgZHJhZ0V2ZW50LCBzd2FwcGVkRWxlbWVudCB9KSB7XHJcbiAgY29uc3Qgc291cmNlVGV4dCA9IGRyYWdFdmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyYWdFdmVudC5zb3VyY2UuaWQgfHwgJ3N3YXBwYWJsZSBlbGVtZW50JztcclxuICBjb25zdCBvdmVyVGV4dCA9IHN3YXBwZWRFbGVtZW50LnRleHRDb250ZW50LnRyaW0oKSB8fCBzd2FwcGVkRWxlbWVudC5pZCB8fCAnc3dhcHBhYmxlIGVsZW1lbnQnO1xyXG5cclxuICByZXR1cm4gYFN3YXBwZWQgJHtzb3VyY2VUZXh0fSB3aXRoICR7b3ZlclRleHR9YDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBjb25zdCB7T2JqZWN0fSBkZWZhdWx0QW5ub3VuY2VtZW50c1xyXG4gKiBAY29uc3Qge0Z1bmN0aW9ufSBkZWZhdWx0QW5ub3VuY2VtZW50c1snc3dhcHBhYmxlZDpzd2FwcGVkJ11cclxuICovXHJcbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xyXG4gICdzd2FwcGFibGVkOnN3YXBwZWQnOiBvblN3YXBwYWJsZVN3YXBwZWREZWZhdWx0QW5ub3VuY2VtZW50XHJcbn07XHJcblxyXG4vKipcclxuICogU3dhcHBhYmxlIGlzIGJ1aWx0IG9uIHRvcCBvZiBEcmFnZ2FibGUgYW5kIGFsbG93cyBzd2FwcGluZyBvZiBkcmFnZ2FibGUgZWxlbWVudHMuXHJcbiAqIE9yZGVyIGlzIGlycmVsZXZhbnQgdG8gU3dhcHBhYmxlLlxyXG4gKiBAY2xhc3MgU3dhcHBhYmxlXHJcbiAqIEBtb2R1bGUgU3dhcHBhYmxlXHJcbiAqIEBleHRlbmRzIERyYWdnYWJsZVxyXG4gKi9cclxuY2xhc3MgU3dhcHBhYmxlIGV4dGVuZHMgX0RyYWdnYWJsZTIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogU3dhcHBhYmxlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFN3YXBwYWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIFN3YXBwYWJsZSBjb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciBTd2FwcGFibGVcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcclxuICAgICAgYW5ub3VuY2VtZW50czogX2V4dGVuZHMoe30sIGRlZmF1bHRBbm5vdW5jZW1lbnRzLCBvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pXHJcbiAgICB9KSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMYXN0IGRyYWdnYWJsZSBlbGVtZW50IHRoYXQgd2FzIGRyYWdnZWQgb3ZlclxyXG4gICAgICogQHByb3BlcnR5IGxhc3RPdmVyXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGFzdE92ZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnT3Zlcl0gPSB0aGlzW29uRHJhZ092ZXJdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3lzIFN3YXBwYWJsZSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgc3VwZXIuZGVzdHJveSgpO1xyXG5cclxuICAgIHRoaXMub2ZmKCdkcmFnOnN0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpLm9mZignZHJhZzpvdmVyJywgdGhpcy5fb25EcmFnT3Zlcikub2ZmKCdkcmFnOnN0b3AnLCB0aGlzLl9vbkRyYWdTdG9wKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RhcnRFdmVudH0gZXZlbnQgLSBEcmFnIHN0YXJ0IGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xyXG4gICAgY29uc3Qgc3dhcHBhYmxlU3RhcnRFdmVudCA9IG5ldyBfU3dhcHBhYmxlRXZlbnQuU3dhcHBhYmxlU3RhcnRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzd2FwcGFibGVTdGFydEV2ZW50KTtcclxuXHJcbiAgICBpZiAoc3dhcHBhYmxlU3RhcnRFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBvdmVyIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ092ZXJFdmVudH0gZXZlbnQgLSBEcmFnIG92ZXIgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnT3Zlcl0oZXZlbnQpIHtcclxuICAgIGlmIChldmVudC5vdmVyID09PSBldmVudC5vcmlnaW5hbFNvdXJjZSB8fCBldmVudC5vdmVyID09PSBldmVudC5zb3VyY2UgfHwgZXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3dhcHBhYmxlU3dhcEV2ZW50ID0gbmV3IF9Td2FwcGFibGVFdmVudC5Td2FwcGFibGVTd2FwRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBvdmVyOiBldmVudC5vdmVyLFxyXG4gICAgICBvdmVyQ29udGFpbmVyOiBldmVudC5vdmVyQ29udGFpbmVyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoc3dhcHBhYmxlU3dhcEV2ZW50KTtcclxuXHJcbiAgICBpZiAoc3dhcHBhYmxlU3dhcEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHN3YXAgb3JpZ2luYWxseSBzd2FwcGVkIGVsZW1lbnQgYmFja1xyXG4gICAgaWYgKHRoaXMubGFzdE92ZXIgJiYgdGhpcy5sYXN0T3ZlciAhPT0gZXZlbnQub3Zlcikge1xyXG4gICAgICBzd2FwKHRoaXMubGFzdE92ZXIsIGV2ZW50LnNvdXJjZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubGFzdE92ZXIgPT09IGV2ZW50Lm92ZXIpIHtcclxuICAgICAgdGhpcy5sYXN0T3ZlciA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmxhc3RPdmVyID0gZXZlbnQub3ZlcjtcclxuICAgIH1cclxuXHJcbiAgICBzd2FwKGV2ZW50LnNvdXJjZSwgZXZlbnQub3Zlcik7XHJcblxyXG4gICAgY29uc3Qgc3dhcHBhYmxlU3dhcHBlZEV2ZW50ID0gbmV3IF9Td2FwcGFibGVFdmVudC5Td2FwcGFibGVTd2FwcGVkRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBzd2FwcGVkRWxlbWVudDogZXZlbnQub3ZlclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHN3YXBwYWJsZVN3YXBwZWRFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0b3AgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RvcEV2ZW50fSBldmVudCAtIERyYWcgc3RvcCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdG9wXShldmVudCkge1xyXG4gICAgY29uc3Qgc3dhcHBhYmxlU3RvcEV2ZW50ID0gbmV3IF9Td2FwcGFibGVFdmVudC5Td2FwcGFibGVTdG9wRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoc3dhcHBhYmxlU3RvcEV2ZW50KTtcclxuICAgIHRoaXMubGFzdE92ZXIgPSBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gU3dhcHBhYmxlO1xyXG5mdW5jdGlvbiB3aXRoVGVtcEVsZW1lbnQoY2FsbGJhY2spIHtcclxuICBjb25zdCB0bXBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgY2FsbGJhY2sodG1wRWxlbWVudCk7XHJcbiAgdG1wRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRtcEVsZW1lbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzd2FwKHNvdXJjZSwgb3Zlcikge1xyXG4gIGNvbnN0IG92ZXJQYXJlbnQgPSBvdmVyLnBhcmVudE5vZGU7XHJcbiAgY29uc3Qgc291cmNlUGFyZW50ID0gc291cmNlLnBhcmVudE5vZGU7XHJcblxyXG4gIHdpdGhUZW1wRWxlbWVudCh0bXBFbGVtZW50ID0+IHtcclxuICAgIHNvdXJjZVBhcmVudC5pbnNlcnRCZWZvcmUodG1wRWxlbWVudCwgc291cmNlKTtcclxuICAgIG92ZXJQYXJlbnQuaW5zZXJ0QmVmb3JlKHNvdXJjZSwgb3Zlcik7XHJcbiAgICBzb3VyY2VQYXJlbnQuaW5zZXJ0QmVmb3JlKG92ZXIsIHRtcEVsZW1lbnQpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNjYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuU3dhcHBhYmxlU3RvcEV2ZW50ID0gZXhwb3J0cy5Td2FwcGFibGVTd2FwcGVkRXZlbnQgPSBleHBvcnRzLlN3YXBwYWJsZVN3YXBFdmVudCA9IGV4cG9ydHMuU3dhcHBhYmxlU3RhcnRFdmVudCA9IGV4cG9ydHMuU3dhcHBhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIHN3YXBwYWJsZSBldmVudFxyXG4gKiBAY2xhc3MgU3dhcHBhYmxlRXZlbnRcclxuICogQG1vZHVsZSBTd2FwcGFibGVFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBTd2FwcGFibGVFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgZHJhZyBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIHN3YXBwYWJsZSBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBkcmFnRXZlbnRcclxuICAgKiBAdHlwZSB7RHJhZ0V2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkcmFnRXZlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuU3dhcHBhYmxlRXZlbnQgPSBTd2FwcGFibGVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3dhcHBhYmxlIHN0YXJ0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFN3YXBwYWJsZVN0YXJ0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFN3YXBwYWJsZVN0YXJ0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTd2FwcGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuU3dhcHBhYmxlRXZlbnQudHlwZSA9ICdzd2FwcGFibGUnO1xyXG5jbGFzcyBTd2FwcGFibGVTdGFydEV2ZW50IGV4dGVuZHMgU3dhcHBhYmxlRXZlbnQge31cclxuXHJcbmV4cG9ydHMuU3dhcHBhYmxlU3RhcnRFdmVudCA9IFN3YXBwYWJsZVN0YXJ0RXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTd2FwcGFibGUgc3dhcCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgU3dhcHBhYmxlU3dhcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU3dhcHBhYmxlU3dhcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFN3YXBwYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuU3dhcHBhYmxlU3RhcnRFdmVudC50eXBlID0gJ3N3YXBwYWJsZTpzdGFydCc7XHJcblN3YXBwYWJsZVN0YXJ0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIFN3YXBwYWJsZVN3YXBFdmVudCBleHRlbmRzIFN3YXBwYWJsZUV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGVsZW1lbnQgeW91IGFyZSBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIHlvdSBhcmUgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Td2FwcGFibGVTd2FwRXZlbnQgPSBTd2FwcGFibGVTd2FwRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3dhcHBhYmxlIHN3YXBwZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTd2FwcGFibGVTd2FwcGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU3dhcHBhYmxlU3dhcHBlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTd2FwcGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Td2FwcGFibGVTd2FwRXZlbnQudHlwZSA9ICdzd2FwcGFibGU6c3dhcCc7XHJcblN3YXBwYWJsZVN3YXBFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgU3dhcHBhYmxlU3dhcHBlZEV2ZW50IGV4dGVuZHMgU3dhcHBhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZHJhZ2dhYmxlIGVsZW1lbnQgdGhhdCB5b3Ugc3dhcHBlZCB3aXRoXHJcbiAgICogQHByb3BlcnR5IHN3YXBwZWRFbGVtZW50XHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzd2FwcGVkRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc3dhcHBlZEVsZW1lbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLlN3YXBwYWJsZVN3YXBwZWRFdmVudCA9IFN3YXBwYWJsZVN3YXBwZWRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTd2FwcGFibGUgc3RvcCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFN3YXBwYWJsZVN0b3BFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBTd2FwcGFibGVTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFN3YXBwYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblN3YXBwYWJsZVN3YXBwZWRFdmVudC50eXBlID0gJ3N3YXBwYWJsZTpzd2FwcGVkJztcclxuY2xhc3MgU3dhcHBhYmxlU3RvcEV2ZW50IGV4dGVuZHMgU3dhcHBhYmxlRXZlbnQge31cclxuZXhwb3J0cy5Td2FwcGFibGVTdG9wRXZlbnQgPSBTd2FwcGFibGVTdG9wRXZlbnQ7XHJcblN3YXBwYWJsZVN0b3BFdmVudC50eXBlID0gJ3N3YXBwYWJsZTpzdG9wJztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2NyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU3dhcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcclxuXHJcbk9iamVjdC5rZXlzKF9Td2FwcGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9Td2FwcGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbnZhciBfU3dhcHBhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XHJcblxyXG52YXIgX1N3YXBwYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Td2FwcGFibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Td2FwcGFibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNjggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG52YXIgX0RyYWdnYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xyXG5cclxudmFyIF9EcmFnZ2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ2dhYmxlKTtcclxuXHJcbnZhciBfRHJvcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcclxuY29uc3Qgb25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xyXG5jb25zdCBvbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XHJcbmNvbnN0IGRyb3BJbkRyb3B6b25lID0gU3ltYm9sKCdkcm9wSW5Ecm9wWm9uZScpO1xyXG5jb25zdCByZXR1cm5Ub09yaWdpbmFsRHJvcHpvbmUgPSBTeW1ib2woJ3JldHVyblRvT3JpZ2luYWxEcm9wem9uZScpO1xyXG5jb25zdCBjbG9zZXN0RHJvcHpvbmUgPSBTeW1ib2woJ2Nsb3Nlc3REcm9wem9uZScpO1xyXG5jb25zdCBnZXREcm9wem9uZXMgPSBTeW1ib2woJ2dldERyb3B6b25lcycpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYW5ub3VuY2VtZW50IG1lc3NhZ2Ugd2hlbiB0aGUgRHJhZ2dhYmxlIGVsZW1lbnQgaXMgZHJvcHBlZCBpbnRvIGEgZHJvcHpvbmUgZWxlbWVudFxyXG4gKiBAcGFyYW0ge0Ryb3BwYWJsZURyb3BwZWRFdmVudH0gZHJvcHBhYmxlRXZlbnRcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gb25Ecm9wcGFibGVEcm9wcGVkRGVmYXVsdEFubm91bmNlbWVudCh7IGRyYWdFdmVudCwgZHJvcHpvbmUgfSkge1xyXG4gIGNvbnN0IHNvdXJjZVRleHQgPSBkcmFnRXZlbnQuc291cmNlLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcmFnRXZlbnQuc291cmNlLmlkIHx8ICdkcmFnZ2FibGUgZWxlbWVudCc7XHJcbiAgY29uc3QgZHJvcHpvbmVUZXh0ID0gZHJvcHpvbmUudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyb3B6b25lLmlkIHx8ICdkcm9wcGFibGUgZWxlbWVudCc7XHJcblxyXG4gIHJldHVybiBgRHJvcHBlZCAke3NvdXJjZVRleHR9IGludG8gJHtkcm9wem9uZVRleHR9YDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYW5ub3VuY2VtZW50IG1lc3NhZ2Ugd2hlbiB0aGUgRHJhZ2dhYmxlIGVsZW1lbnQgaGFzIHJldHVybmVkIHRvIGl0cyBvcmlnaW5hbCBkcm9wem9uZSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7RHJvcHBhYmxlUmV0dXJuZWRFdmVudH0gZHJvcHBhYmxlRXZlbnRcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gb25Ecm9wcGFibGVSZXR1cm5lZERlZmF1bHRBbm5vdW5jZW1lbnQoeyBkcmFnRXZlbnQsIGRyb3B6b25lIH0pIHtcclxuICBjb25zdCBzb3VyY2VUZXh0ID0gZHJhZ0V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnO1xyXG4gIGNvbnN0IGRyb3B6b25lVGV4dCA9IGRyb3B6b25lLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcm9wem9uZS5pZCB8fCAnZHJvcHBhYmxlIGVsZW1lbnQnO1xyXG5cclxuICByZXR1cm4gYFJldHVybmVkICR7c291cmNlVGV4dH0gZnJvbSAke2Ryb3B6b25lVGV4dH1gO1xyXG59XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtPYmplY3R9IGRlZmF1bHRBbm5vdW5jZW1lbnRzXHJcbiAqIEBjb25zdCB7RnVuY3Rpb259IGRlZmF1bHRBbm5vdW5jZW1lbnRzWydkcm9wcGFibGU6ZHJvcHBlZCddXHJcbiAqIEBjb25zdCB7RnVuY3Rpb259IGRlZmF1bHRBbm5vdW5jZW1lbnRzWydkcm9wcGFibGU6cmV0dXJuZWQnXVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdEFubm91bmNlbWVudHMgPSB7XHJcbiAgJ2Ryb3BwYWJsZTpkcm9wcGVkJzogb25Ecm9wcGFibGVEcm9wcGVkRGVmYXVsdEFubm91bmNlbWVudCxcclxuICAnZHJvcHBhYmxlOnJldHVybmVkJzogb25Ecm9wcGFibGVSZXR1cm5lZERlZmF1bHRBbm5vdW5jZW1lbnRcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRDbGFzc2VzID0ge1xyXG4gICdkcm9wcGFibGU6YWN0aXZlJzogJ2RyYWdnYWJsZS1kcm9wem9uZS0tYWN0aXZlJyxcclxuICAnZHJvcHBhYmxlOm9jY3VwaWVkJzogJ2RyYWdnYWJsZS1kcm9wem9uZS0tb2NjdXBpZWQnXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICBkcm9wem9uZTogJy5kcmFnZ2FibGUtZHJvcHBhYmxlJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERyb3BwYWJsZSBpcyBidWlsdCBvbiB0b3Agb2YgRHJhZ2dhYmxlIGFuZCBhbGxvd3MgZHJvcHBpbmcgZHJhZ2dhYmxlIGVsZW1lbnRzXHJcbiAqIGludG8gZHJvcHpvbmUgZWxlbWVudFxyXG4gKiBAY2xhc3MgRHJvcHBhYmxlXHJcbiAqIEBtb2R1bGUgRHJvcHBhYmxlXHJcbiAqIEBleHRlbmRzIERyYWdnYWJsZVxyXG4gKi9cclxuY2xhc3MgRHJvcHBhYmxlIGV4dGVuZHMgX0RyYWdnYWJsZTIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogRHJvcHBhYmxlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIERyb3BwYWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIERyb3BwYWJsZSBjb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciBEcm9wcGFibGVcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zLCB7XHJcbiAgICAgIGNsYXNzZXM6IF9leHRlbmRzKHt9LCBkZWZhdWx0Q2xhc3Nlcywgb3B0aW9ucy5jbGFzc2VzIHx8IHt9KSxcclxuICAgICAgYW5ub3VuY2VtZW50czogX2V4dGVuZHMoe30sIGRlZmF1bHRBbm5vdW5jZW1lbnRzLCBvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pXHJcbiAgICB9KSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgZHJvcHpvbmUgZWxlbWVudHMgb24gZHJhZyBzdGFydFxyXG4gICAgICogQHByb3BlcnR5IGRyb3B6b25lc1xyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJvcHpvbmVzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExhc3QgZHJvcHpvbmUgZWxlbWVudCB0aGF0IHRoZSBzb3VyY2Ugd2FzIGRyb3BwZWQgaW50b1xyXG4gICAgICogQHByb3BlcnR5IGxhc3REcm9wem9uZVxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxhc3REcm9wem9uZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsIGRyb3B6b25lIGVsZW1lbnQgdGhhdCB0aGUgc291cmNlIHdhcyBkcmFnIGZyb21cclxuICAgICAqIEBwcm9wZXJ0eSBpbml0aWFsRHJvcHpvbmVcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbml0aWFsRHJvcHpvbmUgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnTW92ZV0gPSB0aGlzW29uRHJhZ01vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3lzIERyb3BwYWJsZSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgc3VwZXIuZGVzdHJveSgpO1xyXG5cclxuICAgIHRoaXMub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RhcnRFdmVudH0gZXZlbnQgLSBEcmFnIHN0YXJ0IGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZHJvcHpvbmVzID0gWy4uLnRoaXNbZ2V0RHJvcHpvbmVzXSgpXTtcclxuICAgIGNvbnN0IGRyb3B6b25lID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC5zZW5zb3JFdmVudC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcm9wem9uZSk7XHJcblxyXG4gICAgaWYgKCFkcm9wem9uZSkge1xyXG4gICAgICBldmVudC5jYW5jZWwoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyb3BwYWJsZVN0YXJ0RXZlbnQgPSBuZXcgX0Ryb3BwYWJsZUV2ZW50LkRyb3BwYWJsZVN0YXJ0RXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBkcm9wem9uZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVN0YXJ0RXZlbnQpO1xyXG5cclxuICAgIGlmIChkcm9wcGFibGVTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgZXZlbnQuY2FuY2VsKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmluaXRpYWxEcm9wem9uZSA9IGRyb3B6b25lO1xyXG5cclxuICAgIGZvciAoY29uc3QgZHJvcHpvbmVFbGVtZW50IG9mIHRoaXMuZHJvcHpvbmVzKSB7XHJcbiAgICAgIGlmIChkcm9wem9uZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKSkpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZHJvcHpvbmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6YWN0aXZlJykpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ01vdmVFdmVudH0gZXZlbnQgLSBEcmFnIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnTW92ZV0oZXZlbnQpIHtcclxuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkcm9wem9uZSA9IHRoaXNbY2xvc2VzdERyb3B6b25lXShldmVudC5zZW5zb3JFdmVudC50YXJnZXQpO1xyXG4gICAgY29uc3Qgb3ZlckVtcHR5RHJvcHpvbmUgPSBkcm9wem9uZSAmJiAhZHJvcHpvbmUuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKSk7XHJcblxyXG4gICAgaWYgKG92ZXJFbXB0eURyb3B6b25lICYmIHRoaXNbZHJvcEluRHJvcHpvbmVdKGV2ZW50LCBkcm9wem9uZSkpIHtcclxuICAgICAgdGhpcy5sYXN0RHJvcHpvbmUgPSBkcm9wem9uZTtcclxuICAgIH0gZWxzZSBpZiAoKCFkcm9wem9uZSB8fCBkcm9wem9uZSA9PT0gdGhpcy5pbml0aWFsRHJvcHpvbmUpICYmIHRoaXMubGFzdERyb3B6b25lKSB7XHJcbiAgICAgIHRoaXNbcmV0dXJuVG9PcmlnaW5hbERyb3B6b25lXShldmVudCk7XHJcbiAgICAgIHRoaXMubGFzdERyb3B6b25lID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RvcCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdTdG9wRXZlbnR9IGV2ZW50IC0gRHJhZyBzdG9wIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XHJcbiAgICBjb25zdCBkcm9wcGFibGVTdG9wRXZlbnQgPSBuZXcgX0Ryb3BwYWJsZUV2ZW50LkRyb3BwYWJsZVN0b3BFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGRyb3B6b25lOiB0aGlzLmxhc3REcm9wem9uZSB8fCB0aGlzLmluaXRpYWxEcm9wem9uZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVN0b3BFdmVudCk7XHJcblxyXG4gICAgY29uc3Qgb2NjdXBpZWRDbGFzc2VzID0gdGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGRyb3B6b25lIG9mIHRoaXMuZHJvcHpvbmVzKSB7XHJcbiAgICAgIGRyb3B6b25lLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6YWN0aXZlJykpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmxhc3REcm9wem9uZSAmJiB0aGlzLmxhc3REcm9wem9uZSAhPT0gdGhpcy5pbml0aWFsRHJvcHpvbmUpIHtcclxuICAgICAgdGhpcy5pbml0aWFsRHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZSguLi5vY2N1cGllZENsYXNzZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZHJvcHpvbmVzID0gbnVsbDtcclxuICAgIHRoaXMubGFzdERyb3B6b25lID0gbnVsbDtcclxuICAgIHRoaXMuaW5pdGlhbERyb3B6b25lID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyb3BzIGEgZHJhZ2dhYmxlIGVsZW1lbnQgaW50byBhIGRyb3B6b25lIGVsZW1lbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ01vdmVFdmVudH0gZXZlbnQgLSBEcmFnIG1vdmUgZXZlbnRcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkcm9wem9uZSAtIERyb3B6b25lIGVsZW1lbnQgdG8gZHJvcCBkcmFnZ2FibGUgaW50b1xyXG4gICAqL1xyXG4gIFtkcm9wSW5Ecm9wem9uZV0oZXZlbnQsIGRyb3B6b25lKSB7XHJcbiAgICBjb25zdCBkcm9wcGFibGVEcm9wcGVkRXZlbnQgPSBuZXcgX0Ryb3BwYWJsZUV2ZW50LkRyb3BwYWJsZURyb3BwZWRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGRyb3B6b25lXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJvcHBhYmxlRHJvcHBlZEV2ZW50KTtcclxuXHJcbiAgICBpZiAoZHJvcHBhYmxlRHJvcHBlZEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9jY3VwaWVkQ2xhc3NlcyA9IHRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJvcHBhYmxlOm9jY3VwaWVkJyk7XHJcblxyXG4gICAgaWYgKHRoaXMubGFzdERyb3B6b25lKSB7XHJcbiAgICAgIHRoaXMubGFzdERyb3B6b25lLmNsYXNzTGlzdC5yZW1vdmUoLi4ub2NjdXBpZWRDbGFzc2VzKTtcclxuICAgIH1cclxuXHJcbiAgICBkcm9wem9uZS5hcHBlbmRDaGlsZChldmVudC5zb3VyY2UpO1xyXG4gICAgZHJvcHpvbmUuY2xhc3NMaXN0LmFkZCguLi5vY2N1cGllZENsYXNzZXMpO1xyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW92ZXMgdGhlIHByZXZpb3VzbHkgZHJvcHBlZCBlbGVtZW50IGJhY2sgaW50byBpdHMgb3JpZ2luYWwgZHJvcHpvbmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ01vdmVFdmVudH0gZXZlbnQgLSBEcmFnIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbcmV0dXJuVG9PcmlnaW5hbERyb3B6b25lXShldmVudCkge1xyXG4gICAgY29uc3QgZHJvcHBhYmxlUmV0dXJuZWRFdmVudCA9IG5ldyBfRHJvcHBhYmxlRXZlbnQuRHJvcHBhYmxlUmV0dXJuZWRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGRyb3B6b25lOiB0aGlzLmxhc3REcm9wem9uZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVJldHVybmVkRXZlbnQpO1xyXG5cclxuICAgIGlmIChkcm9wcGFibGVSZXR1cm5lZEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaW5pdGlhbERyb3B6b25lLmFwcGVuZENoaWxkKGV2ZW50LnNvdXJjZSk7XHJcbiAgICB0aGlzLmxhc3REcm9wem9uZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJvcHBhYmxlOm9jY3VwaWVkJykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjbG9zZXN0IGRyb3B6b25lIGVsZW1lbnQgZm9yIGV2ZW4gdGFyZ2V0XHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBFdmVudCB0YXJnZXRcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfVxyXG4gICAqL1xyXG4gIFtjbG9zZXN0RHJvcHpvbmVdKHRhcmdldCkge1xyXG4gICAgaWYgKCF0aGlzLmRyb3B6b25lcykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIHRoaXMuZHJvcHpvbmVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYWxsIGN1cnJlbnQgZHJvcHpvbmUgZWxlbWVudHMgZm9yIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJuIHtOb2RlTGlzdHxIVE1MRWxlbWVudFtdfEFycmF5fVxyXG4gICAqL1xyXG4gIFtnZXREcm9wem9uZXNdKCkge1xyXG4gICAgY29uc3QgZHJvcHpvbmUgPSB0aGlzLm9wdGlvbnMuZHJvcHpvbmU7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkcm9wem9uZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZHJvcHpvbmUpO1xyXG4gICAgfSBlbHNlIGlmIChkcm9wem9uZSBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGRyb3B6b25lIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgcmV0dXJuIGRyb3B6b25lO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHJvcHpvbmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIGRyb3B6b25lKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERyb3BwYWJsZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2OSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5Ecm9wcGFibGVTdG9wRXZlbnQgPSBleHBvcnRzLkRyb3BwYWJsZVJldHVybmVkRXZlbnQgPSBleHBvcnRzLkRyb3BwYWJsZURyb3BwZWRFdmVudCA9IGV4cG9ydHMuRHJvcHBhYmxlU3RhcnRFdmVudCA9IGV4cG9ydHMuRHJvcHBhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIGRyb3BwYWJsZSBldmVudFxyXG4gKiBAY2xhc3MgRHJvcHBhYmxlRXZlbnRcclxuICogQG1vZHVsZSBEcm9wcGFibGVFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBEcm9wcGFibGVFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgZHJhZyBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGRyb3BwYWJsZSBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBkcmFnRXZlbnRcclxuICAgKiBAdHlwZSB7RHJhZ0V2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkcmFnRXZlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJvcHBhYmxlRXZlbnQgPSBEcm9wcGFibGVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJvcHBhYmxlIHN0YXJ0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyb3BwYWJsZVN0YXJ0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyb3BwYWJsZVN0YXJ0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcm9wcGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJvcHBhYmxlRXZlbnQudHlwZSA9ICdkcm9wcGFibGUnO1xyXG5jbGFzcyBEcm9wcGFibGVTdGFydEV2ZW50IGV4dGVuZHMgRHJvcHBhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgaW5pdGlhbCBkcm9wem9uZSBlbGVtZW50IG9mIHRoZSBjdXJyZW50bHkgZHJhZ2dpbmcgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgZHJvcHpvbmVcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyb3B6b25lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcm9wem9uZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJvcHBhYmxlU3RhcnRFdmVudCA9IERyb3BwYWJsZVN0YXJ0RXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcm9wcGFibGUgZHJvcHBlZCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJvcHBhYmxlRHJvcHBlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJvcHBhYmxlRHJvcHBlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyb3BwYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJvcHBhYmxlU3RhcnRFdmVudC50eXBlID0gJ2Ryb3BwYWJsZTpzdGFydCc7XHJcbkRyb3BwYWJsZVN0YXJ0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIERyb3BwYWJsZURyb3BwZWRFdmVudCBleHRlbmRzIERyb3BwYWJsZUV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRyb3B6b25lIGVsZW1lbnQgeW91IGRyb3BwZWQgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGludG9cclxuICAgKiBAcHJvcGVydHkgZHJvcHpvbmVcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyb3B6b25lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcm9wem9uZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJvcHBhYmxlRHJvcHBlZEV2ZW50ID0gRHJvcHBhYmxlRHJvcHBlZEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyb3BwYWJsZSByZXR1cm5lZCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyb3BwYWJsZVJldHVybmVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJvcHBhYmxlUmV0dXJuZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJvcHBhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJvcHBhYmxlRHJvcHBlZEV2ZW50LnR5cGUgPSAnZHJvcHBhYmxlOmRyb3BwZWQnO1xyXG5Ecm9wcGFibGVEcm9wcGVkRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIERyb3BwYWJsZVJldHVybmVkRXZlbnQgZXh0ZW5kcyBEcm9wcGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBkcm9wem9uZSBlbGVtZW50IHlvdSBkcmFnZ2VkIGF3YXkgZnJvbVxyXG4gICAqIEBwcm9wZXJ0eSBkcm9wem9uZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJvcHpvbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyb3B6b25lO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Ecm9wcGFibGVSZXR1cm5lZEV2ZW50ID0gRHJvcHBhYmxlUmV0dXJuZWRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyb3BwYWJsZSBzdG9wIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcm9wcGFibGVTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcm9wcGFibGVTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJvcHBhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Ecm9wcGFibGVSZXR1cm5lZEV2ZW50LnR5cGUgPSAnZHJvcHBhYmxlOnJldHVybmVkJztcclxuRHJvcHBhYmxlUmV0dXJuZWRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgRHJvcHBhYmxlU3RvcEV2ZW50IGV4dGVuZHMgRHJvcHBhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZmluYWwgZHJvcHpvbmUgZWxlbWVudCBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgZHJvcHpvbmVcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyb3B6b25lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcm9wem9uZTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5Ecm9wcGFibGVTdG9wRXZlbnQgPSBEcm9wcGFibGVTdG9wRXZlbnQ7XHJcbkRyb3BwYWJsZVN0b3BFdmVudC50eXBlID0gJ2Ryb3BwYWJsZTpzdG9wJztcclxuRHJvcHBhYmxlU3RvcEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDcwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Ecm9wcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xyXG5cclxuT2JqZWN0LmtleXMoX0Ryb3BwYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX0Ryb3BwYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9Ecm9wcGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcclxuXHJcbnZhciBfRHJvcHBhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Ryb3BwYWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0Ryb3BwYWJsZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuLyoqXHJcbiAqIFRoZSBFbWl0dGVyIGlzIGEgc2ltcGxlIGVtaXR0ZXIgY2xhc3MgdGhhdCBwcm92aWRlcyB5b3Ugd2l0aCBgb24oKWAsIGBvZmYoKWAgYW5kIGB0cmlnZ2VyKClgIG1ldGhvZHNcclxuICogQGNsYXNzIEVtaXR0ZXJcclxuICogQG1vZHVsZSBFbWl0dGVyXHJcbiAqL1xyXG5jbGFzcyBFbWl0dGVyIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGJ5IGV2ZW50IG5hbWVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxyXG4gICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGNhbGxiYWNrc1xyXG4gICAqL1xyXG4gIG9uKHR5cGUsIC4uLmNhbGxiYWNrcykge1xyXG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1t0eXBlXSkge1xyXG4gICAgICB0aGlzLmNhbGxiYWNrc1t0eXBlXSA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdLnB1c2goLi4uY2FsbGJhY2tzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVucmVnaXN0ZXJzIGNhbGxiYWNrcyBieSBldmVudCBuYW1lXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIG9mZih0eXBlLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1t0eXBlXSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb3B5ID0gdGhpcy5jYWxsYmFja3NbdHlwZV0uc2xpY2UoMCk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3B5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChjYWxsYmFjayA9PT0gY29weVtpXSkge1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdLnNwbGljZShpLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlcnMgZXZlbnQgY2FsbGJhY2tzIGJ5IGV2ZW50IG9iamVjdFxyXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RFdmVudH0gZXZlbnRcclxuICAgKi9cclxuICB0cmlnZ2VyKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50LnR5cGVdKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNhbGxiYWNrcyA9IFsuLi50aGlzLmNhbGxiYWNrc1tldmVudC50eXBlXV07XHJcbiAgICBjb25zdCBjYXVnaHRFcnJvcnMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjYWxsYmFjayhldmVudCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY2F1Z2h0RXJyb3JzLnB1c2goZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNhdWdodEVycm9ycy5sZW5ndGgpIHtcclxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBEcmFnZ2FibGUgY2F1Z2h0IGVycm9ycyB3aGlsZSB0cmlnZ2VyaW5nICcke2V2ZW50LnR5cGV9J2AsIGNhdWdodEVycm9ycyk7XHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gRW1pdHRlcjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xyXG5cclxudmFyIF9FbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VtaXR0ZXIpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9FbWl0dGVyMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDczICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxudmFyIF9QbHVnaW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XHJcblxyXG52YXIgX0VtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcclxuXHJcbnZhciBfRW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FbWl0dGVyKTtcclxuXHJcbnZhciBfU2Vuc29ycyA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xyXG5cclxudmFyIF9EcmFnZ2FibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xyXG5cclxudmFyIF9EcmFnRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcclxuY29uc3Qgb25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xyXG5jb25zdCBvbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XHJcbmNvbnN0IG9uRHJhZ1ByZXNzdXJlID0gU3ltYm9sKCdvbkRyYWdQcmVzc3VyZScpO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdCB7T2JqZWN0fSBkZWZhdWx0QW5ub3VuY2VtZW50c1xyXG4gKiBAY29uc3Qge0Z1bmN0aW9ufSBkZWZhdWx0QW5ub3VuY2VtZW50c1snZHJhZzpzdGFydCddXHJcbiAqIEBjb25zdCB7RnVuY3Rpb259IGRlZmF1bHRBbm5vdW5jZW1lbnRzWydkcmFnOnN0b3AnXVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdEFubm91bmNlbWVudHMgPSB7XHJcbiAgJ2RyYWc6c3RhcnQnOiBldmVudCA9PiBgUGlja2VkIHVwICR7ZXZlbnQuc291cmNlLnRleHRDb250ZW50LnRyaW0oKSB8fCBldmVudC5zb3VyY2UuaWQgfHwgJ2RyYWdnYWJsZSBlbGVtZW50J31gLFxyXG4gICdkcmFnOnN0b3AnOiBldmVudCA9PiBgUmVsZWFzZWQgJHtldmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGV2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnfWBcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRDbGFzc2VzID0ge1xyXG4gICdjb250YWluZXI6ZHJhZ2dpbmcnOiAnZHJhZ2dhYmxlLWNvbnRhaW5lci0taXMtZHJhZ2dpbmcnLFxyXG4gICdzb3VyY2U6ZHJhZ2dpbmcnOiAnZHJhZ2dhYmxlLXNvdXJjZS0taXMtZHJhZ2dpbmcnLFxyXG4gICdzb3VyY2U6cGxhY2VkJzogJ2RyYWdnYWJsZS1zb3VyY2UtLXBsYWNlZCcsXHJcbiAgJ2NvbnRhaW5lcjpwbGFjZWQnOiAnZHJhZ2dhYmxlLWNvbnRhaW5lci0tcGxhY2VkJyxcclxuICAnYm9keTpkcmFnZ2luZyc6ICdkcmFnZ2FibGUtLWlzLWRyYWdnaW5nJyxcclxuICAnZHJhZ2dhYmxlOm92ZXInOiAnZHJhZ2dhYmxlLS1vdmVyJyxcclxuICAnY29udGFpbmVyOm92ZXInOiAnZHJhZ2dhYmxlLWNvbnRhaW5lci0tb3ZlcicsXHJcbiAgJ3NvdXJjZTpvcmlnaW5hbCc6ICdkcmFnZ2FibGUtLW9yaWdpbmFsJyxcclxuICBtaXJyb3I6ICdkcmFnZ2FibGUtbWlycm9yJ1xyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xyXG4gIGRyYWdnYWJsZTogJy5kcmFnZ2FibGUtc291cmNlJyxcclxuICBoYW5kbGU6IG51bGwsXHJcbiAgZGVsYXk6IHt9LFxyXG4gIGRpc3RhbmNlOiAwLFxyXG4gIHBsYWNlZFRpbWVvdXQ6IDgwMCxcclxuICBwbHVnaW5zOiBbXSxcclxuICBzZW5zb3JzOiBbXSxcclxuICBleGNsdWRlOiB7XHJcbiAgICBwbHVnaW5zOiBbXSxcclxuICAgIHNlbnNvcnM6IFtdXHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdGhlIGNvcmUgZHJhZ2dhYmxlIGxpYnJhcnkgdGhhdCBkb2VzIHRoZSBoZWF2eSBsaWZ0aW5nXHJcbiAqIEBjbGFzcyBEcmFnZ2FibGVcclxuICogQG1vZHVsZSBEcmFnZ2FibGVcclxuICovXHJcbmNsYXNzIERyYWdnYWJsZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBEcmFnZ2FibGVcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBEcmFnZ2FibGUgY29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZHJhZ2dhYmxlXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmF1bHQgcGx1Z2lucyBkcmFnZ2FibGUgdXNlc1xyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcHJvcGVydHkge09iamVjdH0gUGx1Z2luc1xyXG4gICAqIEBwcm9wZXJ0eSB7QW5ub3VuY2VtZW50fSBQbHVnaW5zLkFubm91bmNlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSB7Rm9jdXNhYmxlfSBQbHVnaW5zLkZvY3VzYWJsZVxyXG4gICAqIEBwcm9wZXJ0eSB7TWlycm9yfSBQbHVnaW5zLk1pcnJvclxyXG4gICAqIEBwcm9wZXJ0eSB7U2Nyb2xsYWJsZX0gUGx1Z2lucy5TY3JvbGxhYmxlXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW2RvY3VtZW50LmJvZHldLCBvcHRpb25zID0ge30pIHtcclxuICAgIC8qKlxyXG4gICAgICogRHJhZ2dhYmxlIGNvbnRhaW5lcnNcclxuICAgICAqIEBwcm9wZXJ0eSBjb250YWluZXJzXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX1cclxuICAgICAqL1xyXG4gICAgaWYgKGNvbnRhaW5lcnMgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBjb250YWluZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgdGhpcy5jb250YWluZXJzID0gWy4uLmNvbnRhaW5lcnNdO1xyXG4gICAgfSBlbHNlIGlmIChjb250YWluZXJzIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5jb250YWluZXJzID0gW2NvbnRhaW5lcnNdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcmFnZ2FibGUgY29udGFpbmVycyBhcmUgZXhwZWN0ZWQgdG8gYmUgb2YgdHlwZSBgTm9kZUxpc3RgLCBgSFRNTEVsZW1lbnRbXWAgb3IgYEhUTUxFbGVtZW50YCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucywge1xyXG4gICAgICBjbGFzc2VzOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdENsYXNzZXMsIG9wdGlvbnMuY2xhc3NlcyB8fCB7fSksXHJcbiAgICAgIGFubm91bmNlbWVudHM6IF9leHRlbmRzKHt9LCBkZWZhdWx0QW5ub3VuY2VtZW50cywgb3B0aW9ucy5hbm5vdW5jZW1lbnRzIHx8IHt9KSxcclxuICAgICAgZXhjbHVkZToge1xyXG4gICAgICAgIHBsdWdpbnM6IG9wdGlvbnMuZXhjbHVkZSAmJiBvcHRpb25zLmV4Y2x1ZGUucGx1Z2lucyB8fCBbXSxcclxuICAgICAgICBzZW5zb3JzOiBvcHRpb25zLmV4Y2x1ZGUgJiYgb3B0aW9ucy5leGNsdWRlLnNlbnNvcnMgfHwgW11cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmFnZ2FibGVzIGV2ZW50IGVtaXR0ZXJcclxuICAgICAqIEBwcm9wZXJ0eSBlbWl0dGVyXHJcbiAgICAgKiBAdHlwZSB7RW1pdHRlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IF9FbWl0dGVyMi5kZWZhdWx0KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGRyYWcgc3RhdGVcclxuICAgICAqIEBwcm9wZXJ0eSBkcmFnZ2luZ1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFjdGl2ZSBwbHVnaW5zXHJcbiAgICAgKiBAcHJvcGVydHkgcGx1Z2luc1xyXG4gICAgICogQHR5cGUge1BsdWdpbltdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBsdWdpbnMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFjdGl2ZSBzZW5zb3JzXHJcbiAgICAgKiBAcHJvcGVydHkgc2Vuc29yc1xyXG4gICAgICogQHR5cGUge1NlbnNvcltdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbnNvcnMgPSBbXTtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnUHJlc3N1cmVdID0gdGhpc1tvbkRyYWdQcmVzc3VyZV0uYmluZCh0aGlzKTtcclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWc6cHJlc3N1cmUnLCB0aGlzW29uRHJhZ1ByZXNzdXJlXSwgdHJ1ZSk7XHJcblxyXG4gICAgY29uc3QgZGVmYXVsdFBsdWdpbnMgPSBPYmplY3QudmFsdWVzKERyYWdnYWJsZS5QbHVnaW5zKS5maWx0ZXIoUGx1Z2luID0+ICF0aGlzLm9wdGlvbnMuZXhjbHVkZS5wbHVnaW5zLmluY2x1ZGVzKFBsdWdpbikpO1xyXG4gICAgY29uc3QgZGVmYXVsdFNlbnNvcnMgPSBPYmplY3QudmFsdWVzKERyYWdnYWJsZS5TZW5zb3JzKS5maWx0ZXIoc2Vuc29yID0+ICF0aGlzLm9wdGlvbnMuZXhjbHVkZS5zZW5zb3JzLmluY2x1ZGVzKHNlbnNvcikpO1xyXG5cclxuICAgIHRoaXMuYWRkUGx1Z2luKC4uLlsuLi5kZWZhdWx0UGx1Z2lucywgLi4udGhpcy5vcHRpb25zLnBsdWdpbnNdKTtcclxuICAgIHRoaXMuYWRkU2Vuc29yKC4uLlsuLi5kZWZhdWx0U2Vuc29ycywgLi4udGhpcy5vcHRpb25zLnNlbnNvcnNdKTtcclxuXHJcbiAgICBjb25zdCBkcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50ID0gbmV3IF9EcmFnZ2FibGVFdmVudC5EcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50KHtcclxuICAgICAgZHJhZ2dhYmxlOiB0aGlzXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLm9uKCdtaXJyb3I6Y3JlYXRlZCcsICh7IG1pcnJvciB9KSA9PiB0aGlzLm1pcnJvciA9IG1pcnJvcik7XHJcbiAgICB0aGlzLm9uKCdtaXJyb3I6ZGVzdHJveScsICgpID0+IHRoaXMubWlycm9yID0gbnVsbCk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzdHJveXMgRHJhZ2dhYmxlIGluc3RhbmNlLiBUaGlzIHJlbW92ZXMgYWxsIGludGVybmFsIGV2ZW50IGxpc3RlbmVycyBhbmRcclxuICAgKiBkZWFjdGl2YXRlcyBzZW5zb3JzIGFuZCBwbHVnaW5zXHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBEZWZhdWx0IHNlbnNvcnMgZHJhZ2dhYmxlIHVzZXNcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IFNlbnNvcnNcclxuICAgKiBAcHJvcGVydHkge01vdXNlU2Vuc29yfSBTZW5zb3JzLk1vdXNlU2Vuc29yXHJcbiAgICogQHByb3BlcnR5IHtUb3VjaFNlbnNvcn0gU2Vuc29ycy5Ub3VjaFNlbnNvclxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzpwcmVzc3VyZScsIHRoaXNbb25EcmFnUHJlc3N1cmVdLCB0cnVlKTtcclxuXHJcbiAgICBjb25zdCBkcmFnZ2FibGVEZXN0cm95RXZlbnQgPSBuZXcgX0RyYWdnYWJsZUV2ZW50LkRyYWdnYWJsZURlc3Ryb3lFdmVudCh7XHJcbiAgICAgIGRyYWdnYWJsZTogdGhpc1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdnYWJsZURlc3Ryb3lFdmVudCk7XHJcblxyXG4gICAgdGhpcy5yZW1vdmVQbHVnaW4oLi4udGhpcy5wbHVnaW5zLm1hcChwbHVnaW4gPT4gcGx1Z2luLmNvbnN0cnVjdG9yKSk7XHJcbiAgICB0aGlzLnJlbW92ZVNlbnNvciguLi50aGlzLnNlbnNvcnMubWFwKHNlbnNvciA9PiBzZW5zb3IuY29uc3RydWN0b3IpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgcGx1Z2luIHRvIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlLiBUaGlzIHdpbGwgZW5kIHVwIGNhbGxpbmcgdGhlIGF0dGFjaCBtZXRob2Qgb2YgdGhlIHBsdWdpblxyXG4gICAqIEBwYXJhbSB7Li4udHlwZW9mIFBsdWdpbn0gcGx1Z2lucyAtIFBsdWdpbnMgdGhhdCB5b3Ugd2FudCBhdHRhY2hlZCB0byBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLmFkZFBsdWdpbihDdXN0b21BMTF5UGx1Z2luLCBDdXN0b21NaXJyb3JQbHVnaW4pXHJcbiAgICovXHJcbiAgYWRkUGx1Z2luKC4uLnBsdWdpbnMpIHtcclxuICAgIGNvbnN0IGFjdGl2ZVBsdWdpbnMgPSBwbHVnaW5zLm1hcChQbHVnaW4gPT4gbmV3IFBsdWdpbih0aGlzKSk7XHJcblxyXG4gICAgYWN0aXZlUGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiBwbHVnaW4uYXR0YWNoKCkpO1xyXG4gICAgdGhpcy5wbHVnaW5zID0gWy4uLnRoaXMucGx1Z2lucywgLi4uYWN0aXZlUGx1Z2luc107XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIHBsdWdpbnMgdGhhdCBhcmUgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZS4gVGhpcyB3aWxsIGVuZCB1cCBjYWxsaW5nXHJcbiAgICogdGhlIGRldGFjaCBtZXRob2Qgb2YgdGhlIHBsdWdpblxyXG4gICAqIEBwYXJhbSB7Li4udHlwZW9mIFBsdWdpbn0gcGx1Z2lucyAtIFBsdWdpbnMgdGhhdCB5b3Ugd2FudCBkZXRhY2hlZCBmcm9tIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUucmVtb3ZlUGx1Z2luKE1pcnJvclBsdWdpbiwgQ3VzdG9tTWlycm9yUGx1Z2luKVxyXG4gICAqL1xyXG4gIHJlbW92ZVBsdWdpbiguLi5wbHVnaW5zKSB7XHJcbiAgICBjb25zdCByZW1vdmVkUGx1Z2lucyA9IHRoaXMucGx1Z2lucy5maWx0ZXIocGx1Z2luID0+IHBsdWdpbnMuaW5jbHVkZXMocGx1Z2luLmNvbnN0cnVjdG9yKSk7XHJcblxyXG4gICAgcmVtb3ZlZFBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4gcGx1Z2luLmRldGFjaCgpKTtcclxuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucGx1Z2lucy5maWx0ZXIocGx1Z2luID0+ICFwbHVnaW5zLmluY2x1ZGVzKHBsdWdpbi5jb25zdHJ1Y3RvcikpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBzZW5zb3JzIHRvIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlLiBUaGlzIHdpbGwgZW5kIHVwIGNhbGxpbmcgdGhlIGF0dGFjaCBtZXRob2Qgb2YgdGhlIHNlbnNvclxyXG4gICAqIEBwYXJhbSB7Li4udHlwZW9mIFNlbnNvcn0gc2Vuc29ycyAtIFNlbnNvcnMgdGhhdCB5b3Ugd2FudCBhdHRhY2hlZCB0byBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLmFkZFNlbnNvcihGb3JjZVRvdWNoU2Vuc29yLCBDdXN0b21TZW5zb3IpXHJcbiAgICovXHJcbiAgYWRkU2Vuc29yKC4uLnNlbnNvcnMpIHtcclxuICAgIGNvbnN0IGFjdGl2ZVNlbnNvcnMgPSBzZW5zb3JzLm1hcChTZW5zb3IgPT4gbmV3IFNlbnNvcih0aGlzLmNvbnRhaW5lcnMsIHRoaXMub3B0aW9ucykpO1xyXG5cclxuICAgIGFjdGl2ZVNlbnNvcnMuZm9yRWFjaChzZW5zb3IgPT4gc2Vuc29yLmF0dGFjaCgpKTtcclxuICAgIHRoaXMuc2Vuc29ycyA9IFsuLi50aGlzLnNlbnNvcnMsIC4uLmFjdGl2ZVNlbnNvcnNdO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBzZW5zb3JzIHRoYXQgYXJlIGFscmVhZHkgYXR0YWNoZWQgdG8gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2UuIFRoaXMgd2lsbCBlbmQgdXAgY2FsbGluZ1xyXG4gICAqIHRoZSBkZXRhY2ggbWV0aG9kIG9mIHRoZSBzZW5zb3JcclxuICAgKiBAcGFyYW0gey4uLnR5cGVvZiBTZW5zb3J9IHNlbnNvcnMgLSBTZW5zb3JzIHRoYXQgeW91IHdhbnQgYXR0YWNoZWQgdG8gZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5yZW1vdmVTZW5zb3IoVG91Y2hTZW5zb3IsIERyYWdTZW5zb3IpXHJcbiAgICovXHJcbiAgcmVtb3ZlU2Vuc29yKC4uLnNlbnNvcnMpIHtcclxuICAgIGNvbnN0IHJlbW92ZWRTZW5zb3JzID0gdGhpcy5zZW5zb3JzLmZpbHRlcihzZW5zb3IgPT4gc2Vuc29ycy5pbmNsdWRlcyhzZW5zb3IuY29uc3RydWN0b3IpKTtcclxuXHJcbiAgICByZW1vdmVkU2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IuZGV0YWNoKCkpO1xyXG4gICAgdGhpcy5zZW5zb3JzID0gdGhpcy5zZW5zb3JzLmZpbHRlcihzZW5zb3IgPT4gIXNlbnNvcnMuaW5jbHVkZXMoc2Vuc29yLmNvbnN0cnVjdG9yKSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGNvbnRhaW5lciB0byB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7Li4uSFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzIHlvdSB3YW50IHRvIGFkZCB0byBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLmFkZENvbnRhaW5lcihkb2N1bWVudC5ib2R5KVxyXG4gICAqL1xyXG4gIGFkZENvbnRhaW5lciguLi5jb250YWluZXJzKSB7XHJcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSBbLi4udGhpcy5jb250YWluZXJzLCAuLi5jb250YWluZXJzXTtcclxuICAgIHRoaXMuc2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IuYWRkQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBjb250YWluZXIgZnJvbSB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7Li4uSFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzIHlvdSB3YW50IHRvIHJlbW92ZSBmcm9tIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUucmVtb3ZlQ29udGFpbmVyKGRvY3VtZW50LmJvZHkpXHJcbiAgICovXHJcbiAgcmVtb3ZlQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcclxuICAgIHRoaXMuY29udGFpbmVycyA9IHRoaXMuY29udGFpbmVycy5maWx0ZXIoY29udGFpbmVyID0+ICFjb250YWluZXJzLmluY2x1ZGVzKGNvbnRhaW5lcikpO1xyXG4gICAgdGhpcy5zZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5yZW1vdmVDb250YWluZXIoLi4uY29udGFpbmVycykpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGxpc3RlbmVyIGZvciBkcmFnZ2FibGUgZXZlbnRzXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBFdmVudCBuYW1lXHJcbiAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gY2FsbGJhY2tzIC0gRXZlbnQgY2FsbGJhY2tzXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5vbignZHJhZzpzdGFydCcsIChkcmFnRXZlbnQpID0+IGRyYWdFdmVudC5jYW5jZWwoKSk7XHJcbiAgICovXHJcbiAgb24odHlwZSwgLi4uY2FsbGJhY2tzKSB7XHJcbiAgICB0aGlzLmVtaXR0ZXIub24odHlwZSwgLi4uY2FsbGJhY2tzKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBsaXN0ZW5lciBmcm9tIGRyYWdnYWJsZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gRXZlbnQgbmFtZVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRXZlbnQgY2FsbGJhY2tcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLm9mZignZHJhZzpzdGFydCcsIGhhbmRsZXJGdW5jdGlvbik7XHJcbiAgICovXHJcbiAgb2ZmKHR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLmVtaXR0ZXIub2ZmKHR5cGUsIGNhbGxiYWNrKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlcnMgZHJhZ2dhYmxlIGV2ZW50XHJcbiAgICogQHBhcmFtIHtBYnN0cmFjdEV2ZW50fSBldmVudCAtIEV2ZW50IGluc3RhbmNlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS50cmlnZ2VyKGV2ZW50KTtcclxuICAgKi9cclxuICB0cmlnZ2VyKGV2ZW50KSB7XHJcbiAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcihldmVudCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY2xhc3MgbmFtZSBmb3IgY2xhc3MgaWRlbnRpZmllclxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiBjbGFzcyBpZGVudGlmaWVyXHJcbiAgICogQHJldHVybiB7U3RyaW5nfG51bGx9XHJcbiAgICovXHJcbiAgZ2V0Q2xhc3NOYW1lRm9yKG5hbWUpIHtcclxuICAgIHJldHVybiB0aGlzLmdldENsYXNzTmFtZXNGb3IobmFtZSlbMF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGNsYXNzIG5hbWVzIGZvciBjbGFzcyBpZGVudGlmaWVyXHJcbiAgICogQHJldHVybiB7U3RyaW5nW119XHJcbiAgICovXHJcbiAgZ2V0Q2xhc3NOYW1lc0ZvcihuYW1lKSB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gdGhpcy5vcHRpb25zLmNsYXNzZXNbbmFtZV07XHJcblxyXG4gICAgaWYgKGNsYXNzTmFtZXMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICByZXR1cm4gY2xhc3NOYW1lcztcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNsYXNzTmFtZXMgPT09ICdzdHJpbmcnIHx8IGNsYXNzTmFtZXMgaW5zdGFuY2VvZiBTdHJpbmcpIHtcclxuICAgICAgcmV0dXJuIFtjbGFzc05hbWVzXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZSBpcyBjdXJyZW50bHkgZHJhZ2dpbmdcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGlzRHJhZ2dpbmcoKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmRyYWdnaW5nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYWxsIGRyYWdnYWJsZSBlbGVtZW50c1xyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XHJcbiAgICovXHJcbiAgZ2V0RHJhZ2dhYmxlRWxlbWVudHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJzLnJlZHVjZSgoY3VycmVudCwgY29udGFpbmVyKSA9PiB7XHJcbiAgICAgIHJldHVybiBbLi4uY3VycmVudCwgLi4udGhpcy5nZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihjb250YWluZXIpXTtcclxuICAgIH0sIFtdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgZHJhZ2dhYmxlIGVsZW1lbnRzIGZvciBhIGdpdmVuIGNvbnRhaW5lciwgZXhjbHVkaW5nIHRoZSBtaXJyb3IgYW5kXHJcbiAgICogb3JpZ2luYWwgc291cmNlIGVsZW1lbnQgaWYgcHJlc2VudFxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XHJcbiAgICovXHJcbiAgZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIoY29udGFpbmVyKSB7XHJcbiAgICBjb25zdCBhbGxEcmFnZ2FibGVFbGVtZW50cyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xyXG5cclxuICAgIHJldHVybiBbLi4uYWxsRHJhZ2dhYmxlRWxlbWVudHNdLmZpbHRlcihjaGlsZEVsZW1lbnQgPT4ge1xyXG4gICAgICByZXR1cm4gY2hpbGRFbGVtZW50ICE9PSB0aGlzLm9yaWdpbmFsU291cmNlICYmIGNoaWxkRWxlbWVudCAhPT0gdGhpcy5taXJyb3I7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBET00gRHJhZyBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xyXG4gICAgY29uc3QgeyB0YXJnZXQsIGNvbnRhaW5lciB9ID0gc2Vuc29yRXZlbnQ7XHJcblxyXG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcnMuaW5jbHVkZXMoY29udGFpbmVyKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oYW5kbGUgJiYgdGFyZ2V0ICYmICEoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgdGhpcy5vcHRpb25zLmhhbmRsZSkpIHtcclxuICAgICAgc2Vuc29yRXZlbnQuY2FuY2VsKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaW5kIGRyYWdnYWJsZSBzb3VyY2UgZWxlbWVudFxyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZSA9ICgwLCBfdXRpbHMuY2xvc2VzdCkodGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcclxuICAgIHRoaXMuc291cmNlQ29udGFpbmVyID0gY29udGFpbmVyO1xyXG5cclxuICAgIGlmICghdGhpcy5vcmlnaW5hbFNvdXJjZSkge1xyXG4gICAgICBzZW5zb3JFdmVudC5jYW5jZWwoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmxhc3RQbGFjZWRTb3VyY2UgJiYgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBsYWNlZFRpbWVvdXRJRCk7XHJcbiAgICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcclxuICAgICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6cGxhY2VkJykpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc291cmNlID0gdGhpcy5vcmlnaW5hbFNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuc291cmNlLCB0aGlzLm9yaWdpbmFsU291cmNlKTtcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHJcbiAgICBjb25zdCBkcmFnRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnU3RhcnRFdmVudCh7XHJcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnRXZlbnQpO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dpbmcgPSAhZHJhZ0V2ZW50LmNhbmNlbGVkKCk7XHJcblxyXG4gICAgaWYgKGRyYWdFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHRoaXMuc291cmNlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zb3VyY2UpO1xyXG4gICAgICB0aGlzLm9yaWdpbmFsU291cmNlLnN0eWxlLmRpc3BsYXkgPSBudWxsO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOm9yaWdpbmFsJykpO1xyXG4gICAgdGhpcy5zb3VyY2UuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpkcmFnZ2luZycpKTtcclxuICAgIHRoaXMuc291cmNlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6ZHJhZ2dpbmcnKSk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdib2R5OmRyYWdnaW5nJykpO1xyXG4gICAgYXBwbHlVc2VyU2VsZWN0KGRvY3VtZW50LmJvZHksICdub25lJyk7XHJcblxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgY29uc3Qgb2xkU2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XHJcbiAgICAgIGNvbnN0IG5ld1NlbnNvckV2ZW50ID0gb2xkU2Vuc29yRXZlbnQuY2xvbmUoeyB0YXJnZXQ6IHRoaXMuc291cmNlIH0pO1xyXG5cclxuICAgICAgdGhpc1tvbkRyYWdNb3ZlXShfZXh0ZW5kcyh7fSwgZXZlbnQsIHtcclxuICAgICAgICBkZXRhaWw6IG5ld1NlbnNvckV2ZW50XHJcbiAgICAgIH0pKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRE9NIERyYWcgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnTW92ZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XHJcbiAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gc2Vuc29yRXZlbnQ7XHJcbiAgICBsZXQgdGFyZ2V0ID0gc2Vuc29yRXZlbnQudGFyZ2V0O1xyXG5cclxuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnTW92ZUV2ZW50KHtcclxuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdNb3ZlRXZlbnQpO1xyXG5cclxuICAgIGlmIChkcmFnTW92ZUV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgc2Vuc29yRXZlbnQuY2FuY2VsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGFyZ2V0ID0gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xyXG4gICAgY29uc3Qgd2l0aGluQ29ycmVjdENvbnRhaW5lciA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoc2Vuc29yRXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xyXG4gICAgY29uc3Qgb3ZlckNvbnRhaW5lciA9IHNlbnNvckV2ZW50Lm92ZXJDb250YWluZXIgfHwgd2l0aGluQ29ycmVjdENvbnRhaW5lcjtcclxuICAgIGNvbnN0IGlzTGVhdmluZ0NvbnRhaW5lciA9IHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgJiYgb3ZlckNvbnRhaW5lciAhPT0gdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lcjtcclxuICAgIGNvbnN0IGlzTGVhdmluZ0RyYWdnYWJsZSA9IHRoaXMuY3VycmVudE92ZXIgJiYgdGFyZ2V0ICE9PSB0aGlzLmN1cnJlbnRPdmVyO1xyXG4gICAgY29uc3QgaXNPdmVyQ29udGFpbmVyID0gb3ZlckNvbnRhaW5lciAmJiB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyICE9PSBvdmVyQ29udGFpbmVyO1xyXG4gICAgY29uc3QgaXNPdmVyRHJhZ2dhYmxlID0gd2l0aGluQ29ycmVjdENvbnRhaW5lciAmJiB0YXJnZXQgJiYgdGhpcy5jdXJyZW50T3ZlciAhPT0gdGFyZ2V0O1xyXG5cclxuICAgIGlmIChpc0xlYXZpbmdEcmFnZ2FibGUpIHtcclxuICAgICAgY29uc3QgZHJhZ091dEV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ091dEV2ZW50KHtcclxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG92ZXI6IHRoaXMuY3VycmVudE92ZXIsXHJcbiAgICAgICAgb3ZlckNvbnRhaW5lcjogdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lclxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2RyYWdnYWJsZTpvdmVyJykpO1xyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyID0gbnVsbDtcclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3V0RXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0xlYXZpbmdDb250YWluZXIpIHtcclxuICAgICAgY29uc3QgZHJhZ091dENvbnRhaW5lckV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ091dENvbnRhaW5lckV2ZW50KHtcclxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG92ZXJDb250YWluZXI6IHRoaXMuY3VycmVudE92ZXJDb250YWluZXJcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6b3ZlcicpKTtcclxuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciA9IG51bGw7XHJcblxyXG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ091dENvbnRhaW5lckV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNPdmVyQ29udGFpbmVyKSB7XHJcbiAgICAgIG92ZXJDb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpvdmVyJykpO1xyXG5cclxuICAgICAgY29uc3QgZHJhZ092ZXJDb250YWluZXJFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdPdmVyQ29udGFpbmVyRXZlbnQoe1xyXG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgICAgb3ZlckNvbnRhaW5lclxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgPSBvdmVyQ29udGFpbmVyO1xyXG5cclxuICAgICAgdGhpcy50cmlnZ2VyKGRyYWdPdmVyQ29udGFpbmVyRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc092ZXJEcmFnZ2FibGUpIHtcclxuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcmFnZ2FibGU6b3ZlcicpKTtcclxuXHJcbiAgICAgIGNvbnN0IGRyYWdPdmVyRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnT3ZlckV2ZW50KHtcclxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG92ZXJDb250YWluZXIsXHJcbiAgICAgICAgb3ZlcjogdGFyZ2V0XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5jdXJyZW50T3ZlciA9IHRhcmdldDtcclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3ZlckV2ZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RvcCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERPTSBEcmFnIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ1N0b3BFdmVudCh7XHJcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzZW5zb3JFdmVudDogZXZlbnQuc2Vuc29yRXZlbnQsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogdGhpcy5zb3VyY2VDb250YWluZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnU3RvcEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLnNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLm9yaWdpbmFsU291cmNlLCB0aGlzLnNvdXJjZSk7XHJcbiAgICB0aGlzLnNvdXJjZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc291cmNlKTtcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2Uuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG5cclxuICAgIHRoaXMuc291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6ZHJhZ2dpbmcnKSk7XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6b3JpZ2luYWwnKSk7XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xyXG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpwbGFjZWQnKSk7XHJcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOmRyYWdnaW5nJykpO1xyXG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignYm9keTpkcmFnZ2luZycpKTtcclxuICAgIGFwcGx5VXNlclNlbGVjdChkb2N1bWVudC5ib2R5LCAnJyk7XHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudE92ZXIpIHtcclxuICAgICAgdGhpcy5jdXJyZW50T3Zlci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJhZ2dhYmxlOm92ZXInKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudE92ZXJDb250YWluZXIpIHtcclxuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOm92ZXInKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5sYXN0UGxhY2VkU291cmNlID0gdGhpcy5vcmlnaW5hbFNvdXJjZTtcclxuICAgIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lciA9IHRoaXMuc291cmNlQ29udGFpbmVyO1xyXG5cclxuICAgIHRoaXMucGxhY2VkVGltZW91dElEID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmxhc3RQbGFjZWRTb3VyY2UpIHtcclxuICAgICAgICB0aGlzLmxhc3RQbGFjZWRTb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmxhc3RQbGFjZWRDb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpwbGFjZWQnKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZSA9IG51bGw7XHJcbiAgICAgIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lciA9IG51bGw7XHJcbiAgICB9LCB0aGlzLm9wdGlvbnMucGxhY2VkVGltZW91dCk7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BwZWRFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdTdG9wcGVkRXZlbnQoe1xyXG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc2Vuc29yRXZlbnQ6IGV2ZW50LnNlbnNvckV2ZW50LFxyXG4gICAgICBzb3VyY2VDb250YWluZXI6IHRoaXMuc291cmNlQ29udGFpbmVyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ1N0b3BwZWRFdmVudCk7XHJcblxyXG4gICAgdGhpcy5zb3VyY2UgPSBudWxsO1xyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZSA9IG51bGw7XHJcbiAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyID0gbnVsbDtcclxuICAgIHRoaXMuY3VycmVudE92ZXIgPSBudWxsO1xyXG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBwcmVzc3VyZSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERPTSBEcmFnIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1ByZXNzdXJlXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZW5zb3JFdmVudCA9IGdldFNlbnNvckV2ZW50KGV2ZW50KTtcclxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlIHx8ICgwLCBfdXRpbHMuY2xvc2VzdCkoc2Vuc29yRXZlbnQub3JpZ2luYWxFdmVudC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdQcmVzc3VyZUV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ1ByZXNzdXJlRXZlbnQoe1xyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgc291cmNlLFxyXG4gICAgICBwcmVzc3VyZTogc2Vuc29yRXZlbnQucHJlc3N1cmVcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnUHJlc3N1cmVFdmVudCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGU7XHJcbkRyYWdnYWJsZS5QbHVnaW5zID0geyBBbm5vdW5jZW1lbnQ6IF9QbHVnaW5zLkFubm91bmNlbWVudCwgRm9jdXNhYmxlOiBfUGx1Z2lucy5Gb2N1c2FibGUsIE1pcnJvcjogX1BsdWdpbnMuTWlycm9yLCBTY3JvbGxhYmxlOiBfUGx1Z2lucy5TY3JvbGxhYmxlIH07XHJcbkRyYWdnYWJsZS5TZW5zb3JzID0geyBNb3VzZVNlbnNvcjogX1NlbnNvcnMuTW91c2VTZW5zb3IsIFRvdWNoU2Vuc29yOiBfU2Vuc29ycy5Ub3VjaFNlbnNvciB9O1xyXG5mdW5jdGlvbiBnZXRTZW5zb3JFdmVudChldmVudCkge1xyXG4gIHJldHVybiBldmVudC5kZXRhaWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VXNlclNlbGVjdChlbGVtZW50LCB2YWx1ZSkge1xyXG4gIGVsZW1lbnQuc3R5bGUud2Via2l0VXNlclNlbGVjdCA9IHZhbHVlO1xyXG4gIGVsZW1lbnQuc3R5bGUubW96VXNlclNlbGVjdCA9IHZhbHVlO1xyXG4gIGVsZW1lbnQuc3R5bGUubXNVc2VyU2VsZWN0ID0gdmFsdWU7XHJcbiAgZWxlbWVudC5zdHlsZS5vVXNlclNlbGVjdCA9IHZhbHVlO1xyXG4gIGVsZW1lbnQuc3R5bGUudXNlclNlbGVjdCA9IHZhbHVlO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNzQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLnNjcm9sbCA9IGV4cG9ydHMub25EcmFnU3RvcCA9IGV4cG9ydHMub25EcmFnTW92ZSA9IGV4cG9ydHMub25EcmFnU3RhcnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gZXhwb3J0cy5vbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcclxuY29uc3Qgb25EcmFnTW92ZSA9IGV4cG9ydHMub25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xyXG5jb25zdCBvbkRyYWdTdG9wID0gZXhwb3J0cy5vbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XHJcbmNvbnN0IHNjcm9sbCA9IGV4cG9ydHMuc2Nyb2xsID0gU3ltYm9sKCdzY3JvbGwnKTtcclxuXHJcbi8qKlxyXG4gKiBTY3JvbGxhYmxlIGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLnNwZWVkXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWZhdWx0T3B0aW9ucy5zZW5zaXRpdml0eVxyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50W119IGRlZmF1bHRPcHRpb25zLnNjcm9sbGFibGVFbGVtZW50c1xyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xyXG4gIHNwZWVkOiA2LFxyXG4gIHNlbnNpdGl2aXR5OiA1MCxcclxuICBzY3JvbGxhYmxlRWxlbWVudHM6IFtdXHJcbn07XHJcblxyXG4vKipcclxuICogU2Nyb2xsYWJsZSBwbHVnaW4gd2hpY2ggc2Nyb2xscyB0aGUgY2xvc2VzdCBzY3JvbGxhYmxlIHBhcmVudFxyXG4gKiBAY2xhc3MgU2Nyb2xsYWJsZVxyXG4gKiBAbW9kdWxlIFNjcm9sbGFibGVcclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIFNjcm9sbGFibGUgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIFNjcm9sbGFibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgU2Nyb2xsYWJsZVxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY3JvbGxhYmxlIG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gb3B0aW9ucy5zcGVlZFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG9wdGlvbnMuc2Vuc2l0aXZpdHlcclxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnRbXX0gb3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2VlcHMgY3VycmVudCBtb3VzZSBwb3NpdGlvblxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IGN1cnJlbnRNb3VzZVBvc2l0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY3VycmVudE1vdXNlUG9zaXRpb24uY2xpZW50WFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGN1cnJlbnRNb3VzZVBvc2l0aW9uLmNsaWVudFlcclxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbiA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY3JvbGwgYW5pbWF0aW9uIGZyYW1lXHJcbiAgICAgKiBAcHJvcGVydHkgc2Nyb2xsQW5pbWF0aW9uRnJhbWVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXN0IHNjcm9sbGFibGUgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHNjcm9sbGFibGVFbGVtZW50XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zY3JvbGxhYmxlRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbmltYXRpb24gZnJhbWUgbG9va2luZyBmb3IgdGhlIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBlbGVtZW50XHJcbiAgICAgKiBAcHJvcGVydHkgZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW3Njcm9sbF0gPSB0aGlzW3Njcm9sbF0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgb3B0aW9ucyBwYXNzZWQgdGhyb3VnaCBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXHJcbiAgZ2V0T3B0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLnNjcm9sbGFibGUgfHwge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBlbGVtZW50cyBieSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAgICovXHJcbiAgZ2V0U2Nyb2xsYWJsZUVsZW1lbnQodGFyZ2V0KSB7XHJcbiAgICBpZiAodGhpcy5oYXNEZWZpbmVkU2Nyb2xsYWJsZUVsZW1lbnRzKCkpIHtcclxuICAgICAgcmV0dXJuICgwLCBfdXRpbHMuY2xvc2VzdCkodGFyZ2V0LCB0aGlzLm9wdGlvbnMuc2Nyb2xsYWJsZUVsZW1lbnRzKSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gY2xvc2VzdFNjcm9sbGFibGVFbGVtZW50KHRhcmdldCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgYXQgbGVhc3Qgb25lIHNjcm9sbGFibGUgZWxlbWVudCBoYXZlIGJlZW4gZGVmaW5lZCB2aWEgb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaGFzRGVmaW5lZFNjcm9sbGFibGVFbGVtZW50cygpIHtcclxuICAgIHJldHVybiBCb29sZWFuKHRoaXMub3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHMubGVuZ3RoICE9PSAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlci4gRmluZHMgY2xvc2VzdCBzY3JvbGxhYmxlIHBhcmVudCBpbiBzZXBhcmF0ZSBmcmFtZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0YXJ0RXZlbnR9IGRyYWdFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRHJhZ1N0YXJ0XShkcmFnRXZlbnQpIHtcclxuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gdGhpcy5nZXRTY3JvbGxhYmxlRWxlbWVudChkcmFnRXZlbnQuc291cmNlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBtb3ZlIGhhbmRsZXIuIFJlbWVtYmVycyBtb3VzZSBwb3NpdGlvbiBhbmQgaW5pdGlhdGVzIHNjcm9sbGluZ1xyXG4gICAqIEBwYXJhbSB7RHJhZ01vdmVFdmVudH0gZHJhZ0V2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25EcmFnTW92ZV0oZHJhZ0V2ZW50KSB7XHJcbiAgICB0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgdGhpcy5zY3JvbGxhYmxlRWxlbWVudCA9IHRoaXMuZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZHJhZ0V2ZW50LnNlbnNvckV2ZW50LnRhcmdldCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZHJhZ0V2ZW50LnNlbnNvckV2ZW50O1xyXG4gICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcblxyXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xyXG4gICAgICBzY3JvbGxPZmZzZXQueSA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IDA7XHJcbiAgICAgIHNjcm9sbE9mZnNldC54ID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCB8fCAwO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24gPSB7XHJcbiAgICAgIGNsaWVudFg6IHNlbnNvckV2ZW50LmNsaWVudFggLSBzY3JvbGxPZmZzZXQueCxcclxuICAgICAgY2xpZW50WTogc2Vuc29yRXZlbnQuY2xpZW50WSAtIHNjcm9sbE9mZnNldC55XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpc1tzY3JvbGxdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RvcCBoYW5kbGVyLiBDYW5jZWxzIHNjcm9sbCBhbmltYXRpb25zIGFuZCByZXNldHMgc3RhdGVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdG9wXSgpIHtcclxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUpO1xyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSk7XHJcblxyXG4gICAgdGhpcy5zY3JvbGxhYmxlRWxlbWVudCA9IG51bGw7XHJcbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcclxuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSBudWxsO1xyXG4gICAgdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbiA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY3JvbGwgZnVuY3Rpb24gdGhhdCBkb2VzIHRoZSBoZWF2eWxpZnRpbmdcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtzY3JvbGxdKCkge1xyXG4gICAgaWYgKCF0aGlzLnNjcm9sbGFibGVFbGVtZW50IHx8ICF0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lKTtcclxuXHJcbiAgICBjb25zdCB7IHNwZWVkLCBzZW5zaXRpdml0eSB9ID0gdGhpcy5vcHRpb25zO1xyXG5cclxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnNjcm9sbGFibGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgY29uc3QgYm90dG9tQ3V0T2ZmID0gcmVjdC5ib3R0b20gPiB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICBjb25zdCB0b3BDdXRPZmYgPSByZWN0LnRvcCA8IDA7XHJcbiAgICBjb25zdCBjdXRPZmYgPSB0b3BDdXRPZmYgfHwgYm90dG9tQ3V0T2ZmO1xyXG5cclxuICAgIGNvbnN0IGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCA9IGdldERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCgpO1xyXG4gICAgY29uc3Qgc2Nyb2xsYWJsZUVsZW1lbnQgPSB0aGlzLnNjcm9sbGFibGVFbGVtZW50O1xyXG4gICAgY29uc3QgY2xpZW50WCA9IHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24uY2xpZW50WDtcclxuICAgIGNvbnN0IGNsaWVudFkgPSB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uLmNsaWVudFk7XHJcblxyXG4gICAgaWYgKHNjcm9sbGFibGVFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIHNjcm9sbGFibGVFbGVtZW50ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgIWN1dE9mZikge1xyXG4gICAgICBjb25zdCB7IG9mZnNldEhlaWdodCwgb2Zmc2V0V2lkdGggfSA9IHNjcm9sbGFibGVFbGVtZW50O1xyXG5cclxuICAgICAgaWYgKHJlY3QudG9wICsgb2Zmc2V0SGVpZ2h0IC0gY2xpZW50WSA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsVG9wICs9IHNwZWVkO1xyXG4gICAgICB9IGVsc2UgaWYgKGNsaWVudFkgLSByZWN0LnRvcCA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsVG9wIC09IHNwZWVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVjdC5sZWZ0ICsgb2Zmc2V0V2lkdGggLSBjbGllbnRYIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxMZWZ0ICs9IHNwZWVkO1xyXG4gICAgICB9IGVsc2UgaWYgKGNsaWVudFggLSByZWN0LmxlZnQgPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbExlZnQgLT0gc3BlZWQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHsgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGggfSA9IHdpbmRvdztcclxuXHJcbiAgICAgIGlmIChjbGllbnRZIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wIC09IHNwZWVkO1xyXG4gICAgICB9IGVsc2UgaWYgKGlubmVySGVpZ2h0IC0gY2xpZW50WSA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCArPSBzcGVlZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNsaWVudFggPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0IC09IHNwZWVkO1xyXG4gICAgICB9IGVsc2UgaWYgKGlubmVyV2lkdGggLSBjbGllbnRYIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCArPSBzcGVlZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpc1tzY3JvbGxdKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNjcm9sbGFibGU7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCBlbGVtZW50IGhhcyBvdmVyZmxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuZnVuY3Rpb24gaGFzT3ZlcmZsb3coZWxlbWVudCkge1xyXG4gIGNvbnN0IG92ZXJmbG93UmVnZXggPSAvKGF1dG98c2Nyb2xsKS87XHJcbiAgY29uc3QgY29tcHV0ZWRTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xyXG5cclxuICBjb25zdCBvdmVyZmxvdyA9IGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93JykgKyBjb21wdXRlZFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdy15JykgKyBjb21wdXRlZFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdy14Jyk7XHJcblxyXG4gIHJldHVybiBvdmVyZmxvd1JlZ2V4LnRlc3Qob3ZlcmZsb3cpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgZWxlbWVudCBpcyBzdGF0aWNhbGx5IHBvc2l0aW9uZWRcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNTdGF0aWNhbGx5UG9zaXRpb25lZChlbGVtZW50KSB7XHJcbiAgY29uc3QgcG9zaXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJyk7XHJcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAnc3RhdGljJztcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmRzIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9zZXN0U2Nyb2xsYWJsZUVsZW1lbnQoZWxlbWVudCkge1xyXG4gIGlmICghZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIGdldERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCgpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcG9zaXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJyk7XHJcbiAgY29uc3QgZXhjbHVkZVN0YXRpY1BhcmVudHMgPSBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJztcclxuXHJcbiAgY29uc3Qgc2Nyb2xsYWJsZUVsZW1lbnQgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGVsZW1lbnQsIHBhcmVudCA9PiB7XHJcbiAgICBpZiAoZXhjbHVkZVN0YXRpY1BhcmVudHMgJiYgaXNTdGF0aWNhbGx5UG9zaXRpb25lZChwYXJlbnQpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBoYXNPdmVyZmxvdyhwYXJlbnQpO1xyXG4gIH0pO1xyXG5cclxuICBpZiAocG9zaXRpb24gPT09ICdmaXhlZCcgfHwgIXNjcm9sbGFibGVFbGVtZW50KSB7XHJcbiAgICByZXR1cm4gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBzY3JvbGxhYmxlRWxlbWVudDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGVsZW1lbnQgdGhhdCBzY3JvbGxzIGRvY3VtZW50XHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCkge1xyXG4gIHJldHVybiBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDc1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9TY3JvbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XHJcblxyXG52YXIgX1Njcm9sbGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Nyb2xsYWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX1Njcm9sbGFibGUyLmRlZmF1bHQ7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfU2Nyb2xsYWJsZS5kZWZhdWx0T3B0aW9ucztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3NiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5NaXJyb3JEZXN0cm95RXZlbnQgPSBleHBvcnRzLk1pcnJvck1vdmVFdmVudCA9IGV4cG9ydHMuTWlycm9yQXR0YWNoZWRFdmVudCA9IGV4cG9ydHMuTWlycm9yQ3JlYXRlZEV2ZW50ID0gZXhwb3J0cy5NaXJyb3JDcmVhdGVFdmVudCA9IGV4cG9ydHMuTWlycm9yRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIG1pcnJvciBldmVudFxyXG4gKiBAY2xhc3MgTWlycm9yRXZlbnRcclxuICogQG1vZHVsZSBNaXJyb3JFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBNaXJyb3JFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIHNvdXJjZSBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IHNvdXJjZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc291cmNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG9yaWdpbmFsIHNvdXJjZSBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG9yaWdpbmFsU291cmNlXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvcmlnaW5hbFNvdXJjZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxTb3VyY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIHNvdXJjZSBjb250YWluZXIgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBzb3VyY2VDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNvdXJjZUNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Vuc29yIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IHNlbnNvckV2ZW50XHJcbiAgICogQHR5cGUge1NlbnNvckV2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzZW5zb3JFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc2Vuc29yRXZlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IGRyYWdFdmVudFxyXG4gICAqIEB0eXBlIHtEcmFnRXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyYWdFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgc2Vuc29yIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IG9yaWdpbmFsRXZlbnRcclxuICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9yaWdpbmFsRXZlbnQoKSB7XHJcbiAgICBpZiAodGhpcy5zZW5zb3JFdmVudCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5NaXJyb3JFdmVudCA9IE1pcnJvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNaXJyb3IgY3JlYXRlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIE1pcnJvckNyZWF0ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JDcmVhdGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIE1pcnJvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5jbGFzcyBNaXJyb3JDcmVhdGVFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHt9XHJcblxyXG5leHBvcnRzLk1pcnJvckNyZWF0ZUV2ZW50ID0gTWlycm9yQ3JlYXRlRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1pcnJvciBjcmVhdGVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIE1pcnJvckNyZWF0ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgTWlycm9yQ3JlYXRlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgTWlycm9yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbk1pcnJvckNyZWF0ZUV2ZW50LnR5cGUgPSAnbWlycm9yOmNyZWF0ZSc7XHJcbmNsYXNzIE1pcnJvckNyZWF0ZWRFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBtaXJyb3IgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG1pcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5NaXJyb3JDcmVhdGVkRXZlbnQgPSBNaXJyb3JDcmVhdGVkRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWlycm9yIGF0dGFjaGVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgTWlycm9yQXR0YWNoZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JBdHRhY2hlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBNaXJyb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5NaXJyb3JDcmVhdGVkRXZlbnQudHlwZSA9ICdtaXJyb3I6Y3JlYXRlZCc7XHJcbmNsYXNzIE1pcnJvckF0dGFjaGVkRXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgbWlycm9yIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbWlycm9yXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBtaXJyb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuTWlycm9yQXR0YWNoZWRFdmVudCA9IE1pcnJvckF0dGFjaGVkRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNaXJyb3IgbW92ZSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgTWlycm9yTW92ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgTWlycm9yTW92ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIE1pcnJvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuTWlycm9yQXR0YWNoZWRFdmVudC50eXBlID0gJ21pcnJvcjphdHRhY2hlZCc7XHJcbmNsYXNzIE1pcnJvck1vdmVFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBtaXJyb3IgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG1pcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Vuc29yIGhhcyBleGNlZWRlZCBtaXJyb3IncyB0aHJlc2hvbGQgb24geCBheGlzXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHBhc3NlZFRocmVzaFgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnBhc3NlZFRocmVzaFg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5zb3IgaGFzIGV4Y2VlZGVkIG1pcnJvcidzIHRocmVzaG9sZCBvbiB5IGF4aXNcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcGFzc2VkVGhyZXNoWSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEucGFzc2VkVGhyZXNoWTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuTWlycm9yTW92ZUV2ZW50ID0gTWlycm9yTW92ZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1pcnJvciBkZXN0cm95IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgTWlycm9yRGVzdHJveUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIE1pcnJvckRlc3Ryb3lFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgTWlycm9yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuTWlycm9yTW92ZUV2ZW50LnR5cGUgPSAnbWlycm9yOm1vdmUnO1xyXG5NaXJyb3JNb3ZlRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIE1pcnJvckRlc3Ryb3lFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBtaXJyb3IgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG1pcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLk1pcnJvckRlc3Ryb3lFdmVudCA9IE1pcnJvckRlc3Ryb3lFdmVudDtcclxuTWlycm9yRGVzdHJveUV2ZW50LnR5cGUgPSAnbWlycm9yOmRlc3Ryb3knO1xyXG5NaXJyb3JEZXN0cm95RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNzcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX01pcnJvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XHJcblxyXG5PYmplY3Qua2V5cyhfTWlycm9yRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfTWlycm9yRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNzggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmdldEFwcGVuZGFibGVDb250YWluZXIgPSBleHBvcnRzLm9uU2Nyb2xsID0gZXhwb3J0cy5vbk1pcnJvck1vdmUgPSBleHBvcnRzLm9uTWlycm9yQ3JlYXRlZCA9IGV4cG9ydHMub25EcmFnU3RvcCA9IGV4cG9ydHMub25EcmFnTW92ZSA9IGV4cG9ydHMub25EcmFnU3RhcnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbnZhciBfTWlycm9yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XHJcblxyXG5jb25zdCBvbkRyYWdTdGFydCA9IGV4cG9ydHMub25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XHJcbmNvbnN0IG9uRHJhZ01vdmUgPSBleHBvcnRzLm9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcclxuY29uc3Qgb25EcmFnU3RvcCA9IGV4cG9ydHMub25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xyXG5jb25zdCBvbk1pcnJvckNyZWF0ZWQgPSBleHBvcnRzLm9uTWlycm9yQ3JlYXRlZCA9IFN5bWJvbCgnb25NaXJyb3JDcmVhdGVkJyk7XHJcbmNvbnN0IG9uTWlycm9yTW92ZSA9IGV4cG9ydHMub25NaXJyb3JNb3ZlID0gU3ltYm9sKCdvbk1pcnJvck1vdmUnKTtcclxuY29uc3Qgb25TY3JvbGwgPSBleHBvcnRzLm9uU2Nyb2xsID0gU3ltYm9sKCdvblNjcm9sbCcpO1xyXG5jb25zdCBnZXRBcHBlbmRhYmxlQ29udGFpbmVyID0gZXhwb3J0cy5nZXRBcHBlbmRhYmxlQ29udGFpbmVyID0gU3ltYm9sKCdnZXRBcHBlbmRhYmxlQ29udGFpbmVyJyk7XHJcblxyXG4vKipcclxuICogTWlycm9yIGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkZWZhdWx0T3B0aW9ucy5jb25zdHJhaW5EaW1lbnNpb25zXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVmYXVsdE9wdGlvbnMueEF4aXNcclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkZWZhdWx0T3B0aW9ucy55QXhpc1xyXG4gKiBAcHJvcGVydHkge251bGx9IGRlZmF1bHRPcHRpb25zLmN1cnNvck9mZnNldFhcclxuICogQHByb3BlcnR5IHtudWxsfSBkZWZhdWx0T3B0aW9ucy5jdXJzb3JPZmZzZXRZXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgY29uc3RyYWluRGltZW5zaW9uczogZmFsc2UsXHJcbiAgeEF4aXM6IHRydWUsXHJcbiAgeUF4aXM6IHRydWUsXHJcbiAgY3Vyc29yT2Zmc2V0WDogbnVsbCxcclxuICBjdXJzb3JPZmZzZXRZOiBudWxsLFxyXG4gIHRocmVzaG9sZFg6IG51bGwsXHJcbiAgdGhyZXNob2xkWTogbnVsbFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1pcnJvciBwbHVnaW4gd2hpY2ggY29udHJvbHMgdGhlIG1pcnJvciBwb3NpdGlvbmluZyB3aGlsZSBkcmFnZ2luZ1xyXG4gKiBAY2xhc3MgTWlycm9yXHJcbiAqIEBtb2R1bGUgTWlycm9yXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBNaXJyb3IgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIE1pcnJvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBNaXJyb3JcclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWlycm9yIG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBvcHRpb25zLnhBeGlzXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG9wdGlvbnMueUF4aXNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfG51bGx9IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8bnVsbH0gb3B0aW9ucy5jdXJzb3JPZmZzZXRZXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbn0gb3B0aW9ucy5hcHBlbmRUb1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY3JvbGwgb2Zmc2V0IGZvciB0b3VjaCBkZXZpY2VzIGJlY2F1c2UgdGhlIG1pcnJvciBpcyBwb3NpdGlvbmVkIGZpeGVkXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gc2Nyb2xsT2Zmc2V0XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc2Nyb2xsT2Zmc2V0LnhcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY3JvbGxPZmZzZXQueVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbCBzY3JvbGwgb2Zmc2V0IGZvciB0b3VjaCBkZXZpY2VzIGJlY2F1c2UgdGhlIG1pcnJvciBpcyBwb3NpdGlvbmVkIGZpeGVkXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gc2Nyb2xsT2Zmc2V0XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc2Nyb2xsT2Zmc2V0LnhcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY3JvbGxPZmZzZXQueVxyXG4gICAgICovXHJcbiAgICB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQgPSB7XHJcbiAgICAgIHg6IHdpbmRvdy5zY3JvbGxYLFxyXG4gICAgICB5OiB3aW5kb3cuc2Nyb2xsWVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25NaXJyb3JDcmVhdGVkXSA9IHRoaXNbb25NaXJyb3JDcmVhdGVkXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1pcnJvck1vdmVdID0gdGhpc1tvbk1pcnJvck1vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uU2Nyb2xsXSA9IHRoaXNbb25TY3JvbGxdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9uKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSkub24oJ21pcnJvcjpjcmVhdGVkJywgdGhpc1tvbk1pcnJvckNyZWF0ZWRdKS5vbignbWlycm9yOm1vdmUnLCB0aGlzW29uTWlycm9yTW92ZV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9mZignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9mZignbWlycm9yOm1vdmUnLCB0aGlzW29uTWlycm9yTW92ZV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBvcHRpb25zIHBhc3NlZCB0aHJvdWdoIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMubWlycm9yIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgW29uRHJhZ1N0YXJ0XShkcmFnRXZlbnQpIHtcclxuICAgIGlmIChkcmFnRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzW29uU2Nyb2xsXSwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0ID0ge1xyXG4gICAgICB4OiB3aW5kb3cuc2Nyb2xsWCxcclxuICAgICAgeTogd2luZG93LnNjcm9sbFlcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgeyBzb3VyY2UsIG9yaWdpbmFsU291cmNlLCBzb3VyY2VDb250YWluZXIsIHNlbnNvckV2ZW50IH0gPSBkcmFnRXZlbnQ7XHJcblxyXG4gICAgLy8gTGFzdCBzZW5zb3IgcG9zaXRpb24gb2YgbWlycm9yIG1vdmVcclxuICAgIHRoaXMubGFzdE1pcnJvck1vdmVkQ2xpZW50ID0ge1xyXG4gICAgICB4OiBzZW5zb3JFdmVudC5jbGllbnRYLFxyXG4gICAgICB5OiBzZW5zb3JFdmVudC5jbGllbnRZXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IG1pcnJvckNyZWF0ZUV2ZW50ID0gbmV3IF9NaXJyb3JFdmVudC5NaXJyb3JDcmVhdGVFdmVudCh7XHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIGRyYWdFdmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JDcmVhdGVFdmVudCk7XHJcblxyXG4gICAgaWYgKGlzTmF0aXZlRHJhZ0V2ZW50KHNlbnNvckV2ZW50KSB8fCBtaXJyb3JDcmVhdGVFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhcHBlbmRhYmxlQ29udGFpbmVyID0gdGhpc1tnZXRBcHBlbmRhYmxlQ29udGFpbmVyXShzb3VyY2UpIHx8IHNvdXJjZUNvbnRhaW5lcjtcclxuICAgIHRoaXMubWlycm9yID0gc291cmNlLmNsb25lTm9kZSh0cnVlKTtcclxuXHJcbiAgICBjb25zdCBtaXJyb3JDcmVhdGVkRXZlbnQgPSBuZXcgX01pcnJvckV2ZW50Lk1pcnJvckNyZWF0ZWRFdmVudCh7XHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIGRyYWdFdmVudCxcclxuICAgICAgbWlycm9yOiB0aGlzLm1pcnJvclxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbWlycm9yQXR0YWNoZWRFdmVudCA9IG5ldyBfTWlycm9yRXZlbnQuTWlycm9yQXR0YWNoZWRFdmVudCh7XHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIGRyYWdFdmVudCxcclxuICAgICAgbWlycm9yOiB0aGlzLm1pcnJvclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JDcmVhdGVkRXZlbnQpO1xyXG4gICAgYXBwZW5kYWJsZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1pcnJvcik7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckF0dGFjaGVkRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgW29uRHJhZ01vdmVdKGRyYWdFdmVudCkge1xyXG4gICAgaWYgKCF0aGlzLm1pcnJvciB8fCBkcmFnRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBzb3VyY2UsIG9yaWdpbmFsU291cmNlLCBzb3VyY2VDb250YWluZXIsIHNlbnNvckV2ZW50IH0gPSBkcmFnRXZlbnQ7XHJcblxyXG4gICAgbGV0IHBhc3NlZFRocmVzaFggPSB0cnVlO1xyXG4gICAgbGV0IHBhc3NlZFRocmVzaFkgPSB0cnVlO1xyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMudGhyZXNob2xkWCB8fCB0aGlzLm9wdGlvbnMudGhyZXNob2xkWSkge1xyXG4gICAgICBjb25zdCB7IHg6IGxhc3RYLCB5OiBsYXN0WSB9ID0gdGhpcy5sYXN0TWlycm9yTW92ZWRDbGllbnQ7XHJcblxyXG4gICAgICBpZiAoTWF0aC5hYnMobGFzdFggLSBzZW5zb3JFdmVudC5jbGllbnRYKSA8IHRoaXMub3B0aW9ucy50aHJlc2hvbGRYKSB7XHJcbiAgICAgICAgcGFzc2VkVGhyZXNoWCA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubGFzdE1pcnJvck1vdmVkQ2xpZW50LnggPSBzZW5zb3JFdmVudC5jbGllbnRYO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoTWF0aC5hYnMobGFzdFkgLSBzZW5zb3JFdmVudC5jbGllbnRZKSA8IHRoaXMub3B0aW9ucy50aHJlc2hvbGRZKSB7XHJcbiAgICAgICAgcGFzc2VkVGhyZXNoWSA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubGFzdE1pcnJvck1vdmVkQ2xpZW50LnkgPSBzZW5zb3JFdmVudC5jbGllbnRZO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXBhc3NlZFRocmVzaFggJiYgIXBhc3NlZFRocmVzaFkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtaXJyb3JNb3ZlRXZlbnQgPSBuZXcgX01pcnJvckV2ZW50Lk1pcnJvck1vdmVFdmVudCh7XHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIGRyYWdFdmVudCxcclxuICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcclxuICAgICAgcGFzc2VkVGhyZXNoWCxcclxuICAgICAgcGFzc2VkVGhyZXNoWVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JNb3ZlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgW29uRHJhZ1N0b3BdKGRyYWdFdmVudCkge1xyXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzW29uU2Nyb2xsXSwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgIGlmICghdGhpcy5taXJyb3IpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgc291cmNlLCBzb3VyY2VDb250YWluZXIsIHNlbnNvckV2ZW50IH0gPSBkcmFnRXZlbnQ7XHJcblxyXG4gICAgY29uc3QgbWlycm9yRGVzdHJveUV2ZW50ID0gbmV3IF9NaXJyb3JFdmVudC5NaXJyb3JEZXN0cm95RXZlbnQoe1xyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIGRyYWdFdmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JEZXN0cm95RXZlbnQpO1xyXG5cclxuICAgIGlmICghbWlycm9yRGVzdHJveUV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgdGhpcy5taXJyb3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm1pcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBbb25TY3JvbGxdKCkge1xyXG4gICAgdGhpcy5zY3JvbGxPZmZzZXQgPSB7XHJcbiAgICAgIHg6IHdpbmRvdy5zY3JvbGxYIC0gdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0LngsXHJcbiAgICAgIHk6IHdpbmRvdy5zY3JvbGxZIC0gdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0LnlcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNaXJyb3IgY3JlYXRlZCBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtNaXJyb3JDcmVhdGVkRXZlbnR9IG1pcnJvckV2ZW50XHJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbk1pcnJvckNyZWF0ZWRdKHsgbWlycm9yLCBzb3VyY2UsIHNlbnNvckV2ZW50IH0pIHtcclxuICAgIGNvbnN0IG1pcnJvckNsYXNzZXMgPSB0aGlzLmRyYWdnYWJsZS5nZXRDbGFzc05hbWVzRm9yKCdtaXJyb3InKTtcclxuXHJcbiAgICBjb25zdCBzZXRTdGF0ZSA9IChfcmVmKSA9PiB7XHJcbiAgICAgIGxldCB7IG1pcnJvck9mZnNldCwgaW5pdGlhbFgsIGluaXRpYWxZIH0gPSBfcmVmLFxyXG4gICAgICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ21pcnJvck9mZnNldCcsICdpbml0aWFsWCcsICdpbml0aWFsWSddKTtcclxuXHJcbiAgICAgIHRoaXMubWlycm9yT2Zmc2V0ID0gbWlycm9yT2Zmc2V0O1xyXG4gICAgICB0aGlzLmluaXRpYWxYID0gaW5pdGlhbFg7XHJcbiAgICAgIHRoaXMuaW5pdGlhbFkgPSBpbml0aWFsWTtcclxuICAgICAgdGhpcy5sYXN0TW92ZWRYID0gaW5pdGlhbFg7XHJcbiAgICAgIHRoaXMubGFzdE1vdmVkWSA9IGluaXRpYWxZO1xyXG4gICAgICByZXR1cm4gX2V4dGVuZHMoeyBtaXJyb3JPZmZzZXQsIGluaXRpYWxYLCBpbml0aWFsWSB9LCBhcmdzKTtcclxuICAgIH07XHJcblxyXG4gICAgbWlycm9yLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xyXG4gICAgICBtaXJyb3IsXHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIG1pcnJvckNsYXNzZXMsXHJcbiAgICAgIHNjcm9sbE9mZnNldDogdGhpcy5zY3JvbGxPZmZzZXQsXHJcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcclxuICAgICAgcGFzc2VkVGhyZXNoWDogdHJ1ZSxcclxuICAgICAgcGFzc2VkVGhyZXNoWTogdHJ1ZVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluaXRpYWxTdGF0ZSlcclxuICAgIC8vIEZpeCByZWZsb3cgaGVyZVxyXG4gICAgLnRoZW4oY29tcHV0ZU1pcnJvckRpbWVuc2lvbnMpLnRoZW4oY2FsY3VsYXRlTWlycm9yT2Zmc2V0KS50aGVuKHJlc2V0TWlycm9yKS50aGVuKGFkZE1pcnJvckNsYXNzZXMpLnRoZW4ocG9zaXRpb25NaXJyb3IoeyBpbml0aWFsOiB0cnVlIH0pKS50aGVuKHJlbW92ZU1pcnJvcklEKS50aGVuKHNldFN0YXRlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1pcnJvciBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge01pcnJvck1vdmVFdmVudH0gbWlycm9yRXZlbnRcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfG51bGx9XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25NaXJyb3JNb3ZlXShtaXJyb3JFdmVudCkge1xyXG4gICAgaWYgKG1pcnJvckV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2V0U3RhdGUgPSAoX3JlZjIpID0+IHtcclxuICAgICAgbGV0IHsgbGFzdE1vdmVkWCwgbGFzdE1vdmVkWSB9ID0gX3JlZjIsXHJcbiAgICAgICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2xhc3RNb3ZlZFgnLCAnbGFzdE1vdmVkWSddKTtcclxuXHJcbiAgICAgIHRoaXMubGFzdE1vdmVkWCA9IGxhc3RNb3ZlZFg7XHJcbiAgICAgIHRoaXMubGFzdE1vdmVkWSA9IGxhc3RNb3ZlZFk7XHJcblxyXG4gICAgICByZXR1cm4gX2V4dGVuZHMoeyBsYXN0TW92ZWRYLCBsYXN0TW92ZWRZIH0sIGFyZ3MpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSB7XHJcbiAgICAgIG1pcnJvcjogbWlycm9yRXZlbnQubWlycm9yLFxyXG4gICAgICBzZW5zb3JFdmVudDogbWlycm9yRXZlbnQuc2Vuc29yRXZlbnQsXHJcbiAgICAgIG1pcnJvck9mZnNldDogdGhpcy5taXJyb3JPZmZzZXQsXHJcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcclxuICAgICAgaW5pdGlhbFg6IHRoaXMuaW5pdGlhbFgsXHJcbiAgICAgIGluaXRpYWxZOiB0aGlzLmluaXRpYWxZLFxyXG4gICAgICBzY3JvbGxPZmZzZXQ6IHRoaXMuc2Nyb2xsT2Zmc2V0LFxyXG4gICAgICBwYXNzZWRUaHJlc2hYOiBtaXJyb3JFdmVudC5wYXNzZWRUaHJlc2hYLFxyXG4gICAgICBwYXNzZWRUaHJlc2hZOiBtaXJyb3JFdmVudC5wYXNzZWRUaHJlc2hZLFxyXG4gICAgICBsYXN0TW92ZWRYOiB0aGlzLmxhc3RNb3ZlZFgsXHJcbiAgICAgIGxhc3RNb3ZlZFk6IHRoaXMubGFzdE1vdmVkWVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluaXRpYWxTdGF0ZSkudGhlbihwb3NpdGlvbk1pcnJvcih7IHJhZjogdHJ1ZSB9KSkudGhlbihzZXRTdGF0ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFwcGVuZGFibGUgY29udGFpbmVyIGZvciBtaXJyb3IgYmFzZWQgb24gdGhlIGFwcGVuZFRvIG9wdGlvblxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25zLnNvdXJjZSAtIEN1cnJlbnQgc291cmNlXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAgICovXHJcbiAgW2dldEFwcGVuZGFibGVDb250YWluZXJdKHNvdXJjZSkge1xyXG4gICAgY29uc3QgYXBwZW5kVG8gPSB0aGlzLm9wdGlvbnMuYXBwZW5kVG87XHJcblxyXG4gICAgaWYgKHR5cGVvZiBhcHBlbmRUbyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXBwZW5kVG8pO1xyXG4gICAgfSBlbHNlIGlmIChhcHBlbmRUbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBhcHBlbmRUbztcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFwcGVuZFRvID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHJldHVybiBhcHBlbmRUbyhzb3VyY2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHNvdXJjZS5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gTWlycm9yOyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb21wdXRlcyBtaXJyb3IgZGltZW5zaW9ucyBiYXNlZCBvbiB0aGUgc291cmNlIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBBZGRzIHNvdXJjZVJlY3QgdG8gc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5zb3VyY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5mdW5jdGlvbiBjb21wdXRlTWlycm9yRGltZW5zaW9ucyhfcmVmMykge1xyXG4gIGxldCB7IHNvdXJjZSB9ID0gX3JlZjMsXHJcbiAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjMsIFsnc291cmNlJ10pO1xyXG5cclxuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBjb25zdCBzb3VyY2VSZWN0ID0gc291cmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgcmVzb2x2ZShfZXh0ZW5kcyh7IHNvdXJjZSwgc291cmNlUmVjdCB9LCBhcmdzKSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIG1pcnJvciBvZmZzZXRcclxuICogQWRkcyBtaXJyb3JPZmZzZXQgdG8gc3RhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAqIEBwYXJhbSB7U2Vuc29yRXZlbnR9IHN0YXRlLnNlbnNvckV2ZW50XHJcbiAqIEBwYXJhbSB7RE9NUmVjdH0gc3RhdGUuc291cmNlUmVjdFxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlTWlycm9yT2Zmc2V0KF9yZWY0KSB7XHJcbiAgbGV0IHsgc2Vuc29yRXZlbnQsIHNvdXJjZVJlY3QsIG9wdGlvbnMgfSA9IF9yZWY0LFxyXG4gICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY0LCBbJ3NlbnNvckV2ZW50JywgJ3NvdXJjZVJlY3QnLCAnb3B0aW9ucyddKTtcclxuXHJcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgY29uc3QgdG9wID0gb3B0aW9ucy5jdXJzb3JPZmZzZXRZID09PSBudWxsID8gc2Vuc29yRXZlbnQuY2xpZW50WSAtIHNvdXJjZVJlY3QudG9wIDogb3B0aW9ucy5jdXJzb3JPZmZzZXRZO1xyXG4gICAgY29uc3QgbGVmdCA9IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WCA9PT0gbnVsbCA/IHNlbnNvckV2ZW50LmNsaWVudFggLSBzb3VyY2VSZWN0LmxlZnQgOiBvcHRpb25zLmN1cnNvck9mZnNldFg7XHJcblxyXG4gICAgY29uc3QgbWlycm9yT2Zmc2V0ID0geyB0b3AsIGxlZnQgfTtcclxuXHJcbiAgICByZXNvbHZlKF9leHRlbmRzKHsgc2Vuc29yRXZlbnQsIHNvdXJjZVJlY3QsIG1pcnJvck9mZnNldCwgb3B0aW9ucyB9LCBhcmdzKSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBcHBseXMgbWlycm9yIHN0eWxlc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUubWlycm9yXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLnNvdXJjZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUub3B0aW9uc1xyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzZXRNaXJyb3IoX3JlZjUpIHtcclxuICBsZXQgeyBtaXJyb3IsIHNvdXJjZSwgb3B0aW9ucyB9ID0gX3JlZjUsXHJcbiAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjUsIFsnbWlycm9yJywgJ3NvdXJjZScsICdvcHRpb25zJ10pO1xyXG5cclxuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBsZXQgb2Zmc2V0SGVpZ2h0O1xyXG4gICAgbGV0IG9mZnNldFdpZHRoO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmNvbnN0cmFpbkRpbWVuc2lvbnMpIHtcclxuICAgICAgY29uc3QgY29tcHV0ZWRTb3VyY2VTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHNvdXJjZSk7XHJcbiAgICAgIG9mZnNldEhlaWdodCA9IGNvbXB1dGVkU291cmNlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpO1xyXG4gICAgICBvZmZzZXRXaWR0aCA9IGNvbXB1dGVkU291cmNlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJyk7XHJcbiAgICB9XHJcblxyXG4gICAgbWlycm9yLnN0eWxlLmRpc3BsYXkgPSBudWxsO1xyXG4gICAgbWlycm9yLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcclxuICAgIG1pcnJvci5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG4gICAgbWlycm9yLnN0eWxlLnRvcCA9IDA7XHJcbiAgICBtaXJyb3Iuc3R5bGUubGVmdCA9IDA7XHJcbiAgICBtaXJyb3Iuc3R5bGUubWFyZ2luID0gMDtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5jb25zdHJhaW5EaW1lbnNpb25zKSB7XHJcbiAgICAgIG1pcnJvci5zdHlsZS5oZWlnaHQgPSBvZmZzZXRIZWlnaHQ7XHJcbiAgICAgIG1pcnJvci5zdHlsZS53aWR0aCA9IG9mZnNldFdpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc29sdmUoX2V4dGVuZHMoeyBtaXJyb3IsIHNvdXJjZSwgb3B0aW9ucyB9LCBhcmdzKSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBcHBseXMgbWlycm9yIGNsYXNzIG9uIG1pcnJvciBlbGVtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5taXJyb3JcclxuICogQHBhcmFtIHtTdHJpbmdbXX0gc3RhdGUubWlycm9yQ2xhc3Nlc1xyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gYWRkTWlycm9yQ2xhc3NlcyhfcmVmNikge1xyXG4gIGxldCB7IG1pcnJvciwgbWlycm9yQ2xhc3NlcyB9ID0gX3JlZjYsXHJcbiAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjYsIFsnbWlycm9yJywgJ21pcnJvckNsYXNzZXMnXSk7XHJcblxyXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIG1pcnJvci5jbGFzc0xpc3QuYWRkKC4uLm1pcnJvckNsYXNzZXMpO1xyXG4gICAgcmVzb2x2ZShfZXh0ZW5kcyh7IG1pcnJvciwgbWlycm9yQ2xhc3NlcyB9LCBhcmdzKSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIHNvdXJjZSBJRCBmcm9tIGNsb25lZCBtaXJyb3IgZWxlbWVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUubWlycm9yXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmVNaXJyb3JJRChfcmVmNykge1xyXG4gIGxldCB7IG1pcnJvciB9ID0gX3JlZjcsXHJcbiAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjcsIFsnbWlycm9yJ10pO1xyXG5cclxuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBtaXJyb3IucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xyXG4gICAgZGVsZXRlIG1pcnJvci5pZDtcclxuICAgIHJlc29sdmUoX2V4dGVuZHMoeyBtaXJyb3IgfSwgYXJncykpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUG9zaXRpb25zIG1pcnJvciB3aXRoIHRyYW5zbGF0ZTNkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5taXJyb3JcclxuICogQHBhcmFtIHtTZW5zb3JFdmVudH0gc3RhdGUuc2Vuc29yRXZlbnRcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlLm1pcnJvck9mZnNldFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdGUuaW5pdGlhbFlcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXRlLmluaXRpYWxYXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZS5vcHRpb25zXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBwb3NpdGlvbk1pcnJvcih7IHdpdGhGcmFtZSA9IGZhbHNlLCBpbml0aWFsID0gZmFsc2UgfSA9IHt9KSB7XHJcbiAgcmV0dXJuIChfcmVmOCkgPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgbWlycm9yLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgbWlycm9yT2Zmc2V0LFxyXG4gICAgICBpbml0aWFsWSxcclxuICAgICAgaW5pdGlhbFgsXHJcbiAgICAgIHNjcm9sbE9mZnNldCxcclxuICAgICAgb3B0aW9ucyxcclxuICAgICAgcGFzc2VkVGhyZXNoWCxcclxuICAgICAgcGFzc2VkVGhyZXNoWSxcclxuICAgICAgbGFzdE1vdmVkWCxcclxuICAgICAgbGFzdE1vdmVkWVxyXG4gICAgfSA9IF9yZWY4LFxyXG4gICAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjgsIFsnbWlycm9yJywgJ3NlbnNvckV2ZW50JywgJ21pcnJvck9mZnNldCcsICdpbml0aWFsWScsICdpbml0aWFsWCcsICdzY3JvbGxPZmZzZXQnLCAnb3B0aW9ucycsICdwYXNzZWRUaHJlc2hYJywgJ3Bhc3NlZFRocmVzaFknLCAnbGFzdE1vdmVkWCcsICdsYXN0TW92ZWRZJ10pO1xyXG5cclxuICAgIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gX2V4dGVuZHMoe1xyXG4gICAgICAgIG1pcnJvcixcclxuICAgICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgICBtaXJyb3JPZmZzZXQsXHJcbiAgICAgICAgb3B0aW9uc1xyXG4gICAgICB9LCBhcmdzKTtcclxuXHJcbiAgICAgIGlmIChtaXJyb3JPZmZzZXQpIHtcclxuICAgICAgICBjb25zdCB4ID0gcGFzc2VkVGhyZXNoWCA/IE1hdGgucm91bmQoKHNlbnNvckV2ZW50LmNsaWVudFggLSBtaXJyb3JPZmZzZXQubGVmdCAtIHNjcm9sbE9mZnNldC54KSAvIChvcHRpb25zLnRocmVzaG9sZFggfHwgMSkpICogKG9wdGlvbnMudGhyZXNob2xkWCB8fCAxKSA6IE1hdGgucm91bmQobGFzdE1vdmVkWCk7XHJcbiAgICAgICAgY29uc3QgeSA9IHBhc3NlZFRocmVzaFkgPyBNYXRoLnJvdW5kKChzZW5zb3JFdmVudC5jbGllbnRZIC0gbWlycm9yT2Zmc2V0LnRvcCAtIHNjcm9sbE9mZnNldC55KSAvIChvcHRpb25zLnRocmVzaG9sZFkgfHwgMSkpICogKG9wdGlvbnMudGhyZXNob2xkWSB8fCAxKSA6IE1hdGgucm91bmQobGFzdE1vdmVkWSk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnhBeGlzICYmIG9wdGlvbnMueUF4aXMgfHwgaW5pdGlhbCkge1xyXG4gICAgICAgICAgbWlycm9yLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7eX1weCwgMClgO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy54QXhpcyAmJiAhb3B0aW9ucy55QXhpcykge1xyXG4gICAgICAgICAgbWlycm9yLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7aW5pdGlhbFl9cHgsIDApYDtcclxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMueUF4aXMgJiYgIW9wdGlvbnMueEF4aXMpIHtcclxuICAgICAgICAgIG1pcnJvci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtpbml0aWFsWH1weCwgJHt5fXB4LCAwKWA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaW5pdGlhbCkge1xyXG4gICAgICAgICAgcmVzdWx0LmluaXRpYWxYID0geDtcclxuICAgICAgICAgIHJlc3VsdC5pbml0aWFsWSA9IHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXN1bHQubGFzdE1vdmVkWCA9IHg7XHJcbiAgICAgICAgcmVzdWx0Lmxhc3RNb3ZlZFkgPSB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICB9LCB7IGZyYW1lOiB3aXRoRnJhbWUgfSk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdyYXBzIGZ1bmN0aW9ucyBpbiBwcm9taXNlIHdpdGggcG90ZW50aWFsIGFuaW1hdGlvbiBmcmFtZSBvcHRpb25cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnJhZlxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gd2l0aFByb21pc2UoY2FsbGJhY2ssIHsgcmFmID0gZmFsc2UgfSA9IHt9KSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGlmIChyYWYpIHtcclxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICBjYWxsYmFjayhyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNlbnNvciBldmVudCB3YXMgdHJpZ2dlcmVkIGJ5IGEgbmF0aXZlIGJyb3dzZXIgZHJhZyBldmVudFxyXG4gKiBAcGFyYW0ge1NlbnNvckV2ZW50fSBzZW5zb3JFdmVudFxyXG4gKi9cclxuZnVuY3Rpb24gaXNOYXRpdmVEcmFnRXZlbnQoc2Vuc29yRXZlbnQpIHtcclxuICByZXR1cm4gKC9eZHJhZy8udGVzdChzZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50LnR5cGUpXHJcbiAgKTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDc5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9NaXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KTtcclxuXHJcbnZhciBfTWlycm9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01pcnJvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX01pcnJvcjIuZGVmYXVsdDtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IF9NaXJyb3IuZGVmYXVsdE9wdGlvbnM7XHJcblxyXG4vKioqLyB9KSxcclxuLyogODAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkluaXRpYWxpemUgPSBTeW1ib2woJ29uSW5pdGlhbGl6ZScpO1xyXG5jb25zdCBvbkRlc3Ryb3kgPSBTeW1ib2woJ29uRGVzdHJveScpO1xyXG5cclxuLyoqXHJcbiAqIEZvY3VzYWJsZSBkZWZhdWx0IG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEZvY3VzYWJsZSBwbHVnaW5cclxuICogQGNsYXNzIEZvY3VzYWJsZVxyXG4gKiBAbW9kdWxlIEZvY3VzYWJsZVxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgRm9jdXNhYmxlIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBGb2N1c2FibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgRm9jdXNhYmxlXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvY3VzYWJsZSBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XHJcblxyXG4gICAgdGhpc1tvbkluaXRpYWxpemVdID0gdGhpc1tvbkluaXRpYWxpemVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRGVzdHJveV0gPSB0aGlzW29uRGVzdHJveV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIGxpc3RlbmVycyB0byBkcmFnZ2FibGVcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZ2dhYmxlOmluaXRpYWxpemUnLCB0aGlzW29uSW5pdGlhbGl6ZV0pLm9uKCdkcmFnZ2FibGU6ZGVzdHJveScsIHRoaXNbb25EZXN0cm95XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBsaXN0ZW5lcnMgZnJvbSBkcmFnZ2FibGVcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWdnYWJsZTppbml0aWFsaXplJywgdGhpc1tvbkluaXRpYWxpemVdKS5vZmYoJ2RyYWdnYWJsZTpkZXN0cm95JywgdGhpc1tvbkRlc3Ryb3ldKTtcclxuXHJcbiAgICAvLyBSZW1vdmUgbW9kaWZpZWQgZWxlbWVudHMgd2hlbiBkZXRhY2hcclxuICAgIHRoaXNbb25EZXN0cm95XSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBvcHRpb25zIHBhc3NlZCB0aHJvdWdoIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuZm9jdXNhYmxlIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBkcmFnZ2FibGUgY29udGFpbmVycyBhbmQgZWxlbWVudHNcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudFtdfVxyXG4gICAqL1xyXG4gIGdldEVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIFsuLi50aGlzLmRyYWdnYWJsZS5jb250YWluZXJzLCAuLi50aGlzLmRyYWdnYWJsZS5nZXREcmFnZ2FibGVFbGVtZW50cygpXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGlhbGl6ZSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25Jbml0aWFsaXplXSgpIHtcclxuICAgIC8vIENhbiB3YWl0IHVudGlsIHRoZSBuZXh0IGJlc3QgZnJhbWUgaXMgYXZhaWxhYmxlXHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB0aGlzLmdldEVsZW1lbnRzKCkuZm9yRWFjaChlbGVtZW50ID0+IGRlY29yYXRlRWxlbWVudChlbGVtZW50KSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRGVzdHJveV0oKSB7XHJcbiAgICAvLyBDYW4gd2FpdCB1bnRpbCB0aGUgbmV4dCBiZXN0IGZyYW1lIGlzIGF2YWlsYWJsZVxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgdGhpcy5nZXRFbGVtZW50cygpLmZvckVhY2goZWxlbWVudCA9PiBzdHJpcEVsZW1lbnQoZWxlbWVudCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBGb2N1c2FibGU7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgbWlzc2luZyB0YWJpbmRleCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc28gdGhleSBjYW4gYmUgcmVzZXQgd2hlbiBkcmFnZ2FibGUgZ2V0cyBkZXN0cm95ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3Qge0hUTUxFbGVtZW50W119IGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuY29uc3QgZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4ID0gW107XHJcblxyXG4vKipcclxuICogRGVjb3JhdGVzIGVsZW1lbnQgd2l0aCB0YWJpbmRleCBhdHRyaWJ1dGVzXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQpIHtcclxuICBjb25zdCBoYXNNaXNzaW5nVGFiSW5kZXggPSBCb29sZWFuKCFlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSAmJiBlbGVtZW50LnRhYkluZGV4ID09PSAtMSk7XHJcblxyXG4gIGlmIChoYXNNaXNzaW5nVGFiSW5kZXgpIHtcclxuICAgIGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleC5wdXNoKGVsZW1lbnQpO1xyXG4gICAgZWxlbWVudC50YWJJbmRleCA9IDA7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBlbGVtZW50cyB0YWJpbmRleCBhdHRyaWJ1dGVzXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHN0cmlwRWxlbWVudChlbGVtZW50KSB7XHJcbiAgY29uc3QgdGFiSW5kZXhFbGVtZW50UG9zaXRpb24gPSBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXguaW5kZXhPZihlbGVtZW50KTtcclxuXHJcbiAgaWYgKHRhYkluZGV4RWxlbWVudFBvc2l0aW9uICE9PSAtMSkge1xyXG4gICAgZWxlbWVudC50YWJJbmRleCA9IC0xO1xyXG4gICAgZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4LnNwbGljZSh0YWJJbmRleEVsZW1lbnRQb3NpdGlvbiwgMSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogODEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0ZvY3VzYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODApO1xyXG5cclxudmFyIF9Gb2N1c2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRm9jdXNhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfRm9jdXNhYmxlMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDgyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Jbml0aWFsaXplID0gU3ltYm9sKCdvbkluaXRpYWxpemUnKTtcclxuY29uc3Qgb25EZXN0cm95ID0gU3ltYm9sKCdvbkRlc3Ryb3knKTtcclxuY29uc3QgYW5ub3VuY2VFdmVudCA9IFN5bWJvbCgnYW5ub3VuY2VFdmVudCcpO1xyXG5jb25zdCBhbm5vdW5jZU1lc3NhZ2UgPSBTeW1ib2woJ2Fubm91bmNlTWVzc2FnZScpO1xyXG5cclxuY29uc3QgQVJJQV9SRUxFVkFOVCA9ICdhcmlhLXJlbGV2YW50JztcclxuY29uc3QgQVJJQV9BVE9NSUMgPSAnYXJpYS1hdG9taWMnO1xyXG5jb25zdCBBUklBX0xJVkUgPSAnYXJpYS1saXZlJztcclxuY29uc3QgUk9MRSA9ICdyb2xlJztcclxuXHJcbi8qKlxyXG4gKiBBbm5vdW5jZW1lbnQgZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMuZXhwaXJlXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgZXhwaXJlOiA3MDAwXHJcbn07XHJcblxyXG4vKipcclxuICogQW5ub3VuY2VtZW50IHBsdWdpblxyXG4gKiBAY2xhc3MgQW5ub3VuY2VtZW50XHJcbiAqIEBtb2R1bGUgQW5ub3VuY2VtZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBBbm5vdW5jZW1lbnQgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIEFubm91bmNlbWVudCBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBBbm5vdW5jZW1lbnRcclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGx1Z2luIG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIHRoaXMuZ2V0T3B0aW9ucygpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9yaWdpbmFsIGRyYWdnYWJsZSB0cmlnZ2VyIG1ldGhvZC4gSGFjayB1bnRpbCB3ZSBoYXZlIG9uQWxsIG9yIG9uKCdhbGwnKVxyXG4gICAgICogQHByb3BlcnR5IG9yaWdpbmFsVHJpZ2dlck1ldGhvZFxyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9yaWdpbmFsVHJpZ2dlck1ldGhvZCA9IHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXI7XHJcblxyXG4gICAgdGhpc1tvbkluaXRpYWxpemVdID0gdGhpc1tvbkluaXRpYWxpemVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRGVzdHJveV0gPSB0aGlzW29uRGVzdHJveV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIGxpc3RlbmVycyB0byBkcmFnZ2FibGVcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZ2dhYmxlOmluaXRpYWxpemUnLCB0aGlzW29uSW5pdGlhbGl6ZV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgbGlzdGVuZXJzIGZyb20gZHJhZ2dhYmxlXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnZ2FibGU6ZGVzdHJveScsIHRoaXNbb25EZXN0cm95XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHBhc3NlZCBpbiBvcHRpb25zXHJcbiAgICovXHJcbiAgZ2V0T3B0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLmFubm91bmNlbWVudHMgfHwge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbm5vdW5jZXMgZXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RFdmVudH0gZXZlbnRcclxuICAgKi9cclxuICBbYW5ub3VuY2VFdmVudF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnNbZXZlbnQudHlwZV07XHJcblxyXG4gICAgaWYgKG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRoaXNbYW5ub3VuY2VNZXNzYWdlXShtZXNzYWdlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzW2Fubm91bmNlTWVzc2FnZV0obWVzc2FnZShldmVudCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW5ub3VuY2VzIG1lc3NhZ2UgdG8gc2NyZWVuIHJlYWRlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcclxuICAgKi9cclxuICBbYW5ub3VuY2VNZXNzYWdlXShtZXNzYWdlKSB7XHJcbiAgICBhbm5vdW5jZShtZXNzYWdlLCB7IGV4cGlyZTogdGhpcy5vcHRpb25zLmV4cGlyZSB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgaGFuZGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25Jbml0aWFsaXplXSgpIHtcclxuICAgIC8vIEhhY2sgdW50aWwgdGhlcmUgaXMgYW4gYXBpIGZvciBsaXN0ZW5pbmcgZm9yIGFsbCBldmVudHNcclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIgPSBldmVudCA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhpc1thbm5vdW5jZUV2ZW50XShldmVudCk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgb3JpZ2luYWwgdHJpZ2dlciBpcyBjYWxsZWRcclxuICAgICAgICB0aGlzLm9yaWdpbmFsVHJpZ2dlck1ldGhvZC5jYWxsKHRoaXMuZHJhZ2dhYmxlLCBldmVudCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IGhhbmRlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRGVzdHJveV0oKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyID0gdGhpcy5vcmlnaW5hbFRyaWdnZXJNZXRob2Q7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBBbm5vdW5jZW1lbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjb25zdCB7SFRNTEVsZW1lbnR9IGxpdmVSZWdpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmNvbnN0IGxpdmVSZWdpb24gPSBjcmVhdGVSZWdpb24oKTtcclxuXHJcbi8qKlxyXG4gKiBBbm5vdW5jZXMgbWVzc2FnZSB2aWEgbGl2ZSByZWdpb25cclxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZXhwaXJlXHJcbiAqL1xyXG5mdW5jdGlvbiBhbm5vdW5jZShtZXNzYWdlLCB7IGV4cGlyZSB9KSB7XHJcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICBlbGVtZW50LnRleHRDb250ZW50ID0gbWVzc2FnZTtcclxuICBsaXZlUmVnaW9uLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG5cclxuICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICBsaXZlUmVnaW9uLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xyXG4gIH0sIGV4cGlyZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIHJlZ2lvbiBlbGVtZW50XHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVnaW9uKCkge1xyXG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2RyYWdnYWJsZS1saXZlLXJlZ2lvbicpO1xyXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKEFSSUFfUkVMRVZBTlQsICdhZGRpdGlvbnMnKTtcclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZShBUklBX0FUT01JQywgJ3RydWUnKTtcclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZShBUklBX0xJVkUsICdhc3NlcnRpdmUnKTtcclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZShST0xFLCAnbG9nJyk7XHJcblxyXG4gIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xyXG4gIGVsZW1lbnQuc3R5bGUud2lkdGggPSAnMXB4JztcclxuICBlbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxcHgnO1xyXG4gIGVsZW1lbnQuc3R5bGUudG9wID0gJy0xcHgnO1xyXG4gIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuXHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn1cclxuXHJcbi8vIEFwcGVuZCBsaXZlIHJlZ2lvbiBlbGVtZW50IGFzIGVhcmx5IGFzIHBvc3NpYmxlXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XHJcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaXZlUmVnaW9uKTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogODMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fubm91bmNlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oODIpO1xyXG5cclxudmFyIF9Bbm5vdW5jZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQW5ub3VuY2VtZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfQW5ub3VuY2VtZW50Mi5kZWZhdWx0O1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gX0Fubm91bmNlbWVudC5kZWZhdWx0T3B0aW9ucztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA4NCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5EcmFnZ2FibGVEZXN0cm95RXZlbnQgPSBleHBvcnRzLkRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQgPSBleHBvcnRzLkRyYWdnYWJsZUV2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKipcclxuICogQmFzZSBkcmFnZ2FibGUgZXZlbnRcclxuICogQGNsYXNzIERyYWdnYWJsZUV2ZW50XHJcbiAqIEBtb2R1bGUgRHJhZ2dhYmxlRXZlbnRcclxuICogQGV4dGVuZHMgQWJzdHJhY3RFdmVudFxyXG4gKi9cclxuY2xhc3MgRHJhZ2dhYmxlRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqIEBwcm9wZXJ0eSBkcmFnZ2FibGVcclxuICAgKiBAdHlwZSB7RHJhZ2dhYmxlfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkcmFnZ2FibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdnYWJsZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ2dhYmxlRXZlbnQgPSBEcmFnZ2FibGVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZ2dhYmxlIGluaXRpYWxpemVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnZ2FibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ2dhYmxlRXZlbnQudHlwZSA9ICdkcmFnZ2FibGUnO1xyXG5jbGFzcyBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50IGV4dGVuZHMgRHJhZ2dhYmxlRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCA9IERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnZ2FibGUgZGVzdG9yeSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdnYWJsZURlc3Ryb3lFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnZ2FibGVEZXN0cm95RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50LnR5cGUgPSAnZHJhZ2dhYmxlOmluaXRpYWxpemUnO1xyXG5jbGFzcyBEcmFnZ2FibGVEZXN0cm95RXZlbnQgZXh0ZW5kcyBEcmFnZ2FibGVFdmVudCB7fVxyXG5leHBvcnRzLkRyYWdnYWJsZURlc3Ryb3lFdmVudCA9IERyYWdnYWJsZURlc3Ryb3lFdmVudDtcclxuRHJhZ2dhYmxlRGVzdHJveUV2ZW50LnR5cGUgPSAnZHJhZ2dhYmxlOmRlc3Ryb3knO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDg1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkRyYWdTdG9wcGVkRXZlbnQgPSBleHBvcnRzLkRyYWdTdG9wRXZlbnQgPSBleHBvcnRzLkRyYWdQcmVzc3VyZUV2ZW50ID0gZXhwb3J0cy5EcmFnT3V0Q29udGFpbmVyRXZlbnQgPSBleHBvcnRzLkRyYWdPdmVyQ29udGFpbmVyRXZlbnQgPSBleHBvcnRzLkRyYWdPdXRFdmVudCA9IGV4cG9ydHMuRHJhZ092ZXJFdmVudCA9IGV4cG9ydHMuRHJhZ01vdmVFdmVudCA9IGV4cG9ydHMuRHJhZ1N0YXJ0RXZlbnQgPSBleHBvcnRzLkRyYWdFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgZHJhZyBldmVudFxyXG4gKiBAY2xhc3MgRHJhZ0V2ZW50XHJcbiAqIEBtb2R1bGUgRHJhZ0V2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIERyYWdFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBzb3VyY2UgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBzb3VyY2VcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNvdXJjZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBvcmlnaW5hbCBzb3VyY2UgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbFNvdXJjZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3JpZ2luYWxTb3VyY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9yaWdpbmFsU291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBtaXJyb3IgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG1pcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBzb3VyY2UgY29udGFpbmVyIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgc291cmNlQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzb3VyY2VDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZUNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbnNvciBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBzZW5zb3JFdmVudFxyXG4gICAqIEB0eXBlIHtTZW5zb3JFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc2Vuc29yRXZlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNlbnNvckV2ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgc2Vuc29yIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IG9yaWdpbmFsRXZlbnRcclxuICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9yaWdpbmFsRXZlbnQoKSB7XHJcbiAgICBpZiAodGhpcy5zZW5zb3JFdmVudCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnRXZlbnQgPSBEcmFnRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdGFydCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdTdGFydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdTdGFydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ0V2ZW50LnR5cGUgPSAnZHJhZyc7XHJcbmNsYXNzIERyYWdTdGFydEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdTdGFydEV2ZW50ID0gRHJhZ1N0YXJ0RXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgbW92ZSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnTW92ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnTW92ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnU3RhcnRFdmVudC50eXBlID0gJ2RyYWc6c3RhcnQnO1xyXG5EcmFnU3RhcnRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgRHJhZ01vdmVFdmVudCBleHRlbmRzIERyYWdFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5EcmFnTW92ZUV2ZW50ID0gRHJhZ01vdmVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgb3ZlciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ092ZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdPdmVyRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ01vdmVFdmVudC50eXBlID0gJ2RyYWc6bW92ZSc7XHJcbmNsYXNzIERyYWdPdmVyRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIHlvdSBhcmUgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGVsZW1lbnQgeW91IGFyZSBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXI7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdPdmVyRXZlbnQgPSBEcmFnT3ZlckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBvdXQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdPdXRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdPdXRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnT3ZlckV2ZW50LnR5cGUgPSAnZHJhZzpvdmVyJztcclxuRHJhZ092ZXJFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgRHJhZ091dEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciB5b3UgYXJlIG92ZXJcclxuICAgKiBAcHJvcGVydHkgb3ZlckNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBlbGVtZW50IHlvdSBsZWZ0XHJcbiAgICogQHByb3BlcnR5IG92ZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXI7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdPdXRFdmVudCA9IERyYWdPdXRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG92ZXIgY29udGFpbmVyIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ092ZXJDb250YWluZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnT3ZlckNvbnRhaW5lckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ091dEV2ZW50LnR5cGUgPSAnZHJhZzpvdXQnO1xyXG5jbGFzcyBEcmFnT3ZlckNvbnRhaW5lckV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciB5b3UgYXJlIG92ZXJcclxuICAgKiBAcHJvcGVydHkgb3ZlckNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ092ZXJDb250YWluZXJFdmVudCA9IERyYWdPdmVyQ29udGFpbmVyRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG91dCBjb250YWluZXIgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdPdXRDb250YWluZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdPdXRDb250YWluZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnT3ZlckNvbnRhaW5lckV2ZW50LnR5cGUgPSAnZHJhZzpvdmVyOmNvbnRhaW5lcic7XHJcbmNsYXNzIERyYWdPdXRDb250YWluZXJFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBjb250YWluZXIgeW91IGxlZnRcclxuICAgKiBAcHJvcGVydHkgb3ZlckNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ091dENvbnRhaW5lckV2ZW50ID0gRHJhZ091dENvbnRhaW5lckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgcHJlc3N1cmUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnUHJlc3N1cmVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnUHJlc3N1cmVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdPdXRDb250YWluZXJFdmVudC50eXBlID0gJ2RyYWc6b3V0OmNvbnRhaW5lcic7XHJcbmNsYXNzIERyYWdQcmVzc3VyZUV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogUHJlc3N1cmUgYXBwbGllZCBvbiBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBwcmVzc3VyZVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHByZXNzdXJlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wcmVzc3VyZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ1ByZXNzdXJlRXZlbnQgPSBEcmFnUHJlc3N1cmVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdG9wIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdQcmVzc3VyZUV2ZW50LnR5cGUgPSAnZHJhZzpwcmVzc3VyZSc7XHJcbmNsYXNzIERyYWdTdG9wRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ1N0b3BFdmVudCA9IERyYWdTdG9wRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHN0b3BwZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdTdG9wcGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnU3RvcHBlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdTdG9wRXZlbnQudHlwZSA9ICdkcmFnOnN0b3AnO1xyXG5jbGFzcyBEcmFnU3RvcHBlZEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XHJcbmV4cG9ydHMuRHJhZ1N0b3BwZWRFdmVudCA9IERyYWdTdG9wcGVkRXZlbnQ7XHJcbkRyYWdTdG9wcGVkRXZlbnQudHlwZSA9ICdkcmFnOnN0b3BwZWQnO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDg2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Tb3J0YWJsZVNvcnRlZCA9IFN5bWJvbCgnb25Tb3J0YWJsZVNvcnRlZCcpO1xyXG5jb25zdCBvblNvcnRhYmxlU29ydCA9IFN5bWJvbCgnb25Tb3J0YWJsZVNvcnQnKTtcclxuXHJcbi8qKlxyXG4gKiBTb3J0QW5pbWF0aW9uIGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLmR1cmF0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZWZhdWx0T3B0aW9ucy5lYXNpbmdGdW5jdGlvblxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xyXG4gIGR1cmF0aW9uOiAxNTAsXHJcbiAgZWFzaW5nRnVuY3Rpb246ICdlYXNlLWluLW91dCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTb3J0QW5pbWF0aW9uIHBsdWdpbiBhZGRzIHNvcnQgYW5pbWF0aW9uIGZvciBzb3J0YWJsZVxyXG4gKiBAY2xhc3MgU29ydEFuaW1hdGlvblxyXG4gKiBAbW9kdWxlIFNvcnRBbmltYXRpb25cclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIFNvcnRBbmltYXRpb24gZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIFNvcnRBbmltYXRpb24gY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgU29ydEFuaW1hdGlvblxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3J0QW5pbWF0aW9uIG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMuZHVyYXRpb25cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZWZhdWx0T3B0aW9ucy5lYXNpbmdGdW5jdGlvblxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMYXN0IGFuaW1hdGlvbiBmcmFtZVxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxhc3RBbmltYXRpb25GcmFtZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUgPSBudWxsO1xyXG4gICAgdGhpcy5sYXN0RWxlbWVudHMgPSBbXTtcclxuXHJcbiAgICB0aGlzW29uU29ydGFibGVTb3J0ZWRdID0gdGhpc1tvblNvcnRhYmxlU29ydGVkXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvblNvcnRhYmxlU29ydF0gPSB0aGlzW29uU29ydGFibGVTb3J0XS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignc29ydGFibGU6c29ydCcsIHRoaXNbb25Tb3J0YWJsZVNvcnRdKTtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdzb3J0YWJsZTpzb3J0ZWQnLCB0aGlzW29uU29ydGFibGVTb3J0ZWRdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdzb3J0YWJsZTpzb3J0JywgdGhpc1tvblNvcnRhYmxlU29ydF0pO1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdzb3J0YWJsZTpzb3J0ZWQnLCB0aGlzW29uU29ydGFibGVTb3J0ZWRdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgb3B0aW9ucyBwYXNzZWQgdGhyb3VnaCBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXHJcbiAgZ2V0T3B0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLnNvcnRBbmltYXRpb24gfHwge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTb3J0YWJsZSBzb3J0IGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge1NvcnRhYmxlU29ydEV2ZW50fSBzb3J0YWJsZUV2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25Tb3J0YWJsZVNvcnRdKHsgZHJhZ0V2ZW50IH0pIHtcclxuICAgIGNvbnN0IHsgc291cmNlQ29udGFpbmVyIH0gPSBkcmFnRXZlbnQ7XHJcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKHNvdXJjZUNvbnRhaW5lcik7XHJcbiAgICB0aGlzLmxhc3RFbGVtZW50cyA9IEFycmF5LmZyb20oZWxlbWVudHMpLm1hcChlbCA9PiB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZG9tRWw6IGVsLFxyXG4gICAgICAgIG9mZnNldFRvcDogZWwub2Zmc2V0VG9wLFxyXG4gICAgICAgIG9mZnNldExlZnQ6IGVsLm9mZnNldExlZnRcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU29ydGFibGUgc29ydGVkIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge1NvcnRhYmxlU29ydGVkRXZlbnR9IHNvcnRhYmxlRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvblNvcnRhYmxlU29ydGVkXSh7IG9sZEluZGV4LCBuZXdJbmRleCB9KSB7XHJcbiAgICBpZiAob2xkSW5kZXggPT09IG5ld0luZGV4KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBlZmZlY3RlZEVsZW1lbnRzID0gW107XHJcbiAgICBsZXQgc3RhcnQ7XHJcbiAgICBsZXQgZW5kO1xyXG4gICAgbGV0IG51bTtcclxuICAgIGlmIChvbGRJbmRleCA+IG5ld0luZGV4KSB7XHJcbiAgICAgIHN0YXJ0ID0gbmV3SW5kZXg7XHJcbiAgICAgIGVuZCA9IG9sZEluZGV4IC0gMTtcclxuICAgICAgbnVtID0gMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXJ0ID0gb2xkSW5kZXggKyAxO1xyXG4gICAgICBlbmQgPSBuZXdJbmRleDtcclxuICAgICAgbnVtID0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmxhc3RFbGVtZW50c1tpXTtcclxuICAgICAgY29uc3QgdG8gPSB0aGlzLmxhc3RFbGVtZW50c1tpICsgbnVtXTtcclxuICAgICAgZWZmZWN0ZWRFbGVtZW50cy5wdXNoKHsgZnJvbSwgdG8gfSk7XHJcbiAgICB9XHJcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmxhc3RBbmltYXRpb25GcmFtZSk7XHJcblxyXG4gICAgLy8gQ2FuIGJlIGRvbmUgaW4gYSBzZXBhcmF0ZSBmcmFtZVxyXG4gICAgdGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICBlZmZlY3RlZEVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiBhbmltYXRlKGVsZW1lbnQsIHRoaXMub3B0aW9ucykpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBTb3J0QW5pbWF0aW9uOyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQW5pbWF0ZXMgdHdvIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50LmZyb21cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQudG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZWFzaW5nRnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5mdW5jdGlvbiBhbmltYXRlKHsgZnJvbSwgdG8gfSwgeyBkdXJhdGlvbiwgZWFzaW5nRnVuY3Rpb24gfSkge1xyXG4gIGNvbnN0IGRvbUVsID0gZnJvbS5kb21FbDtcclxuICBjb25zdCB4ID0gZnJvbS5vZmZzZXRMZWZ0IC0gdG8ub2Zmc2V0TGVmdDtcclxuICBjb25zdCB5ID0gZnJvbS5vZmZzZXRUb3AgLSB0by5vZmZzZXRUb3A7XHJcblxyXG4gIGRvbUVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcbiAgZG9tRWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7eH1weCwgJHt5fXB4LCAwKWA7XHJcblxyXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICBkb21FbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgcmVzZXRFbGVtZW50T25UcmFuc2l0aW9uRW5kKTtcclxuICAgIGRvbUVsLnN0eWxlLnRyYW5zaXRpb24gPSBgdHJhbnNmb3JtICR7ZHVyYXRpb259bXMgJHtlYXNpbmdGdW5jdGlvbn1gO1xyXG4gICAgZG9tRWwuc3R5bGUudHJhbnNmb3JtID0gJyc7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXNldHMgYW5pbWF0aW9uIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgYW5pbWF0aW9uIGhhcyBjb21wbGV0ZWRcclxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZChldmVudCkge1xyXG4gIGV2ZW50LnRhcmdldC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XHJcbiAgZXZlbnQudGFyZ2V0LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcclxuICBldmVudC50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZCk7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA4NyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfU29ydEFuaW1hdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oODYpO1xyXG5cclxudmFyIF9Tb3J0QW5pbWF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NvcnRBbmltYXRpb24pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Tb3J0QW5pbWF0aW9uMi5kZWZhdWx0O1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gX1NvcnRBbmltYXRpb24uZGVmYXVsdE9wdGlvbnM7XHJcblxyXG4vKioqLyB9KSxcclxuLyogODggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvblNvcnRhYmxlU29ydGVkID0gU3ltYm9sKCdvblNvcnRhYmxlU29ydGVkJyk7XHJcblxyXG4vKipcclxuICogU3dhcEFuaW1hdGlvbiBkZWZhdWx0IG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWZhdWx0T3B0aW9ucy5kdXJhdGlvblxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGVmYXVsdE9wdGlvbnMuZWFzaW5nRnVuY3Rpb25cclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkZWZhdWx0T3B0aW9ucy5ob3Jpem9udGFsXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgZHVyYXRpb246IDE1MCxcclxuICBlYXNpbmdGdW5jdGlvbjogJ2Vhc2UtaW4tb3V0JyxcclxuICBob3Jpem9udGFsOiBmYWxzZVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN3YXBBbmltYXRpb24gcGx1Z2luIGFkZHMgc3dhcCBhbmltYXRpb25zIGZvciBzb3J0YWJsZVxyXG4gKiBAY2xhc3MgU3dhcEFuaW1hdGlvblxyXG4gKiBAbW9kdWxlIFN3YXBBbmltYXRpb25cclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIFN3YXBBbmltYXRpb24gZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIFN3YXBBbmltYXRpb24gY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgU3dhcEFuaW1hdGlvblxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTd2FwQW5pbWF0aW9uIG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMuZHVyYXRpb25cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZWZhdWx0T3B0aW9ucy5lYXNpbmdGdW5jdGlvblxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMYXN0IGFuaW1hdGlvbiBmcmFtZVxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxhc3RBbmltYXRpb25GcmFtZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25Tb3J0YWJsZVNvcnRlZF0gPSB0aGlzW29uU29ydGFibGVTb3J0ZWRdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdzb3J0YWJsZTpzb3J0ZWQnLCB0aGlzW29uU29ydGFibGVTb3J0ZWRdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdzb3J0YWJsZTpzb3J0ZWQnLCB0aGlzW29uU29ydGFibGVTb3J0ZWRdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgb3B0aW9ucyBwYXNzZWQgdGhyb3VnaCBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXHJcbiAgZ2V0T3B0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLnN3YXBBbmltYXRpb24gfHwge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTb3J0YWJsZSBzb3J0ZWQgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7U29ydGFibGVTb3J0ZWRFdmVudH0gc29ydGFibGVFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uU29ydGFibGVTb3J0ZWRdKHsgb2xkSW5kZXgsIG5ld0luZGV4LCBkcmFnRXZlbnQgfSkge1xyXG4gICAgY29uc3QgeyBzb3VyY2UsIG92ZXIgfSA9IGRyYWdFdmVudDtcclxuXHJcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmxhc3RBbmltYXRpb25GcmFtZSk7XHJcblxyXG4gICAgLy8gQ2FuIGJlIGRvbmUgaW4gYSBzZXBhcmF0ZSBmcmFtZVxyXG4gICAgdGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICBpZiAob2xkSW5kZXggPj0gbmV3SW5kZXgpIHtcclxuICAgICAgICBhbmltYXRlKHNvdXJjZSwgb3ZlciwgdGhpcy5vcHRpb25zKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhbmltYXRlKG92ZXIsIHNvdXJjZSwgdGhpcy5vcHRpb25zKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBTd2FwQW5pbWF0aW9uOyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQW5pbWF0ZXMgdHdvIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGZyb21cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZWFzaW5nRnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmZ1bmN0aW9uIGFuaW1hdGUoZnJvbSwgdG8sIHsgZHVyYXRpb24sIGVhc2luZ0Z1bmN0aW9uLCBob3Jpem9udGFsIH0pIHtcclxuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgW2Zyb20sIHRvXSkge1xyXG4gICAgZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG4gIH1cclxuXHJcbiAgaWYgKGhvcml6b250YWwpIHtcclxuICAgIGNvbnN0IHdpZHRoID0gZnJvbS5vZmZzZXRXaWR0aDtcclxuICAgIGZyb20uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7d2lkdGh9cHgsIDAsIDApYDtcclxuICAgIHRvLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgtJHt3aWR0aH1weCwgMCwgMClgO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBoZWlnaHQgPSBmcm9tLm9mZnNldEhlaWdodDtcclxuICAgIGZyb20uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDAsICR7aGVpZ2h0fXB4LCAwKWA7XHJcbiAgICB0by5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoMCwgLSR7aGVpZ2h0fXB4LCAwKWA7XHJcbiAgfVxyXG5cclxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtmcm9tLCB0b10pIHtcclxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgcmVzZXRFbGVtZW50T25UcmFuc2l0aW9uRW5kKTtcclxuICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uID0gYHRyYW5zZm9ybSAke2R1cmF0aW9ufW1zICR7ZWFzaW5nRnVuY3Rpb259YDtcclxuICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlc2V0cyBhbmltYXRpb24gc3R5bGUgcHJvcGVydGllcyBhZnRlciBhbmltYXRpb24gaGFzIGNvbXBsZXRlZFxyXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzZXRFbGVtZW50T25UcmFuc2l0aW9uRW5kKGV2ZW50KSB7XHJcbiAgZXZlbnQudGFyZ2V0LnN0eWxlLnRyYW5zaXRpb24gPSAnJztcclxuICBldmVudC50YXJnZXQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xyXG4gIGV2ZW50LnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgcmVzZXRFbGVtZW50T25UcmFuc2l0aW9uRW5kKTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDg5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9Td2FwQW5pbWF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OCk7XHJcblxyXG52YXIgX1N3YXBBbmltYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3dhcEFuaW1hdGlvbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX1N3YXBBbmltYXRpb24yLmRlZmF1bHQ7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfU3dhcEFuaW1hdGlvbi5kZWZhdWx0T3B0aW9ucztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA5MCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG52YXIgX1NuYXBwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xyXG5jb25zdCBvbkRyYWdPdXQgPSBTeW1ib2woJ29uRHJhZ091dCcpO1xyXG5jb25zdCBvbk1pcnJvckNyZWF0ZWQgPSBTeW1ib2woJ29uTWlycm9yQ3JlYXRlZCcpO1xyXG5jb25zdCBvbk1pcnJvckRlc3Ryb3kgPSBTeW1ib2woJ29uTWlycm9yRGVzdHJveScpO1xyXG5cclxuLyoqXHJcbiAqIFNuYXBwYWJsZSBwbHVnaW4gd2hpY2ggc25hcHMgZHJhZ2dhYmxlIGVsZW1lbnRzIGludG8gcGxhY2VcclxuICogQGNsYXNzIFNuYXBwYWJsZVxyXG4gKiBAbW9kdWxlIFNuYXBwYWJsZVxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgU25hcHBhYmxlIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBTbmFwcGFibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgU25hcHBhYmxlXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBmaXJzdCBzb3VyY2UgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxudWxsfSBmaXJzdFNvdXJjZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpcnN0U291cmNlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBtaXJyb3IgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gbWlycm9yXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWlycm9yID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnT3V0XSA9IHRoaXNbb25EcmFnT3V0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1pcnJvckNyZWF0ZWRdID0gdGhpc1tvbk1pcnJvckNyZWF0ZWRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTWlycm9yRGVzdHJveV0gPSB0aGlzW29uTWlycm9yRGVzdHJveV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9uKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vbignZHJhZzpvdXQnLCB0aGlzW29uRHJhZ091dF0pLm9uKCdkcm9wcGFibGU6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcm9wcGFibGU6b3V0JywgdGhpc1tvbkRyYWdPdXRdKS5vbignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9uKCdtaXJyb3I6ZGVzdHJveScsIHRoaXNbb25NaXJyb3JEZXN0cm95XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9mZignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub2ZmKCdkcmFnOm91dCcsIHRoaXNbb25EcmFnT3V0XSkub2ZmKCdkcm9wcGFibGU6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9mZignZHJvcHBhYmxlOm91dCcsIHRoaXNbb25EcmFnT3V0XSkub2ZmKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub2ZmKCdtaXJyb3I6ZGVzdHJveScsIHRoaXNbb25NaXJyb3JEZXN0cm95XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0YXJ0RXZlbnR9IGV2ZW50IC0gRHJhZyBzdGFydCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcclxuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmZpcnN0U291cmNlID0gZXZlbnQuc291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdG9wIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0b3BFdmVudH0gZXZlbnQgLSBEcmFnIHN0b3AgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RvcF0oKSB7XHJcbiAgICB0aGlzLmZpcnN0U291cmNlID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgb3ZlciBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyRXZlbnR8RHJvcHBhYmxlT3ZlckV2ZW50fSBldmVudCAtIERyYWcgb3ZlciBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdmVyXShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNvdXJjZSA9IGV2ZW50LnNvdXJjZSB8fCBldmVudC5kcmFnRXZlbnQuc291cmNlO1xyXG5cclxuICAgIGlmIChzb3VyY2UgPT09IHRoaXMuZmlyc3RTb3VyY2UpIHtcclxuICAgICAgdGhpcy5maXJzdFNvdXJjZSA9IG51bGw7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzbmFwSW5FdmVudCA9IG5ldyBfU25hcHBhYmxlRXZlbnQuU25hcEluRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBzbmFwcGFibGU6IGV2ZW50Lm92ZXIgfHwgZXZlbnQuZHJvcHBhYmxlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKHNuYXBJbkV2ZW50KTtcclxuXHJcbiAgICBpZiAoc25hcEluRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubWlycm9yKSB7XHJcbiAgICAgIHRoaXMubWlycm9yLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICB9XHJcblxyXG4gICAgc291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOmRyYWdnaW5nJykpO1xyXG4gICAgc291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcclxuXHJcbiAgICAvLyBOZWVkIHRvIGNhbmNlbCB0aGlzIGluIGRyYWcgb3V0XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgc291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcclxuICAgIH0sIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMucGxhY2VkVGltZW91dCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG91dCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdPdXRFdmVudHxEcm9wcGFibGVPdXRFdmVudH0gZXZlbnQgLSBEcmFnIG91dCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdXRdKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc291cmNlID0gZXZlbnQuc291cmNlIHx8IGV2ZW50LmRyYWdFdmVudC5zb3VyY2U7XHJcblxyXG4gICAgY29uc3Qgc25hcE91dEV2ZW50ID0gbmV3IF9TbmFwcGFibGVFdmVudC5TbmFwT3V0RXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBzbmFwcGFibGU6IGV2ZW50Lm92ZXIgfHwgZXZlbnQuZHJvcHBhYmxlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKHNuYXBPdXRFdmVudCk7XHJcblxyXG4gICAgaWYgKHNuYXBPdXRFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5taXJyb3IpIHtcclxuICAgICAgdGhpcy5taXJyb3Iuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHNvdXJjZS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZHJhZ2dhYmxlLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpkcmFnZ2luZycpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1pcnJvciBjcmVhdGVkIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge01pcnJvckNyZWF0ZWRFdmVudH0gbWlycm9yRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbk1pcnJvckNyZWF0ZWRdKHsgbWlycm9yIH0pIHtcclxuICAgIHRoaXMubWlycm9yID0gbWlycm9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlycm9yIGRlc3Ryb3kgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7TWlycm9yRGVzdHJveUV2ZW50fSBtaXJyb3JFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uTWlycm9yRGVzdHJveV0oKSB7XHJcbiAgICB0aGlzLm1pcnJvciA9IG51bGw7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNuYXBwYWJsZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA5MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5TbmFwT3V0RXZlbnQgPSBleHBvcnRzLlNuYXBJbkV2ZW50ID0gZXhwb3J0cy5TbmFwRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIHNuYXAgZXZlbnRcclxuICogQGNsYXNzIFNuYXBFdmVudFxyXG4gKiBAbW9kdWxlIFNuYXBFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBTbmFwRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBzbmFwIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IGRyYWdFdmVudFxyXG4gICAqIEB0eXBlIHtEcmFnRXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyYWdFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU25hcHBhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgc25hcHBhYmxlXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzbmFwcGFibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNuYXBwYWJsZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuU25hcEV2ZW50ID0gU25hcEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNuYXAgaW4gZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTbmFwSW5FdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBTbmFwSW5FdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU25hcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblNuYXBFdmVudC50eXBlID0gJ3NuYXAnO1xyXG5jbGFzcyBTbmFwSW5FdmVudCBleHRlbmRzIFNuYXBFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5TbmFwSW5FdmVudCA9IFNuYXBJbkV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTbmFwIG91dCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTbmFwT3V0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNuYXBPdXRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNuYXBFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuU25hcEluRXZlbnQudHlwZSA9ICdzbmFwOmluJztcclxuU25hcEluRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIFNuYXBPdXRFdmVudCBleHRlbmRzIFNuYXBFdmVudCB7fVxyXG5leHBvcnRzLlNuYXBPdXRFdmVudCA9IFNuYXBPdXRFdmVudDtcclxuU25hcE91dEV2ZW50LnR5cGUgPSAnc25hcDpvdXQnO1xyXG5TbmFwT3V0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcblxyXG4vKioqLyB9KSxcclxuLyogOTIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NuYXBwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XHJcblxyXG5PYmplY3Qua2V5cyhfU25hcHBhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfU25hcHBhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX1NuYXBwYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTApO1xyXG5cclxudmFyIF9TbmFwcGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU25hcHBhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfU25hcHBhYmxlMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDkzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbk1pcnJvckNyZWF0ZWQgPSBTeW1ib2woJ29uTWlycm9yQ3JlYXRlZCcpO1xyXG5jb25zdCBvbk1pcnJvckRlc3Ryb3kgPSBTeW1ib2woJ29uTWlycm9yRGVzdHJveScpO1xyXG5jb25zdCBvbkRyYWdPdmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyJyk7XHJcbmNvbnN0IHJlc2l6ZSA9IFN5bWJvbCgncmVzaXplJyk7XHJcblxyXG4vKipcclxuICogUmVzaXplTWlycm9yIGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBSZXNpemVNaXJyb3IgcGx1Z2luIHJlc2l6ZXMgdGhlIG1pcnJvciBlbGVtZW50IHRvIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBkcmFnZ2FibGUgZWxlbWVudCB0aGF0IHRoZSBtaXJyb3IgaXMgaG92ZXJpbmcgb3ZlclxyXG4gKiBAY2xhc3MgUmVzaXplTWlycm9yXHJcbiAqIEBtb2R1bGUgUmVzaXplTWlycm9yXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBSZXNpemVNaXJyb3IgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIFJlc2l6ZU1pcnJvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBSZXNpemVNaXJyb3JcclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplTWlycm9yIG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIHRoaXMuZ2V0T3B0aW9ucygpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZU1pcnJvciByZW1lbWJlcnMgdGhlIGxhc3Qgd2lkdGggd2hlbiByZXNpemluZyB0aGUgbWlycm9yXHJcbiAgICAgKiB0byBhdm9pZCBhZGRpdGlvbmFsIHdyaXRlcyB0byB0aGUgRE9NXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbGFzdFdpZHRoXHJcbiAgICAgKi9cclxuICAgIHRoaXMubGFzdFdpZHRoID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZU1pcnJvciByZW1lbWJlcnMgdGhlIGxhc3QgaGVpZ2h0IHdoZW4gcmVzaXppbmcgdGhlIG1pcnJvclxyXG4gICAgICogdG8gYXZvaWQgYWRkaXRpb25hbCB3cml0ZXMgdG8gdGhlIERPTVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxhc3RIZWlnaHRcclxuICAgICAqL1xyXG4gICAgdGhpcy5sYXN0SGVpZ2h0ID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBtaXJyb3IgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gbWlycm9yXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWlycm9yID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uTWlycm9yQ3JlYXRlZF0gPSB0aGlzW29uTWlycm9yQ3JlYXRlZF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25NaXJyb3JEZXN0cm95XSA9IHRoaXNbb25NaXJyb3JEZXN0cm95XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ21pcnJvcjpjcmVhdGVkJywgdGhpc1tvbk1pcnJvckNyZWF0ZWRdKS5vbignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub24oJ2RyYWc6b3Zlcjpjb250YWluZXInLCB0aGlzW29uRHJhZ092ZXJdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub2ZmKCdtaXJyb3I6ZGVzdHJveScsIHRoaXNbb25NaXJyb3JEZXN0cm95XSkub2ZmKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vZmYoJ2RyYWc6b3Zlcjpjb250YWluZXInLCB0aGlzW29uRHJhZ092ZXJdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgb3B0aW9ucyBwYXNzZWQgdGhyb3VnaCBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXHJcbiAgZ2V0T3B0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLnJlc2l6ZU1pcnJvciB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1pcnJvciBjcmVhdGVkIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge01pcnJvckNyZWF0ZWRFdmVudH0gbWlycm9yRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbk1pcnJvckNyZWF0ZWRdKHsgbWlycm9yIH0pIHtcclxuICAgIHRoaXMubWlycm9yID0gbWlycm9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlycm9yIGRlc3Ryb3kgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7TWlycm9yRGVzdHJveUV2ZW50fSBtaXJyb3JFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uTWlycm9yRGVzdHJveV0oKSB7XHJcbiAgICB0aGlzLm1pcnJvciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG92ZXIgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7RHJhZ092ZXJFdmVudCB8IERyYWdPdmVyQ29udGFpbmVyfSBkcmFnRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdmVyXShkcmFnRXZlbnQpIHtcclxuICAgIHRoaXNbcmVzaXplXShkcmFnRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzaXplIGZ1bmN0aW9uIGZvclxyXG4gICAqIEBwYXJhbSB7RHJhZ092ZXJFdmVudCB8IERyYWdPdmVyQ29udGFpbmVyfSBkcmFnRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtyZXNpemVdKHsgb3ZlckNvbnRhaW5lciwgb3ZlciB9KSB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMubWlycm9yLnBhcmVudE5vZGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLm1pcnJvci5wYXJlbnROb2RlICE9PSBvdmVyQ29udGFpbmVyKSB7XHJcbiAgICAgICAgb3ZlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1pcnJvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG92ZXJFbGVtZW50ID0gb3ZlciB8fCB0aGlzLmRyYWdnYWJsZS5nZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihvdmVyQ29udGFpbmVyKVswXTtcclxuXHJcbiAgICAgIGlmICghb3ZlckVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICgwLCBfdXRpbHMucmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSkoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG92ZXJSZWN0ID0gb3ZlckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxhc3RIZWlnaHQgPT09IG92ZXJSZWN0LmhlaWdodCAmJiB0aGlzLmxhc3RXaWR0aCA9PT0gb3ZlclJlY3Qud2lkdGgpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubWlycm9yLnN0eWxlLndpZHRoID0gYCR7b3ZlclJlY3Qud2lkdGh9cHhgO1xyXG4gICAgICAgIHRoaXMubWlycm9yLnN0eWxlLmhlaWdodCA9IGAke292ZXJSZWN0LmhlaWdodH1weGA7XHJcblxyXG4gICAgICAgIHRoaXMubGFzdFdpZHRoID0gb3ZlclJlY3Qud2lkdGg7XHJcbiAgICAgICAgdGhpcy5sYXN0SGVpZ2h0ID0gb3ZlclJlY3QuaGVpZ2h0O1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBSZXNpemVNaXJyb3I7XHJcblxyXG4vKioqLyB9KSxcclxuLyogOTQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX1Jlc2l6ZU1pcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oOTMpO1xyXG5cclxudmFyIF9SZXNpemVNaXJyb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVzaXplTWlycm9yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfUmVzaXplTWlycm9yMi5kZWZhdWx0O1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gX1Jlc2l6ZU1pcnJvci5kZWZhdWx0T3B0aW9ucztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA5NSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcbnZhciBfQ29sbGlkYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xyXG5jb25zdCBvbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XHJcbmNvbnN0IG9uUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gU3ltYm9sKCdvblJlcXVlc3RBbmltYXRpb25GcmFtZScpO1xyXG5cclxuLyoqXHJcbiAqIENvbGxpZGFibGUgcGx1Z2luIHdoaWNoIGRldGVjdHMgY29sbGlkaW5nIGVsZW1lbnRzIHdoaWxlIGRyYWdnaW5nXHJcbiAqIEBjbGFzcyBDb2xsaWRhYmxlXHJcbiAqIEBtb2R1bGUgQ29sbGlkYWJsZVxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgQ29sbGlkYWJsZSBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogQ29sbGlkYWJsZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBDb2xsaWRhYmxlXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtlZXBzIHRyYWNrIG9mIGN1cnJlbnRseSBjb2xsaWRpbmcgZWxlbWVudHNcclxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8bnVsbH0gY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZWVwcyB0cmFjayBvZiBjdXJyZW50bHkgY29sbGlkaW5nIGVsZW1lbnRzXHJcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fG51bGx9IGxhc3RDb2xsaWRpbmdFbGVtZW50XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbmltYXRpb24gZnJhbWUgZm9yIGZpbmRpbmcgY29sbGlkaW5nIGVsZW1lbnRzXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxudWxsfSBjdXJyZW50QW5pbWF0aW9uRnJhbWVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25EcmFnTW92ZV0gPSB0aGlzW29uRHJhZ01vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvblJlcXVlc3RBbmltYXRpb25GcmFtZV0gPSB0aGlzW29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGN1cnJlbnQgY29sbGlkYWJsZXMgYmFzZWQgb24gYGNvbGxpZGFibGVzYCBvcHRpb25cclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudFtdfVxyXG4gICAqL1xyXG4gIGdldENvbGxpZGFibGVzKCkge1xyXG4gICAgY29uc3QgY29sbGlkYWJsZXMgPSB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLmNvbGxpZGFibGVzO1xyXG5cclxuICAgIGlmICh0eXBlb2YgY29sbGlkYWJsZXMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGNvbGxpZGFibGVzKSk7XHJcbiAgICB9IGVsc2UgaWYgKGNvbGxpZGFibGVzIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgY29sbGlkYWJsZXMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29sbGlkYWJsZXMpO1xyXG4gICAgfSBlbHNlIGlmIChjb2xsaWRhYmxlcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBbY29sbGlkYWJsZXNdO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29sbGlkYWJsZXMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIGNvbGxpZGFibGVzKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG1vdmUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnTW92ZUV2ZW50fSBldmVudCAtIERyYWcgbW92ZSBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdNb3ZlXShldmVudCkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuc2Vuc29yRXZlbnQudGFyZ2V0O1xyXG5cclxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXNbb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWVdKHRhcmdldCkpO1xyXG5cclxuICAgIGlmICh0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQpIHtcclxuICAgICAgZXZlbnQuY2FuY2VsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY29sbGlkYWJsZUluRXZlbnQgPSBuZXcgX0NvbGxpZGFibGVFdmVudC5Db2xsaWRhYmxlSW5FdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGNvbGxpZGluZ0VsZW1lbnQ6IHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgY29sbGlkYWJsZU91dEV2ZW50ID0gbmV3IF9Db2xsaWRhYmxlRXZlbnQuQ29sbGlkYWJsZU91dEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcclxuICAgICAgY29sbGlkaW5nRWxlbWVudDogdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgZW50ZXJpbmdDb2xsaWRhYmxlID0gQm9vbGVhbih0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgJiYgdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudCAhPT0gdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50KTtcclxuICAgIGNvbnN0IGxlYXZpbmdDb2xsaWRhYmxlID0gQm9vbGVhbighdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ICYmIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQpO1xyXG5cclxuICAgIGlmIChlbnRlcmluZ0NvbGxpZGFibGUpIHtcclxuICAgICAgaWYgKHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKGNvbGxpZGFibGVPdXRFdmVudCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIoY29sbGlkYWJsZUluRXZlbnQpO1xyXG4gICAgfSBlbHNlIGlmIChsZWF2aW5nQ29sbGlkYWJsZSkge1xyXG4gICAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKGNvbGxpZGFibGVPdXRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudCA9IHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RvcCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdTdG9wRXZlbnR9IGV2ZW50IC0gRHJhZyBzdG9wIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XHJcbiAgICBjb25zdCBsYXN0Q29sbGlkaW5nRWxlbWVudCA9IHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCB8fCB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50O1xyXG4gICAgY29uc3QgY29sbGlkYWJsZU91dEV2ZW50ID0gbmV3IF9Db2xsaWRhYmxlRXZlbnQuQ29sbGlkYWJsZU91dEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcclxuICAgICAgY29sbGlkaW5nRWxlbWVudDogbGFzdENvbGxpZGluZ0VsZW1lbnRcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChsYXN0Q29sbGlkaW5nRWxlbWVudCkge1xyXG4gICAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKGNvbGxpZGFibGVPdXRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudCA9IG51bGw7XHJcbiAgICB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW5pbWF0aW9uIGZyYW1lIGZ1bmN0aW9uXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBDdXJyZW50IG1vdmUgdGFyZ2V0XHJcbiAgICogQHJldHVybiB7RnVuY3Rpb259XHJcbiAgICovXHJcbiAgW29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lXSh0YXJnZXQpIHtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbGxpZGFibGVzID0gdGhpcy5nZXRDb2xsaWRhYmxlcygpO1xyXG4gICAgICB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgZWxlbWVudCA9PiBjb2xsaWRhYmxlcy5pbmNsdWRlcyhlbGVtZW50KSk7XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBDb2xsaWRhYmxlO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDk2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkNvbGxpZGFibGVPdXRFdmVudCA9IGV4cG9ydHMuQ29sbGlkYWJsZUluRXZlbnQgPSBleHBvcnRzLkNvbGxpZGFibGVFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgY29sbGlkYWJsZSBldmVudFxyXG4gKiBAY2xhc3MgQ29sbGlkYWJsZUV2ZW50XHJcbiAqIEBtb2R1bGUgQ29sbGlkYWJsZUV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIENvbGxpZGFibGVFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGNvbGxpYWJsZSBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBkcmFnRXZlbnRcclxuICAgKiBAdHlwZSB7RHJhZ0V2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkcmFnRXZlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuQ29sbGlkYWJsZUV2ZW50ID0gQ29sbGlkYWJsZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbGxpZGFibGUgaW4gZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBDb2xsaWRhYmxlSW5FdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBDb2xsaWRhYmxlSW5FdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgQ29sbGlkYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkNvbGxpZGFibGVFdmVudC50eXBlID0gJ2NvbGxpZGFibGUnO1xyXG5jbGFzcyBDb2xsaWRhYmxlSW5FdmVudCBleHRlbmRzIENvbGxpZGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEVsZW1lbnQgeW91IGFyZSBjdXJyZW50bHkgY29sbGlkaW5nIHdpdGhcclxuICAgKiBAcHJvcGVydHkgY29sbGlkaW5nRWxlbWVudFxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgY29sbGlkaW5nRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuY29sbGlkaW5nRWxlbWVudDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuQ29sbGlkYWJsZUluRXZlbnQgPSBDb2xsaWRhYmxlSW5FdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29sbGlkYWJsZSBvdXQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgQ29sbGlkYWJsZU91dEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBDb2xsaWRhYmxlT3V0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBDb2xsaWRhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkNvbGxpZGFibGVJbkV2ZW50LnR5cGUgPSAnY29sbGlkYWJsZTppbic7XHJcbmNsYXNzIENvbGxpZGFibGVPdXRFdmVudCBleHRlbmRzIENvbGxpZGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEVsZW1lbnQgeW91IHdlcmUgcHJldmlvdXNseSBjb2xsaWRpbmcgd2l0aFxyXG4gICAqIEBwcm9wZXJ0eSBjb2xsaWRpbmdFbGVtZW50XHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjb2xsaWRpbmdFbGVtZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jb2xsaWRpbmdFbGVtZW50O1xyXG4gIH1cclxufVxyXG5leHBvcnRzLkNvbGxpZGFibGVPdXRFdmVudCA9IENvbGxpZGFibGVPdXRFdmVudDtcclxuQ29sbGlkYWJsZU91dEV2ZW50LnR5cGUgPSAnY29sbGlkYWJsZTpvdXQnO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDk3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Db2xsaWRhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcclxuXHJcbk9iamVjdC5rZXlzKF9Db2xsaWRhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfQ29sbGlkYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9Db2xsaWRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XHJcblxyXG52YXIgX0NvbGxpZGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29sbGlkYWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0NvbGxpZGFibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogOTggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0NvbGxpZGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQ29sbGlkYWJsZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbGxpZGFibGUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfUmVzaXplTWlycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NCk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1Jlc2l6ZU1pcnJvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Jlc2l6ZU1pcnJvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRSZXNpemVNaXJyb3JPcHRpb25zJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX1Jlc2l6ZU1pcnJvci5kZWZhdWx0T3B0aW9ucztcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9TbmFwcGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU25hcHBhYmxlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU25hcHBhYmxlKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1N3YXBBbmltYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU3dhcEFuaW1hdGlvbicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N3YXBBbmltYXRpb24pLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0U3dhcEFuaW1hdGlvbk9wdGlvbnMnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfU3dhcEFuaW1hdGlvbi5kZWZhdWx0T3B0aW9ucztcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Tb3J0QW5pbWF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nyk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1NvcnRBbmltYXRpb24nLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Tb3J0QW5pbWF0aW9uKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGVmYXVsdFNvcnRBbmltYXRpb25PcHRpb25zJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX1NvcnRBbmltYXRpb24uZGVmYXVsdE9wdGlvbnM7XHJcbiAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKioqLyB9KSxcclxuLyogOTkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG5cclxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbk1vdXNlRm9yY2VXaWxsQmVnaW4gPSBTeW1ib2woJ29uTW91c2VGb3JjZVdpbGxCZWdpbicpO1xyXG5jb25zdCBvbk1vdXNlRm9yY2VEb3duID0gU3ltYm9sKCdvbk1vdXNlRm9yY2VEb3duJyk7XHJcbmNvbnN0IG9uTW91c2VEb3duID0gU3ltYm9sKCdvbk1vdXNlRG93bicpO1xyXG5jb25zdCBvbk1vdXNlRm9yY2VDaGFuZ2UgPSBTeW1ib2woJ29uTW91c2VGb3JjZUNoYW5nZScpO1xyXG5jb25zdCBvbk1vdXNlTW92ZSA9IFN5bWJvbCgnb25Nb3VzZU1vdmUnKTtcclxuY29uc3Qgb25Nb3VzZVVwID0gU3ltYm9sKCdvbk1vdXNlVXAnKTtcclxuY29uc3Qgb25Nb3VzZUZvcmNlR2xvYmFsQ2hhbmdlID0gU3ltYm9sKCdvbk1vdXNlRm9yY2VHbG9iYWxDaGFuZ2UnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHNlbnNvciBwaWNrcyB1cCBuYXRpdmUgZm9yY2UgdG91Y2ggZXZlbnRzIGFuZCBkaWN0YXRlcyBkcmFnIG9wZXJhdGlvbnNcclxuICogQGNsYXNzIEZvcmNlVG91Y2hTZW5zb3JcclxuICogQG1vZHVsZSBGb3JjZVRvdWNoU2Vuc29yXHJcbiAqIEBleHRlbmRzIFNlbnNvclxyXG4gKi9cclxuY2xhc3MgRm9yY2VUb3VjaFNlbnNvciBleHRlbmRzIF9TZW5zb3IyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIEZvcmNlVG91Y2hTZW5zb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgRm9yY2VUb3VjaFNlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmFnZ2FibGUgZWxlbWVudCBuZWVkcyB0byBiZSByZW1lbWJlcmVkIHRvIHVuc2V0IHRoZSBkcmFnZ2FibGUgYXR0cmlidXRlIGFmdGVyIGRyYWcgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWRcclxuICAgICAqIEBwcm9wZXJ0eSBtaWdodERyYWdcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXNbb25Nb3VzZUZvcmNlV2lsbEJlZ2luXSA9IHRoaXNbb25Nb3VzZUZvcmNlV2lsbEJlZ2luXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlRm9yY2VEb3duXSA9IHRoaXNbb25Nb3VzZUZvcmNlRG93bl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Nb3VzZURvd25dID0gdGhpc1tvbk1vdXNlRG93bl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Nb3VzZUZvcmNlQ2hhbmdlXSA9IHRoaXNbb25Nb3VzZUZvcmNlQ2hhbmdlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlTW92ZV0gPSB0aGlzW29uTW91c2VNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlVXBdID0gdGhpc1tvbk1vdXNlVXBdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgdGhpcy5jb250YWluZXJzKSB7XHJcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luJywgdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dLCBmYWxzZSk7XHJcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNlZG93bicsIHRoaXNbb25Nb3VzZUZvcmNlRG93bl0sIGZhbHNlKTtcclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2VjaGFuZ2VkJywgdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgdGhpcy5jb250YWluZXJzKSB7XHJcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luJywgdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dLCBmYWxzZSk7XHJcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNlZG93bicsIHRoaXNbb25Nb3VzZUZvcmNlRG93bl0sIGZhbHNlKTtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2VjaGFuZ2VkJywgdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBmb3JjZSB3aWxsIGJlZ2luIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2Ugd2lsbCBiZWdpbiBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRm9yY2VXaWxsQmVnaW5dKGV2ZW50KSB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgdGhpcy5taWdodERyYWcgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZm9yY2UgZG93biBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGZvcmNlIGRvd24gZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZUZvcmNlRG93bl0oZXZlbnQpIHtcclxuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gZXZlbnQuY3VycmVudFRhcmdldDtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCk7XHJcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgdXAgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlVXBdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdG9wU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQ6IG51bGwsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMubWlnaHREcmFnID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBkb3duIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZG93biBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRG93bl0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5taWdodERyYWcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5lZWQgd29ya2Fyb3VuZCBmb3IgcmVhbCBjbGlja1xyXG4gICAgLy8gQ2FuY2VsIHBvdGVudGlhbCBkcmFnIGV2ZW50c1xyXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2Ugd2lsbCBiZWdpbiBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlTW92ZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuXHJcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnTW92ZVNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZm9yY2UgY2hhbmdlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2UgY2hhbmdlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VGb3JjZUNoYW5nZV0oZXZlbnQpIHtcclxuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xyXG5cclxuICAgIGNvbnN0IGRyYWdQcmVzc3VyZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnUHJlc3N1cmVTZW5zb3JFdmVudCh7XHJcbiAgICAgIHByZXNzdXJlOiBldmVudC53ZWJraXRGb3JjZSxcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnUHJlc3N1cmVFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBmb3JjZSBnbG9iYWwgY2hhbmdlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2UgZ2xvYmFsIGNoYW5nZSBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRm9yY2VHbG9iYWxDaGFuZ2VdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuXHJcbiAgICBjb25zdCBkcmFnUHJlc3N1cmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQoe1xyXG4gICAgICBwcmVzc3VyZTogZXZlbnQud2Via2l0Rm9yY2UsXHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnUHJlc3N1cmVFdmVudCk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEZvcmNlVG91Y2hTZW5zb3I7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTAwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Gb3JjZVRvdWNoU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OSk7XHJcblxyXG52YXIgX0ZvcmNlVG91Y2hTZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRm9yY2VUb3VjaFNlbnNvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0ZvcmNlVG91Y2hTZW5zb3IyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTAxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG5cclxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbk1vdXNlRG93biA9IFN5bWJvbCgnb25Nb3VzZURvd24nKTtcclxuY29uc3Qgb25Nb3VzZVVwID0gU3ltYm9sKCdvbk1vdXNlVXAnKTtcclxuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XHJcbmNvbnN0IG9uRHJhZ092ZXIgPSBTeW1ib2woJ29uRHJhZ092ZXInKTtcclxuY29uc3Qgb25EcmFnRW5kID0gU3ltYm9sKCdvbkRyYWdFbmQnKTtcclxuY29uc3Qgb25Ecm9wID0gU3ltYm9sKCdvbkRyb3AnKTtcclxuY29uc3QgcmVzZXQgPSBTeW1ib2woJ3Jlc2V0Jyk7XHJcblxyXG4vKipcclxuICogVGhpcyBzZW5zb3IgcGlja3MgdXAgbmF0aXZlIGJyb3dzZXIgZHJhZyBldmVudHMgYW5kIGRpY3RhdGVzIGRyYWcgb3BlcmF0aW9uc1xyXG4gKiBAY2xhc3MgRHJhZ1NlbnNvclxyXG4gKiBAbW9kdWxlIERyYWdTZW5zb3JcclxuICogQGV4dGVuZHMgU2Vuc29yXHJcbiAqL1xyXG5jbGFzcyBEcmFnU2Vuc29yIGV4dGVuZHMgX1NlbnNvcjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogRHJhZ1NlbnNvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBEcmFnU2Vuc29yXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGRvd24gdGltZXIgd2hpY2ggd2lsbCBlbmQgdXAgc2V0dGluZyB0aGUgZHJhZ2dhYmxlIGF0dHJpYnV0ZSwgdW5sZXNzIGNhbmNlbGVkXHJcbiAgICAgKiBAcHJvcGVydHkgbW91c2VEb3duVGltZW91dFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZSBlbGVtZW50IG5lZWRzIHRvIGJlIHJlbWVtYmVyZWQgdG8gdW5zZXQgdGhlIGRyYWdnYWJsZSBhdHRyaWJ1dGUgYWZ0ZXIgZHJhZyBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZFxyXG4gICAgICogQHByb3BlcnR5IGRyYWdnYWJsZUVsZW1lbnRcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5hdGl2ZSBkcmFnZ2FibGUgZWxlbWVudCBjb3VsZCBiZSBsaW5rcyBvciBpbWFnZXMsIHRoZWlyIGRyYWdnYWJsZSBzdGF0ZSB3aWxsIGJlIGRpc2FibGVkIGR1cmluZyBkcmFnIG9wZXJhdGlvblxyXG4gICAgICogQHByb3BlcnR5IG5hdGl2ZURyYWdnYWJsZUVsZW1lbnRcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uTW91c2VEb3duXSA9IHRoaXNbb25Nb3VzZURvd25dLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VVcF0gPSB0aGlzW29uTW91c2VVcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnT3Zlcl0gPSB0aGlzW29uRHJhZ092ZXJdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ0VuZF0gPSB0aGlzW29uRHJhZ0VuZF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Ecm9wXSA9IHRoaXNbb25Ecm9wXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRHJhZyBzdGFydCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcclxuICAgIC8vIE5lZWQgZm9yIGZpcmVmb3guIFwidGV4dFwiIGtleSBpcyBuZWVkZWQgZm9yIElFXHJcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YSgndGV4dCcsICcnKTtcclxuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gdGhpcy5vcHRpb25zLnR5cGU7XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xyXG5cclxuICAgIGlmICghdGhpcy5jdXJyZW50Q29udGFpbmVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gV29ya2Fyb3VuZFxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcclxuXHJcbiAgICAgIGlmIChkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9LCAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgb3ZlciBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERyYWcgb3ZlciBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdmVyXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jdXJyZW50Q29udGFpbmVyO1xyXG5cclxuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdNb3ZlU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xyXG5cclxuICAgIGlmICghZHJhZ01vdmVFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gdGhpcy5vcHRpb25zLnR5cGU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIGVuZCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERyYWcgZW5kIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ0VuZF0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSwgdHJ1ZSk7XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbnRhaW5lcjtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RvcFNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnU3RvcEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbcmVzZXRdKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcm9wIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRHJvcCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyb3BdKGV2ZW50KSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBkb3duIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZG93biBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRG93bl0oZXZlbnQpIHtcclxuICAgIC8vIEZpcmVmb3ggYnVnIGZvciBpbnB1dHMgd2l0aGluIGRyYWdnYWJsZXMgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzM5MDcxXHJcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICYmIChldmVudC50YXJnZXQuZm9ybSB8fCBldmVudC50YXJnZXQuY29udGVudGVkaXRhYmxlKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZXZlbnQudGFyZ2V0LCBlbGVtZW50ID0+IGVsZW1lbnQuZHJhZ2dhYmxlKTtcclxuXHJcbiAgICBpZiAobmF0aXZlRHJhZ2dhYmxlRWxlbWVudCkge1xyXG4gICAgICBuYXRpdmVEcmFnZ2FibGVFbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQgPSBuYXRpdmVEcmFnZ2FibGVFbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0sIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIHRoaXNbb25EcmFnRW5kXSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXNbb25Ecm9wXSwgZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZXZlbnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcclxuXHJcbiAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdGFydEV2ZW50ID0gZXZlbnQ7XHJcblxyXG4gICAgdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xyXG4gICAgICB0aGlzLmRyYWdnYWJsZUVsZW1lbnQgPSB0YXJnZXQ7XHJcbiAgICB9LCB0aGlzLmRlbGF5LmRyYWcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgdXAgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlVXBdKCkge1xyXG4gICAgdGhpc1tyZXNldF0oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIHVwIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgdXAgZXZlbnRcclxuICAgKi9cclxuICBbcmVzZXRdKCkge1xyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzW29uRHJhZ092ZXJdLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpc1tvbkRyYWdFbmRdLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpc1tvbkRyb3BdLCBmYWxzZSk7XHJcblxyXG4gICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCkge1xyXG4gICAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuICAgICAgdGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5kcmFnZ2FibGVFbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuZHJhZ2dhYmxlRWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcclxuICAgICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ1NlbnNvcjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMDIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0RyYWdTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XHJcblxyXG52YXIgX0RyYWdTZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ1NlbnNvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0RyYWdTZW5zb3IyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTAzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG5cclxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvblRvdWNoU3RhcnQgPSBTeW1ib2woJ29uVG91Y2hTdGFydCcpO1xyXG5jb25zdCBvblRvdWNoRW5kID0gU3ltYm9sKCdvblRvdWNoRW5kJyk7XHJcbmNvbnN0IG9uVG91Y2hNb3ZlID0gU3ltYm9sKCdvblRvdWNoTW92ZScpO1xyXG5jb25zdCBzdGFydERyYWcgPSBTeW1ib2woJ3N0YXJ0RHJhZycpO1xyXG5jb25zdCBvbkRpc3RhbmNlQ2hhbmdlID0gU3ltYm9sKCdvbkRpc3RhbmNlQ2hhbmdlJyk7XHJcblxyXG4vKipcclxuICogUHJldmVudHMgc2Nyb2xsaW5nIHdoZW4gc2V0IHRvIHRydWVcclxuICogQHZhciB7Qm9vbGVhbn0gcHJldmVudFNjcm9sbGluZ1xyXG4gKi9cclxubGV0IHByZXZlbnRTY3JvbGxpbmcgPSBmYWxzZTtcclxuXHJcbi8vIFdlYktpdCByZXF1aXJlcyBjYW5jZWxhYmxlIGB0b3VjaG1vdmVgIGV2ZW50cyB0byBiZSBhZGRlZCBhcyBlYXJseSBhcyBwb3NzaWJsZVxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZXZlbnQgPT4ge1xyXG4gIGlmICghcHJldmVudFNjcm9sbGluZykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gUHJldmVudCBzY3JvbGxpbmdcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG59LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgc2Vuc29yIHBpY2tzIHVwIG5hdGl2ZSBicm93c2VyIHRvdWNoIGV2ZW50cyBhbmQgZGljdGF0ZXMgZHJhZyBvcGVyYXRpb25zXHJcbiAqIEBjbGFzcyBUb3VjaFNlbnNvclxyXG4gKiBAbW9kdWxlIFRvdWNoU2Vuc29yXHJcbiAqIEBleHRlbmRzIFNlbnNvclxyXG4gKi9cclxuY2xhc3MgVG91Y2hTZW5zb3IgZXh0ZW5kcyBfU2Vuc29yMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBUb3VjaFNlbnNvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBUb3VjaFNlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXN0IHNjcm9sbGFibGUgY29udGFpbmVyIHNvIGFjY2lkZW50YWwgc2Nyb2xsIGNhbiBjYW5jZWwgbG9uZyB0b3VjaFxyXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRTY3JvbGxhYmxlUGFyZW50XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudFNjcm9sbGFibGVQYXJlbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGltZW91dElEIGZvciBtYW5hZ2luZyBkZWxheVxyXG4gICAgICogQHByb3BlcnR5IHRhcFRpbWVvdXRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudGFwVGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0b3VjaE1vdmVkIGluZGljYXRlcyBpZiB0b3VjaCBoYXMgbW92ZWQgZHVyaW5nIHRhcFRpbWVvdXRcclxuICAgICAqIEBwcm9wZXJ0eSB0b3VjaE1vdmVkXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy50b3VjaE1vdmVkID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTYXZlIHBhZ2VYIGNvb3JkaW5hdGVzIGZvciBkZWxheSBkcmFnXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJyZX0gcGFnZVhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFnZVggPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2F2ZSBwYWdlWSBjb29yZGluYXRlcyBmb3IgZGVsYXkgZHJhZ1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1icmV9IHBhZ2VZXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBhZ2VZID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uVG91Y2hTdGFydF0gPSB0aGlzW29uVG91Y2hTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Ub3VjaEVuZF0gPSB0aGlzW29uVG91Y2hFbmRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uVG91Y2hNb3ZlXSA9IHRoaXNbb25Ub3VjaE1vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW3N0YXJ0RHJhZ10gPSB0aGlzW3N0YXJ0RHJhZ10uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0gPSB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXNbb25Ub3VjaFN0YXJ0XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXNbb25Ub3VjaFN0YXJ0XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUb3VjaCBzdGFydCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRvdWNoIHN0YXJ0IGV2ZW50XHJcbiAgICovXHJcbiAgW29uVG91Y2hTdGFydF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xyXG5cclxuICAgIGlmICghY29udGFpbmVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgZGlzdGFuY2UgPSAwIH0gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCB7IGRlbGF5IH0gPSB0aGlzO1xyXG4gICAgY29uc3QgeyBwYWdlWCwgcGFnZVkgfSA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKGV2ZW50KTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgcGFnZVgsIHBhZ2VZIH0pO1xyXG4gICAgdGhpcy5vblRvdWNoU3RhcnRBdCA9IERhdGUubm93KCk7XHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBldmVudDtcclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzW29uVG91Y2hFbmRdKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSk7XHJcblxyXG4gICAgaWYgKGRpc3RhbmNlKSB7XHJcbiAgICAgIHByZXZlbnRTY3JvbGxpbmcgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudGFwVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSh7IHRvdWNoZXM6IFt7IHBhZ2VYOiB0aGlzLnBhZ2VYLCBwYWdlWTogdGhpcy5wYWdlWSB9XSB9KTtcclxuICAgIH0sIGRlbGF5LnRvdWNoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IHRoZSBkcmFnXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbc3RhcnREcmFnXSgpIHtcclxuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSB0aGlzLnN0YXJ0RXZlbnQ7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XHJcbiAgICBjb25zdCB0b3VjaCA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKHN0YXJ0RXZlbnQpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RhcnRTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IHRvdWNoLnBhZ2VYLFxyXG4gICAgICBjbGllbnRZOiB0b3VjaC5wYWdlWSxcclxuICAgICAgdGFyZ2V0OiBzdGFydEV2ZW50LnRhcmdldCxcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBzdGFydEV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2luZyA9ICFkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpO1xyXG5cclxuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25Ub3VjaE1vdmVdKTtcclxuICAgIH1cclxuICAgIHByZXZlbnRTY3JvbGxpbmcgPSB0aGlzLmRyYWdnaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVG91Y2ggbW92ZSBoYW5kbGVyIHByaW9yIHRvIGRyYWcgc3RhcnQuXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRvdWNoIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25EaXN0YW5jZUNoYW5nZV0oZXZlbnQpIHtcclxuICAgIGNvbnN0IHsgZGlzdGFuY2UgfSA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IHsgc3RhcnRFdmVudCwgZGVsYXkgfSA9IHRoaXM7XHJcbiAgICBjb25zdCBzdGFydCA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKHN0YXJ0RXZlbnQpO1xyXG4gICAgY29uc3QgY3VycmVudCA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKGV2ZW50KTtcclxuICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gRGF0ZS5ub3coKSAtIHRoaXMub25Ub3VjaFN0YXJ0QXQ7XHJcbiAgICBjb25zdCBkaXN0YW5jZVRyYXZlbGxlZCA9ICgwLCBfdXRpbHMuZGlzdGFuY2UpKHN0YXJ0LnBhZ2VYLCBzdGFydC5wYWdlWSwgY3VycmVudC5wYWdlWCwgY3VycmVudC5wYWdlWSk7XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjdXJyZW50KTtcclxuXHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy50YXBUaW1lb3V0KTtcclxuXHJcbiAgICBpZiAodGltZUVsYXBzZWQgPCBkZWxheS50b3VjaCkge1xyXG4gICAgICAvLyBtb3ZlZCBkdXJpbmcgZGVsYXlcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlVHJhdmVsbGVkID49IGRpc3RhbmNlKSB7XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG4gICAgICB0aGlzW3N0YXJ0RHJhZ10oKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIG1vdmUgaGFuZGxlciB3aGlsZSBkcmFnZ2luZ1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUb3VjaCBtb3ZlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uVG91Y2hNb3ZlXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgcGFnZVgsIHBhZ2VZIH0gPSAoMCwgX3V0aWxzLnRvdWNoQ29vcmRzKShldmVudCk7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHBhZ2VYIC0gd2luZG93LnNjcm9sbFgsIHBhZ2VZIC0gd2luZG93LnNjcm9sbFkpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdNb3ZlU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBwYWdlWCxcclxuICAgICAgY2xpZW50WTogcGFnZVksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRvdWNoIGVuZCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRvdWNoIGVuZCBldmVudFxyXG4gICAqL1xyXG4gIFtvblRvdWNoRW5kXShldmVudCkge1xyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGFwVGltZW91dCk7XHJcbiAgICBwcmV2ZW50U2Nyb2xsaW5nID0gZmFsc2U7XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzW29uVG91Y2hFbmRdKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpc1tvblRvdWNoRW5kXSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50Q29udGFpbmVyKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudENvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvblRvdWNoTW92ZV0pO1xyXG5cclxuICAgIGNvbnN0IHsgcGFnZVgsIHBhZ2VZIH0gPSAoMCwgX3V0aWxzLnRvdWNoQ29vcmRzKShldmVudCk7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHBhZ2VYIC0gd2luZG93LnNjcm9sbFgsIHBhZ2VZIC0gd2luZG93LnNjcm9sbFkpO1xyXG5cclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0b3BTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IHBhZ2VYLFxyXG4gICAgICBjbGllbnRZOiBwYWdlWSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdG9wRXZlbnQpO1xyXG5cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IG51bGw7XHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gVG91Y2hTZW5zb3I7XHJcbmZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTA0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Ub3VjaFNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTAzKTtcclxuXHJcbnZhciBfVG91Y2hTZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVG91Y2hTZW5zb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Ub3VjaFNlbnNvcjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMDUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdTdG9wU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdNb3ZlU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdTdGFydFNlbnNvckV2ZW50ID0gZXhwb3J0cy5TZW5zb3JFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2Ugc2Vuc29yIGV2ZW50XHJcbiAqIEBjbGFzcyBTZW5zb3JFdmVudFxyXG4gKiBAbW9kdWxlIFNlbnNvckV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIFNlbnNvckV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIE9yaWdpbmFsIGJyb3dzZXIgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgYSBzZW5zb3JcclxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxFdmVudFxyXG4gICAqIEB0eXBlIHtFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3JpZ2luYWxFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxFdmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZWQgY2xpZW50WCBmb3IgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzXHJcbiAgICogQHByb3BlcnR5IGNsaWVudFhcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjbGllbnRYKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jbGllbnRYO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplZCBjbGllbnRZIGZvciBib3RoIHRvdWNoIGFuZCBtb3VzZSBldmVudHNcclxuICAgKiBAcHJvcGVydHkgY2xpZW50WVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGNsaWVudFkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNsaWVudFk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOb3JtYWxpemVkIHRhcmdldCBmb3IgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzXHJcbiAgICogUmV0dXJucyB0aGUgZWxlbWVudCB0aGF0IGlzIGJlaGluZCBjdXJzb3Igb3IgdG91Y2ggcG9pbnRlclxyXG4gICAqIEBwcm9wZXJ0eSB0YXJnZXRcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHRhcmdldCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEudGFyZ2V0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udGFpbmVyIHRoYXQgaW5pdGlhdGVkIHRoZSBzZW5zb3JcclxuICAgKiBAcHJvcGVydHkgY29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYWNrcGFkIHByZXNzdXJlXHJcbiAgICogQHByb3BlcnR5IHByZXNzdXJlXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcHJlc3N1cmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnByZXNzdXJlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5TZW5zb3JFdmVudCA9IFNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHN0YXJ0IHNlbnNvciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RhcnRTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1N0YXJ0U2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuY2xhc3MgRHJhZ1N0YXJ0U2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5EcmFnU3RhcnRTZW5zb3JFdmVudCA9IERyYWdTdGFydFNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG1vdmUgc2Vuc29yIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdNb3ZlU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdNb3ZlU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQudHlwZSA9ICdkcmFnOnN0YXJ0JztcclxuY2xhc3MgRHJhZ01vdmVTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdNb3ZlU2Vuc29yRXZlbnQgPSBEcmFnTW92ZVNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdG9wIHNlbnNvciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1N0b3BTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdTdG9wU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnTW92ZVNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzptb3ZlJztcclxuY2xhc3MgRHJhZ1N0b3BTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdTdG9wU2Vuc29yRXZlbnQgPSBEcmFnU3RvcFNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBwcmVzc3VyZSBzZW5zb3IgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdQcmVzc3VyZVNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnU3RvcFNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzpzdG9wJztcclxuY2xhc3MgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxyXG5leHBvcnRzLkRyYWdQcmVzc3VyZVNlbnNvckV2ZW50ID0gRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQ7XHJcbkRyYWdQcmVzc3VyZVNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzpwcmVzc3VyZSc7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTA2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSB0b3VjaENvb3JkcztcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGZpcnN0IHRvdWNoIGV2ZW50IGZvdW5kIGluIHRvdWNoZXMgb3IgY2hhbmdlZFRvdWNoZXMgb2YgYSB0b3VjaCBldmVudHMuXHJcbiAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnQgYSB0b3VjaCBldmVudFxyXG4gKiBAcmV0dXJuIHtUb3VjaH0gYSB0b3VjaCBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIHRvdWNoQ29vcmRzKGV2ZW50ID0ge30pIHtcclxuICBjb25zdCB7IHRvdWNoZXMsIGNoYW5nZWRUb3VjaGVzIH0gPSBldmVudDtcclxuICByZXR1cm4gdG91Y2hlcyAmJiB0b3VjaGVzWzBdIHx8IGNoYW5nZWRUb3VjaGVzICYmIGNoYW5nZWRUb3VjaGVzWzBdO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTA3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF90b3VjaENvb3JkcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTA2KTtcclxuXHJcbnZhciBfdG91Y2hDb29yZHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG91Y2hDb29yZHMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF90b3VjaENvb3JkczIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMDggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGRpc3RhbmNlO1xyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXHJcbiAqIEBwYXJhbSAge051bWJlcn0geDEgVGhlIFggcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50XHJcbiAqIEBwYXJhbSAge051bWJlcn0geTEgVGhlIFkgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50XHJcbiAqIEBwYXJhbSAge051bWJlcn0geDIgVGhlIFggcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHkyIFRoZSBZIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnRcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcclxuICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqKiAyICsgKHkyIC0geTEpICoqIDIpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTA5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9kaXN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTA4KTtcclxuXHJcbnZhciBfZGlzdGFuY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzdGFuY2UpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9kaXN0YW5jZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMTAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWU7XHJcbmZ1bmN0aW9uIHJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHtcclxuICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMTEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMCk7XHJcblxyXG52YXIgX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTEyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBjbG9zZXN0O1xyXG5jb25zdCBtYXRjaEZ1bmN0aW9uID0gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgY2xvc2VzdCBwYXJlbnQgZWxlbWVudCBvZiBhIGdpdmVuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBnaXZlblxyXG4gKiBzZWxlY3RvciBzdHJpbmcgb3IgbWF0Y2hpbmcgZnVuY3Rpb25cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBjaGlsZCBlbGVtZW50IHRvIGZpbmQgYSBwYXJlbnQgb2ZcclxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIFRoZSBzdHJpbmcgb3IgZnVuY3Rpb24gdG8gdXNlIHRvIG1hdGNoXHJcbiAqICAgICB0aGUgcGFyZW50IGVsZW1lbnRcclxuICogQHJldHVybiB7RWxlbWVudHxudWxsfVxyXG4gKi9cclxuZnVuY3Rpb24gY2xvc2VzdChlbGVtZW50LCB2YWx1ZSkge1xyXG4gIGlmICghZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzZWxlY3RvciA9IHZhbHVlO1xyXG4gIGNvbnN0IGNhbGxiYWNrID0gdmFsdWU7XHJcbiAgY29uc3Qgbm9kZUxpc3QgPSB2YWx1ZTtcclxuICBjb25zdCBzaW5nbGVFbGVtZW50ID0gdmFsdWU7XHJcblxyXG4gIGNvbnN0IGlzU2VsZWN0b3IgPSBCb29sZWFuKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpO1xyXG4gIGNvbnN0IGlzRnVuY3Rpb24gPSBCb29sZWFuKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyk7XHJcbiAgY29uc3QgaXNOb2RlTGlzdCA9IEJvb2xlYW4odmFsdWUgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KTtcclxuICBjb25zdCBpc0VsZW1lbnQgPSBCb29sZWFuKHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpO1xyXG5cclxuICBmdW5jdGlvbiBjb25kaXRpb25GbihjdXJyZW50RWxlbWVudCkge1xyXG4gICAgaWYgKCFjdXJyZW50RWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XHJcbiAgICB9IGVsc2UgaWYgKGlzU2VsZWN0b3IpIHtcclxuICAgICAgcmV0dXJuIG1hdGNoRnVuY3Rpb24uY2FsbChjdXJyZW50RWxlbWVudCwgc2VsZWN0b3IpO1xyXG4gICAgfSBlbHNlIGlmIChpc05vZGVMaXN0KSB7XHJcbiAgICAgIHJldHVybiBbLi4ubm9kZUxpc3RdLmluY2x1ZGVzKGN1cnJlbnRFbGVtZW50KTtcclxuICAgIH0gZWxzZSBpZiAoaXNFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBzaW5nbGVFbGVtZW50ID09PSBjdXJyZW50RWxlbWVudDtcclxuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbikge1xyXG4gICAgICByZXR1cm4gY2FsbGJhY2soY3VycmVudEVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsZXQgY3VycmVudCA9IGVsZW1lbnQ7XHJcblxyXG4gIGRvIHtcclxuICAgIGN1cnJlbnQgPSBjdXJyZW50LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50IHx8IGN1cnJlbnQuY29ycmVzcG9uZGluZ0VsZW1lbnQgfHwgY3VycmVudDtcclxuXHJcbiAgICBpZiAoY29uZGl0aW9uRm4oY3VycmVudCkpIHtcclxuICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcclxuICB9IHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQpO1xyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDExMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfY2xvc2VzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEyKTtcclxuXHJcbnZhciBfY2xvc2VzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9zZXN0KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfY2xvc2VzdDIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMTQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcbnZhciBfU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcblxyXG52YXIgX1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpO1xyXG5cclxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nID0gU3ltYm9sKCdvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZycpO1xyXG5jb25zdCBvbk1vdXNlRG93biA9IFN5bWJvbCgnb25Nb3VzZURvd24nKTtcclxuY29uc3Qgb25Nb3VzZU1vdmUgPSBTeW1ib2woJ29uTW91c2VNb3ZlJyk7XHJcbmNvbnN0IG9uTW91c2VVcCA9IFN5bWJvbCgnb25Nb3VzZVVwJyk7XHJcbmNvbnN0IHN0YXJ0RHJhZyA9IFN5bWJvbCgnc3RhcnREcmFnJyk7XHJcbmNvbnN0IG9uRGlzdGFuY2VDaGFuZ2UgPSBTeW1ib2woJ29uRGlzdGFuY2VDaGFuZ2UnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHNlbnNvciBwaWNrcyB1cCBuYXRpdmUgYnJvd3NlciBtb3VzZSBldmVudHMgYW5kIGRpY3RhdGVzIGRyYWcgb3BlcmF0aW9uc1xyXG4gKiBAY2xhc3MgTW91c2VTZW5zb3JcclxuICogQG1vZHVsZSBNb3VzZVNlbnNvclxyXG4gKiBAZXh0ZW5kcyBTZW5zb3JcclxuICovXHJcbmNsYXNzIE1vdXNlU2Vuc29yIGV4dGVuZHMgX1NlbnNvcjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogTW91c2VTZW5zb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgTW91c2VTZW5zb3JcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lcnMsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgZG93biB0aW1lciB3aGljaCB3aWxsIGVuZCB1cCB0cmlnZ2VyaW5nIHRoZSBkcmFnIHN0YXJ0IG9wZXJhdGlvblxyXG4gICAgICogQHByb3BlcnR5IG1vdXNlRG93blRpbWVvdXRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubW91c2VEb3duVGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTYXZlIHBhZ2VYIGNvb3JkaW5hdGVzIGZvciBkZWxheSBkcmFnXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJyZX0gcGFnZVhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFnZVggPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2F2ZSBwYWdlWSBjb29yZGluYXRlcyBmb3IgZGVsYXkgZHJhZ1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1icmV9IHBhZ2VZXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBhZ2VZID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXSA9IHRoaXNbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VEb3duXSA9IHRoaXNbb25Nb3VzZURvd25dLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VNb3ZlXSA9IHRoaXNbb25Nb3VzZU1vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VVcF0gPSB0aGlzW29uTW91c2VVcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbc3RhcnREcmFnXSA9IHRoaXNbc3RhcnREcmFnXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSA9IHRoaXNbb25EaXN0YW5jZUNoYW5nZV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZG93biBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGRvd24gZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZURvd25dKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb250YWluZXIgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGV2ZW50LnRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcclxuXHJcbiAgICBpZiAoIWNvbnRhaW5lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBkZWxheSB9ID0gdGhpcztcclxuICAgIGNvbnN0IHsgcGFnZVgsIHBhZ2VZIH0gPSBldmVudDtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgcGFnZVgsIHBhZ2VZIH0pO1xyXG4gICAgdGhpcy5vbk1vdXNlRG93bkF0ID0gRGF0ZS5ub3coKTtcclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IGV2ZW50O1xyXG5cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0pO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgcHJldmVudE5hdGl2ZURyYWdTdGFydCk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuXHJcbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0oeyBwYWdlWDogdGhpcy5wYWdlWCwgcGFnZVk6IHRoaXMucGFnZVkgfSk7XHJcbiAgICB9LCBkZWxheS5tb3VzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCB0aGUgZHJhZ1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW3N0YXJ0RHJhZ10oKSB7XHJcbiAgICBjb25zdCBzdGFydEV2ZW50ID0gdGhpcy5zdGFydEV2ZW50O1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jdXJyZW50Q29udGFpbmVyO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RhcnRTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IHN0YXJ0RXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogc3RhcnRFdmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQ6IHN0YXJ0RXZlbnQudGFyZ2V0LFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IHN0YXJ0RXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCk7XHJcblxyXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXSwgdHJ1ZSk7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25Nb3VzZU1vdmVdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVjdCBjaGFuZ2UgaW4gZGlzdGFuY2UsIHN0YXJ0aW5nIGRyYWcgd2hlbiBib3RoXHJcbiAgICogZGVsYXkgYW5kIGRpc3RhbmNlIHJlcXVpcmVtZW50cyBhcmUgbWV0XHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25EaXN0YW5jZUNoYW5nZV0oZXZlbnQpIHtcclxuICAgIGNvbnN0IHsgcGFnZVgsIHBhZ2VZIH0gPSBldmVudDtcclxuICAgIGNvbnN0IHsgZGlzdGFuY2UgfSA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IHsgc3RhcnRFdmVudCwgZGVsYXkgfSA9IHRoaXM7XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IHBhZ2VYLCBwYWdlWSB9KTtcclxuXHJcbiAgICBpZiAoIXRoaXMuY3VycmVudENvbnRhaW5lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGltZUVsYXBzZWQgPSBEYXRlLm5vdygpIC0gdGhpcy5vbk1vdXNlRG93bkF0O1xyXG4gICAgY29uc3QgZGlzdGFuY2VUcmF2ZWxsZWQgPSAoMCwgX3V0aWxzLmRpc3RhbmNlKShzdGFydEV2ZW50LnBhZ2VYLCBzdGFydEV2ZW50LnBhZ2VZLCBwYWdlWCwgcGFnZVkpIHx8IDA7XHJcblxyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XHJcblxyXG4gICAgaWYgKHRpbWVFbGFwc2VkIDwgZGVsYXkubW91c2UpIHtcclxuICAgICAgLy8gbW92ZWQgZHVyaW5nIGRlbGF5XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZVRyYXZlbGxlZCA+PSBkaXN0YW5jZSkge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuICAgICAgdGhpc1tzdGFydERyYWddKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgbW92ZSBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlTW92ZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuXHJcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnTW92ZVNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgdXAgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlVXBdKGV2ZW50KSB7XHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy5tb3VzZURvd25UaW1lb3V0KTtcclxuXHJcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHByZXZlbnROYXRpdmVEcmFnU3RhcnQpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcblxyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdG9wU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uTW91c2VNb3ZlXSk7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb250ZXh0IG1lbnUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBDb250ZXh0IG1lbnUgZXZlbnRcclxuICAgKi9cclxuICBbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddKGV2ZW50KSB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gTW91c2VTZW5zb3I7XHJcbmZ1bmN0aW9uIHByZXZlbnROYXRpdmVEcmFnU3RhcnQoZXZlbnQpIHtcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTE1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Nb3VzZVNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTE0KTtcclxuXHJcbnZhciBfTW91c2VTZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW91c2VTZW5zb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Nb3VzZVNlbnNvcjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMTYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxuY29uc3QgZGVmYXVsdERlYWx5ID0ge1xyXG4gIG1vdXNlOiAwLFxyXG4gIGRyYWc6IDAsXHJcbiAgdG91Y2g6IDEwMFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEJhc2Ugc2Vuc29yIGNsYXNzLiBFeHRlbmQgZnJvbSB0aGlzIGNsYXNzIHRvIGNyZWF0ZSBhIG5ldyBvciBjdXN0b20gc2Vuc29yXHJcbiAqIEBjbGFzcyBTZW5zb3JcclxuICogQG1vZHVsZSBTZW5zb3JcclxuICovXHJcbmNsYXNzIFNlbnNvciB7XHJcbiAgLyoqXHJcbiAgICogU2Vuc29yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFNlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGNvbnRhaW5lcnNcclxuICAgICAqIEBwcm9wZXJ0eSBjb250YWluZXJzXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb250YWluZXJzID0gWy4uLmNvbnRhaW5lcnNdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBkcmFnIHN0YXRlXHJcbiAgICAgKiBAcHJvcGVydHkgZHJhZ2dpbmdcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGNvbnRhaW5lclxyXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRDb250YWluZXJcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBldmVudCBvZiB0aGUgaW5pdGlhbCBzZW5zb3IgZG93blxyXG4gICAgICogQHByb3BlcnR5IHN0YXJ0RXZlbnRcclxuICAgICAqIEB0eXBlIHtFdmVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGFydEV2ZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWxheSBvZiBlYWNoIHNlbnNvclxyXG4gICAgICogQHByb3BlcnR5IGRlbGF5XHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlbGF5ID0gY2FsY0RlbGF5KG9wdGlvbnMuZGVsYXkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqIEByZXR1cm4ge1NlbnNvcn1cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKiBAcmV0dXJuIHtTZW5zb3J9XHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGNvbnRhaW5lciB0byB0aGlzIHNlbnNvciBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7Li4uSFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzIHlvdSB3YW50IHRvIGFkZCB0byB0aGlzIHNlbnNvclxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5hZGRDb250YWluZXIoZG9jdW1lbnQuYm9keSlcclxuICAgKi9cclxuICBhZGRDb250YWluZXIoLi4uY29udGFpbmVycykge1xyXG4gICAgdGhpcy5jb250YWluZXJzID0gWy4uLnRoaXMuY29udGFpbmVycywgLi4uY29udGFpbmVyc107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGNvbnRhaW5lciBmcm9tIHRoaXMgc2Vuc29yIGluc3RhbmNlXHJcbiAgICogQHBhcmFtIHsuLi5IVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnMgeW91IHdhbnQgdG8gcmVtb3ZlIGZyb20gdGhpcyBzZW5zb3JcclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUucmVtb3ZlQ29udGFpbmVyKGRvY3VtZW50LmJvZHkpXHJcbiAgICovXHJcbiAgcmVtb3ZlQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcclxuICAgIHRoaXMuY29udGFpbmVycyA9IHRoaXMuY29udGFpbmVycy5maWx0ZXIoY29udGFpbmVyID0+ICFjb250YWluZXJzLmluY2x1ZGVzKGNvbnRhaW5lcikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlcnMgZXZlbnQgb24gdGFyZ2V0IGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byB0cmlnZ2VyIGV2ZW50IG9uXHJcbiAgICogQHBhcmFtIHtTZW5zb3JFdmVudH0gc2Vuc29yRXZlbnQgLSBTZW5zb3IgZXZlbnQgdG8gdHJpZ2dlclxyXG4gICAqL1xyXG4gIHRyaWdnZXIoZWxlbWVudCwgc2Vuc29yRXZlbnQpIHtcclxuICAgIGNvbnN0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbiAgICBldmVudC5kZXRhaWwgPSBzZW5zb3JFdmVudDtcclxuICAgIGV2ZW50LmluaXRFdmVudChzZW5zb3JFdmVudC50eXBlLCB0cnVlLCB0cnVlKTtcclxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB0aGlzLmxhc3RFdmVudCA9IHNlbnNvckV2ZW50O1xyXG5cclxuICAgIHJldHVybiBzZW5zb3JFdmVudDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNlbnNvcjsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBkZWxheSBvZiBlYWNoIHNlbnNvciB0aHJvdWdoIHRoZSBkZWxheSBpbiB0aGUgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfE51bWJlcnxPYmplY3R9IG9wdGlvbnNEZWxheSAtIHRoZSBkZWxheSBpbiB0aGUgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmZ1bmN0aW9uIGNhbGNEZWxheShvcHRpb25zRGVsYXkpIHtcclxuICBjb25zdCBkZWxheSA9IHt9O1xyXG5cclxuICBpZiAob3B0aW9uc0RlbGF5ID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGVmYXVsdERlYWx5KTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2Ygb3B0aW9uc0RlbGF5ID09PSAnbnVtYmVyJykge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdERlYWx5KSB7XHJcbiAgICAgIGlmIChkZWZhdWx0RGVhbHkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgIGRlbGF5W2tleV0gPSBvcHRpb25zRGVsYXk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkZWxheTtcclxuICB9XHJcblxyXG4gIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHREZWFseSkge1xyXG4gICAgaWYgKGRlZmF1bHREZWFseS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgIGlmIChvcHRpb25zRGVsYXlba2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZGVsYXlba2V5XSA9IGRlZmF1bHREZWFseVtrZXldO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRlbGF5W2tleV0gPSBvcHRpb25zRGVsYXlba2V5XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRlbGF5O1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTE3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG4vKipcclxuICogQWxsIGRyYWdnYWJsZSBwbHVnaW5zIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gKiBAYWJzdHJhY3RcclxuICogQGNsYXNzIEFic3RyYWN0UGx1Z2luXHJcbiAqIEBtb2R1bGUgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIEFic3RyYWN0UGx1Z2luIHtcclxuICAvKipcclxuICAgKiBBYnN0cmFjdFBsdWdpbiBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBBYnN0cmFjdFBsdWdpblxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICAgKiBAcHJvcGVydHkgZHJhZ2dhYmxlXHJcbiAgICAgKiBAdHlwZSB7RHJhZ2dhYmxlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYWdnYWJsZSA9IGRyYWdnYWJsZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRlIHRvIGFkZCBsaXN0ZW5lcnNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3ZlcnJpZGUgdG8gcmVtb3ZlIGxpc3RlbmVyc1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0UGx1Z2luO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDExOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG5jb25zdCBjYW5jZWxlZCA9IFN5bWJvbCgnY2FuY2VsZWQnKTtcclxuXHJcbi8qKlxyXG4gKiBBbGwgZXZlbnRzIGZpcmVkIGJ5IGRyYWdnYWJsZSBpbmhlcml0IHRoaXMgY2xhc3MuIFlvdSBjYW4gY2FsbCBgY2FuY2VsKClgIHRvXHJcbiAqIGNhbmNlbCBhIHNwZWNpZmljIGV2ZW50IG9yIHlvdSBjYW4gY2hlY2sgaWYgYW4gZXZlbnQgaGFzIGJlZW4gY2FuY2VsZWQgYnlcclxuICogY2FsbGluZyBgY2FuY2VsZWQoKWAuXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAY2xhc3MgQWJzdHJhY3RFdmVudFxyXG4gKiBAbW9kdWxlIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIEFic3RyYWN0RXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBBYnN0cmFjdEV2ZW50IGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIEFic3RyYWN0RXZlbnRcclxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIEV2ZW50IGRhdGFcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogRXZlbnQgdHlwZVxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcHJvcGVydHkgdHlwZVxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZGF0YSkge1xyXG4gICAgdGhpc1tjYW5jZWxlZF0gPSBmYWxzZTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFkLW9ubHkgdHlwZVxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW50IGNhbmNlbGFibGVcclxuICAgKiBAc3RhdGljXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgdHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnR5cGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFkLW9ubHkgY2FuY2VsYWJsZVxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IGNhbmNlbGFibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jYW5jZWxhYmxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FuY2VscyB0aGUgZXZlbnQgaW5zdGFuY2VcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuICBjYW5jZWwoKSB7XHJcbiAgICB0aGlzW2NhbmNlbGVkXSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBldmVudCBoYXMgYmVlbiBjYW5jZWxlZFxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgY2FuY2VsZWQoKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzW2NhbmNlbGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG5ldyBldmVudCBpbnN0YW5jZSB3aXRoIGV4aXN0aW5nIGV2ZW50IGRhdGEuXHJcbiAgICogVGhpcyBtZXRob2QgYWxsb3dzIGZvciBvdmVycmlkaW5nIG9mIGV2ZW50IGRhdGEuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdEV2ZW50fVxyXG4gICAqL1xyXG4gIGNsb25lKGRhdGEpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihfZXh0ZW5kcyh7fSwgdGhpcy5kYXRhLCBkYXRhKSk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0RXZlbnQ7XHJcbkFic3RyYWN0RXZlbnQudHlwZSA9ICdldmVudCc7XHJcbkFic3RyYWN0RXZlbnQuY2FuY2VsYWJsZSA9IGZhbHNlO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDExOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xyXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG52YXIgJGluY2x1ZGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NykodHJ1ZSk7XHJcblxyXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xyXG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcclxuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcclxuICB9XHJcbn0pO1xyXG5cclxuX193ZWJwYWNrX3JlcXVpcmVfXyg0OSkoJ2luY2x1ZGVzJyk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEyMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDExOSk7XHJcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKS5BcnJheS5pbmNsdWRlcztcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTIxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbnZhciBnZXRLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgaXNFbnVtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSkuZjtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXNFbnRyaWVzKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xyXG4gICAgdmFyIE8gPSB0b0lPYmplY3QoaXQpO1xyXG4gICAgdmFyIGtleXMgPSBnZXRLZXlzKE8pO1xyXG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgdmFyIGtleTtcclxuICAgIHdoaWxlIChsZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoTywga2V5ID0ga2V5c1tpKytdKSkge1xyXG4gICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcclxuICAgIH0gcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMjIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXHJcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciAkdmFsdWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjEpKGZhbHNlKTtcclxuXHJcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xyXG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGl0KSB7XHJcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XHJcbiAgfVxyXG59KTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTIzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbl9fd2VicGFja19yZXF1aXJlX18oMTIyKTtcclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLk9iamVjdC52YWx1ZXM7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEyNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcclxudmFyIGdldEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIGdPUFMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcclxudmFyIHBJRSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcclxudmFyIElPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcclxudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xyXG5cclxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXHJcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygyMykoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBBID0ge307XHJcbiAgdmFyIEIgPSB7fTtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcclxuICB2YXIgUyA9IFN5bWJvbCgpO1xyXG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcclxuICBBW1NdID0gNztcclxuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcclxuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcclxufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcclxuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgdmFyIGluZGV4ID0gMTtcclxuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcclxuICB2YXIgaXNFbnVtID0gcElFLmY7XHJcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xyXG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XHJcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XHJcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICB2YXIgaiA9IDA7XHJcbiAgICB2YXIga2V5O1xyXG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XHJcbiAgfSByZXR1cm4gVDtcclxufSA6ICRhc3NpZ247XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEyNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4vLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxyXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG5cclxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogX193ZWJwYWNrX3JlcXVpcmVfXygxMjQpIH0pO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMjYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuX193ZWJwYWNrX3JlcXVpcmVfXygxMjUpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMikuT2JqZWN0LmFzc2lnbjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTI3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oMCkoJ2l0ZXJhdG9yJyk7XHJcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcclxuXHJcbnRyeSB7XHJcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xyXG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxyXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XHJcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcclxuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcclxuICB2YXIgc2FmZSA9IGZhbHNlO1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgYXJyID0gWzddO1xyXG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XHJcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XHJcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcclxuICAgIGV4ZWMoYXJyKTtcclxuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cclxuICByZXR1cm4gc2FmZTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTI4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG52YXIgU1BFQ0lFUyA9IF9fd2VicGFja19yZXF1aXJlX18oMCkoJ3NwZWNpZXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xyXG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XHJcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XHJcbiAgfSk7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEyOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcclxuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEzMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcclxuICBhbk9iamVjdChDKTtcclxuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XHJcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcclxuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XHJcbiAgcmVzb2x2ZSh4KTtcclxuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTMxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgbmF2aWdhdG9yID0gZ2xvYmFsLm5hdmlnYXRvcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEzMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiB7IGU6IGZhbHNlLCB2OiBleGVjKCkgfTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4geyBlOiB0cnVlLCB2OiBlIH07XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMzMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBtYWNyb3Rhc2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KS5zZXQ7XHJcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xyXG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xyXG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xyXG52YXIgaXNOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCkocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcclxuXHJcbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHBhcmVudCwgZm47XHJcbiAgICBpZiAoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XHJcbiAgICB3aGlsZSAoaGVhZCkge1xyXG4gICAgICBmbiA9IGhlYWQuZm47XHJcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZm4oKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcclxuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgICAgfVxyXG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XHJcbiAgfTtcclxuXHJcbiAgLy8gTm9kZS5qc1xyXG4gIGlmIChpc05vZGUpIHtcclxuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XHJcbiAgICB9O1xyXG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyBTYWZhcmkgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XHJcbiAgfSBlbHNlIGlmIChPYnNlcnZlciAmJiAhKGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci5zdGFuZGFsb25lKSkge1xyXG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XHJcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcclxuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XHJcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XHJcbiAgICB9O1xyXG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXHJcbiAgfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xyXG4gICAgLy8gUHJvbWlzZS5yZXNvbHZlIHdpdGhvdXQgYW4gYXJndW1lbnQgdGhyb3dzIGFuIGVycm9yIGluIExHIFdlYk9TIDJcclxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XHJcbiAgICB9O1xyXG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XHJcbiAgLy8gLSBzZXRJbW1lZGlhdGVcclxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXHJcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xyXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXHJcbiAgLy8gLSBzZXRUaW1lb3V0XHJcbiAgfSBlbHNlIHtcclxuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxyXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcclxuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xyXG4gICAgaWYgKCFoZWFkKSB7XHJcbiAgICAgIGhlYWQgPSB0YXNrO1xyXG4gICAgICBub3RpZnkoKTtcclxuICAgIH0gbGFzdCA9IHRhc2s7XHJcbiAgfTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTM0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgYXJncywgdGhhdCkge1xyXG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcclxuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XHJcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcclxuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcclxuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcclxuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcclxuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcclxuICB9IHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTM1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxyXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgYUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XHJcbnZhciBTUEVDSUVTID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKSgnc3BlY2llcycpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XHJcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcclxuICB2YXIgUztcclxuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEzNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xyXG52YXIgSVRFUkFUT1IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKCdpdGVyYXRvcicpO1xyXG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xyXG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cclxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cclxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEzNyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXHJcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxudmFyIElURVJBVE9SID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKSgnaXRlcmF0b3InKTtcclxudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xyXG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEzOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4vLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXHJcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcclxuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XHJcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XHJcbiAgICB0aHJvdyBlO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTM5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbnZhciBjdHggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcclxudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzOCk7XHJcbnZhciBpc0FycmF5SXRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTM3KTtcclxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XHJcbnZhciBnZXRJdGVyRm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNik7XHJcbnZhciBCUkVBSyA9IHt9O1xyXG52YXIgUkVUVVJOID0ge307XHJcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xyXG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcclxuICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKTtcclxuICB2YXIgaW5kZXggPSAwO1xyXG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XHJcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XHJcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXHJcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcclxuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcclxuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xyXG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XHJcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcclxuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxufTtcclxuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xyXG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTQwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcclxuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpIHtcclxuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XHJcbiAgfSByZXR1cm4gaXQ7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE0MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBMSUJSQVJZID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgY3R4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XHJcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XHJcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcclxudmFyIGFuSW5zdGFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCk7XHJcbnZhciBmb3JPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTM5KTtcclxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTM1KTtcclxudmFyIHRhc2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KS5zZXQ7XHJcbnZhciBtaWNyb3Rhc2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMykoKTtcclxudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XHJcbnZhciBwZXJmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzIpO1xyXG52YXIgdXNlckFnZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzEpO1xyXG52YXIgcHJvbWlzZVJlc29sdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMCk7XHJcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xyXG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcclxudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcclxudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zO1xyXG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52OCB8fCAnJztcclxudmFyICRQcm9taXNlID0gZ2xvYmFsW1BST01JU0VdO1xyXG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XHJcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcclxudmFyIEludGVybmFsLCBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIE93blByb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xyXG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xyXG5cclxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHtcclxuICB0cnkge1xyXG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XHJcbiAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7XHJcbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtfX3dlYnBhY2tfcmVxdWlyZV9fKDApKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcclxuICAgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xyXG4gICAgfTtcclxuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcclxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlXHJcbiAgICAgIC8vIHY4IDYuNiAoTm9kZSAxMCBhbmQgQ2hyb21lIDY2KSBoYXZlIGEgYnVnIHdpdGggcmVzb2x2aW5nIGN1c3RvbSB0aGVuYWJsZXNcclxuICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XHJcbiAgICAgIC8vIHdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXHJcbiAgICAgICYmIHY4LmluZGV4T2YoJzYuNicpICE9PSAwXHJcbiAgICAgICYmIHVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUvNjYnKSA9PT0gLTE7XHJcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XHJcbn0oKTtcclxuXHJcbi8vIGhlbHBlcnNcclxudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcclxuICB2YXIgdGhlbjtcclxuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XHJcbn07XHJcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAocHJvbWlzZSwgaXNSZWplY3QpIHtcclxuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xyXG4gIHByb21pc2UuX24gPSB0cnVlO1xyXG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XHJcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XHJcbiAgICB2YXIgb2sgPSBwcm9taXNlLl9zID09IDE7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XHJcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XHJcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcclxuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcclxuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcclxuICAgICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChoYW5kbGVyKSB7XHJcbiAgICAgICAgICBpZiAoIW9rKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9oID09IDIpIG9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xyXG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIG1heSB0aHJvd1xyXG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XHJcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcclxuICAgICAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XHJcbiAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcclxuICAgIHByb21pc2UuX2MgPSBbXTtcclxuICAgIHByb21pc2UuX24gPSBmYWxzZTtcclxuICAgIGlmIChpc1JlamVjdCAmJiAhcHJvbWlzZS5faCkgb25VbmhhbmRsZWQocHJvbWlzZSk7XHJcbiAgfSk7XHJcbn07XHJcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XHJcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcclxuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcclxuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XHJcbiAgICBpZiAodW5oYW5kbGVkKSB7XHJcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChpc05vZGUpIHtcclxuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikge1xyXG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcclxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xyXG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKHVuaGFuZGxlZCAmJiByZXN1bHQuZSkgdGhyb3cgcmVzdWx0LnY7XHJcbiAgfSk7XHJcbn07XHJcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XHJcbiAgcmV0dXJuIHByb21pc2UuX2ggIT09IDEgJiYgKHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYykubGVuZ3RoID09PSAwO1xyXG59O1xyXG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xyXG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBoYW5kbGVyO1xyXG4gICAgaWYgKGlzTm9kZSkge1xyXG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcclxuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpIHtcclxuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcclxuICAgIH1cclxuICB9KTtcclxufTtcclxudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICB2YXIgcHJvbWlzZSA9IHRoaXM7XHJcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcclxuICBwcm9taXNlLl9kID0gdHJ1ZTtcclxuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcclxuICBwcm9taXNlLl92ID0gdmFsdWU7XHJcbiAgcHJvbWlzZS5fcyA9IDI7XHJcbiAgaWYgKCFwcm9taXNlLl9hKSBwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xyXG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcclxufTtcclxudmFyICRyZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xyXG4gIHZhciB0aGVuO1xyXG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XHJcbiAgcHJvbWlzZS5fZCA9IHRydWU7XHJcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXHJcbiAgdHJ5IHtcclxuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XHJcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XHJcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XHJcbiAgICAgIHByb21pc2UuX3MgPSAxO1xyXG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcclxuICB9XHJcbn07XHJcblxyXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxyXG5pZiAoIVVTRV9OQVRJVkUpIHtcclxuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxyXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xyXG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XHJcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xyXG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XHJcbiAgICB9XHJcbiAgfTtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcclxuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcclxuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXHJcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXHJcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXHJcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcclxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcclxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcclxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XHJcbiAgfTtcclxuICBJbnRlcm5hbC5wcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyOSkoJFByb21pc2UucHJvdG90eXBlLCB7XHJcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxyXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xyXG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcclxuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcclxuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcclxuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XHJcbiAgICAgIGlmICh0aGlzLl9hKSB0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xyXG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcclxuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XHJcbiAgICB9LFxyXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcclxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcclxuICAgIH1cclxuICB9KTtcclxuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XHJcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xyXG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcclxuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xyXG4gIH07XHJcbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcclxuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXHJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXHJcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xyXG4gIH07XHJcbn1cclxuXHJcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XHJcbl9fd2VicGFja19yZXF1aXJlX18oMjUpKCRQcm9taXNlLCBQUk9NSVNFKTtcclxuX193ZWJwYWNrX3JlcXVpcmVfXygxMjgpKFBST01JU0UpO1xyXG5XcmFwcGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKVtQUk9NSVNFXTtcclxuXHJcbi8vIHN0YXRpY3NcclxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xyXG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXHJcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xyXG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcclxuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xyXG4gICAgJCRyZWplY3Qocik7XHJcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xyXG4gIH1cclxufSk7XHJcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XHJcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXHJcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XHJcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoTElCUkFSWSAmJiB0aGlzID09PSBXcmFwcGVyID8gJFByb21pc2UgOiB0aGlzLCB4KTtcclxuICB9XHJcbn0pO1xyXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNykoZnVuY3Rpb24gKGl0ZXIpIHtcclxuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xyXG59KSksIFBST01JU0UsIHtcclxuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcclxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xyXG4gICAgdmFyIEMgPSB0aGlzO1xyXG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcclxuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xyXG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xyXG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xyXG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XHJcbiAgICAgICAgdmFyICRpbmRleCA9IGluZGV4Kys7XHJcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xyXG4gICAgICAgIHJlbWFpbmluZysrO1xyXG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcclxuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcclxuICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICB9KTtcclxuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XHJcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xyXG4gIH0sXHJcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxyXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcclxuICAgIHZhciBDID0gdGhpcztcclxuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XHJcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XHJcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcclxuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XHJcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xyXG4gIH1cclxufSk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE0MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xyXG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE0MyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XHJcbnZhciBzdGVwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDIpO1xyXG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5cclxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxyXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxyXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXHJcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxyXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTEpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcclxuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XHJcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcclxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxyXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcclxufSwgZnVuY3Rpb24gKCkge1xyXG4gIHZhciBPID0gdGhpcy5fdDtcclxuICB2YXIga2luZCA9IHRoaXMuX2s7XHJcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xyXG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcclxuICAgIHJldHVybiBzdGVwKDEpO1xyXG4gIH1cclxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcclxuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xyXG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcclxufSwgJ3ZhbHVlcycpO1xyXG5cclxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxyXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xyXG5cclxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xyXG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcclxuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNDQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxudmFyICRpdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0Myk7XHJcbnZhciBnZXRLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG52YXIgd2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xyXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcclxudmFyIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5O1xyXG5cclxudmFyIERPTUl0ZXJhYmxlcyA9IHtcclxuICBDU1NSdWxlTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXHJcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogZmFsc2UsXHJcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcclxuICBDbGllbnRSZWN0TGlzdDogZmFsc2UsXHJcbiAgRE9NUmVjdExpc3Q6IGZhbHNlLFxyXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxyXG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcclxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogZmFsc2UsXHJcbiAgRmlsZUxpc3Q6IGZhbHNlLFxyXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiBmYWxzZSxcclxuICBIVE1MQ29sbGVjdGlvbjogZmFsc2UsXHJcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcclxuICBIVE1MU2VsZWN0RWxlbWVudDogZmFsc2UsXHJcbiAgTWVkaWFMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cclxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcclxuICBOYW1lZE5vZGVNYXA6IGZhbHNlLFxyXG4gIE5vZGVMaXN0OiB0cnVlLFxyXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxyXG4gIFBsdWdpbjogZmFsc2UsXHJcbiAgUGx1Z2luQXJyYXk6IGZhbHNlLFxyXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxyXG4gIFNWR051bWJlckxpc3Q6IGZhbHNlLFxyXG4gIFNWR1BhdGhTZWdMaXN0OiBmYWxzZSxcclxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxyXG4gIFNWR1N0cmluZ0xpc3Q6IGZhbHNlLFxyXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IGZhbHNlLFxyXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxyXG4gIFN0eWxlU2hlZXRMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cclxuICBUZXh0VHJhY2tDdWVMaXN0OiBmYWxzZSxcclxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcclxuICBUb3VjaExpc3Q6IGZhbHNlXHJcbn07XHJcblxyXG5mb3IgKHZhciBjb2xsZWN0aW9ucyA9IGdldEtleXMoRE9NSXRlcmFibGVzKSwgaSA9IDA7IGkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gIHZhciBOQU1FID0gY29sbGVjdGlvbnNbaV07XHJcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xyXG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xyXG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XHJcbiAgdmFyIGtleTtcclxuICBpZiAocHJvdG8pIHtcclxuICAgIGlmICghcHJvdG9bSVRFUkFUT1JdKSBoaWRlKHByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xyXG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XHJcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcclxuICAgIGlmIChleHBsaWNpdCkgZm9yIChrZXkgaW4gJGl0ZXJhdG9ycykgaWYgKCFwcm90b1trZXldKSByZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNDUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcclxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcclxudmFyIElFX1BST1RPID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMykoJ0lFX1BST1RPJyk7XHJcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xyXG4gIE8gPSB0b09iamVjdChPKTtcclxuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xyXG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XHJcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XHJcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTQ2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xyXG52YXIgZGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xyXG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcclxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XHJcblxyXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEwKShJdGVyYXRvclByb3RvdHlwZSwgX193ZWJwYWNrX3JlcXVpcmVfXygwKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xyXG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xyXG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNDcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcclxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xyXG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XHJcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcclxuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XHJcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xyXG4gICAgdmFyIGEsIGI7XHJcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XHJcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcclxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcclxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XHJcbiAgfTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTQ4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyICRhdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ3KSh0cnVlKTtcclxuXHJcbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcclxuX193ZWJwYWNrX3JlcXVpcmVfXyg1MSkoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XHJcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxyXG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XHJcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcclxufSwgZnVuY3Rpb24gKCkge1xyXG4gIHZhciBPID0gdGhpcy5fdDtcclxuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xyXG4gIHZhciBwb2ludDtcclxuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcclxuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XHJcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XHJcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xyXG59KTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTQ5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbl9fd2VicGFja19yZXF1aXJlX18oNTIpO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE0OCk7XHJcbl9fd2VicGFja19yZXF1aXJlX18oMTQ0KTtcclxuX193ZWJwYWNrX3JlcXVpcmVfXygxNDEpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMikuUHJvbWlzZTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTUwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbnZhciBwSUUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxudmFyIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcclxudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xyXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XHJcblxyXG5leHBvcnRzLmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xyXG4gIE8gPSB0b0lPYmplY3QoTyk7XHJcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xyXG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcclxuICAgIHJldHVybiBnT1BEKE8sIFApO1xyXG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxyXG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTUxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcclxudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciBnT1BOID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MykuZjtcclxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XHJcblxyXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xyXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xyXG5cclxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBnT1BOKGl0KTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xyXG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE1MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG52YXIgZFAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgZ2V0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XHJcbiAgYW5PYmplY3QoTyk7XHJcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xyXG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcclxuICB2YXIgaSA9IDA7XHJcbiAgdmFyIFA7XHJcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XHJcbiAgcmV0dXJuIE87XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE1MyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4vLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxyXG52YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xyXG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNTQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG52YXIgbWF4ID0gTWF0aC5tYXg7XHJcbnZhciBtaW4gPSBNYXRoLm1pbjtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xyXG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcclxuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTU1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXHJcbnZhciBnZXRLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBnT1BTID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XHJcbnZhciBwSUUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcclxuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XHJcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XHJcbiAgaWYgKGdldFN5bWJvbHMpIHtcclxuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XHJcbiAgICB2YXIgaXNFbnVtID0gcElFLmY7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIga2V5O1xyXG4gICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKSByZXN1bHQucHVzaChrZXkpO1xyXG4gIH0gcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTU2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBMSUJSQVJZID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcbnZhciB3a3NFeHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcclxudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KS5mO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcclxuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE1NyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG52YXIgTUVUQSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpKCdtZXRhJyk7XHJcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxudmFyIHNldERlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLmY7XHJcbnZhciBpZCA9IDA7XHJcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxudmFyIEZSRUVaRSA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKShmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcclxufSk7XHJcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XHJcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xyXG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXHJcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xyXG4gIH0gfSk7XHJcbn07XHJcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcclxuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XHJcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XHJcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XHJcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxyXG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xyXG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcclxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xyXG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcclxuICAgIHNldE1ldGEoaXQpO1xyXG4gIC8vIHJldHVybiBvYmplY3QgSURcclxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xyXG59O1xyXG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XHJcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XHJcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxyXG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcclxuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXHJcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcclxuICAgIHNldE1ldGEoaXQpO1xyXG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXHJcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcclxufTtcclxuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXHJcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xyXG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xyXG4gIHJldHVybiBpdDtcclxufTtcclxudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICBLRVk6IE1FVEEsXHJcbiAgTkVFRDogZmFsc2UsXHJcbiAgZmFzdEtleTogZmFzdEtleSxcclxuICBnZXRXZWFrOiBnZXRXZWFrLFxyXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNTggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXHJcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxudmFyIE1FVEEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NykuS0VZO1xyXG52YXIgJGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcclxudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XHJcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxudmFyIHdrcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciB3a3NFeHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcclxudmFyIHdrc0RlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTU2KTtcclxudmFyIGVudW1LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTUpO1xyXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUzKTtcclxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xyXG52YXIgY3JlYXRlRGVzYyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xyXG52YXIgX2NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xyXG52YXIgZ09QTkV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUxKTtcclxudmFyICRHT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTApO1xyXG52YXIgJERQID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxudmFyICRrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBnT1BEID0gJEdPUEQuZjtcclxudmFyIGRQID0gJERQLmY7XHJcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xyXG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XHJcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xyXG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcclxudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xyXG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XHJcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XHJcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcclxudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcclxudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcclxudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xyXG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcclxudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xyXG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xyXG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcclxudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XHJcblxyXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcclxudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcclxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cclxuICB9KSkuYSAhPSA3O1xyXG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XHJcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XHJcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XHJcbiAgZFAoaXQsIGtleSwgRCk7XHJcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XHJcbn0gOiBkUDtcclxuXHJcbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xyXG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XHJcbiAgc3ltLl9rID0gdGFnO1xyXG4gIHJldHVybiBzeW07XHJcbn07XHJcblxyXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcclxufSA6IGZ1bmN0aW9uIChpdCkge1xyXG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XHJcbn07XHJcblxyXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xyXG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XHJcbiAgYW5PYmplY3QoaXQpO1xyXG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XHJcbiAgYW5PYmplY3QoRCk7XHJcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XHJcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xyXG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xyXG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xyXG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xyXG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcclxuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcclxufTtcclxudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xyXG4gIGFuT2JqZWN0KGl0KTtcclxuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xyXG4gIHZhciBpID0gMDtcclxuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xyXG4gIHZhciBrZXk7XHJcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcclxuICByZXR1cm4gaXQ7XHJcbn07XHJcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XHJcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xyXG59O1xyXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XHJcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcclxuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcclxuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XHJcbn07XHJcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcclxuICBpdCA9IHRvSU9iamVjdChpdCk7XHJcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcclxuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XHJcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xyXG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XHJcbiAgcmV0dXJuIEQ7XHJcbn07XHJcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcclxuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xyXG4gIHZhciByZXN1bHQgPSBbXTtcclxuICB2YXIgaSA9IDA7XHJcbiAgdmFyIGtleTtcclxuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xyXG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcclxuICB9IHJldHVybiByZXN1bHQ7XHJcbn07XHJcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XHJcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xyXG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcclxuICB2YXIgcmVzdWx0ID0gW107XHJcbiAgdmFyIGkgPSAwO1xyXG4gIHZhciBrZXk7XHJcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcclxuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XHJcbiAgfSByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXHJcbmlmICghVVNFX05BVElWRSkge1xyXG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XHJcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xyXG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XHJcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcclxuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XHJcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XHJcbiAgICB9O1xyXG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xyXG4gICAgcmV0dXJuIHdyYXAodGFnKTtcclxuICB9O1xyXG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faztcclxuICB9KTtcclxuXHJcbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XHJcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XHJcbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg1MykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xyXG4gIF9fd2VicGFja19yZXF1aXJlX18oMTkpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XHJcbiAgX193ZWJwYWNrX3JlcXVpcmVfXygzMSkuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XHJcblxyXG4gIGlmIChERVNDUklQVE9SUyAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXygyMSkpIHtcclxuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcclxuICB9O1xyXG59XHJcblxyXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTtcclxuXHJcbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXHJcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcclxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXHJcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XHJcblxyXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xyXG5cclxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcclxuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcclxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxyXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cclxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xyXG4gIH0sXHJcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXHJcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XHJcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcclxuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcclxuICB9LFxyXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LFxyXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxyXG59KTtcclxuXHJcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XHJcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxyXG4gIGNyZWF0ZTogJGNyZWF0ZSxcclxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcclxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxyXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXHJcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXHJcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxyXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcclxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxyXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxyXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcclxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcclxufSk7XHJcblxyXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcclxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgUyA9ICRTeW1ib2woKTtcclxuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxyXG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxyXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXHJcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xyXG59KSksICdKU09OJywge1xyXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XHJcbiAgICB2YXIgYXJncyA9IFtpdF07XHJcbiAgICB2YXIgaSA9IDE7XHJcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcclxuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcclxuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcclxuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcclxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XHJcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XHJcbiAgfVxyXG59KTtcclxuXHJcbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcclxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygxMCkoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcclxuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxyXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XHJcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cclxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcclxuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cclxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE1OSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE1OCk7XHJcbl9fd2VicGFja19yZXF1aXJlX18oNTIpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMikuU3ltYm9sO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNjAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuUGx1Z2lucyA9IGV4cG9ydHMuU2Vuc29ycyA9IGV4cG9ydHMuU29ydGFibGUgPSBleHBvcnRzLlN3YXBwYWJsZSA9IGV4cG9ydHMuRHJvcHBhYmxlID0gZXhwb3J0cy5EcmFnZ2FibGUgPSBleHBvcnRzLkJhc2VQbHVnaW4gPSBleHBvcnRzLkJhc2VFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbl9fd2VicGFja19yZXF1aXJlX18oMTU5KTtcclxuXHJcbl9fd2VicGFja19yZXF1aXJlX18oMTQ5KTtcclxuXHJcbl9fd2VicGFja19yZXF1aXJlX18oMTI2KTtcclxuXHJcbl9fd2VicGFja19yZXF1aXJlX18oMTIzKTtcclxuXHJcbl9fd2VicGFja19yZXF1aXJlX18oMTIwKTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxudmFyIF9TZW5zb3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XHJcblxyXG52YXIgU2Vuc29ycyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9TZW5zb3JzKTtcclxuXHJcbnZhciBfUGx1Z2lucyA9IF9fd2VicGFja19yZXF1aXJlX18oOTgpO1xyXG5cclxudmFyIFBsdWdpbnMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfUGx1Z2lucyk7XHJcblxyXG52YXIgX0RyYWdnYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xyXG5cclxudmFyIF9EcmFnZ2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ2dhYmxlKTtcclxuXHJcbnZhciBfRHJvcHBhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XHJcblxyXG52YXIgX0Ryb3BwYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ecm9wcGFibGUpO1xyXG5cclxudmFyIF9Td2FwcGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcclxuXHJcbnZhciBfU3dhcHBhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N3YXBwYWJsZSk7XHJcblxyXG52YXIgX1NvcnRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XHJcblxyXG52YXIgX1NvcnRhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NvcnRhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5CYXNlRXZlbnQgPSBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdDtcclxuZXhwb3J0cy5CYXNlUGx1Z2luID0gX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0O1xyXG5leHBvcnRzLkRyYWdnYWJsZSA9IF9EcmFnZ2FibGUyLmRlZmF1bHQ7XHJcbmV4cG9ydHMuRHJvcHBhYmxlID0gX0Ryb3BwYWJsZTIuZGVmYXVsdDtcclxuZXhwb3J0cy5Td2FwcGFibGUgPSBfU3dhcHBhYmxlMi5kZWZhdWx0O1xyXG5leHBvcnRzLlNvcnRhYmxlID0gX1NvcnRhYmxlMi5kZWZhdWx0O1xyXG5leHBvcnRzLlNlbnNvcnMgPSBTZW5zb3JzO1xyXG5leHBvcnRzLlBsdWdpbnMgPSBQbHVnaW5zO1xyXG5cclxuLyoqKi8gfSlcclxuLyoqKioqKi8gXSk7XHJcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@shopify/draggable/lib/draggable.bundle.legacy.js\n");

/***/ }),

/***/ "./node_modules/@shopify/draggable/lib/draggable.js":
/*!**********************************************************!*\
  !*** ./node_modules/@shopify/draggable/lib/draggable.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(true)\r\n\t\tmodule.exports = factory();\r\n\telse {}\r\n})(window, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __nested_webpack_require_571__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId]) {\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_571__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__nested_webpack_require_571__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__nested_webpack_require_571__.c = installedModules;\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__nested_webpack_require_571__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__nested_webpack_require_571__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// define __esModule on exports\r\n/******/ \t__nested_webpack_require_571__.r = function(exports) {\r\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\r\n/******/ \t\t}\r\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\r\n/******/ \t};\r\n/******/\r\n/******/ \t// create a fake namespace object\r\n/******/ \t// mode & 1: value is a module id, require it\r\n/******/ \t// mode & 2: merge all properties of value into the ns\r\n/******/ \t// mode & 4: return value when already ns object\r\n/******/ \t// mode & 8|1: behave like require\r\n/******/ \t__nested_webpack_require_571__.t = function(value, mode) {\r\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_571__(value);\r\n/******/ \t\tif(mode & 8) return value;\r\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\r\n/******/ \t\tvar ns = Object.create(null);\r\n/******/ \t\t__nested_webpack_require_571__.r(ns);\r\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\r\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_571__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\r\n/******/ \t\treturn ns;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__nested_webpack_require_571__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__nested_webpack_require_571__.d(getter, 'a', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__nested_webpack_require_571__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__nested_webpack_require_571__.p = \"\";\r\n/******/\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __nested_webpack_require_571__(__nested_webpack_require_571__.s = 44);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __nested_webpack_require_4119__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SensorEvent = __nested_webpack_require_4119__(18);\r\n\r\nObject.keys(_SensorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SensorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports, __nested_webpack_require_4586__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_4586__(21);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Sensor2.default;\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports, __nested_webpack_require_4985__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_4985__(29);\r\n\r\nObject.defineProperty(exports, 'closest', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_closest).default;\r\n  }\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_4985__(27);\r\n\r\nObject.defineProperty(exports, 'requestNextAnimationFrame', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_requestNextAnimationFrame).default;\r\n  }\r\n});\r\n\r\nvar _distance = __nested_webpack_require_4985__(25);\r\n\r\nObject.defineProperty(exports, 'distance', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_distance).default;\r\n  }\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_4985__(23);\r\n\r\nObject.defineProperty(exports, 'touchCoords', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_touchCoords).default;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports, __nested_webpack_require_6109__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_6109__(38);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractPlugin2.default;\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports, __nested_webpack_require_6540__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractEvent = __nested_webpack_require_6540__(42);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractEvent2.default;\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports, __nested_webpack_require_6967__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_6967__(1);\r\n\r\nObject.defineProperty(exports, 'Sensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Sensor).default;\r\n  }\r\n});\r\n\r\nvar _MouseSensor = __nested_webpack_require_6967__(20);\r\n\r\nObject.defineProperty(exports, 'MouseSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_MouseSensor).default;\r\n  }\r\n});\r\n\r\nvar _TouchSensor = __nested_webpack_require_6967__(17);\r\n\r\nObject.defineProperty(exports, 'TouchSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_TouchSensor).default;\r\n  }\r\n});\r\n\r\nvar _DragSensor = __nested_webpack_require_6967__(15);\r\n\r\nObject.defineProperty(exports, 'DragSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_DragSensor).default;\r\n  }\r\n});\r\n\r\nvar _ForceTouchSensor = __nested_webpack_require_6967__(13);\r\n\r\nObject.defineProperty(exports, 'ForceTouchSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_ForceTouchSensor).default;\r\n  }\r\n});\r\n\r\nvar _SensorEvent = __nested_webpack_require_6967__(0);\r\n\r\nObject.keys(_SensorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SensorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports, __nested_webpack_require_8573__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Announcement = __nested_webpack_require_8573__(40);\r\n\r\nObject.defineProperty(exports, 'Announcement', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Announcement).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultAnnouncementOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Announcement.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Focusable = __nested_webpack_require_8573__(37);\r\n\r\nObject.defineProperty(exports, 'Focusable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Focusable).default;\r\n  }\r\n});\r\n\r\nvar _Mirror = __nested_webpack_require_8573__(35);\r\n\r\nObject.defineProperty(exports, 'Mirror', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Mirror).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultMirrorOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Mirror.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Scrollable = __nested_webpack_require_8573__(31);\r\n\r\nObject.defineProperty(exports, 'Scrollable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Scrollable).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultScrollableOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Scrollable.defaultOptions;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports, __nested_webpack_require_10116__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DraggableEvent = __nested_webpack_require_10116__(41);\r\n\r\nObject.keys(_DraggableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DraggableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ (function(module, exports, __nested_webpack_require_10592__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragEvent = __nested_webpack_require_10592__(43);\r\n\r\nObject.keys(_DragEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DragEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * The Emitter is a simple emitter class that provides you with `on()`, `off()` and `trigger()` methods\r\n * @class Emitter\r\n * @module Emitter\r\n */\r\nclass Emitter {\r\n  constructor() {\r\n    this.callbacks = {};\r\n  }\r\n\r\n  /**\r\n   * Registers callbacks by event name\r\n   * @param {String} type\r\n   * @param {...Function} callbacks\r\n   */\r\n  on(type, ...callbacks) {\r\n    if (!this.callbacks[type]) {\r\n      this.callbacks[type] = [];\r\n    }\r\n\r\n    this.callbacks[type].push(...callbacks);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Unregisters callbacks by event name\r\n   * @param {String} type\r\n   * @param {Function} callback\r\n   */\r\n  off(type, callback) {\r\n    if (!this.callbacks[type]) {\r\n      return null;\r\n    }\r\n\r\n    const copy = this.callbacks[type].slice(0);\r\n\r\n    for (let i = 0; i < copy.length; i++) {\r\n      if (callback === copy[i]) {\r\n        this.callbacks[type].splice(i, 1);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Triggers event callbacks by event object\r\n   * @param {AbstractEvent} event\r\n   */\r\n  trigger(event) {\r\n    if (!this.callbacks[event.type]) {\r\n      return null;\r\n    }\r\n\r\n    const callbacks = [...this.callbacks[event.type]];\r\n    const caughtErrors = [];\r\n\r\n    for (let i = callbacks.length - 1; i >= 0; i--) {\r\n      const callback = callbacks[i];\r\n\r\n      try {\r\n        callback(event);\r\n      } catch (error) {\r\n        caughtErrors.push(error);\r\n      }\r\n    }\r\n\r\n    if (caughtErrors.length) {\r\n      /* eslint-disable no-console */\r\n      console.error(`Draggable caught errors while triggering '${event.type}'`, caughtErrors);\r\n      /* eslint-disable no-console */\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\nexports.default = Emitter;\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ (function(module, exports, __nested_webpack_require_12917__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Emitter = __nested_webpack_require_12917__(9);\r\n\r\nvar _Emitter2 = _interopRequireDefault(_Emitter);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Emitter2.default;\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ (function(module, exports, __nested_webpack_require_13320__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _utils = __nested_webpack_require_13320__(2);\r\n\r\nvar _Plugins = __nested_webpack_require_13320__(6);\r\n\r\nvar _Emitter = __nested_webpack_require_13320__(10);\r\n\r\nvar _Emitter2 = _interopRequireDefault(_Emitter);\r\n\r\nvar _Sensors = __nested_webpack_require_13320__(5);\r\n\r\nvar _DraggableEvent = __nested_webpack_require_13320__(7);\r\n\r\nvar _DragEvent = __nested_webpack_require_13320__(8);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragMove = Symbol('onDragMove');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst onDragPressure = Symbol('onDragPressure');\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['drag:start']\r\n * @const {Function} defaultAnnouncements['drag:stop']\r\n */\r\nconst defaultAnnouncements = {\r\n  'drag:start': event => `Picked up ${event.source.textContent.trim() || event.source.id || 'draggable element'}`,\r\n  'drag:stop': event => `Released ${event.source.textContent.trim() || event.source.id || 'draggable element'}`\r\n};\r\n\r\nconst defaultClasses = {\r\n  'container:dragging': 'draggable-container--is-dragging',\r\n  'source:dragging': 'draggable-source--is-dragging',\r\n  'source:placed': 'draggable-source--placed',\r\n  'container:placed': 'draggable-container--placed',\r\n  'body:dragging': 'draggable--is-dragging',\r\n  'draggable:over': 'draggable--over',\r\n  'container:over': 'draggable-container--over',\r\n  'source:original': 'draggable--original',\r\n  mirror: 'draggable-mirror'\r\n};\r\n\r\nconst defaultOptions = exports.defaultOptions = {\r\n  draggable: '.draggable-source',\r\n  handle: null,\r\n  delay: {},\r\n  distance: 0,\r\n  placedTimeout: 800,\r\n  plugins: [],\r\n  sensors: [],\r\n  exclude: {\r\n    plugins: [],\r\n    sensors: []\r\n  }\r\n};\r\n\r\n/**\r\n * This is the core draggable library that does the heavy lifting\r\n * @class Draggable\r\n * @module Draggable\r\n */\r\nclass Draggable {\r\n\r\n  /**\r\n   * Draggable constructor.\r\n   * @constructs Draggable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Draggable containers\r\n   * @param {Object} options - Options for draggable\r\n   */\r\n\r\n  /**\r\n   * Default plugins draggable uses\r\n   * @static\r\n   * @property {Object} Plugins\r\n   * @property {Announcement} Plugins.Announcement\r\n   * @property {Focusable} Plugins.Focusable\r\n   * @property {Mirror} Plugins.Mirror\r\n   * @property {Scrollable} Plugins.Scrollable\r\n   * @type {Object}\r\n   */\r\n  constructor(containers = [document.body], options = {}) {\r\n    /**\r\n     * Draggable containers\r\n     * @property containers\r\n     * @type {HTMLElement[]}\r\n     */\r\n    if (containers instanceof NodeList || containers instanceof Array) {\r\n      this.containers = [...containers];\r\n    } else if (containers instanceof HTMLElement) {\r\n      this.containers = [containers];\r\n    } else {\r\n      throw new Error('Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`');\r\n    }\r\n\r\n    this.options = _extends({}, defaultOptions, options, {\r\n      classes: _extends({}, defaultClasses, options.classes || {}),\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {}),\r\n      exclude: {\r\n        plugins: options.exclude && options.exclude.plugins || [],\r\n        sensors: options.exclude && options.exclude.sensors || []\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Draggables event emitter\r\n     * @property emitter\r\n     * @type {Emitter}\r\n     */\r\n    this.emitter = new _Emitter2.default();\r\n\r\n    /**\r\n     * Current drag state\r\n     * @property dragging\r\n     * @type {Boolean}\r\n     */\r\n    this.dragging = false;\r\n\r\n    /**\r\n     * Active plugins\r\n     * @property plugins\r\n     * @type {Plugin[]}\r\n     */\r\n    this.plugins = [];\r\n\r\n    /**\r\n     * Active sensors\r\n     * @property sensors\r\n     * @type {Sensor[]}\r\n     */\r\n    this.sensors = [];\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onDragPressure] = this[onDragPressure].bind(this);\r\n\r\n    document.addEventListener('drag:start', this[onDragStart], true);\r\n    document.addEventListener('drag:move', this[onDragMove], true);\r\n    document.addEventListener('drag:stop', this[onDragStop], true);\r\n    document.addEventListener('drag:pressure', this[onDragPressure], true);\r\n\r\n    const defaultPlugins = Object.values(Draggable.Plugins).filter(Plugin => !this.options.exclude.plugins.includes(Plugin));\r\n    const defaultSensors = Object.values(Draggable.Sensors).filter(sensor => !this.options.exclude.sensors.includes(sensor));\r\n\r\n    this.addPlugin(...[...defaultPlugins, ...this.options.plugins]);\r\n    this.addSensor(...[...defaultSensors, ...this.options.sensors]);\r\n\r\n    const draggableInitializedEvent = new _DraggableEvent.DraggableInitializedEvent({\r\n      draggable: this\r\n    });\r\n\r\n    this.on('mirror:created', ({ mirror }) => this.mirror = mirror);\r\n    this.on('mirror:destroy', () => this.mirror = null);\r\n\r\n    this.trigger(draggableInitializedEvent);\r\n  }\r\n\r\n  /**\r\n   * Destroys Draggable instance. This removes all internal event listeners and\r\n   * deactivates sensors and plugins\r\n   */\r\n\r\n\r\n  /**\r\n   * Default sensors draggable uses\r\n   * @static\r\n   * @property {Object} Sensors\r\n   * @property {MouseSensor} Sensors.MouseSensor\r\n   * @property {TouchSensor} Sensors.TouchSensor\r\n   * @type {Object}\r\n   */\r\n  destroy() {\r\n    document.removeEventListener('drag:start', this[onDragStart], true);\r\n    document.removeEventListener('drag:move', this[onDragMove], true);\r\n    document.removeEventListener('drag:stop', this[onDragStop], true);\r\n    document.removeEventListener('drag:pressure', this[onDragPressure], true);\r\n\r\n    const draggableDestroyEvent = new _DraggableEvent.DraggableDestroyEvent({\r\n      draggable: this\r\n    });\r\n\r\n    this.trigger(draggableDestroyEvent);\r\n\r\n    this.removePlugin(...this.plugins.map(plugin => plugin.constructor));\r\n    this.removeSensor(...this.sensors.map(sensor => sensor.constructor));\r\n  }\r\n\r\n  /**\r\n   * Adds plugin to this draggable instance. This will end up calling the attach method of the plugin\r\n   * @param {...typeof Plugin} plugins - Plugins that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addPlugin(CustomA11yPlugin, CustomMirrorPlugin)\r\n   */\r\n  addPlugin(...plugins) {\r\n    const activePlugins = plugins.map(Plugin => new Plugin(this));\r\n\r\n    activePlugins.forEach(plugin => plugin.attach());\r\n    this.plugins = [...this.plugins, ...activePlugins];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes plugins that are already attached to this draggable instance. This will end up calling\r\n   * the detach method of the plugin\r\n   * @param {...typeof Plugin} plugins - Plugins that you want detached from draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removePlugin(MirrorPlugin, CustomMirrorPlugin)\r\n   */\r\n  removePlugin(...plugins) {\r\n    const removedPlugins = this.plugins.filter(plugin => plugins.includes(plugin.constructor));\r\n\r\n    removedPlugins.forEach(plugin => plugin.detach());\r\n    this.plugins = this.plugins.filter(plugin => !plugins.includes(plugin.constructor));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds sensors to this draggable instance. This will end up calling the attach method of the sensor\r\n   * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addSensor(ForceTouchSensor, CustomSensor)\r\n   */\r\n  addSensor(...sensors) {\r\n    const activeSensors = sensors.map(Sensor => new Sensor(this.containers, this.options));\r\n\r\n    activeSensors.forEach(sensor => sensor.attach());\r\n    this.sensors = [...this.sensors, ...activeSensors];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes sensors that are already attached to this draggable instance. This will end up calling\r\n   * the detach method of the sensor\r\n   * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removeSensor(TouchSensor, DragSensor)\r\n   */\r\n  removeSensor(...sensors) {\r\n    const removedSensors = this.sensors.filter(sensor => sensors.includes(sensor.constructor));\r\n\r\n    removedSensors.forEach(sensor => sensor.detach());\r\n    this.sensors = this.sensors.filter(sensor => !sensors.includes(sensor.constructor));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds container to this draggable instance\r\n   * @param {...HTMLElement} containers - Containers you want to add to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addContainer(document.body)\r\n   */\r\n  addContainer(...containers) {\r\n    this.containers = [...this.containers, ...containers];\r\n    this.sensors.forEach(sensor => sensor.addContainer(...containers));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes container from this draggable instance\r\n   * @param {...HTMLElement} containers - Containers you want to remove from draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removeContainer(document.body)\r\n   */\r\n  removeContainer(...containers) {\r\n    this.containers = this.containers.filter(container => !containers.includes(container));\r\n    this.sensors.forEach(sensor => sensor.removeContainer(...containers));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds listener for draggable events\r\n   * @param {String} type - Event name\r\n   * @param {...Function} callbacks - Event callbacks\r\n   * @return {Draggable}\r\n   * @example draggable.on('drag:start', (dragEvent) => dragEvent.cancel());\r\n   */\r\n  on(type, ...callbacks) {\r\n    this.emitter.on(type, ...callbacks);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes listener from draggable\r\n   * @param {String} type - Event name\r\n   * @param {Function} callback - Event callback\r\n   * @return {Draggable}\r\n   * @example draggable.off('drag:start', handlerFunction);\r\n   */\r\n  off(type, callback) {\r\n    this.emitter.off(type, callback);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Triggers draggable event\r\n   * @param {AbstractEvent} event - Event instance\r\n   * @return {Draggable}\r\n   * @example draggable.trigger(event);\r\n   */\r\n  trigger(event) {\r\n    this.emitter.trigger(event);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns class name for class identifier\r\n   * @param {String} name - Name of class identifier\r\n   * @return {String|null}\r\n   */\r\n  getClassNameFor(name) {\r\n    return this.getClassNamesFor(name)[0];\r\n  }\r\n\r\n  /**\r\n   * Returns class names for class identifier\r\n   * @return {String[]}\r\n   */\r\n  getClassNamesFor(name) {\r\n    const classNames = this.options.classes[name];\r\n\r\n    if (classNames instanceof Array) {\r\n      return classNames;\r\n    } else if (typeof classNames === 'string' || classNames instanceof String) {\r\n      return [classNames];\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if this draggable instance is currently dragging\r\n   * @return {Boolean}\r\n   */\r\n  isDragging() {\r\n    return Boolean(this.dragging);\r\n  }\r\n\r\n  /**\r\n   * Returns all draggable elements\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getDraggableElements() {\r\n    return this.containers.reduce((current, container) => {\r\n      return [...current, ...this.getDraggableElementsForContainer(container)];\r\n    }, []);\r\n  }\r\n\r\n  /**\r\n   * Returns draggable elements for a given container, excluding the mirror and\r\n   * original source element if present\r\n   * @param {HTMLElement} container\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getDraggableElementsForContainer(container) {\r\n    const allDraggableElements = container.querySelectorAll(this.options.draggable);\r\n\r\n    return [...allDraggableElements].filter(childElement => {\r\n      return childElement !== this.originalSource && childElement !== this.mirror;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragStart](event) {\r\n    const sensorEvent = getSensorEvent(event);\r\n    const { target, container } = sensorEvent;\r\n\r\n    if (!this.containers.includes(container)) {\r\n      return;\r\n    }\r\n\r\n    if (this.options.handle && target && !(0, _utils.closest)(target, this.options.handle)) {\r\n      sensorEvent.cancel();\r\n      return;\r\n    }\r\n\r\n    // Find draggable source element\r\n    this.originalSource = (0, _utils.closest)(target, this.options.draggable);\r\n    this.sourceContainer = container;\r\n\r\n    if (!this.originalSource) {\r\n      sensorEvent.cancel();\r\n      return;\r\n    }\r\n\r\n    if (this.lastPlacedSource && this.lastPlacedContainer) {\r\n      clearTimeout(this.placedTimeoutID);\r\n      this.lastPlacedSource.classList.remove(...this.getClassNamesFor('source:placed'));\r\n      this.lastPlacedContainer.classList.remove(...this.getClassNamesFor('container:placed'));\r\n    }\r\n\r\n    this.source = this.originalSource.cloneNode(true);\r\n    this.originalSource.parentNode.insertBefore(this.source, this.originalSource);\r\n    this.originalSource.style.display = 'none';\r\n\r\n    const dragEvent = new _DragEvent.DragStartEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sourceContainer: container,\r\n      sensorEvent\r\n    });\r\n\r\n    this.trigger(dragEvent);\r\n\r\n    this.dragging = !dragEvent.canceled();\r\n\r\n    if (dragEvent.canceled()) {\r\n      this.source.parentNode.removeChild(this.source);\r\n      this.originalSource.style.display = null;\r\n      return;\r\n    }\r\n\r\n    this.originalSource.classList.add(...this.getClassNamesFor('source:original'));\r\n    this.source.classList.add(...this.getClassNamesFor('source:dragging'));\r\n    this.sourceContainer.classList.add(...this.getClassNamesFor('container:dragging'));\r\n    document.body.classList.add(...this.getClassNamesFor('body:dragging'));\r\n    applyUserSelect(document.body, 'none');\r\n\r\n    requestAnimationFrame(() => {\r\n      const oldSensorEvent = getSensorEvent(event);\r\n      const newSensorEvent = oldSensorEvent.clone({ target: this.source });\r\n\r\n      this[onDragMove](_extends({}, event, {\r\n        detail: newSensorEvent\r\n      }));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag move handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = getSensorEvent(event);\r\n    const { container } = sensorEvent;\r\n    let target = sensorEvent.target;\r\n\r\n    const dragMoveEvent = new _DragEvent.DragMoveEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sourceContainer: container,\r\n      sensorEvent\r\n    });\r\n\r\n    this.trigger(dragMoveEvent);\r\n\r\n    if (dragMoveEvent.canceled()) {\r\n      sensorEvent.cancel();\r\n    }\r\n\r\n    target = (0, _utils.closest)(target, this.options.draggable);\r\n    const withinCorrectContainer = (0, _utils.closest)(sensorEvent.target, this.containers);\r\n    const overContainer = sensorEvent.overContainer || withinCorrectContainer;\r\n    const isLeavingContainer = this.currentOverContainer && overContainer !== this.currentOverContainer;\r\n    const isLeavingDraggable = this.currentOver && target !== this.currentOver;\r\n    const isOverContainer = overContainer && this.currentOverContainer !== overContainer;\r\n    const isOverDraggable = withinCorrectContainer && target && this.currentOver !== target;\r\n\r\n    if (isLeavingDraggable) {\r\n      const dragOutEvent = new _DragEvent.DragOutEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        over: this.currentOver,\r\n        overContainer: this.currentOverContainer\r\n      });\r\n\r\n      this.currentOver.classList.remove(...this.getClassNamesFor('draggable:over'));\r\n      this.currentOver = null;\r\n\r\n      this.trigger(dragOutEvent);\r\n    }\r\n\r\n    if (isLeavingContainer) {\r\n      const dragOutContainerEvent = new _DragEvent.DragOutContainerEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer: this.currentOverContainer\r\n      });\r\n\r\n      this.currentOverContainer.classList.remove(...this.getClassNamesFor('container:over'));\r\n      this.currentOverContainer = null;\r\n\r\n      this.trigger(dragOutContainerEvent);\r\n    }\r\n\r\n    if (isOverContainer) {\r\n      overContainer.classList.add(...this.getClassNamesFor('container:over'));\r\n\r\n      const dragOverContainerEvent = new _DragEvent.DragOverContainerEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer\r\n      });\r\n\r\n      this.currentOverContainer = overContainer;\r\n\r\n      this.trigger(dragOverContainerEvent);\r\n    }\r\n\r\n    if (isOverDraggable) {\r\n      target.classList.add(...this.getClassNamesFor('draggable:over'));\r\n\r\n      const dragOverEvent = new _DragEvent.DragOverEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer,\r\n        over: target\r\n      });\r\n\r\n      this.currentOver = target;\r\n\r\n      this.trigger(dragOverEvent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragStop](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    this.dragging = false;\r\n\r\n    const dragStopEvent = new _DragEvent.DragStopEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sensorEvent: event.sensorEvent,\r\n      sourceContainer: this.sourceContainer\r\n    });\r\n\r\n    this.trigger(dragStopEvent);\r\n\r\n    this.source.parentNode.insertBefore(this.originalSource, this.source);\r\n    this.source.parentNode.removeChild(this.source);\r\n    this.originalSource.style.display = '';\r\n\r\n    this.source.classList.remove(...this.getClassNamesFor('source:dragging'));\r\n    this.originalSource.classList.remove(...this.getClassNamesFor('source:original'));\r\n    this.originalSource.classList.add(...this.getClassNamesFor('source:placed'));\r\n    this.sourceContainer.classList.add(...this.getClassNamesFor('container:placed'));\r\n    this.sourceContainer.classList.remove(...this.getClassNamesFor('container:dragging'));\r\n    document.body.classList.remove(...this.getClassNamesFor('body:dragging'));\r\n    applyUserSelect(document.body, '');\r\n\r\n    if (this.currentOver) {\r\n      this.currentOver.classList.remove(...this.getClassNamesFor('draggable:over'));\r\n    }\r\n\r\n    if (this.currentOverContainer) {\r\n      this.currentOverContainer.classList.remove(...this.getClassNamesFor('container:over'));\r\n    }\r\n\r\n    this.lastPlacedSource = this.originalSource;\r\n    this.lastPlacedContainer = this.sourceContainer;\r\n\r\n    this.placedTimeoutID = setTimeout(() => {\r\n      if (this.lastPlacedSource) {\r\n        this.lastPlacedSource.classList.remove(...this.getClassNamesFor('source:placed'));\r\n      }\r\n\r\n      if (this.lastPlacedContainer) {\r\n        this.lastPlacedContainer.classList.remove(...this.getClassNamesFor('container:placed'));\r\n      }\r\n\r\n      this.lastPlacedSource = null;\r\n      this.lastPlacedContainer = null;\r\n    }, this.options.placedTimeout);\r\n\r\n    const dragStoppedEvent = new _DragEvent.DragStoppedEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sensorEvent: event.sensorEvent,\r\n      sourceContainer: this.sourceContainer\r\n    });\r\n\r\n    this.trigger(dragStoppedEvent);\r\n\r\n    this.source = null;\r\n    this.originalSource = null;\r\n    this.currentOverContainer = null;\r\n    this.currentOver = null;\r\n    this.sourceContainer = null;\r\n  }\r\n\r\n  /**\r\n   * Drag pressure handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragPressure](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = getSensorEvent(event);\r\n    const source = this.source || (0, _utils.closest)(sensorEvent.originalEvent.target, this.options.draggable);\r\n\r\n    const dragPressureEvent = new _DragEvent.DragPressureEvent({\r\n      sensorEvent,\r\n      source,\r\n      pressure: sensorEvent.pressure\r\n    });\r\n\r\n    this.trigger(dragPressureEvent);\r\n  }\r\n}\r\n\r\nexports.default = Draggable;\r\nDraggable.Plugins = { Announcement: _Plugins.Announcement, Focusable: _Plugins.Focusable, Mirror: _Plugins.Mirror, Scrollable: _Plugins.Scrollable };\r\nDraggable.Sensors = { MouseSensor: _Sensors.MouseSensor, TouchSensor: _Sensors.TouchSensor };\r\nfunction getSensorEvent(event) {\r\n  return event.detail;\r\n}\r\n\r\nfunction applyUserSelect(element, value) {\r\n  element.style.webkitUserSelect = value;\r\n  element.style.mozUserSelect = value;\r\n  element.style.msUserSelect = value;\r\n  element.style.oUserSelect = value;\r\n  element.style.userSelect = value;\r\n}\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ (function(module, exports, __nested_webpack_require_34453__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_34453__(1);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_34453__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMouseForceWillBegin = Symbol('onMouseForceWillBegin');\r\nconst onMouseForceDown = Symbol('onMouseForceDown');\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseForceChange = Symbol('onMouseForceChange');\r\nconst onMouseMove = Symbol('onMouseMove');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst onMouseForceGlobalChange = Symbol('onMouseForceGlobalChange');\r\n\r\n/**\r\n * This sensor picks up native force touch events and dictates drag operations\r\n * @class ForceTouchSensor\r\n * @module ForceTouchSensor\r\n * @extends Sensor\r\n */\r\nclass ForceTouchSensor extends _Sensor2.default {\r\n  /**\r\n   * ForceTouchSensor constructor.\r\n   * @constructs ForceTouchSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed\r\n     * @property mightDrag\r\n     * @type {Boolean}\r\n     */\r\n    this.mightDrag = false;\r\n\r\n    this[onMouseForceWillBegin] = this[onMouseForceWillBegin].bind(this);\r\n    this[onMouseForceDown] = this[onMouseForceDown].bind(this);\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseForceChange] = this[onMouseForceChange].bind(this);\r\n    this[onMouseMove] = this[onMouseMove].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    for (const container of this.containers) {\r\n      container.addEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\r\n      container.addEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\r\n      container.addEventListener('mousedown', this[onMouseDown], true);\r\n      container.addEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\r\n    }\r\n\r\n    document.addEventListener('mousemove', this[onMouseMove]);\r\n    document.addEventListener('mouseup', this[onMouseUp]);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    for (const container of this.containers) {\r\n      container.removeEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\r\n      container.removeEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\r\n      container.removeEventListener('mousedown', this[onMouseDown], true);\r\n      container.removeEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\r\n    }\r\n\r\n    document.removeEventListener('mousemove', this[onMouseMove]);\r\n    document.removeEventListener('mouseup', this[onMouseUp]);\r\n  }\r\n\r\n  /**\r\n   * Mouse force will begin handler\r\n   * @private\r\n   * @param {Event} event - Mouse force will begin event\r\n   */\r\n  [onMouseForceWillBegin](event) {\r\n    event.preventDefault();\r\n    this.mightDrag = true;\r\n  }\r\n\r\n  /**\r\n   * Mouse force down handler\r\n   * @private\r\n   * @param {Event} event - Mouse force down event\r\n   */\r\n  [onMouseForceDown](event) {\r\n    if (this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = event.currentTarget;\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragStartEvent);\r\n\r\n    this.currentContainer = container;\r\n    this.dragging = !dragStartEvent.canceled();\r\n    this.mightDrag = false;\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target: null,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.mightDrag = false;\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    if (!this.mightDrag) {\r\n      return;\r\n    }\r\n\r\n    // Need workaround for real click\r\n    // Cancel potential drag events\r\n    event.stopPropagation();\r\n    event.stopImmediatePropagation();\r\n    event.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler\r\n   * @private\r\n   * @param {Event} event - Mouse force will begin event\r\n   */\r\n  [onMouseMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse force change handler\r\n   * @private\r\n   * @param {Event} event - Mouse force change event\r\n   */\r\n  [onMouseForceChange](event) {\r\n    if (this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = event.target;\r\n    const container = event.currentTarget;\r\n\r\n    const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({\r\n      pressure: event.webkitForce,\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragPressureEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse force global change handler\r\n   * @private\r\n   * @param {Event} event - Mouse force global change event\r\n   */\r\n  [onMouseForceGlobalChange](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = event.target;\r\n\r\n    const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({\r\n      pressure: event.webkitForce,\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragPressureEvent);\r\n  }\r\n}\r\nexports.default = ForceTouchSensor;\r\n\r\n/***/ }),\r\n/* 13 */\r\n/***/ (function(module, exports, __nested_webpack_require_41193__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _ForceTouchSensor = __nested_webpack_require_41193__(12);\r\n\r\nvar _ForceTouchSensor2 = _interopRequireDefault(_ForceTouchSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _ForceTouchSensor2.default;\r\n\r\n/***/ }),\r\n/* 14 */\r\n/***/ (function(module, exports, __nested_webpack_require_41633__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_41633__(2);\r\n\r\nvar _Sensor = __nested_webpack_require_41633__(1);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_41633__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragEnd = Symbol('onDragEnd');\r\nconst onDrop = Symbol('onDrop');\r\nconst reset = Symbol('reset');\r\n\r\n/**\r\n * This sensor picks up native browser drag events and dictates drag operations\r\n * @class DragSensor\r\n * @module DragSensor\r\n * @extends Sensor\r\n */\r\nclass DragSensor extends _Sensor2.default {\r\n  /**\r\n   * DragSensor constructor.\r\n   * @constructs DragSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Mouse down timer which will end up setting the draggable attribute, unless canceled\r\n     * @property mouseDownTimeout\r\n     * @type {Number}\r\n     */\r\n    this.mouseDownTimeout = null;\r\n\r\n    /**\r\n     * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed\r\n     * @property draggableElement\r\n     * @type {HTMLElement}\r\n     */\r\n    this.draggableElement = null;\r\n\r\n    /**\r\n     * Native draggable element could be links or images, their draggable state will be disabled during drag operation\r\n     * @property nativeDraggableElement\r\n     * @type {HTMLElement}\r\n     */\r\n    this.nativeDraggableElement = null;\r\n\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragEnd] = this[onDragEnd].bind(this);\r\n    this[onDrop] = this[onDrop].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {Event} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    // Need for firefox. \"text\" key is needed for IE\r\n    event.dataTransfer.setData('text', '');\r\n    event.dataTransfer.effectAllowed = this.options.type;\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    this.currentContainer = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!this.currentContainer) {\r\n      return;\r\n    }\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    // Workaround\r\n    setTimeout(() => {\r\n      this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n      if (dragStartEvent.canceled()) {\r\n        this.dragging = false;\r\n      } else {\r\n        this.dragging = true;\r\n      }\r\n    }, 0);\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {Event} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = this.currentContainer;\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragMoveEvent);\r\n\r\n    if (!dragMoveEvent.canceled()) {\r\n      event.preventDefault();\r\n      event.dataTransfer.dropEffect = this.options.type;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag end handler\r\n   * @private\r\n   * @param {Event} event - Drag end event\r\n   */\r\n  [onDragEnd](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp], true);\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = this.currentContainer;\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragStopEvent);\r\n\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n\r\n    this[reset]();\r\n  }\r\n\r\n  /**\r\n   * Drop handler\r\n   * @private\r\n   * @param {Event} event - Drop event\r\n   */\r\n  [onDrop](event) {\r\n    // eslint-disable-line class-methods-use-this\r\n    event.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    // Firefox bug for inputs within draggables https://bugzilla.mozilla.org/show_bug.cgi?id=739071\r\n    if (event.target && (event.target.form || event.target.contenteditable)) {\r\n      return;\r\n    }\r\n\r\n    const nativeDraggableElement = (0, _utils.closest)(event.target, element => element.draggable);\r\n\r\n    if (nativeDraggableElement) {\r\n      nativeDraggableElement.draggable = false;\r\n      this.nativeDraggableElement = nativeDraggableElement;\r\n    }\r\n\r\n    document.addEventListener('mouseup', this[onMouseUp], true);\r\n    document.addEventListener('dragstart', this[onDragStart], false);\r\n    document.addEventListener('dragover', this[onDragOver], false);\r\n    document.addEventListener('dragend', this[onDragEnd], false);\r\n    document.addEventListener('drop', this[onDrop], false);\r\n\r\n    const target = (0, _utils.closest)(event.target, this.options.draggable);\r\n\r\n    if (!target) {\r\n      return;\r\n    }\r\n\r\n    this.startEvent = event;\r\n\r\n    this.mouseDownTimeout = setTimeout(() => {\r\n      target.draggable = true;\r\n      this.draggableElement = target;\r\n    }, this.delay.drag);\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp]() {\r\n    this[reset]();\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [reset]() {\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp], true);\r\n    document.removeEventListener('dragstart', this[onDragStart], false);\r\n    document.removeEventListener('dragover', this[onDragOver], false);\r\n    document.removeEventListener('dragend', this[onDragEnd], false);\r\n    document.removeEventListener('drop', this[onDrop], false);\r\n\r\n    if (this.nativeDraggableElement) {\r\n      this.nativeDraggableElement.draggable = true;\r\n      this.nativeDraggableElement = null;\r\n    }\r\n\r\n    if (this.draggableElement) {\r\n      this.draggableElement.draggable = false;\r\n      this.draggableElement = null;\r\n    }\r\n  }\r\n}\r\nexports.default = DragSensor;\r\n\r\n/***/ }),\r\n/* 15 */\r\n/***/ (function(module, exports, __nested_webpack_require_48906__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragSensor = __nested_webpack_require_48906__(14);\r\n\r\nvar _DragSensor2 = _interopRequireDefault(_DragSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _DragSensor2.default;\r\n\r\n/***/ }),\r\n/* 16 */\r\n/***/ (function(module, exports, __nested_webpack_require_49322__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_49322__(2);\r\n\r\nvar _Sensor = __nested_webpack_require_49322__(1);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_49322__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onTouchStart = Symbol('onTouchStart');\r\nconst onTouchEnd = Symbol('onTouchEnd');\r\nconst onTouchMove = Symbol('onTouchMove');\r\nconst startDrag = Symbol('startDrag');\r\nconst onDistanceChange = Symbol('onDistanceChange');\r\n\r\n/**\r\n * Prevents scrolling when set to true\r\n * @var {Boolean} preventScrolling\r\n */\r\nlet preventScrolling = false;\r\n\r\n// WebKit requires cancelable `touchmove` events to be added as early as possible\r\nwindow.addEventListener('touchmove', event => {\r\n  if (!preventScrolling) {\r\n    return;\r\n  }\r\n\r\n  // Prevent scrolling\r\n  event.preventDefault();\r\n}, { passive: false });\r\n\r\n/**\r\n * This sensor picks up native browser touch events and dictates drag operations\r\n * @class TouchSensor\r\n * @module TouchSensor\r\n * @extends Sensor\r\n */\r\nclass TouchSensor extends _Sensor2.default {\r\n  /**\r\n   * TouchSensor constructor.\r\n   * @constructs TouchSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Closest scrollable container so accidental scroll can cancel long touch\r\n     * @property currentScrollableParent\r\n     * @type {HTMLElement}\r\n     */\r\n    this.currentScrollableParent = null;\r\n\r\n    /**\r\n     * TimeoutID for managing delay\r\n     * @property tapTimeout\r\n     * @type {Number}\r\n     */\r\n    this.tapTimeout = null;\r\n\r\n    /**\r\n     * touchMoved indicates if touch has moved during tapTimeout\r\n     * @property touchMoved\r\n     * @type {Boolean}\r\n     */\r\n    this.touchMoved = false;\r\n\r\n    /**\r\n     * Save pageX coordinates for delay drag\r\n     * @property {Numbre} pageX\r\n     * @private\r\n     */\r\n    this.pageX = null;\r\n\r\n    /**\r\n     * Save pageY coordinates for delay drag\r\n     * @property {Numbre} pageY\r\n     * @private\r\n     */\r\n    this.pageY = null;\r\n\r\n    this[onTouchStart] = this[onTouchStart].bind(this);\r\n    this[onTouchEnd] = this[onTouchEnd].bind(this);\r\n    this[onTouchMove] = this[onTouchMove].bind(this);\r\n    this[startDrag] = this[startDrag].bind(this);\r\n    this[onDistanceChange] = this[onDistanceChange].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('touchstart', this[onTouchStart]);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('touchstart', this[onTouchStart]);\r\n  }\r\n\r\n  /**\r\n   * Touch start handler\r\n   * @private\r\n   * @param {Event} event - Touch start event\r\n   */\r\n  [onTouchStart](event) {\r\n    const container = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!container) {\r\n      return;\r\n    }\r\n    const { distance = 0 } = this.options;\r\n    const { delay } = this;\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n    this.onTouchStartAt = Date.now();\r\n    this.startEvent = event;\r\n    this.currentContainer = container;\r\n\r\n    document.addEventListener('touchend', this[onTouchEnd]);\r\n    document.addEventListener('touchcancel', this[onTouchEnd]);\r\n    document.addEventListener('touchmove', this[onDistanceChange]);\r\n    container.addEventListener('contextmenu', onContextMenu);\r\n\r\n    if (distance) {\r\n      preventScrolling = true;\r\n    }\r\n\r\n    this.tapTimeout = window.setTimeout(() => {\r\n      this[onDistanceChange]({ touches: [{ pageX: this.pageX, pageY: this.pageY }] });\r\n    }, delay.touch);\r\n  }\r\n\r\n  /**\r\n   * Start the drag\r\n   * @private\r\n   */\r\n  [startDrag]() {\r\n    const startEvent = this.startEvent;\r\n    const container = this.currentContainer;\r\n    const touch = (0, _utils.touchCoords)(startEvent);\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: touch.pageX,\r\n      clientY: touch.pageY,\r\n      target: startEvent.target,\r\n      container,\r\n      originalEvent: startEvent\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n    this.dragging = !dragStartEvent.canceled();\r\n\r\n    if (this.dragging) {\r\n      document.addEventListener('touchmove', this[onTouchMove]);\r\n    }\r\n    preventScrolling = this.dragging;\r\n  }\r\n\r\n  /**\r\n   * Touch move handler prior to drag start.\r\n   * @private\r\n   * @param {Event} event - Touch move event\r\n   */\r\n  [onDistanceChange](event) {\r\n    const { distance } = this.options;\r\n    const { startEvent, delay } = this;\r\n    const start = (0, _utils.touchCoords)(startEvent);\r\n    const current = (0, _utils.touchCoords)(event);\r\n    const timeElapsed = Date.now() - this.onTouchStartAt;\r\n    const distanceTravelled = (0, _utils.distance)(start.pageX, start.pageY, current.pageX, current.pageY);\r\n\r\n    Object.assign(this, current);\r\n\r\n    clearTimeout(this.tapTimeout);\r\n\r\n    if (timeElapsed < delay.touch) {\r\n      // moved during delay\r\n      document.removeEventListener('touchmove', this[onDistanceChange]);\r\n    } else if (distanceTravelled >= distance) {\r\n      document.removeEventListener('touchmove', this[onDistanceChange]);\r\n      this[startDrag]();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler while dragging\r\n   * @private\r\n   * @param {Event} event - Touch move event\r\n   */\r\n  [onTouchMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n    const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: pageX,\r\n      clientY: pageY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Touch end handler\r\n   * @private\r\n   * @param {Event} event - Touch end event\r\n   */\r\n  [onTouchEnd](event) {\r\n    clearTimeout(this.tapTimeout);\r\n    preventScrolling = false;\r\n\r\n    document.removeEventListener('touchend', this[onTouchEnd]);\r\n    document.removeEventListener('touchcancel', this[onTouchEnd]);\r\n    document.removeEventListener('touchmove', this[onDistanceChange]);\r\n\r\n    if (this.currentContainer) {\r\n      this.currentContainer.removeEventListener('contextmenu', onContextMenu);\r\n    }\r\n\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('touchmove', this[onTouchMove]);\r\n\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n    const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);\r\n\r\n    event.preventDefault();\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: pageX,\r\n      clientY: pageY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n  }\r\n}\r\n\r\nexports.default = TouchSensor;\r\nfunction onContextMenu(event) {\r\n  event.preventDefault();\r\n  event.stopPropagation();\r\n}\r\n\r\n/***/ }),\r\n/* 17 */\r\n/***/ (function(module, exports, __nested_webpack_require_56802__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _TouchSensor = __nested_webpack_require_56802__(16);\r\n\r\nvar _TouchSensor2 = _interopRequireDefault(_TouchSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _TouchSensor2.default;\r\n\r\n/***/ }),\r\n/* 18 */\r\n/***/ (function(module, exports, __nested_webpack_require_57222__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DragPressureSensorEvent = exports.DragStopSensorEvent = exports.DragMoveSensorEvent = exports.DragStartSensorEvent = exports.SensorEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_57222__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base sensor event\r\n * @class SensorEvent\r\n * @module SensorEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SensorEvent extends _AbstractEvent2.default {\r\n  /**\r\n   * Original browser event that triggered a sensor\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    return this.data.originalEvent;\r\n  }\r\n\r\n  /**\r\n   * Normalized clientX for both touch and mouse events\r\n   * @property clientX\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get clientX() {\r\n    return this.data.clientX;\r\n  }\r\n\r\n  /**\r\n   * Normalized clientY for both touch and mouse events\r\n   * @property clientY\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get clientY() {\r\n    return this.data.clientY;\r\n  }\r\n\r\n  /**\r\n   * Normalized target for both touch and mouse events\r\n   * Returns the element that is behind cursor or touch pointer\r\n   * @property target\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get target() {\r\n    return this.data.target;\r\n  }\r\n\r\n  /**\r\n   * Container that initiated the sensor\r\n   * @property container\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get container() {\r\n    return this.data.container;\r\n  }\r\n\r\n  /**\r\n   * Trackpad pressure\r\n   * @property pressure\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get pressure() {\r\n    return this.data.pressure;\r\n  }\r\n}\r\n\r\nexports.SensorEvent = SensorEvent; /**\r\n                                    * Drag start sensor event\r\n                                    * @class DragStartSensorEvent\r\n                                    * @module DragStartSensorEvent\r\n                                    * @extends SensorEvent\r\n                                    */\r\n\r\nclass DragStartSensorEvent extends SensorEvent {}\r\n\r\nexports.DragStartSensorEvent = DragStartSensorEvent; /**\r\n                                                      * Drag move sensor event\r\n                                                      * @class DragMoveSensorEvent\r\n                                                      * @module DragMoveSensorEvent\r\n                                                      * @extends SensorEvent\r\n                                                      */\r\n\r\nDragStartSensorEvent.type = 'drag:start';\r\nclass DragMoveSensorEvent extends SensorEvent {}\r\n\r\nexports.DragMoveSensorEvent = DragMoveSensorEvent; /**\r\n                                                    * Drag stop sensor event\r\n                                                    * @class DragStopSensorEvent\r\n                                                    * @module DragStopSensorEvent\r\n                                                    * @extends SensorEvent\r\n                                                    */\r\n\r\nDragMoveSensorEvent.type = 'drag:move';\r\nclass DragStopSensorEvent extends SensorEvent {}\r\n\r\nexports.DragStopSensorEvent = DragStopSensorEvent; /**\r\n                                                    * Drag pressure sensor event\r\n                                                    * @class DragPressureSensorEvent\r\n                                                    * @module DragPressureSensorEvent\r\n                                                    * @extends SensorEvent\r\n                                                    */\r\n\r\nDragStopSensorEvent.type = 'drag:stop';\r\nclass DragPressureSensorEvent extends SensorEvent {}\r\nexports.DragPressureSensorEvent = DragPressureSensorEvent;\r\nDragPressureSensorEvent.type = 'drag:pressure';\r\n\r\n/***/ }),\r\n/* 19 */\r\n/***/ (function(module, exports, __nested_webpack_require_61213__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_61213__(2);\r\n\r\nvar _Sensor = __nested_webpack_require_61213__(1);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_61213__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onContextMenuWhileDragging = Symbol('onContextMenuWhileDragging');\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseMove = Symbol('onMouseMove');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst startDrag = Symbol('startDrag');\r\nconst onDistanceChange = Symbol('onDistanceChange');\r\n\r\n/**\r\n * This sensor picks up native browser mouse events and dictates drag operations\r\n * @class MouseSensor\r\n * @module MouseSensor\r\n * @extends Sensor\r\n */\r\nclass MouseSensor extends _Sensor2.default {\r\n  /**\r\n   * MouseSensor constructor.\r\n   * @constructs MouseSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Mouse down timer which will end up triggering the drag start operation\r\n     * @property mouseDownTimeout\r\n     * @type {Number}\r\n     */\r\n    this.mouseDownTimeout = null;\r\n\r\n    /**\r\n     * Save pageX coordinates for delay drag\r\n     * @property {Numbre} pageX\r\n     * @private\r\n     */\r\n    this.pageX = null;\r\n\r\n    /**\r\n     * Save pageY coordinates for delay drag\r\n     * @property {Numbre} pageY\r\n     * @private\r\n     */\r\n    this.pageY = null;\r\n\r\n    this[onContextMenuWhileDragging] = this[onContextMenuWhileDragging].bind(this);\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseMove] = this[onMouseMove].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n    this[startDrag] = this[startDrag].bind(this);\r\n    this[onDistanceChange] = this[onDistanceChange].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    if (event.button !== 0 || event.ctrlKey || event.metaKey) {\r\n      return;\r\n    }\r\n    const container = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!container) {\r\n      return;\r\n    }\r\n\r\n    const { delay } = this;\r\n    const { pageX, pageY } = event;\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n    this.onMouseDownAt = Date.now();\r\n    this.startEvent = event;\r\n\r\n    this.currentContainer = container;\r\n    document.addEventListener('mouseup', this[onMouseUp]);\r\n    document.addEventListener('dragstart', preventNativeDragStart);\r\n    document.addEventListener('mousemove', this[onDistanceChange]);\r\n\r\n    this.mouseDownTimeout = window.setTimeout(() => {\r\n      this[onDistanceChange]({ pageX: this.pageX, pageY: this.pageY });\r\n    }, delay.mouse);\r\n  }\r\n\r\n  /**\r\n   * Start the drag\r\n   * @private\r\n   */\r\n  [startDrag]() {\r\n    const startEvent = this.startEvent;\r\n    const container = this.currentContainer;\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: startEvent.clientX,\r\n      clientY: startEvent.clientY,\r\n      target: startEvent.target,\r\n      container,\r\n      originalEvent: startEvent\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n    this.dragging = !dragStartEvent.canceled();\r\n\r\n    if (this.dragging) {\r\n      document.addEventListener('contextmenu', this[onContextMenuWhileDragging], true);\r\n      document.addEventListener('mousemove', this[onMouseMove]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect change in distance, starting drag when both\r\n   * delay and distance requirements are met\r\n   * @private\r\n   * @param {Event} event - Mouse move event\r\n   */\r\n  [onDistanceChange](event) {\r\n    const { pageX, pageY } = event;\r\n    const { distance } = this.options;\r\n    const { startEvent, delay } = this;\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n\r\n    if (!this.currentContainer) {\r\n      return;\r\n    }\r\n\r\n    const timeElapsed = Date.now() - this.onMouseDownAt;\r\n    const distanceTravelled = (0, _utils.distance)(startEvent.pageX, startEvent.pageY, pageX, pageY) || 0;\r\n\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    if (timeElapsed < delay.mouse) {\r\n      // moved during delay\r\n      document.removeEventListener('mousemove', this[onDistanceChange]);\r\n    } else if (distanceTravelled >= distance) {\r\n      document.removeEventListener('mousemove', this[onDistanceChange]);\r\n      this[startDrag]();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler\r\n   * @private\r\n   * @param {Event} event - Mouse move event\r\n   */\r\n  [onMouseMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp](event) {\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    if (event.button !== 0) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp]);\r\n    document.removeEventListener('dragstart', preventNativeDragStart);\r\n    document.removeEventListener('mousemove', this[onDistanceChange]);\r\n\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    document.removeEventListener('contextmenu', this[onContextMenuWhileDragging], true);\r\n    document.removeEventListener('mousemove', this[onMouseMove]);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n  }\r\n\r\n  /**\r\n   * Context menu handler\r\n   * @private\r\n   * @param {Event} event - Context menu event\r\n   */\r\n  [onContextMenuWhileDragging](event) {\r\n    event.preventDefault();\r\n  }\r\n}\r\n\r\nexports.default = MouseSensor;\r\nfunction preventNativeDragStart(event) {\r\n  event.preventDefault();\r\n}\r\n\r\n/***/ }),\r\n/* 20 */\r\n/***/ (function(module, exports, __nested_webpack_require_68085__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _MouseSensor = __nested_webpack_require_68085__(19);\r\n\r\nvar _MouseSensor2 = _interopRequireDefault(_MouseSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _MouseSensor2.default;\r\n\r\n/***/ }),\r\n/* 21 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst defaultDealy = {\r\n  mouse: 0,\r\n  drag: 0,\r\n  touch: 100\r\n};\r\n\r\n/**\r\n * Base sensor class. Extend from this class to create a new or custom sensor\r\n * @class Sensor\r\n * @module Sensor\r\n */\r\nclass Sensor {\r\n  /**\r\n   * Sensor constructor.\r\n   * @constructs Sensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    /**\r\n     * Current containers\r\n     * @property containers\r\n     * @type {HTMLElement[]}\r\n     */\r\n    this.containers = [...containers];\r\n\r\n    /**\r\n     * Current options\r\n     * @property options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, options);\r\n\r\n    /**\r\n     * Current drag state\r\n     * @property dragging\r\n     * @type {Boolean}\r\n     */\r\n    this.dragging = false;\r\n\r\n    /**\r\n     * Current container\r\n     * @property currentContainer\r\n     * @type {HTMLElement}\r\n     */\r\n    this.currentContainer = null;\r\n\r\n    /**\r\n     * The event of the initial sensor down\r\n     * @property startEvent\r\n     * @type {Event}\r\n     */\r\n    this.startEvent = null;\r\n\r\n    /**\r\n     * The delay of each sensor\r\n     * @property delay\r\n     * @type {Object}\r\n     */\r\n    this.delay = calcDelay(options.delay);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   * @return {Sensor}\r\n   */\r\n  attach() {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   * @return {Sensor}\r\n   */\r\n  detach() {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds container to this sensor instance\r\n   * @param {...HTMLElement} containers - Containers you want to add to this sensor\r\n   * @example draggable.addContainer(document.body)\r\n   */\r\n  addContainer(...containers) {\r\n    this.containers = [...this.containers, ...containers];\r\n  }\r\n\r\n  /**\r\n   * Removes container from this sensor instance\r\n   * @param {...HTMLElement} containers - Containers you want to remove from this sensor\r\n   * @example draggable.removeContainer(document.body)\r\n   */\r\n  removeContainer(...containers) {\r\n    this.containers = this.containers.filter(container => !containers.includes(container));\r\n  }\r\n\r\n  /**\r\n   * Triggers event on target element\r\n   * @param {HTMLElement} element - Element to trigger event on\r\n   * @param {SensorEvent} sensorEvent - Sensor event to trigger\r\n   */\r\n  trigger(element, sensorEvent) {\r\n    const event = document.createEvent('Event');\r\n    event.detail = sensorEvent;\r\n    event.initEvent(sensorEvent.type, true, true);\r\n    element.dispatchEvent(event);\r\n    this.lastEvent = sensorEvent;\r\n\r\n    return sensorEvent;\r\n  }\r\n}\r\n\r\nexports.default = Sensor; /**\r\n                           * Calculate the delay of each sensor through the delay in the options\r\n                           * @param {undefined|Number|Object} optionsDelay - the delay in the options\r\n                           * @return {Object}\r\n                           */\r\n\r\nfunction calcDelay(optionsDelay) {\r\n  const delay = {};\r\n\r\n  if (optionsDelay === undefined) {\r\n    return _extends({}, defaultDealy);\r\n  }\r\n\r\n  if (typeof optionsDelay === 'number') {\r\n    for (const key in defaultDealy) {\r\n      if (defaultDealy.hasOwnProperty(key)) {\r\n        delay[key] = optionsDelay;\r\n      }\r\n    }\r\n    return delay;\r\n  }\r\n\r\n  for (const key in defaultDealy) {\r\n    if (defaultDealy.hasOwnProperty(key)) {\r\n      if (optionsDelay[key] === undefined) {\r\n        delay[key] = defaultDealy[key];\r\n      } else {\r\n        delay[key] = optionsDelay[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  return delay;\r\n}\r\n\r\n/***/ }),\r\n/* 22 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = touchCoords;\r\n/**\r\n * Returns the first touch event found in touches or changedTouches of a touch events.\r\n * @param {TouchEvent} event a touch event\r\n * @return {Touch} a touch object\r\n */\r\nfunction touchCoords(event = {}) {\r\n  const { touches, changedTouches } = event;\r\n  return touches && touches[0] || changedTouches && changedTouches[0];\r\n}\r\n\r\n/***/ }),\r\n/* 23 */\r\n/***/ (function(module, exports, __nested_webpack_require_73042__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_73042__(22);\r\n\r\nvar _touchCoords2 = _interopRequireDefault(_touchCoords);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _touchCoords2.default;\r\n\r\n/***/ }),\r\n/* 24 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = distance;\r\n/**\r\n * Returns the distance between two points\r\n * @param  {Number} x1 The X position of the first point\r\n * @param  {Number} y1 The Y position of the first point\r\n * @param  {Number} x2 The X position of the second point\r\n * @param  {Number} y2 The Y position of the second point\r\n * @return {Number}\r\n */\r\nfunction distance(x1, y1, x2, y2) {\r\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\r\n}\r\n\r\n/***/ }),\r\n/* 25 */\r\n/***/ (function(module, exports, __nested_webpack_require_74063__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _distance = __nested_webpack_require_74063__(24);\r\n\r\nvar _distance2 = _interopRequireDefault(_distance);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _distance2.default;\r\n\r\n/***/ }),\r\n/* 26 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = requestNextAnimationFrame;\r\nfunction requestNextAnimationFrame(callback) {\r\n  return requestAnimationFrame(() => {\r\n    requestAnimationFrame(callback);\r\n  });\r\n}\r\n\r\n/***/ }),\r\n/* 27 */\r\n/***/ (function(module, exports, __nested_webpack_require_74822__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_74822__(26);\r\n\r\nvar _requestNextAnimationFrame2 = _interopRequireDefault(_requestNextAnimationFrame);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _requestNextAnimationFrame2.default;\r\n\r\n/***/ }),\r\n/* 28 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = closest;\r\nconst matchFunction = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector;\r\n\r\n/**\r\n * Get the closest parent element of a given element that matches the given\r\n * selector string or matching function\r\n *\r\n * @param {Element} element The child element to find a parent of\r\n * @param {String|Function} selector The string or function to use to match\r\n *     the parent element\r\n * @return {Element|null}\r\n */\r\nfunction closest(element, value) {\r\n  if (!element) {\r\n    return null;\r\n  }\r\n\r\n  const selector = value;\r\n  const callback = value;\r\n  const nodeList = value;\r\n  const singleElement = value;\r\n\r\n  const isSelector = Boolean(typeof value === 'string');\r\n  const isFunction = Boolean(typeof value === 'function');\r\n  const isNodeList = Boolean(value instanceof NodeList || value instanceof Array);\r\n  const isElement = Boolean(value instanceof HTMLElement);\r\n\r\n  function conditionFn(currentElement) {\r\n    if (!currentElement) {\r\n      return currentElement;\r\n    } else if (isSelector) {\r\n      return matchFunction.call(currentElement, selector);\r\n    } else if (isNodeList) {\r\n      return [...nodeList].includes(currentElement);\r\n    } else if (isElement) {\r\n      return singleElement === currentElement;\r\n    } else if (isFunction) {\r\n      return callback(currentElement);\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  let current = element;\r\n\r\n  do {\r\n    current = current.correspondingUseElement || current.correspondingElement || current;\r\n\r\n    if (conditionFn(current)) {\r\n      return current;\r\n    }\r\n\r\n    current = current.parentNode;\r\n  } while (current && current !== document.body && current !== document);\r\n\r\n  return null;\r\n}\r\n\r\n/***/ }),\r\n/* 29 */\r\n/***/ (function(module, exports, __nested_webpack_require_77252__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_77252__(28);\r\n\r\nvar _closest2 = _interopRequireDefault(_closest);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _closest2.default;\r\n\r\n/***/ }),\r\n/* 30 */\r\n/***/ (function(module, exports, __nested_webpack_require_77656__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = exports.scroll = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_77656__(3);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _utils = __nested_webpack_require_77656__(2);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = exports.onDragStart = Symbol('onDragStart');\r\nconst onDragMove = exports.onDragMove = Symbol('onDragMove');\r\nconst onDragStop = exports.onDragStop = Symbol('onDragStop');\r\nconst scroll = exports.scroll = Symbol('scroll');\r\n\r\n/**\r\n * Scrollable default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.speed\r\n * @property {Number} defaultOptions.sensitivity\r\n * @property {HTMLElement[]} defaultOptions.scrollableElements\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  speed: 6,\r\n  sensitivity: 50,\r\n  scrollableElements: []\r\n};\r\n\r\n/**\r\n * Scrollable plugin which scrolls the closest scrollable parent\r\n * @class Scrollable\r\n * @module Scrollable\r\n * @extends AbstractPlugin\r\n */\r\nclass Scrollable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Scrollable constructor.\r\n   * @constructs Scrollable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Scrollable options\r\n     * @property {Object} options\r\n     * @property {Number} options.speed\r\n     * @property {Number} options.sensitivity\r\n     * @property {HTMLElement[]} options.scrollableElements\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Keeps current mouse position\r\n     * @property {Object} currentMousePosition\r\n     * @property {Number} currentMousePosition.clientX\r\n     * @property {Number} currentMousePosition.clientY\r\n     * @type {Object|null}\r\n     */\r\n    this.currentMousePosition = null;\r\n\r\n    /**\r\n     * Scroll animation frame\r\n     * @property scrollAnimationFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.scrollAnimationFrame = null;\r\n\r\n    /**\r\n     * Closest scrollable element\r\n     * @property scrollableElement\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.scrollableElement = null;\r\n\r\n    /**\r\n     * Animation frame looking for the closest scrollable element\r\n     * @property findScrollableElementFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.findScrollableElementFrame = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[scroll] = this[scroll].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.scrollable || {};\r\n  }\r\n\r\n  /**\r\n   * Returns closest scrollable elements by element\r\n   * @param {HTMLElement} target\r\n   * @return {HTMLElement}\r\n   */\r\n  getScrollableElement(target) {\r\n    if (this.hasDefinedScrollableElements()) {\r\n      return (0, _utils.closest)(target, this.options.scrollableElements) || document.documentElement;\r\n    } else {\r\n      return closestScrollableElement(target);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if at least one scrollable element have been defined via options\r\n   * @param {HTMLElement} target\r\n   * @return {Boolean}\r\n   */\r\n  hasDefinedScrollableElements() {\r\n    return Boolean(this.options.scrollableElements.length !== 0);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler. Finds closest scrollable parent in separate frame\r\n   * @param {DragStartEvent} dragEvent\r\n   * @private\r\n   */\r\n  [onDragStart](dragEvent) {\r\n    this.findScrollableElementFrame = requestAnimationFrame(() => {\r\n      this.scrollableElement = this.getScrollableElement(dragEvent.source);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag move handler. Remembers mouse position and initiates scrolling\r\n   * @param {DragMoveEvent} dragEvent\r\n   * @private\r\n   */\r\n  [onDragMove](dragEvent) {\r\n    this.findScrollableElementFrame = requestAnimationFrame(() => {\r\n      this.scrollableElement = this.getScrollableElement(dragEvent.sensorEvent.target);\r\n    });\r\n\r\n    if (!this.scrollableElement) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = dragEvent.sensorEvent;\r\n    const scrollOffset = { x: 0, y: 0 };\r\n\r\n    if ('ontouchstart' in window) {\r\n      scrollOffset.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\r\n      scrollOffset.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;\r\n    }\r\n\r\n    this.currentMousePosition = {\r\n      clientX: sensorEvent.clientX - scrollOffset.x,\r\n      clientY: sensorEvent.clientY - scrollOffset.y\r\n    };\r\n\r\n    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler. Cancels scroll animations and resets state\r\n   * @private\r\n   */\r\n  [onDragStop]() {\r\n    cancelAnimationFrame(this.scrollAnimationFrame);\r\n    cancelAnimationFrame(this.findScrollableElementFrame);\r\n\r\n    this.scrollableElement = null;\r\n    this.scrollAnimationFrame = null;\r\n    this.findScrollableElementFrame = null;\r\n    this.currentMousePosition = null;\r\n  }\r\n\r\n  /**\r\n   * Scroll function that does the heavylifting\r\n   * @private\r\n   */\r\n  [scroll]() {\r\n    if (!this.scrollableElement || !this.currentMousePosition) {\r\n      return;\r\n    }\r\n\r\n    cancelAnimationFrame(this.scrollAnimationFrame);\r\n\r\n    const { speed, sensitivity } = this.options;\r\n\r\n    const rect = this.scrollableElement.getBoundingClientRect();\r\n    const bottomCutOff = rect.bottom > window.innerHeight;\r\n    const topCutOff = rect.top < 0;\r\n    const cutOff = topCutOff || bottomCutOff;\r\n\r\n    const documentScrollingElement = getDocumentScrollingElement();\r\n    const scrollableElement = this.scrollableElement;\r\n    const clientX = this.currentMousePosition.clientX;\r\n    const clientY = this.currentMousePosition.clientY;\r\n\r\n    if (scrollableElement !== document.body && scrollableElement !== document.documentElement && !cutOff) {\r\n      const { offsetHeight, offsetWidth } = scrollableElement;\r\n\r\n      if (rect.top + offsetHeight - clientY < sensitivity) {\r\n        scrollableElement.scrollTop += speed;\r\n      } else if (clientY - rect.top < sensitivity) {\r\n        scrollableElement.scrollTop -= speed;\r\n      }\r\n\r\n      if (rect.left + offsetWidth - clientX < sensitivity) {\r\n        scrollableElement.scrollLeft += speed;\r\n      } else if (clientX - rect.left < sensitivity) {\r\n        scrollableElement.scrollLeft -= speed;\r\n      }\r\n    } else {\r\n      const { innerHeight, innerWidth } = window;\r\n\r\n      if (clientY < sensitivity) {\r\n        documentScrollingElement.scrollTop -= speed;\r\n      } else if (innerHeight - clientY < sensitivity) {\r\n        documentScrollingElement.scrollTop += speed;\r\n      }\r\n\r\n      if (clientX < sensitivity) {\r\n        documentScrollingElement.scrollLeft -= speed;\r\n      } else if (innerWidth - clientX < sensitivity) {\r\n        documentScrollingElement.scrollLeft += speed;\r\n      }\r\n    }\r\n\r\n    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\r\n  }\r\n}\r\n\r\nexports.default = Scrollable; /**\r\n                               * Returns true if the passed element has overflow\r\n                               * @param {HTMLElement} element\r\n                               * @return {Boolean}\r\n                               * @private\r\n                               */\r\n\r\nfunction hasOverflow(element) {\r\n  const overflowRegex = /(auto|scroll)/;\r\n  const computedStyles = getComputedStyle(element, null);\r\n\r\n  const overflow = computedStyles.getPropertyValue('overflow') + computedStyles.getPropertyValue('overflow-y') + computedStyles.getPropertyValue('overflow-x');\r\n\r\n  return overflowRegex.test(overflow);\r\n}\r\n\r\n/**\r\n * Returns true if the passed element is statically positioned\r\n * @param {HTMLElement} element\r\n * @return {Boolean}\r\n * @private\r\n */\r\nfunction isStaticallyPositioned(element) {\r\n  const position = getComputedStyle(element).getPropertyValue('position');\r\n  return position === 'static';\r\n}\r\n\r\n/**\r\n * Finds closest scrollable element\r\n * @param {HTMLElement} element\r\n * @return {HTMLElement}\r\n * @private\r\n */\r\nfunction closestScrollableElement(element) {\r\n  if (!element) {\r\n    return getDocumentScrollingElement();\r\n  }\r\n\r\n  const position = getComputedStyle(element).getPropertyValue('position');\r\n  const excludeStaticParents = position === 'absolute';\r\n\r\n  const scrollableElement = (0, _utils.closest)(element, parent => {\r\n    if (excludeStaticParents && isStaticallyPositioned(parent)) {\r\n      return false;\r\n    }\r\n    return hasOverflow(parent);\r\n  });\r\n\r\n  if (position === 'fixed' || !scrollableElement) {\r\n    return getDocumentScrollingElement();\r\n  } else {\r\n    return scrollableElement;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns element that scrolls document\r\n * @return {HTMLElement}\r\n * @private\r\n */\r\nfunction getDocumentScrollingElement() {\r\n  return document.scrollingElement || document.documentElement;\r\n}\r\n\r\n/***/ }),\r\n/* 31 */\r\n/***/ (function(module, exports, __nested_webpack_require_87578__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Scrollable = __nested_webpack_require_87578__(30);\r\n\r\nvar _Scrollable2 = _interopRequireDefault(_Scrollable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Scrollable2.default;\r\nexports.defaultOptions = _Scrollable.defaultOptions;\r\n\r\n/***/ }),\r\n/* 32 */\r\n/***/ (function(module, exports, __nested_webpack_require_88085__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.MirrorDestroyEvent = exports.MirrorMoveEvent = exports.MirrorAttachedEvent = exports.MirrorCreatedEvent = exports.MirrorCreateEvent = exports.MirrorEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_88085__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base mirror event\r\n * @class MirrorEvent\r\n * @module MirrorEvent\r\n * @extends AbstractEvent\r\n */\r\nclass MirrorEvent extends _AbstractEvent2.default {\r\n  /**\r\n   * Draggables source element\r\n   * @property source\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get source() {\r\n    return this.data.source;\r\n  }\r\n\r\n  /**\r\n   * Draggables original source element\r\n   * @property originalSource\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get originalSource() {\r\n    return this.data.originalSource;\r\n  }\r\n\r\n  /**\r\n   * Draggables source container element\r\n   * @property sourceContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get sourceContainer() {\r\n    return this.data.sourceContainer;\r\n  }\r\n\r\n  /**\r\n   * Sensor event\r\n   * @property sensorEvent\r\n   * @type {SensorEvent}\r\n   * @readonly\r\n   */\r\n  get sensorEvent() {\r\n    return this.data.sensorEvent;\r\n  }\r\n\r\n  /**\r\n   * Drag event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n\r\n  /**\r\n   * Original event that triggered sensor event\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    if (this.sensorEvent) {\r\n      return this.sensorEvent.originalEvent;\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexports.MirrorEvent = MirrorEvent; /**\r\n                                    * Mirror create event\r\n                                    * @class MirrorCreateEvent\r\n                                    * @module MirrorCreateEvent\r\n                                    * @extends MirrorEvent\r\n                                    */\r\n\r\nclass MirrorCreateEvent extends MirrorEvent {}\r\n\r\nexports.MirrorCreateEvent = MirrorCreateEvent; /**\r\n                                                * Mirror created event\r\n                                                * @class MirrorCreatedEvent\r\n                                                * @module MirrorCreatedEvent\r\n                                                * @extends MirrorEvent\r\n                                                */\r\n\r\nMirrorCreateEvent.type = 'mirror:create';\r\nclass MirrorCreatedEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\n\r\nexports.MirrorCreatedEvent = MirrorCreatedEvent; /**\r\n                                                  * Mirror attached event\r\n                                                  * @class MirrorAttachedEvent\r\n                                                  * @module MirrorAttachedEvent\r\n                                                  * @extends MirrorEvent\r\n                                                  */\r\n\r\nMirrorCreatedEvent.type = 'mirror:created';\r\nclass MirrorAttachedEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\n\r\nexports.MirrorAttachedEvent = MirrorAttachedEvent; /**\r\n                                                    * Mirror move event\r\n                                                    * @class MirrorMoveEvent\r\n                                                    * @module MirrorMoveEvent\r\n                                                    * @extends MirrorEvent\r\n                                                    */\r\n\r\nMirrorAttachedEvent.type = 'mirror:attached';\r\nclass MirrorMoveEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n\r\n  /**\r\n   * Sensor has exceeded mirror's threshold on x axis\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  get passedThreshX() {\r\n    return this.data.passedThreshX;\r\n  }\r\n\r\n  /**\r\n   * Sensor has exceeded mirror's threshold on y axis\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  get passedThreshY() {\r\n    return this.data.passedThreshY;\r\n  }\r\n}\r\n\r\nexports.MirrorMoveEvent = MirrorMoveEvent; /**\r\n                                            * Mirror destroy event\r\n                                            * @class MirrorDestroyEvent\r\n                                            * @module MirrorDestroyEvent\r\n                                            * @extends MirrorEvent\r\n                                            */\r\n\r\nMirrorMoveEvent.type = 'mirror:move';\r\nMirrorMoveEvent.cancelable = true;\r\nclass MirrorDestroyEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\nexports.MirrorDestroyEvent = MirrorDestroyEvent;\r\nMirrorDestroyEvent.type = 'mirror:destroy';\r\nMirrorDestroyEvent.cancelable = true;\r\n\r\n/***/ }),\r\n/* 33 */\r\n/***/ (function(module, exports, __nested_webpack_require_93537__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _MirrorEvent = __nested_webpack_require_93537__(32);\r\n\r\nObject.keys(_MirrorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _MirrorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 34 */\r\n/***/ (function(module, exports, __nested_webpack_require_94005__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = exports.getAppendableContainer = exports.onScroll = exports.onMirrorMove = exports.onMirrorCreated = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_94005__(3);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _MirrorEvent = __nested_webpack_require_94005__(33);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\r\n\r\nconst onDragStart = exports.onDragStart = Symbol('onDragStart');\r\nconst onDragMove = exports.onDragMove = Symbol('onDragMove');\r\nconst onDragStop = exports.onDragStop = Symbol('onDragStop');\r\nconst onMirrorCreated = exports.onMirrorCreated = Symbol('onMirrorCreated');\r\nconst onMirrorMove = exports.onMirrorMove = Symbol('onMirrorMove');\r\nconst onScroll = exports.onScroll = Symbol('onScroll');\r\nconst getAppendableContainer = exports.getAppendableContainer = Symbol('getAppendableContainer');\r\n\r\n/**\r\n * Mirror default options\r\n * @property {Object} defaultOptions\r\n * @property {Boolean} defaultOptions.constrainDimensions\r\n * @property {Boolean} defaultOptions.xAxis\r\n * @property {Boolean} defaultOptions.yAxis\r\n * @property {null} defaultOptions.cursorOffsetX\r\n * @property {null} defaultOptions.cursorOffsetY\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  constrainDimensions: false,\r\n  xAxis: true,\r\n  yAxis: true,\r\n  cursorOffsetX: null,\r\n  cursorOffsetY: null,\r\n  thresholdX: null,\r\n  thresholdY: null\r\n};\r\n\r\n/**\r\n * Mirror plugin which controls the mirror positioning while dragging\r\n * @class Mirror\r\n * @module Mirror\r\n * @extends AbstractPlugin\r\n */\r\nclass Mirror extends _AbstractPlugin2.default {\r\n  /**\r\n   * Mirror constructor.\r\n   * @constructs Mirror\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Mirror options\r\n     * @property {Object} options\r\n     * @property {Boolean} options.constrainDimensions\r\n     * @property {Boolean} options.xAxis\r\n     * @property {Boolean} options.yAxis\r\n     * @property {Number|null} options.cursorOffsetX\r\n     * @property {Number|null} options.cursorOffsetY\r\n     * @property {String|HTMLElement|Function} options.appendTo\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Scroll offset for touch devices because the mirror is positioned fixed\r\n     * @property {Object} scrollOffset\r\n     * @property {Number} scrollOffset.x\r\n     * @property {Number} scrollOffset.y\r\n     */\r\n    this.scrollOffset = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Initial scroll offset for touch devices because the mirror is positioned fixed\r\n     * @property {Object} scrollOffset\r\n     * @property {Number} scrollOffset.x\r\n     * @property {Number} scrollOffset.y\r\n     */\r\n    this.initialScrollOffset = {\r\n      x: window.scrollX,\r\n      y: window.scrollY\r\n    };\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\r\n    this[onMirrorMove] = this[onMirrorMove].bind(this);\r\n    this[onScroll] = this[onScroll].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]).on('mirror:created', this[onMirrorCreated]).on('mirror:move', this[onMirrorMove]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]).off('mirror:created', this[onMirrorCreated]).off('mirror:move', this[onMirrorMove]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.mirror || {};\r\n  }\r\n\r\n  [onDragStart](dragEvent) {\r\n    if (dragEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    if ('ontouchstart' in window) {\r\n      document.addEventListener('scroll', this[onScroll], true);\r\n    }\r\n\r\n    this.initialScrollOffset = {\r\n      x: window.scrollX,\r\n      y: window.scrollY\r\n    };\r\n\r\n    const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    // Last sensor position of mirror move\r\n    this.lastMirrorMovedClient = {\r\n      x: sensorEvent.clientX,\r\n      y: sensorEvent.clientY\r\n    };\r\n\r\n    const mirrorCreateEvent = new _MirrorEvent.MirrorCreateEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent\r\n    });\r\n\r\n    this.draggable.trigger(mirrorCreateEvent);\r\n\r\n    if (isNativeDragEvent(sensorEvent) || mirrorCreateEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const appendableContainer = this[getAppendableContainer](source) || sourceContainer;\r\n    this.mirror = source.cloneNode(true);\r\n\r\n    const mirrorCreatedEvent = new _MirrorEvent.MirrorCreatedEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror\r\n    });\r\n\r\n    const mirrorAttachedEvent = new _MirrorEvent.MirrorAttachedEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror\r\n    });\r\n\r\n    this.draggable.trigger(mirrorCreatedEvent);\r\n    appendableContainer.appendChild(this.mirror);\r\n    this.draggable.trigger(mirrorAttachedEvent);\r\n  }\r\n\r\n  [onDragMove](dragEvent) {\r\n    if (!this.mirror || dragEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    let passedThreshX = true;\r\n    let passedThreshY = true;\r\n\r\n    if (this.options.thresholdX || this.options.thresholdY) {\r\n      const { x: lastX, y: lastY } = this.lastMirrorMovedClient;\r\n\r\n      if (Math.abs(lastX - sensorEvent.clientX) < this.options.thresholdX) {\r\n        passedThreshX = false;\r\n      } else {\r\n        this.lastMirrorMovedClient.x = sensorEvent.clientX;\r\n      }\r\n\r\n      if (Math.abs(lastY - sensorEvent.clientY) < this.options.thresholdY) {\r\n        passedThreshY = false;\r\n      } else {\r\n        this.lastMirrorMovedClient.y = sensorEvent.clientY;\r\n      }\r\n\r\n      if (!passedThreshX && !passedThreshY) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const mirrorMoveEvent = new _MirrorEvent.MirrorMoveEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror,\r\n      passedThreshX,\r\n      passedThreshY\r\n    });\r\n\r\n    this.draggable.trigger(mirrorMoveEvent);\r\n  }\r\n\r\n  [onDragStop](dragEvent) {\r\n    if ('ontouchstart' in window) {\r\n      document.removeEventListener('scroll', this[onScroll], true);\r\n    }\r\n\r\n    this.initialScrollOffset = { x: 0, y: 0 };\r\n    this.scrollOffset = { x: 0, y: 0 };\r\n\r\n    if (!this.mirror) {\r\n      return;\r\n    }\r\n\r\n    const { source, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    const mirrorDestroyEvent = new _MirrorEvent.MirrorDestroyEvent({\r\n      source,\r\n      mirror: this.mirror,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent\r\n    });\r\n\r\n    this.draggable.trigger(mirrorDestroyEvent);\r\n\r\n    if (!mirrorDestroyEvent.canceled()) {\r\n      this.mirror.parentNode.removeChild(this.mirror);\r\n    }\r\n  }\r\n\r\n  [onScroll]() {\r\n    this.scrollOffset = {\r\n      x: window.scrollX - this.initialScrollOffset.x,\r\n      y: window.scrollY - this.initialScrollOffset.y\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Mirror created handler\r\n   * @param {MirrorCreatedEvent} mirrorEvent\r\n   * @return {Promise}\r\n   * @private\r\n   */\r\n  [onMirrorCreated]({ mirror, source, sensorEvent }) {\r\n    const mirrorClasses = this.draggable.getClassNamesFor('mirror');\r\n\r\n    const setState = (_ref) => {\r\n      let { mirrorOffset, initialX, initialY } = _ref,\r\n          args = _objectWithoutProperties(_ref, ['mirrorOffset', 'initialX', 'initialY']);\r\n\r\n      this.mirrorOffset = mirrorOffset;\r\n      this.initialX = initialX;\r\n      this.initialY = initialY;\r\n      this.lastMovedX = initialX;\r\n      this.lastMovedY = initialY;\r\n      return _extends({ mirrorOffset, initialX, initialY }, args);\r\n    };\r\n\r\n    mirror.style.display = 'none';\r\n\r\n    const initialState = {\r\n      mirror,\r\n      source,\r\n      sensorEvent,\r\n      mirrorClasses,\r\n      scrollOffset: this.scrollOffset,\r\n      options: this.options,\r\n      passedThreshX: true,\r\n      passedThreshY: true\r\n    };\r\n\r\n    return Promise.resolve(initialState)\r\n    // Fix reflow here\r\n    .then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({ initial: true })).then(removeMirrorID).then(setState);\r\n  }\r\n\r\n  /**\r\n   * Mirror move handler\r\n   * @param {MirrorMoveEvent} mirrorEvent\r\n   * @return {Promise|null}\r\n   * @private\r\n   */\r\n  [onMirrorMove](mirrorEvent) {\r\n    if (mirrorEvent.canceled()) {\r\n      return null;\r\n    }\r\n\r\n    const setState = (_ref2) => {\r\n      let { lastMovedX, lastMovedY } = _ref2,\r\n          args = _objectWithoutProperties(_ref2, ['lastMovedX', 'lastMovedY']);\r\n\r\n      this.lastMovedX = lastMovedX;\r\n      this.lastMovedY = lastMovedY;\r\n\r\n      return _extends({ lastMovedX, lastMovedY }, args);\r\n    };\r\n\r\n    const initialState = {\r\n      mirror: mirrorEvent.mirror,\r\n      sensorEvent: mirrorEvent.sensorEvent,\r\n      mirrorOffset: this.mirrorOffset,\r\n      options: this.options,\r\n      initialX: this.initialX,\r\n      initialY: this.initialY,\r\n      scrollOffset: this.scrollOffset,\r\n      passedThreshX: mirrorEvent.passedThreshX,\r\n      passedThreshY: mirrorEvent.passedThreshY,\r\n      lastMovedX: this.lastMovedX,\r\n      lastMovedY: this.lastMovedY\r\n    };\r\n\r\n    return Promise.resolve(initialState).then(positionMirror({ raf: true })).then(setState);\r\n  }\r\n\r\n  /**\r\n   * Returns appendable container for mirror based on the appendTo option\r\n   * @private\r\n   * @param {Object} options\r\n   * @param {HTMLElement} options.source - Current source\r\n   * @return {HTMLElement}\r\n   */\r\n  [getAppendableContainer](source) {\r\n    const appendTo = this.options.appendTo;\r\n\r\n    if (typeof appendTo === 'string') {\r\n      return document.querySelector(appendTo);\r\n    } else if (appendTo instanceof HTMLElement) {\r\n      return appendTo;\r\n    } else if (typeof appendTo === 'function') {\r\n      return appendTo(source);\r\n    } else {\r\n      return source.parentNode;\r\n    }\r\n  }\r\n}\r\n\r\nexports.default = Mirror; /**\r\n                           * Computes mirror dimensions based on the source element\r\n                           * Adds sourceRect to state\r\n                           * @param {Object} state\r\n                           * @param {HTMLElement} state.source\r\n                           * @return {Promise}\r\n                           * @private\r\n                           */\r\n\r\nfunction computeMirrorDimensions(_ref3) {\r\n  let { source } = _ref3,\r\n      args = _objectWithoutProperties(_ref3, ['source']);\r\n\r\n  return withPromise(resolve => {\r\n    const sourceRect = source.getBoundingClientRect();\r\n    resolve(_extends({ source, sourceRect }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Calculates mirror offset\r\n * Adds mirrorOffset to state\r\n * @param {Object} state\r\n * @param {SensorEvent} state.sensorEvent\r\n * @param {DOMRect} state.sourceRect\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction calculateMirrorOffset(_ref4) {\r\n  let { sensorEvent, sourceRect, options } = _ref4,\r\n      args = _objectWithoutProperties(_ref4, ['sensorEvent', 'sourceRect', 'options']);\r\n\r\n  return withPromise(resolve => {\r\n    const top = options.cursorOffsetY === null ? sensorEvent.clientY - sourceRect.top : options.cursorOffsetY;\r\n    const left = options.cursorOffsetX === null ? sensorEvent.clientX - sourceRect.left : options.cursorOffsetX;\r\n\r\n    const mirrorOffset = { top, left };\r\n\r\n    resolve(_extends({ sensorEvent, sourceRect, mirrorOffset, options }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Applys mirror styles\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {HTMLElement} state.source\r\n * @param {Object} state.options\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction resetMirror(_ref5) {\r\n  let { mirror, source, options } = _ref5,\r\n      args = _objectWithoutProperties(_ref5, ['mirror', 'source', 'options']);\r\n\r\n  return withPromise(resolve => {\r\n    let offsetHeight;\r\n    let offsetWidth;\r\n\r\n    if (options.constrainDimensions) {\r\n      const computedSourceStyles = getComputedStyle(source);\r\n      offsetHeight = computedSourceStyles.getPropertyValue('height');\r\n      offsetWidth = computedSourceStyles.getPropertyValue('width');\r\n    }\r\n\r\n    mirror.style.display = null;\r\n    mirror.style.position = 'fixed';\r\n    mirror.style.pointerEvents = 'none';\r\n    mirror.style.top = 0;\r\n    mirror.style.left = 0;\r\n    mirror.style.margin = 0;\r\n\r\n    if (options.constrainDimensions) {\r\n      mirror.style.height = offsetHeight;\r\n      mirror.style.width = offsetWidth;\r\n    }\r\n\r\n    resolve(_extends({ mirror, source, options }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Applys mirror class on mirror element\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {String[]} state.mirrorClasses\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction addMirrorClasses(_ref6) {\r\n  let { mirror, mirrorClasses } = _ref6,\r\n      args = _objectWithoutProperties(_ref6, ['mirror', 'mirrorClasses']);\r\n\r\n  return withPromise(resolve => {\r\n    mirror.classList.add(...mirrorClasses);\r\n    resolve(_extends({ mirror, mirrorClasses }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Removes source ID from cloned mirror element\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction removeMirrorID(_ref7) {\r\n  let { mirror } = _ref7,\r\n      args = _objectWithoutProperties(_ref7, ['mirror']);\r\n\r\n  return withPromise(resolve => {\r\n    mirror.removeAttribute('id');\r\n    delete mirror.id;\r\n    resolve(_extends({ mirror }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Positions mirror with translate3d\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {SensorEvent} state.sensorEvent\r\n * @param {Object} state.mirrorOffset\r\n * @param {Number} state.initialY\r\n * @param {Number} state.initialX\r\n * @param {Object} state.options\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction positionMirror({ withFrame = false, initial = false } = {}) {\r\n  return (_ref8) => {\r\n    let {\r\n      mirror,\r\n      sensorEvent,\r\n      mirrorOffset,\r\n      initialY,\r\n      initialX,\r\n      scrollOffset,\r\n      options,\r\n      passedThreshX,\r\n      passedThreshY,\r\n      lastMovedX,\r\n      lastMovedY\r\n    } = _ref8,\r\n        args = _objectWithoutProperties(_ref8, ['mirror', 'sensorEvent', 'mirrorOffset', 'initialY', 'initialX', 'scrollOffset', 'options', 'passedThreshX', 'passedThreshY', 'lastMovedX', 'lastMovedY']);\r\n\r\n    return withPromise(resolve => {\r\n      const result = _extends({\r\n        mirror,\r\n        sensorEvent,\r\n        mirrorOffset,\r\n        options\r\n      }, args);\r\n\r\n      if (mirrorOffset) {\r\n        const x = passedThreshX ? Math.round((sensorEvent.clientX - mirrorOffset.left - scrollOffset.x) / (options.thresholdX || 1)) * (options.thresholdX || 1) : Math.round(lastMovedX);\r\n        const y = passedThreshY ? Math.round((sensorEvent.clientY - mirrorOffset.top - scrollOffset.y) / (options.thresholdY || 1)) * (options.thresholdY || 1) : Math.round(lastMovedY);\r\n\r\n        if (options.xAxis && options.yAxis || initial) {\r\n          mirror.style.transform = `translate3d(${x}px, ${y}px, 0)`;\r\n        } else if (options.xAxis && !options.yAxis) {\r\n          mirror.style.transform = `translate3d(${x}px, ${initialY}px, 0)`;\r\n        } else if (options.yAxis && !options.xAxis) {\r\n          mirror.style.transform = `translate3d(${initialX}px, ${y}px, 0)`;\r\n        }\r\n\r\n        if (initial) {\r\n          result.initialX = x;\r\n          result.initialY = y;\r\n        }\r\n\r\n        result.lastMovedX = x;\r\n        result.lastMovedY = y;\r\n      }\r\n\r\n      resolve(result);\r\n    }, { frame: withFrame });\r\n  };\r\n}\r\n\r\n/**\r\n * Wraps functions in promise with potential animation frame option\r\n * @param {Function} callback\r\n * @param {Object} options\r\n * @param {Boolean} options.raf\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction withPromise(callback, { raf = false } = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    if (raf) {\r\n      requestAnimationFrame(() => {\r\n        callback(resolve, reject);\r\n      });\r\n    } else {\r\n      callback(resolve, reject);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Returns true if the sensor event was triggered by a native browser drag event\r\n * @param {SensorEvent} sensorEvent\r\n */\r\nfunction isNativeDragEvent(sensorEvent) {\r\n  return (/^drag/.test(sensorEvent.originalEvent.type)\r\n  );\r\n}\r\n\r\n/***/ }),\r\n/* 35 */\r\n/***/ (function(module, exports, __nested_webpack_require_111519__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Mirror = __nested_webpack_require_111519__(34);\r\n\r\nvar _Mirror2 = _interopRequireDefault(_Mirror);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Mirror2.default;\r\nexports.defaultOptions = _Mirror.defaultOptions;\r\n\r\n/***/ }),\r\n/* 36 */\r\n/***/ (function(module, exports, __nested_webpack_require_112006__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_112006__(3);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onInitialize = Symbol('onInitialize');\r\nconst onDestroy = Symbol('onDestroy');\r\n\r\n/**\r\n * Focusable default options\r\n * @property {Object} defaultOptions\r\n * @type {Object}\r\n */\r\nconst defaultOptions = {};\r\n\r\n/**\r\n * Focusable plugin\r\n * @class Focusable\r\n * @module Focusable\r\n * @extends AbstractPlugin\r\n */\r\nclass Focusable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Focusable constructor.\r\n   * @constructs Focusable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Focusable options\r\n     * @property {Object} options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    this[onInitialize] = this[onInitialize].bind(this);\r\n    this[onDestroy] = this[onDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches listeners to draggable\r\n   */\r\n  attach() {\r\n    this.draggable.on('draggable:initialize', this[onInitialize]).on('draggable:destroy', this[onDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Detaches listeners from draggable\r\n   */\r\n  detach() {\r\n    this.draggable.off('draggable:initialize', this[onInitialize]).off('draggable:destroy', this[onDestroy]);\r\n\r\n    // Remove modified elements when detach\r\n    this[onDestroy]();\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.focusable || {};\r\n  }\r\n\r\n  /**\r\n   * Returns draggable containers and elements\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getElements() {\r\n    return [...this.draggable.containers, ...this.draggable.getDraggableElements()];\r\n  }\r\n\r\n  /**\r\n   * Intialize handler\r\n   * @private\r\n   */\r\n  [onInitialize]() {\r\n    // Can wait until the next best frame is available\r\n    requestAnimationFrame(() => {\r\n      this.getElements().forEach(element => decorateElement(element));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Destroy handler\r\n   * @private\r\n   */\r\n  [onDestroy]() {\r\n    // Can wait until the next best frame is available\r\n    requestAnimationFrame(() => {\r\n      this.getElements().forEach(element => stripElement(element));\r\n    });\r\n  }\r\n}\r\n\r\nexports.default = Focusable; /**\r\n                              * Keeps track of all the elements that are missing tabindex attributes\r\n                              * so they can be reset when draggable gets destroyed\r\n                              * @const {HTMLElement[]} elementsWithMissingTabIndex\r\n                              */\r\n\r\nconst elementsWithMissingTabIndex = [];\r\n\r\n/**\r\n * Decorates element with tabindex attributes\r\n * @param {HTMLElement} element\r\n * @return {Object}\r\n * @private\r\n */\r\nfunction decorateElement(element) {\r\n  const hasMissingTabIndex = Boolean(!element.getAttribute('tabindex') && element.tabIndex === -1);\r\n\r\n  if (hasMissingTabIndex) {\r\n    elementsWithMissingTabIndex.push(element);\r\n    element.tabIndex = 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Removes elements tabindex attributes\r\n * @param {HTMLElement} element\r\n * @private\r\n */\r\nfunction stripElement(element) {\r\n  const tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);\r\n\r\n  if (tabIndexElementPosition !== -1) {\r\n    element.tabIndex = -1;\r\n    elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);\r\n  }\r\n}\r\n\r\n/***/ }),\r\n/* 37 */\r\n/***/ (function(module, exports, __nested_webpack_require_115918__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Focusable = __nested_webpack_require_115918__(36);\r\n\r\nvar _Focusable2 = _interopRequireDefault(_Focusable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Focusable2.default;\r\n\r\n/***/ }),\r\n/* 38 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * All draggable plugins inherit from this class.\r\n * @abstract\r\n * @class AbstractPlugin\r\n * @module AbstractPlugin\r\n */\r\nclass AbstractPlugin {\r\n  /**\r\n   * AbstractPlugin constructor.\r\n   * @constructs AbstractPlugin\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    /**\r\n     * Draggable instance\r\n     * @property draggable\r\n     * @type {Draggable}\r\n     */\r\n    this.draggable = draggable;\r\n  }\r\n\r\n  /**\r\n   * Override to add listeners\r\n   * @abstract\r\n   */\r\n  attach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n\r\n  /**\r\n   * Override to remove listeners\r\n   * @abstract\r\n   */\r\n  detach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n}\r\nexports.default = AbstractPlugin;\r\n\r\n/***/ }),\r\n/* 39 */\r\n/***/ (function(module, exports, __nested_webpack_require_117242__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_117242__(3);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onInitialize = Symbol('onInitialize');\r\nconst onDestroy = Symbol('onDestroy');\r\nconst announceEvent = Symbol('announceEvent');\r\nconst announceMessage = Symbol('announceMessage');\r\n\r\nconst ARIA_RELEVANT = 'aria-relevant';\r\nconst ARIA_ATOMIC = 'aria-atomic';\r\nconst ARIA_LIVE = 'aria-live';\r\nconst ROLE = 'role';\r\n\r\n/**\r\n * Announcement default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.expire\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  expire: 7000\r\n};\r\n\r\n/**\r\n * Announcement plugin\r\n * @class Announcement\r\n * @module Announcement\r\n * @extends AbstractPlugin\r\n */\r\nclass Announcement extends _AbstractPlugin2.default {\r\n  /**\r\n   * Announcement constructor.\r\n   * @constructs Announcement\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Plugin options\r\n     * @property options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Original draggable trigger method. Hack until we have onAll or on('all')\r\n     * @property originalTriggerMethod\r\n     * @type {Function}\r\n     */\r\n    this.originalTriggerMethod = this.draggable.trigger;\r\n\r\n    this[onInitialize] = this[onInitialize].bind(this);\r\n    this[onDestroy] = this[onDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches listeners to draggable\r\n   */\r\n  attach() {\r\n    this.draggable.on('draggable:initialize', this[onInitialize]);\r\n  }\r\n\r\n  /**\r\n   * Detaches listeners from draggable\r\n   */\r\n  detach() {\r\n    this.draggable.off('draggable:destroy', this[onDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Returns passed in options\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.announcements || {};\r\n  }\r\n\r\n  /**\r\n   * Announces event\r\n   * @private\r\n   * @param {AbstractEvent} event\r\n   */\r\n  [announceEvent](event) {\r\n    const message = this.options[event.type];\r\n\r\n    if (message && typeof message === 'string') {\r\n      this[announceMessage](message);\r\n    }\r\n\r\n    if (message && typeof message === 'function') {\r\n      this[announceMessage](message(event));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Announces message to screen reader\r\n   * @private\r\n   * @param {String} message\r\n   */\r\n  [announceMessage](message) {\r\n    announce(message, { expire: this.options.expire });\r\n  }\r\n\r\n  /**\r\n   * Initialize hander\r\n   * @private\r\n   */\r\n  [onInitialize]() {\r\n    // Hack until there is an api for listening for all events\r\n    this.draggable.trigger = event => {\r\n      try {\r\n        this[announceEvent](event);\r\n      } finally {\r\n        // Ensure that original trigger is called\r\n        this.originalTriggerMethod.call(this.draggable, event);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Destroy hander\r\n   * @private\r\n   */\r\n  [onDestroy]() {\r\n    this.draggable.trigger = this.originalTriggerMethod;\r\n  }\r\n}\r\n\r\nexports.default = Announcement; /**\r\n                                 * @const {HTMLElement} liveRegion\r\n                                 */\r\n\r\nconst liveRegion = createRegion();\r\n\r\n/**\r\n * Announces message via live region\r\n * @param {String} message\r\n * @param {Object} options\r\n * @param {Number} options.expire\r\n */\r\nfunction announce(message, { expire }) {\r\n  const element = document.createElement('div');\r\n\r\n  element.textContent = message;\r\n  liveRegion.appendChild(element);\r\n\r\n  return setTimeout(() => {\r\n    liveRegion.removeChild(element);\r\n  }, expire);\r\n}\r\n\r\n/**\r\n * Creates region element\r\n * @return {HTMLElement}\r\n */\r\nfunction createRegion() {\r\n  const element = document.createElement('div');\r\n\r\n  element.setAttribute('id', 'draggable-live-region');\r\n  element.setAttribute(ARIA_RELEVANT, 'additions');\r\n  element.setAttribute(ARIA_ATOMIC, 'true');\r\n  element.setAttribute(ARIA_LIVE, 'assertive');\r\n  element.setAttribute(ROLE, 'log');\r\n\r\n  element.style.position = 'fixed';\r\n  element.style.width = '1px';\r\n  element.style.height = '1px';\r\n  element.style.top = '-1px';\r\n  element.style.overflow = 'hidden';\r\n\r\n  return element;\r\n}\r\n\r\n// Append live region element as early as possible\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  document.body.appendChild(liveRegion);\r\n});\r\n\r\n/***/ }),\r\n/* 40 */\r\n/***/ (function(module, exports, __nested_webpack_require_122130__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Announcement = __nested_webpack_require_122130__(39);\r\n\r\nvar _Announcement2 = _interopRequireDefault(_Announcement);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Announcement2.default;\r\nexports.defaultOptions = _Announcement.defaultOptions;\r\n\r\n/***/ }),\r\n/* 41 */\r\n/***/ (function(module, exports, __nested_webpack_require_122647__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DraggableDestroyEvent = exports.DraggableInitializedEvent = exports.DraggableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_122647__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base draggable event\r\n * @class DraggableEvent\r\n * @module DraggableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DraggableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Draggable instance\r\n   * @property draggable\r\n   * @type {Draggable}\r\n   * @readonly\r\n   */\r\n  get draggable() {\r\n    return this.data.draggable;\r\n  }\r\n}\r\n\r\nexports.DraggableEvent = DraggableEvent; /**\r\n                                          * Draggable initialized event\r\n                                          * @class DraggableInitializedEvent\r\n                                          * @module DraggableInitializedEvent\r\n                                          * @extends DraggableEvent\r\n                                          */\r\n\r\nDraggableEvent.type = 'draggable';\r\nclass DraggableInitializedEvent extends DraggableEvent {}\r\n\r\nexports.DraggableInitializedEvent = DraggableInitializedEvent; /**\r\n                                                                * Draggable destory event\r\n                                                                * @class DraggableInitializedEvent\r\n                                                                * @module DraggableDestroyEvent\r\n                                                                * @extends DraggableDestroyEvent\r\n                                                                */\r\n\r\nDraggableInitializedEvent.type = 'draggable:initialize';\r\nclass DraggableDestroyEvent extends DraggableEvent {}\r\nexports.DraggableDestroyEvent = DraggableDestroyEvent;\r\nDraggableDestroyEvent.type = 'draggable:destroy';\r\n\r\n/***/ }),\r\n/* 42 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst canceled = Symbol('canceled');\r\n\r\n/**\r\n * All events fired by draggable inherit this class. You can call `cancel()` to\r\n * cancel a specific event or you can check if an event has been canceled by\r\n * calling `canceled()`.\r\n * @abstract\r\n * @class AbstractEvent\r\n * @module AbstractEvent\r\n */\r\nclass AbstractEvent {\r\n\r\n  /**\r\n   * AbstractEvent constructor.\r\n   * @constructs AbstractEvent\r\n   * @param {object} data - Event data\r\n   */\r\n\r\n  /**\r\n   * Event type\r\n   * @static\r\n   * @abstract\r\n   * @property type\r\n   * @type {String}\r\n   */\r\n  constructor(data) {\r\n    this[canceled] = false;\r\n    this.data = data;\r\n  }\r\n\r\n  /**\r\n   * Read-only type\r\n   * @abstract\r\n   * @return {String}\r\n   */\r\n\r\n\r\n  /**\r\n   * Event cancelable\r\n   * @static\r\n   * @abstract\r\n   * @property cancelable\r\n   * @type {Boolean}\r\n   */\r\n  get type() {\r\n    return this.constructor.type;\r\n  }\r\n\r\n  /**\r\n   * Read-only cancelable\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  get cancelable() {\r\n    return this.constructor.cancelable;\r\n  }\r\n\r\n  /**\r\n   * Cancels the event instance\r\n   * @abstract\r\n   */\r\n  cancel() {\r\n    this[canceled] = true;\r\n  }\r\n\r\n  /**\r\n   * Check if event has been canceled\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  canceled() {\r\n    return Boolean(this[canceled]);\r\n  }\r\n\r\n  /**\r\n   * Returns new event instance with existing event data.\r\n   * This method allows for overriding of event data.\r\n   * @param {Object} data\r\n   * @return {AbstractEvent}\r\n   */\r\n  clone(data) {\r\n    return new this.constructor(_extends({}, this.data, data));\r\n  }\r\n}\r\nexports.default = AbstractEvent;\r\nAbstractEvent.type = 'event';\r\nAbstractEvent.cancelable = false;\r\n\r\n/***/ }),\r\n/* 43 */\r\n/***/ (function(module, exports, __nested_webpack_require_126817__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DragStoppedEvent = exports.DragStopEvent = exports.DragPressureEvent = exports.DragOutContainerEvent = exports.DragOverContainerEvent = exports.DragOutEvent = exports.DragOverEvent = exports.DragMoveEvent = exports.DragStartEvent = exports.DragEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_126817__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base drag event\r\n * @class DragEvent\r\n * @module DragEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DragEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Draggables source element\r\n   * @property source\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get source() {\r\n    return this.data.source;\r\n  }\r\n\r\n  /**\r\n   * Draggables original source element\r\n   * @property originalSource\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get originalSource() {\r\n    return this.data.originalSource;\r\n  }\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n\r\n  /**\r\n   * Draggables source container element\r\n   * @property sourceContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get sourceContainer() {\r\n    return this.data.sourceContainer;\r\n  }\r\n\r\n  /**\r\n   * Sensor event\r\n   * @property sensorEvent\r\n   * @type {SensorEvent}\r\n   * @readonly\r\n   */\r\n  get sensorEvent() {\r\n    return this.data.sensorEvent;\r\n  }\r\n\r\n  /**\r\n   * Original event that triggered sensor event\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    if (this.sensorEvent) {\r\n      return this.sensorEvent.originalEvent;\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexports.DragEvent = DragEvent; /**\r\n                                * Drag start event\r\n                                * @class DragStartEvent\r\n                                * @module DragStartEvent\r\n                                * @extends DragEvent\r\n                                */\r\n\r\nDragEvent.type = 'drag';\r\nclass DragStartEvent extends DragEvent {}\r\n\r\nexports.DragStartEvent = DragStartEvent; /**\r\n                                          * Drag move event\r\n                                          * @class DragMoveEvent\r\n                                          * @module DragMoveEvent\r\n                                          * @extends DragEvent\r\n                                          */\r\n\r\nDragStartEvent.type = 'drag:start';\r\nDragStartEvent.cancelable = true;\r\nclass DragMoveEvent extends DragEvent {}\r\n\r\nexports.DragMoveEvent = DragMoveEvent; /**\r\n                                        * Drag over event\r\n                                        * @class DragOverEvent\r\n                                        * @module DragOverEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragMoveEvent.type = 'drag:move';\r\nclass DragOverEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you are over\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n}\r\n\r\nexports.DragOverEvent = DragOverEvent; /**\r\n                                        * Drag out event\r\n                                        * @class DragOutEvent\r\n                                        * @module DragOutEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragOverEvent.type = 'drag:over';\r\nDragOverEvent.cancelable = true;\r\nclass DragOutEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you left\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n}\r\n\r\nexports.DragOutEvent = DragOutEvent; /**\r\n                                      * Drag over container event\r\n                                      * @class DragOverContainerEvent\r\n                                      * @module DragOverContainerEvent\r\n                                      * @extends DragEvent\r\n                                      */\r\n\r\nDragOutEvent.type = 'drag:out';\r\nclass DragOverContainerEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.DragOverContainerEvent = DragOverContainerEvent; /**\r\n                                                          * Drag out container event\r\n                                                          * @class DragOutContainerEvent\r\n                                                          * @module DragOutContainerEvent\r\n                                                          * @extends DragEvent\r\n                                                          */\r\n\r\nDragOverContainerEvent.type = 'drag:over:container';\r\nclass DragOutContainerEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you left\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.DragOutContainerEvent = DragOutContainerEvent; /**\r\n                                                        * Drag pressure event\r\n                                                        * @class DragPressureEvent\r\n                                                        * @module DragPressureEvent\r\n                                                        * @extends DragEvent\r\n                                                        */\r\n\r\nDragOutContainerEvent.type = 'drag:out:container';\r\nclass DragPressureEvent extends DragEvent {\r\n\r\n  /**\r\n   * Pressure applied on draggable element\r\n   * @property pressure\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get pressure() {\r\n    return this.data.pressure;\r\n  }\r\n}\r\n\r\nexports.DragPressureEvent = DragPressureEvent; /**\r\n                                                * Drag stop event\r\n                                                * @class DragStopEvent\r\n                                                * @module DragStopEvent\r\n                                                * @extends DragEvent\r\n                                                */\r\n\r\nDragPressureEvent.type = 'drag:pressure';\r\nclass DragStopEvent extends DragEvent {}\r\n\r\nexports.DragStopEvent = DragStopEvent; /**\r\n                                        * Drag stopped event\r\n                                        * @class DragStoppedEvent\r\n                                        * @module DragStoppedEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragStopEvent.type = 'drag:stop';\r\nclass DragStoppedEvent extends DragEvent {}\r\nexports.DragStoppedEvent = DragStoppedEvent;\r\nDragStoppedEvent.type = 'drag:stopped';\r\n\r\n/***/ }),\r\n/* 44 */\r\n/***/ (function(module, exports, __nested_webpack_require_134342__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragEvent = __nested_webpack_require_134342__(8);\r\n\r\nObject.keys(_DragEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DragEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _DraggableEvent = __nested_webpack_require_134342__(7);\r\n\r\nObject.keys(_DraggableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DraggableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Plugins = __nested_webpack_require_134342__(6);\r\n\r\nObject.keys(_Plugins).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _Plugins[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Sensors = __nested_webpack_require_134342__(5);\r\n\r\nObject.keys(_Sensors).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _Sensors[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Draggable = __nested_webpack_require_134342__(11);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Draggable2.default;\r\n\r\n/***/ })\r\n/******/ ]);\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9kcmFnZ2FibGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUswQjtBQUNoQyxDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw4QkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGVBQWUsOEJBQW1CO0FBQ2xDLG1EQUFtRCwrQkFBK0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLGlFQUFpRSxpQkFBaUI7QUFDbEY7QUFDQSwwREFBMEQsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGdDQUFnQyw4QkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBbUI7QUFDOUIsa0RBQWtELGdDQUFnQztBQUNsRiwwRUFBMEUsOEJBQW1CLDRCQUE0QixvQkFBb0I7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsMENBQTBDO0FBQzFDLFdBQVcsOEJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQW1CLENBQUMsOEJBQW1CO0FBQ3hELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0JBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1CQUFtQiwrQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsK0JBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGNBQWMsK0JBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLCtCQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxlQUFlLCtCQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpQ0FBaUMsK0JBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdCQUFnQiwrQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsbUJBQW1CLCtCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx1Q0FBdUMsdUNBQXVDO0FBQzlFO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLCtCQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxzQkFBc0IsK0JBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLCtCQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxxQkFBcUIsK0JBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLCtCQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxjQUFjLCtCQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxtQkFBbUIsK0JBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1CQUFtQiwrQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCLCtCQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3QkFBd0IsK0JBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1CQUFtQiwrQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSx1Q0FBdUMsdUNBQXVDO0FBQzlFO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLCtCQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0IsK0JBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaUJBQWlCLCtCQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxjQUFjLCtCQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtCQUFrQiwrQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx1Q0FBdUMsdUNBQXVDO0FBQzlFO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxzQkFBc0IsZ0NBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpQkFBaUIsZ0NBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFdBQVc7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZUFBZSxnQ0FBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esb0RBQW9ELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCxpQ0FBaUM7QUFDaFA7QUFDQSxhQUFhLGdDQUFtQjtBQUNoQztBQUNBLGVBQWUsZ0NBQW1CO0FBQ2xDO0FBQ0EsZUFBZSxnQ0FBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBbUI7QUFDbEM7QUFDQSxzQkFBc0IsZ0NBQW1CO0FBQ3pDO0FBQ0EsaUJBQWlCLGdDQUFtQjtBQUNwQztBQUNBLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0Esc0NBQXNDLDBFQUEwRTtBQUNoSCxvQ0FBb0MsMEVBQTBFO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0NBQW9DO0FBQ2pELGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFlBQVk7QUFDNUIsWUFBWTtBQUNaO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQix1Q0FBdUM7QUFDakUsZ0NBQWdDLG1EQUFtRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCLGFBQWE7QUFDN0IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsYUFBYTtBQUMxQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QscUJBQXFCO0FBQ3pFO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtCQUFrQixnQ0FBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNB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QVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaUJBQWlCLGlDQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLHNCQUFzQixpQ0FBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxlQUFlLGlDQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLGVBQWUsaUNBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsaUJBQWlCLGlDQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUNBQXVDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9kcmFnZ2FibGUuanM/ZmNiNiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xyXG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxyXG5cdFx0ZGVmaW5lKFwiRHJhZ2dhYmxlXCIsIFtdLCBmYWN0b3J5KTtcclxuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcclxuXHRcdGV4cG9ydHNbXCJEcmFnZ2FibGVcIl0gPSBmYWN0b3J5KCk7XHJcblx0ZWxzZVxyXG5cdFx0cm9vdFtcIkRyYWdnYWJsZVwiXSA9IGZhY3RvcnkoKTtcclxufSkod2luZG93LCBmdW5jdGlvbigpIHtcclxucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcclxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXHJcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxyXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcclxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxyXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xyXG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcclxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXHJcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XHJcbi8qKioqKiovIFx0XHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXHJcbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcclxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XHJcbi8qKioqKiovIFx0fVxyXG4vKioqKioqL1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XHJcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XHJcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcclxuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xyXG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcclxuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XHJcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcclxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcclxuLyoqKioqKi8gXHRcdHJldHVybiBucztcclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cclxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcclxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcclxuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcclxuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xyXG4vKioqKioqL1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xyXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDQ0KTtcclxuLyoqKioqKi8gfSlcclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyoqKioqKi8gKFtcclxuLyogMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxuXHJcbk9iamVjdC5rZXlzKF9TZW5zb3JFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9TZW5zb3JFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxuXHJcbnZhciBfU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX1NlbnNvcjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9jbG9zZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2Nsb3Nlc3QnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9zZXN0KS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncmVxdWVzdE5leHRBbmltYXRpb25GcmFtZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfZGlzdGFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGlzdGFuY2UnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXN0YW5jZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF90b3VjaENvb3JkcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd0b3VjaENvb3JkcycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvdWNoQ29vcmRzKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1NlbnNvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Nb3VzZVNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdNb3VzZVNlbnNvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vdXNlU2Vuc29yKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1RvdWNoU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1RvdWNoU2Vuc29yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVG91Y2hTZW5zb3IpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfRHJhZ1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdEcmFnU2Vuc29yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ1NlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Gb3JjZVRvdWNoU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0ZvcmNlVG91Y2hTZW5zb3InLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Gb3JjZVRvdWNoU2Vuc29yKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbk9iamVjdC5rZXlzKF9TZW5zb3JFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9TZW5zb3JFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKioqLyB9KSxcclxuLyogNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQW5ub3VuY2VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Fubm91bmNlbWVudCcsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fubm91bmNlbWVudCkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRBbm5vdW5jZW1lbnRPcHRpb25zJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX0Fubm91bmNlbWVudC5kZWZhdWx0T3B0aW9ucztcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Gb2N1c2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRm9jdXNhYmxlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRm9jdXNhYmxlKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX01pcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdNaXJyb3InLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NaXJyb3IpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0TWlycm9yT3B0aW9ucycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9NaXJyb3IuZGVmYXVsdE9wdGlvbnM7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfU2Nyb2xsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTY3JvbGxhYmxlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Nyb2xsYWJsZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRTY3JvbGxhYmxlT3B0aW9ucycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9TY3JvbGxhYmxlLmRlZmF1bHRPcHRpb25zO1xyXG4gIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0RyYWdnYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XHJcblxyXG5PYmplY3Qua2V5cyhfRHJhZ2dhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfRHJhZ2dhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRHJhZ0V2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XHJcblxyXG5PYmplY3Qua2V5cyhfRHJhZ0V2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX0RyYWdFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG4vKipcclxuICogVGhlIEVtaXR0ZXIgaXMgYSBzaW1wbGUgZW1pdHRlciBjbGFzcyB0aGF0IHByb3ZpZGVzIHlvdSB3aXRoIGBvbigpYCwgYG9mZigpYCBhbmQgYHRyaWdnZXIoKWAgbWV0aG9kc1xyXG4gKiBAY2xhc3MgRW1pdHRlclxyXG4gKiBAbW9kdWxlIEVtaXR0ZXJcclxuICovXHJcbmNsYXNzIEVtaXR0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgYnkgZXZlbnQgbmFtZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXHJcbiAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gY2FsbGJhY2tzXHJcbiAgICovXHJcbiAgb24odHlwZSwgLi4uY2FsbGJhY2tzKSB7XHJcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW3R5cGVdKSB7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jYWxsYmFja3NbdHlwZV0ucHVzaCguLi5jYWxsYmFja3MpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVW5yZWdpc3RlcnMgY2FsbGJhY2tzIGJ5IGV2ZW50IG5hbWVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgb2ZmKHR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW3R5cGVdKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvcHkgPSB0aGlzLmNhbGxiYWNrc1t0eXBlXS5zbGljZSgwKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvcHkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGNhbGxiYWNrID09PSBjb3B5W2ldKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3NbdHlwZV0uc3BsaWNlKGksIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmlnZ2VycyBldmVudCBjYWxsYmFja3MgYnkgZXZlbnQgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtBYnN0cmFjdEV2ZW50fSBldmVudFxyXG4gICAqL1xyXG4gIHRyaWdnZXIoZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5jYWxsYmFja3NbZXZlbnQudHlwZV0pIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2FsbGJhY2tzID0gWy4uLnRoaXMuY2FsbGJhY2tzW2V2ZW50LnR5cGVdXTtcclxuICAgIGNvbnN0IGNhdWdodEVycm9ycyA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSBjYWxsYmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgY29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjYXVnaHRFcnJvcnMucHVzaChlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2F1Z2h0RXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYERyYWdnYWJsZSBjYXVnaHQgZXJyb3JzIHdoaWxlIHRyaWdnZXJpbmcgJyR7ZXZlbnQudHlwZX0nYCwgY2F1Z2h0RXJyb3JzKTtcclxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBFbWl0dGVyO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9FbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHJcbnZhciBfRW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FbWl0dGVyKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfRW1pdHRlcjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcbnZhciBfUGx1Z2lucyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG52YXIgX0VtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuXHJcbnZhciBfRW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FbWl0dGVyKTtcclxuXHJcbnZhciBfU2Vuc29ycyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG52YXIgX0RyYWdnYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuXHJcbnZhciBfRHJhZ0V2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcclxuY29uc3Qgb25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xyXG5jb25zdCBvbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XHJcbmNvbnN0IG9uRHJhZ1ByZXNzdXJlID0gU3ltYm9sKCdvbkRyYWdQcmVzc3VyZScpO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdCB7T2JqZWN0fSBkZWZhdWx0QW5ub3VuY2VtZW50c1xyXG4gKiBAY29uc3Qge0Z1bmN0aW9ufSBkZWZhdWx0QW5ub3VuY2VtZW50c1snZHJhZzpzdGFydCddXHJcbiAqIEBjb25zdCB7RnVuY3Rpb259IGRlZmF1bHRBbm5vdW5jZW1lbnRzWydkcmFnOnN0b3AnXVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdEFubm91bmNlbWVudHMgPSB7XHJcbiAgJ2RyYWc6c3RhcnQnOiBldmVudCA9PiBgUGlja2VkIHVwICR7ZXZlbnQuc291cmNlLnRleHRDb250ZW50LnRyaW0oKSB8fCBldmVudC5zb3VyY2UuaWQgfHwgJ2RyYWdnYWJsZSBlbGVtZW50J31gLFxyXG4gICdkcmFnOnN0b3AnOiBldmVudCA9PiBgUmVsZWFzZWQgJHtldmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGV2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnfWBcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRDbGFzc2VzID0ge1xyXG4gICdjb250YWluZXI6ZHJhZ2dpbmcnOiAnZHJhZ2dhYmxlLWNvbnRhaW5lci0taXMtZHJhZ2dpbmcnLFxyXG4gICdzb3VyY2U6ZHJhZ2dpbmcnOiAnZHJhZ2dhYmxlLXNvdXJjZS0taXMtZHJhZ2dpbmcnLFxyXG4gICdzb3VyY2U6cGxhY2VkJzogJ2RyYWdnYWJsZS1zb3VyY2UtLXBsYWNlZCcsXHJcbiAgJ2NvbnRhaW5lcjpwbGFjZWQnOiAnZHJhZ2dhYmxlLWNvbnRhaW5lci0tcGxhY2VkJyxcclxuICAnYm9keTpkcmFnZ2luZyc6ICdkcmFnZ2FibGUtLWlzLWRyYWdnaW5nJyxcclxuICAnZHJhZ2dhYmxlOm92ZXInOiAnZHJhZ2dhYmxlLS1vdmVyJyxcclxuICAnY29udGFpbmVyOm92ZXInOiAnZHJhZ2dhYmxlLWNvbnRhaW5lci0tb3ZlcicsXHJcbiAgJ3NvdXJjZTpvcmlnaW5hbCc6ICdkcmFnZ2FibGUtLW9yaWdpbmFsJyxcclxuICBtaXJyb3I6ICdkcmFnZ2FibGUtbWlycm9yJ1xyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xyXG4gIGRyYWdnYWJsZTogJy5kcmFnZ2FibGUtc291cmNlJyxcclxuICBoYW5kbGU6IG51bGwsXHJcbiAgZGVsYXk6IHt9LFxyXG4gIGRpc3RhbmNlOiAwLFxyXG4gIHBsYWNlZFRpbWVvdXQ6IDgwMCxcclxuICBwbHVnaW5zOiBbXSxcclxuICBzZW5zb3JzOiBbXSxcclxuICBleGNsdWRlOiB7XHJcbiAgICBwbHVnaW5zOiBbXSxcclxuICAgIHNlbnNvcnM6IFtdXHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdGhlIGNvcmUgZHJhZ2dhYmxlIGxpYnJhcnkgdGhhdCBkb2VzIHRoZSBoZWF2eSBsaWZ0aW5nXHJcbiAqIEBjbGFzcyBEcmFnZ2FibGVcclxuICogQG1vZHVsZSBEcmFnZ2FibGVcclxuICovXHJcbmNsYXNzIERyYWdnYWJsZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBEcmFnZ2FibGVcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBEcmFnZ2FibGUgY29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZHJhZ2dhYmxlXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmF1bHQgcGx1Z2lucyBkcmFnZ2FibGUgdXNlc1xyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcHJvcGVydHkge09iamVjdH0gUGx1Z2luc1xyXG4gICAqIEBwcm9wZXJ0eSB7QW5ub3VuY2VtZW50fSBQbHVnaW5zLkFubm91bmNlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSB7Rm9jdXNhYmxlfSBQbHVnaW5zLkZvY3VzYWJsZVxyXG4gICAqIEBwcm9wZXJ0eSB7TWlycm9yfSBQbHVnaW5zLk1pcnJvclxyXG4gICAqIEBwcm9wZXJ0eSB7U2Nyb2xsYWJsZX0gUGx1Z2lucy5TY3JvbGxhYmxlXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW2RvY3VtZW50LmJvZHldLCBvcHRpb25zID0ge30pIHtcclxuICAgIC8qKlxyXG4gICAgICogRHJhZ2dhYmxlIGNvbnRhaW5lcnNcclxuICAgICAqIEBwcm9wZXJ0eSBjb250YWluZXJzXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX1cclxuICAgICAqL1xyXG4gICAgaWYgKGNvbnRhaW5lcnMgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBjb250YWluZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgdGhpcy5jb250YWluZXJzID0gWy4uLmNvbnRhaW5lcnNdO1xyXG4gICAgfSBlbHNlIGlmIChjb250YWluZXJzIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5jb250YWluZXJzID0gW2NvbnRhaW5lcnNdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcmFnZ2FibGUgY29udGFpbmVycyBhcmUgZXhwZWN0ZWQgdG8gYmUgb2YgdHlwZSBgTm9kZUxpc3RgLCBgSFRNTEVsZW1lbnRbXWAgb3IgYEhUTUxFbGVtZW50YCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucywge1xyXG4gICAgICBjbGFzc2VzOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdENsYXNzZXMsIG9wdGlvbnMuY2xhc3NlcyB8fCB7fSksXHJcbiAgICAgIGFubm91bmNlbWVudHM6IF9leHRlbmRzKHt9LCBkZWZhdWx0QW5ub3VuY2VtZW50cywgb3B0aW9ucy5hbm5vdW5jZW1lbnRzIHx8IHt9KSxcclxuICAgICAgZXhjbHVkZToge1xyXG4gICAgICAgIHBsdWdpbnM6IG9wdGlvbnMuZXhjbHVkZSAmJiBvcHRpb25zLmV4Y2x1ZGUucGx1Z2lucyB8fCBbXSxcclxuICAgICAgICBzZW5zb3JzOiBvcHRpb25zLmV4Y2x1ZGUgJiYgb3B0aW9ucy5leGNsdWRlLnNlbnNvcnMgfHwgW11cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmFnZ2FibGVzIGV2ZW50IGVtaXR0ZXJcclxuICAgICAqIEBwcm9wZXJ0eSBlbWl0dGVyXHJcbiAgICAgKiBAdHlwZSB7RW1pdHRlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IF9FbWl0dGVyMi5kZWZhdWx0KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGRyYWcgc3RhdGVcclxuICAgICAqIEBwcm9wZXJ0eSBkcmFnZ2luZ1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFjdGl2ZSBwbHVnaW5zXHJcbiAgICAgKiBAcHJvcGVydHkgcGx1Z2luc1xyXG4gICAgICogQHR5cGUge1BsdWdpbltdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBsdWdpbnMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFjdGl2ZSBzZW5zb3JzXHJcbiAgICAgKiBAcHJvcGVydHkgc2Vuc29yc1xyXG4gICAgICogQHR5cGUge1NlbnNvcltdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbnNvcnMgPSBbXTtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnUHJlc3N1cmVdID0gdGhpc1tvbkRyYWdQcmVzc3VyZV0uYmluZCh0aGlzKTtcclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWc6cHJlc3N1cmUnLCB0aGlzW29uRHJhZ1ByZXNzdXJlXSwgdHJ1ZSk7XHJcblxyXG4gICAgY29uc3QgZGVmYXVsdFBsdWdpbnMgPSBPYmplY3QudmFsdWVzKERyYWdnYWJsZS5QbHVnaW5zKS5maWx0ZXIoUGx1Z2luID0+ICF0aGlzLm9wdGlvbnMuZXhjbHVkZS5wbHVnaW5zLmluY2x1ZGVzKFBsdWdpbikpO1xyXG4gICAgY29uc3QgZGVmYXVsdFNlbnNvcnMgPSBPYmplY3QudmFsdWVzKERyYWdnYWJsZS5TZW5zb3JzKS5maWx0ZXIoc2Vuc29yID0+ICF0aGlzLm9wdGlvbnMuZXhjbHVkZS5zZW5zb3JzLmluY2x1ZGVzKHNlbnNvcikpO1xyXG5cclxuICAgIHRoaXMuYWRkUGx1Z2luKC4uLlsuLi5kZWZhdWx0UGx1Z2lucywgLi4udGhpcy5vcHRpb25zLnBsdWdpbnNdKTtcclxuICAgIHRoaXMuYWRkU2Vuc29yKC4uLlsuLi5kZWZhdWx0U2Vuc29ycywgLi4udGhpcy5vcHRpb25zLnNlbnNvcnNdKTtcclxuXHJcbiAgICBjb25zdCBkcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50ID0gbmV3IF9EcmFnZ2FibGVFdmVudC5EcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50KHtcclxuICAgICAgZHJhZ2dhYmxlOiB0aGlzXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLm9uKCdtaXJyb3I6Y3JlYXRlZCcsICh7IG1pcnJvciB9KSA9PiB0aGlzLm1pcnJvciA9IG1pcnJvcik7XHJcbiAgICB0aGlzLm9uKCdtaXJyb3I6ZGVzdHJveScsICgpID0+IHRoaXMubWlycm9yID0gbnVsbCk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzdHJveXMgRHJhZ2dhYmxlIGluc3RhbmNlLiBUaGlzIHJlbW92ZXMgYWxsIGludGVybmFsIGV2ZW50IGxpc3RlbmVycyBhbmRcclxuICAgKiBkZWFjdGl2YXRlcyBzZW5zb3JzIGFuZCBwbHVnaW5zXHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBEZWZhdWx0IHNlbnNvcnMgZHJhZ2dhYmxlIHVzZXNcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IFNlbnNvcnNcclxuICAgKiBAcHJvcGVydHkge01vdXNlU2Vuc29yfSBTZW5zb3JzLk1vdXNlU2Vuc29yXHJcbiAgICogQHByb3BlcnR5IHtUb3VjaFNlbnNvcn0gU2Vuc29ycy5Ub3VjaFNlbnNvclxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzpwcmVzc3VyZScsIHRoaXNbb25EcmFnUHJlc3N1cmVdLCB0cnVlKTtcclxuXHJcbiAgICBjb25zdCBkcmFnZ2FibGVEZXN0cm95RXZlbnQgPSBuZXcgX0RyYWdnYWJsZUV2ZW50LkRyYWdnYWJsZURlc3Ryb3lFdmVudCh7XHJcbiAgICAgIGRyYWdnYWJsZTogdGhpc1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdnYWJsZURlc3Ryb3lFdmVudCk7XHJcblxyXG4gICAgdGhpcy5yZW1vdmVQbHVnaW4oLi4udGhpcy5wbHVnaW5zLm1hcChwbHVnaW4gPT4gcGx1Z2luLmNvbnN0cnVjdG9yKSk7XHJcbiAgICB0aGlzLnJlbW92ZVNlbnNvciguLi50aGlzLnNlbnNvcnMubWFwKHNlbnNvciA9PiBzZW5zb3IuY29uc3RydWN0b3IpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgcGx1Z2luIHRvIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlLiBUaGlzIHdpbGwgZW5kIHVwIGNhbGxpbmcgdGhlIGF0dGFjaCBtZXRob2Qgb2YgdGhlIHBsdWdpblxyXG4gICAqIEBwYXJhbSB7Li4udHlwZW9mIFBsdWdpbn0gcGx1Z2lucyAtIFBsdWdpbnMgdGhhdCB5b3Ugd2FudCBhdHRhY2hlZCB0byBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLmFkZFBsdWdpbihDdXN0b21BMTF5UGx1Z2luLCBDdXN0b21NaXJyb3JQbHVnaW4pXHJcbiAgICovXHJcbiAgYWRkUGx1Z2luKC4uLnBsdWdpbnMpIHtcclxuICAgIGNvbnN0IGFjdGl2ZVBsdWdpbnMgPSBwbHVnaW5zLm1hcChQbHVnaW4gPT4gbmV3IFBsdWdpbih0aGlzKSk7XHJcblxyXG4gICAgYWN0aXZlUGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiBwbHVnaW4uYXR0YWNoKCkpO1xyXG4gICAgdGhpcy5wbHVnaW5zID0gWy4uLnRoaXMucGx1Z2lucywgLi4uYWN0aXZlUGx1Z2luc107XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIHBsdWdpbnMgdGhhdCBhcmUgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZS4gVGhpcyB3aWxsIGVuZCB1cCBjYWxsaW5nXHJcbiAgICogdGhlIGRldGFjaCBtZXRob2Qgb2YgdGhlIHBsdWdpblxyXG4gICAqIEBwYXJhbSB7Li4udHlwZW9mIFBsdWdpbn0gcGx1Z2lucyAtIFBsdWdpbnMgdGhhdCB5b3Ugd2FudCBkZXRhY2hlZCBmcm9tIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUucmVtb3ZlUGx1Z2luKE1pcnJvclBsdWdpbiwgQ3VzdG9tTWlycm9yUGx1Z2luKVxyXG4gICAqL1xyXG4gIHJlbW92ZVBsdWdpbiguLi5wbHVnaW5zKSB7XHJcbiAgICBjb25zdCByZW1vdmVkUGx1Z2lucyA9IHRoaXMucGx1Z2lucy5maWx0ZXIocGx1Z2luID0+IHBsdWdpbnMuaW5jbHVkZXMocGx1Z2luLmNvbnN0cnVjdG9yKSk7XHJcblxyXG4gICAgcmVtb3ZlZFBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4gcGx1Z2luLmRldGFjaCgpKTtcclxuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucGx1Z2lucy5maWx0ZXIocGx1Z2luID0+ICFwbHVnaW5zLmluY2x1ZGVzKHBsdWdpbi5jb25zdHJ1Y3RvcikpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBzZW5zb3JzIHRvIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlLiBUaGlzIHdpbGwgZW5kIHVwIGNhbGxpbmcgdGhlIGF0dGFjaCBtZXRob2Qgb2YgdGhlIHNlbnNvclxyXG4gICAqIEBwYXJhbSB7Li4udHlwZW9mIFNlbnNvcn0gc2Vuc29ycyAtIFNlbnNvcnMgdGhhdCB5b3Ugd2FudCBhdHRhY2hlZCB0byBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLmFkZFNlbnNvcihGb3JjZVRvdWNoU2Vuc29yLCBDdXN0b21TZW5zb3IpXHJcbiAgICovXHJcbiAgYWRkU2Vuc29yKC4uLnNlbnNvcnMpIHtcclxuICAgIGNvbnN0IGFjdGl2ZVNlbnNvcnMgPSBzZW5zb3JzLm1hcChTZW5zb3IgPT4gbmV3IFNlbnNvcih0aGlzLmNvbnRhaW5lcnMsIHRoaXMub3B0aW9ucykpO1xyXG5cclxuICAgIGFjdGl2ZVNlbnNvcnMuZm9yRWFjaChzZW5zb3IgPT4gc2Vuc29yLmF0dGFjaCgpKTtcclxuICAgIHRoaXMuc2Vuc29ycyA9IFsuLi50aGlzLnNlbnNvcnMsIC4uLmFjdGl2ZVNlbnNvcnNdO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBzZW5zb3JzIHRoYXQgYXJlIGFscmVhZHkgYXR0YWNoZWQgdG8gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2UuIFRoaXMgd2lsbCBlbmQgdXAgY2FsbGluZ1xyXG4gICAqIHRoZSBkZXRhY2ggbWV0aG9kIG9mIHRoZSBzZW5zb3JcclxuICAgKiBAcGFyYW0gey4uLnR5cGVvZiBTZW5zb3J9IHNlbnNvcnMgLSBTZW5zb3JzIHRoYXQgeW91IHdhbnQgYXR0YWNoZWQgdG8gZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5yZW1vdmVTZW5zb3IoVG91Y2hTZW5zb3IsIERyYWdTZW5zb3IpXHJcbiAgICovXHJcbiAgcmVtb3ZlU2Vuc29yKC4uLnNlbnNvcnMpIHtcclxuICAgIGNvbnN0IHJlbW92ZWRTZW5zb3JzID0gdGhpcy5zZW5zb3JzLmZpbHRlcihzZW5zb3IgPT4gc2Vuc29ycy5pbmNsdWRlcyhzZW5zb3IuY29uc3RydWN0b3IpKTtcclxuXHJcbiAgICByZW1vdmVkU2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IuZGV0YWNoKCkpO1xyXG4gICAgdGhpcy5zZW5zb3JzID0gdGhpcy5zZW5zb3JzLmZpbHRlcihzZW5zb3IgPT4gIXNlbnNvcnMuaW5jbHVkZXMoc2Vuc29yLmNvbnN0cnVjdG9yKSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGNvbnRhaW5lciB0byB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7Li4uSFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzIHlvdSB3YW50IHRvIGFkZCB0byBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLmFkZENvbnRhaW5lcihkb2N1bWVudC5ib2R5KVxyXG4gICAqL1xyXG4gIGFkZENvbnRhaW5lciguLi5jb250YWluZXJzKSB7XHJcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSBbLi4udGhpcy5jb250YWluZXJzLCAuLi5jb250YWluZXJzXTtcclxuICAgIHRoaXMuc2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IuYWRkQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBjb250YWluZXIgZnJvbSB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7Li4uSFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzIHlvdSB3YW50IHRvIHJlbW92ZSBmcm9tIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUucmVtb3ZlQ29udGFpbmVyKGRvY3VtZW50LmJvZHkpXHJcbiAgICovXHJcbiAgcmVtb3ZlQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcclxuICAgIHRoaXMuY29udGFpbmVycyA9IHRoaXMuY29udGFpbmVycy5maWx0ZXIoY29udGFpbmVyID0+ICFjb250YWluZXJzLmluY2x1ZGVzKGNvbnRhaW5lcikpO1xyXG4gICAgdGhpcy5zZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5yZW1vdmVDb250YWluZXIoLi4uY29udGFpbmVycykpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGxpc3RlbmVyIGZvciBkcmFnZ2FibGUgZXZlbnRzXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBFdmVudCBuYW1lXHJcbiAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gY2FsbGJhY2tzIC0gRXZlbnQgY2FsbGJhY2tzXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5vbignZHJhZzpzdGFydCcsIChkcmFnRXZlbnQpID0+IGRyYWdFdmVudC5jYW5jZWwoKSk7XHJcbiAgICovXHJcbiAgb24odHlwZSwgLi4uY2FsbGJhY2tzKSB7XHJcbiAgICB0aGlzLmVtaXR0ZXIub24odHlwZSwgLi4uY2FsbGJhY2tzKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBsaXN0ZW5lciBmcm9tIGRyYWdnYWJsZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gRXZlbnQgbmFtZVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRXZlbnQgY2FsbGJhY2tcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLm9mZignZHJhZzpzdGFydCcsIGhhbmRsZXJGdW5jdGlvbik7XHJcbiAgICovXHJcbiAgb2ZmKHR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLmVtaXR0ZXIub2ZmKHR5cGUsIGNhbGxiYWNrKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlcnMgZHJhZ2dhYmxlIGV2ZW50XHJcbiAgICogQHBhcmFtIHtBYnN0cmFjdEV2ZW50fSBldmVudCAtIEV2ZW50IGluc3RhbmNlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS50cmlnZ2VyKGV2ZW50KTtcclxuICAgKi9cclxuICB0cmlnZ2VyKGV2ZW50KSB7XHJcbiAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcihldmVudCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY2xhc3MgbmFtZSBmb3IgY2xhc3MgaWRlbnRpZmllclxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiBjbGFzcyBpZGVudGlmaWVyXHJcbiAgICogQHJldHVybiB7U3RyaW5nfG51bGx9XHJcbiAgICovXHJcbiAgZ2V0Q2xhc3NOYW1lRm9yKG5hbWUpIHtcclxuICAgIHJldHVybiB0aGlzLmdldENsYXNzTmFtZXNGb3IobmFtZSlbMF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGNsYXNzIG5hbWVzIGZvciBjbGFzcyBpZGVudGlmaWVyXHJcbiAgICogQHJldHVybiB7U3RyaW5nW119XHJcbiAgICovXHJcbiAgZ2V0Q2xhc3NOYW1lc0ZvcihuYW1lKSB7XHJcbiAgICBjb25zdCBjbGFzc05hbWVzID0gdGhpcy5vcHRpb25zLmNsYXNzZXNbbmFtZV07XHJcblxyXG4gICAgaWYgKGNsYXNzTmFtZXMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICByZXR1cm4gY2xhc3NOYW1lcztcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNsYXNzTmFtZXMgPT09ICdzdHJpbmcnIHx8IGNsYXNzTmFtZXMgaW5zdGFuY2VvZiBTdHJpbmcpIHtcclxuICAgICAgcmV0dXJuIFtjbGFzc05hbWVzXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZSBpcyBjdXJyZW50bHkgZHJhZ2dpbmdcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGlzRHJhZ2dpbmcoKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmRyYWdnaW5nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYWxsIGRyYWdnYWJsZSBlbGVtZW50c1xyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XHJcbiAgICovXHJcbiAgZ2V0RHJhZ2dhYmxlRWxlbWVudHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJzLnJlZHVjZSgoY3VycmVudCwgY29udGFpbmVyKSA9PiB7XHJcbiAgICAgIHJldHVybiBbLi4uY3VycmVudCwgLi4udGhpcy5nZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihjb250YWluZXIpXTtcclxuICAgIH0sIFtdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgZHJhZ2dhYmxlIGVsZW1lbnRzIGZvciBhIGdpdmVuIGNvbnRhaW5lciwgZXhjbHVkaW5nIHRoZSBtaXJyb3IgYW5kXHJcbiAgICogb3JpZ2luYWwgc291cmNlIGVsZW1lbnQgaWYgcHJlc2VudFxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XHJcbiAgICovXHJcbiAgZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIoY29udGFpbmVyKSB7XHJcbiAgICBjb25zdCBhbGxEcmFnZ2FibGVFbGVtZW50cyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xyXG5cclxuICAgIHJldHVybiBbLi4uYWxsRHJhZ2dhYmxlRWxlbWVudHNdLmZpbHRlcihjaGlsZEVsZW1lbnQgPT4ge1xyXG4gICAgICByZXR1cm4gY2hpbGRFbGVtZW50ICE9PSB0aGlzLm9yaWdpbmFsU291cmNlICYmIGNoaWxkRWxlbWVudCAhPT0gdGhpcy5taXJyb3I7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBET00gRHJhZyBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xyXG4gICAgY29uc3QgeyB0YXJnZXQsIGNvbnRhaW5lciB9ID0gc2Vuc29yRXZlbnQ7XHJcblxyXG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcnMuaW5jbHVkZXMoY29udGFpbmVyKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oYW5kbGUgJiYgdGFyZ2V0ICYmICEoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgdGhpcy5vcHRpb25zLmhhbmRsZSkpIHtcclxuICAgICAgc2Vuc29yRXZlbnQuY2FuY2VsKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaW5kIGRyYWdnYWJsZSBzb3VyY2UgZWxlbWVudFxyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZSA9ICgwLCBfdXRpbHMuY2xvc2VzdCkodGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcclxuICAgIHRoaXMuc291cmNlQ29udGFpbmVyID0gY29udGFpbmVyO1xyXG5cclxuICAgIGlmICghdGhpcy5vcmlnaW5hbFNvdXJjZSkge1xyXG4gICAgICBzZW5zb3JFdmVudC5jYW5jZWwoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmxhc3RQbGFjZWRTb3VyY2UgJiYgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBsYWNlZFRpbWVvdXRJRCk7XHJcbiAgICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcclxuICAgICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6cGxhY2VkJykpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc291cmNlID0gdGhpcy5vcmlnaW5hbFNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuc291cmNlLCB0aGlzLm9yaWdpbmFsU291cmNlKTtcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHJcbiAgICBjb25zdCBkcmFnRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnU3RhcnRFdmVudCh7XHJcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnRXZlbnQpO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dpbmcgPSAhZHJhZ0V2ZW50LmNhbmNlbGVkKCk7XHJcblxyXG4gICAgaWYgKGRyYWdFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHRoaXMuc291cmNlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zb3VyY2UpO1xyXG4gICAgICB0aGlzLm9yaWdpbmFsU291cmNlLnN0eWxlLmRpc3BsYXkgPSBudWxsO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOm9yaWdpbmFsJykpO1xyXG4gICAgdGhpcy5zb3VyY2UuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpkcmFnZ2luZycpKTtcclxuICAgIHRoaXMuc291cmNlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6ZHJhZ2dpbmcnKSk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdib2R5OmRyYWdnaW5nJykpO1xyXG4gICAgYXBwbHlVc2VyU2VsZWN0KGRvY3VtZW50LmJvZHksICdub25lJyk7XHJcblxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgY29uc3Qgb2xkU2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XHJcbiAgICAgIGNvbnN0IG5ld1NlbnNvckV2ZW50ID0gb2xkU2Vuc29yRXZlbnQuY2xvbmUoeyB0YXJnZXQ6IHRoaXMuc291cmNlIH0pO1xyXG5cclxuICAgICAgdGhpc1tvbkRyYWdNb3ZlXShfZXh0ZW5kcyh7fSwgZXZlbnQsIHtcclxuICAgICAgICBkZXRhaWw6IG5ld1NlbnNvckV2ZW50XHJcbiAgICAgIH0pKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRE9NIERyYWcgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnTW92ZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XHJcbiAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gc2Vuc29yRXZlbnQ7XHJcbiAgICBsZXQgdGFyZ2V0ID0gc2Vuc29yRXZlbnQudGFyZ2V0O1xyXG5cclxuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnTW92ZUV2ZW50KHtcclxuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdNb3ZlRXZlbnQpO1xyXG5cclxuICAgIGlmIChkcmFnTW92ZUV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgc2Vuc29yRXZlbnQuY2FuY2VsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGFyZ2V0ID0gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xyXG4gICAgY29uc3Qgd2l0aGluQ29ycmVjdENvbnRhaW5lciA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoc2Vuc29yRXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xyXG4gICAgY29uc3Qgb3ZlckNvbnRhaW5lciA9IHNlbnNvckV2ZW50Lm92ZXJDb250YWluZXIgfHwgd2l0aGluQ29ycmVjdENvbnRhaW5lcjtcclxuICAgIGNvbnN0IGlzTGVhdmluZ0NvbnRhaW5lciA9IHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgJiYgb3ZlckNvbnRhaW5lciAhPT0gdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lcjtcclxuICAgIGNvbnN0IGlzTGVhdmluZ0RyYWdnYWJsZSA9IHRoaXMuY3VycmVudE92ZXIgJiYgdGFyZ2V0ICE9PSB0aGlzLmN1cnJlbnRPdmVyO1xyXG4gICAgY29uc3QgaXNPdmVyQ29udGFpbmVyID0gb3ZlckNvbnRhaW5lciAmJiB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyICE9PSBvdmVyQ29udGFpbmVyO1xyXG4gICAgY29uc3QgaXNPdmVyRHJhZ2dhYmxlID0gd2l0aGluQ29ycmVjdENvbnRhaW5lciAmJiB0YXJnZXQgJiYgdGhpcy5jdXJyZW50T3ZlciAhPT0gdGFyZ2V0O1xyXG5cclxuICAgIGlmIChpc0xlYXZpbmdEcmFnZ2FibGUpIHtcclxuICAgICAgY29uc3QgZHJhZ091dEV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ091dEV2ZW50KHtcclxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG92ZXI6IHRoaXMuY3VycmVudE92ZXIsXHJcbiAgICAgICAgb3ZlckNvbnRhaW5lcjogdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lclxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2RyYWdnYWJsZTpvdmVyJykpO1xyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyID0gbnVsbDtcclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3V0RXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0xlYXZpbmdDb250YWluZXIpIHtcclxuICAgICAgY29uc3QgZHJhZ091dENvbnRhaW5lckV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ091dENvbnRhaW5lckV2ZW50KHtcclxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG92ZXJDb250YWluZXI6IHRoaXMuY3VycmVudE92ZXJDb250YWluZXJcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6b3ZlcicpKTtcclxuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciA9IG51bGw7XHJcblxyXG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ091dENvbnRhaW5lckV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNPdmVyQ29udGFpbmVyKSB7XHJcbiAgICAgIG92ZXJDb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpvdmVyJykpO1xyXG5cclxuICAgICAgY29uc3QgZHJhZ092ZXJDb250YWluZXJFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdPdmVyQ29udGFpbmVyRXZlbnQoe1xyXG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgICAgb3ZlckNvbnRhaW5lclxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgPSBvdmVyQ29udGFpbmVyO1xyXG5cclxuICAgICAgdGhpcy50cmlnZ2VyKGRyYWdPdmVyQ29udGFpbmVyRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc092ZXJEcmFnZ2FibGUpIHtcclxuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcmFnZ2FibGU6b3ZlcicpKTtcclxuXHJcbiAgICAgIGNvbnN0IGRyYWdPdmVyRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnT3ZlckV2ZW50KHtcclxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG92ZXJDb250YWluZXIsXHJcbiAgICAgICAgb3ZlcjogdGFyZ2V0XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5jdXJyZW50T3ZlciA9IHRhcmdldDtcclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3ZlckV2ZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RvcCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERPTSBEcmFnIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ1N0b3BFdmVudCh7XHJcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzZW5zb3JFdmVudDogZXZlbnQuc2Vuc29yRXZlbnQsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogdGhpcy5zb3VyY2VDb250YWluZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnU3RvcEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLnNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLm9yaWdpbmFsU291cmNlLCB0aGlzLnNvdXJjZSk7XHJcbiAgICB0aGlzLnNvdXJjZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc291cmNlKTtcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2Uuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG5cclxuICAgIHRoaXMuc291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6ZHJhZ2dpbmcnKSk7XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6b3JpZ2luYWwnKSk7XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xyXG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpwbGFjZWQnKSk7XHJcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOmRyYWdnaW5nJykpO1xyXG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignYm9keTpkcmFnZ2luZycpKTtcclxuICAgIGFwcGx5VXNlclNlbGVjdChkb2N1bWVudC5ib2R5LCAnJyk7XHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudE92ZXIpIHtcclxuICAgICAgdGhpcy5jdXJyZW50T3Zlci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJhZ2dhYmxlOm92ZXInKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudE92ZXJDb250YWluZXIpIHtcclxuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOm92ZXInKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5sYXN0UGxhY2VkU291cmNlID0gdGhpcy5vcmlnaW5hbFNvdXJjZTtcclxuICAgIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lciA9IHRoaXMuc291cmNlQ29udGFpbmVyO1xyXG5cclxuICAgIHRoaXMucGxhY2VkVGltZW91dElEID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmxhc3RQbGFjZWRTb3VyY2UpIHtcclxuICAgICAgICB0aGlzLmxhc3RQbGFjZWRTb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmxhc3RQbGFjZWRDb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpwbGFjZWQnKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZSA9IG51bGw7XHJcbiAgICAgIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lciA9IG51bGw7XHJcbiAgICB9LCB0aGlzLm9wdGlvbnMucGxhY2VkVGltZW91dCk7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BwZWRFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdTdG9wcGVkRXZlbnQoe1xyXG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc2Vuc29yRXZlbnQ6IGV2ZW50LnNlbnNvckV2ZW50LFxyXG4gICAgICBzb3VyY2VDb250YWluZXI6IHRoaXMuc291cmNlQ29udGFpbmVyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ1N0b3BwZWRFdmVudCk7XHJcblxyXG4gICAgdGhpcy5zb3VyY2UgPSBudWxsO1xyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZSA9IG51bGw7XHJcbiAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyID0gbnVsbDtcclxuICAgIHRoaXMuY3VycmVudE92ZXIgPSBudWxsO1xyXG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBwcmVzc3VyZSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERPTSBEcmFnIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1ByZXNzdXJlXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZW5zb3JFdmVudCA9IGdldFNlbnNvckV2ZW50KGV2ZW50KTtcclxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlIHx8ICgwLCBfdXRpbHMuY2xvc2VzdCkoc2Vuc29yRXZlbnQub3JpZ2luYWxFdmVudC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdQcmVzc3VyZUV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ1ByZXNzdXJlRXZlbnQoe1xyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgc291cmNlLFxyXG4gICAgICBwcmVzc3VyZTogc2Vuc29yRXZlbnQucHJlc3N1cmVcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnUHJlc3N1cmVFdmVudCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGU7XHJcbkRyYWdnYWJsZS5QbHVnaW5zID0geyBBbm5vdW5jZW1lbnQ6IF9QbHVnaW5zLkFubm91bmNlbWVudCwgRm9jdXNhYmxlOiBfUGx1Z2lucy5Gb2N1c2FibGUsIE1pcnJvcjogX1BsdWdpbnMuTWlycm9yLCBTY3JvbGxhYmxlOiBfUGx1Z2lucy5TY3JvbGxhYmxlIH07XHJcbkRyYWdnYWJsZS5TZW5zb3JzID0geyBNb3VzZVNlbnNvcjogX1NlbnNvcnMuTW91c2VTZW5zb3IsIFRvdWNoU2Vuc29yOiBfU2Vuc29ycy5Ub3VjaFNlbnNvciB9O1xyXG5mdW5jdGlvbiBnZXRTZW5zb3JFdmVudChldmVudCkge1xyXG4gIHJldHVybiBldmVudC5kZXRhaWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VXNlclNlbGVjdChlbGVtZW50LCB2YWx1ZSkge1xyXG4gIGVsZW1lbnQuc3R5bGUud2Via2l0VXNlclNlbGVjdCA9IHZhbHVlO1xyXG4gIGVsZW1lbnQuc3R5bGUubW96VXNlclNlbGVjdCA9IHZhbHVlO1xyXG4gIGVsZW1lbnQuc3R5bGUubXNVc2VyU2VsZWN0ID0gdmFsdWU7XHJcbiAgZWxlbWVudC5zdHlsZS5vVXNlclNlbGVjdCA9IHZhbHVlO1xyXG4gIGVsZW1lbnQuc3R5bGUudXNlclNlbGVjdCA9IHZhbHVlO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG52YXIgX1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpO1xyXG5cclxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Nb3VzZUZvcmNlV2lsbEJlZ2luID0gU3ltYm9sKCdvbk1vdXNlRm9yY2VXaWxsQmVnaW4nKTtcclxuY29uc3Qgb25Nb3VzZUZvcmNlRG93biA9IFN5bWJvbCgnb25Nb3VzZUZvcmNlRG93bicpO1xyXG5jb25zdCBvbk1vdXNlRG93biA9IFN5bWJvbCgnb25Nb3VzZURvd24nKTtcclxuY29uc3Qgb25Nb3VzZUZvcmNlQ2hhbmdlID0gU3ltYm9sKCdvbk1vdXNlRm9yY2VDaGFuZ2UnKTtcclxuY29uc3Qgb25Nb3VzZU1vdmUgPSBTeW1ib2woJ29uTW91c2VNb3ZlJyk7XHJcbmNvbnN0IG9uTW91c2VVcCA9IFN5bWJvbCgnb25Nb3VzZVVwJyk7XHJcbmNvbnN0IG9uTW91c2VGb3JjZUdsb2JhbENoYW5nZSA9IFN5bWJvbCgnb25Nb3VzZUZvcmNlR2xvYmFsQ2hhbmdlJyk7XHJcblxyXG4vKipcclxuICogVGhpcyBzZW5zb3IgcGlja3MgdXAgbmF0aXZlIGZvcmNlIHRvdWNoIGV2ZW50cyBhbmQgZGljdGF0ZXMgZHJhZyBvcGVyYXRpb25zXHJcbiAqIEBjbGFzcyBGb3JjZVRvdWNoU2Vuc29yXHJcbiAqIEBtb2R1bGUgRm9yY2VUb3VjaFNlbnNvclxyXG4gKiBAZXh0ZW5kcyBTZW5zb3JcclxuICovXHJcbmNsYXNzIEZvcmNlVG91Y2hTZW5zb3IgZXh0ZW5kcyBfU2Vuc29yMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBGb3JjZVRvdWNoU2Vuc29yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIEZvcmNlVG91Y2hTZW5zb3JcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lcnMsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhZ2dhYmxlIGVsZW1lbnQgbmVlZHMgdG8gYmUgcmVtZW1iZXJlZCB0byB1bnNldCB0aGUgZHJhZ2dhYmxlIGF0dHJpYnV0ZSBhZnRlciBkcmFnIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkXHJcbiAgICAgKiBAcHJvcGVydHkgbWlnaHREcmFnXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5taWdodERyYWcgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzW29uTW91c2VGb3JjZVdpbGxCZWdpbl0gPSB0aGlzW29uTW91c2VGb3JjZVdpbGxCZWdpbl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Nb3VzZUZvcmNlRG93bl0gPSB0aGlzW29uTW91c2VGb3JjZURvd25dLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VEb3duXSA9IHRoaXNbb25Nb3VzZURvd25dLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VGb3JjZUNoYW5nZV0gPSB0aGlzW29uTW91c2VGb3JjZUNoYW5nZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Nb3VzZU1vdmVdID0gdGhpc1tvbk1vdXNlTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Nb3VzZVVwXSA9IHRoaXNbb25Nb3VzZVVwXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIGZvciAoY29uc3QgY29udGFpbmVyIG9mIHRoaXMuY29udGFpbmVycykge1xyXG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZXdpbGxiZWdpbicsIHRoaXNbb25Nb3VzZUZvcmNlV2lsbEJlZ2luXSwgZmFsc2UpO1xyXG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZWRvd24nLCB0aGlzW29uTW91c2VGb3JjZURvd25dLCBmYWxzZSk7XHJcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XHJcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNlY2hhbmdlZCcsIHRoaXNbb25Nb3VzZUZvcmNlQ2hhbmdlXSwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25Nb3VzZU1vdmVdKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIGZvciAoY29uc3QgY29udGFpbmVyIG9mIHRoaXMuY29udGFpbmVycykge1xyXG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZXdpbGxiZWdpbicsIHRoaXNbb25Nb3VzZUZvcmNlV2lsbEJlZ2luXSwgZmFsc2UpO1xyXG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZWRvd24nLCB0aGlzW29uTW91c2VGb3JjZURvd25dLCBmYWxzZSk7XHJcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XHJcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNlY2hhbmdlZCcsIHRoaXNbb25Nb3VzZUZvcmNlQ2hhbmdlXSwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25Nb3VzZU1vdmVdKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZm9yY2Ugd2lsbCBiZWdpbiBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGZvcmNlIHdpbGwgYmVnaW4gZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZUZvcmNlV2lsbEJlZ2luXShldmVudCkge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIHRoaXMubWlnaHREcmFnID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGZvcmNlIGRvd24gaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBmb3JjZSBkb3duIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VGb3JjZURvd25dKGV2ZW50KSB7XHJcbiAgICBpZiAodGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdGFydFNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgdGhpcy5kcmFnZ2luZyA9ICFkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpO1xyXG4gICAgdGhpcy5taWdodERyYWcgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIHVwIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgdXAgZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZVVwXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RvcFNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0OiBudWxsLFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdG9wRXZlbnQpO1xyXG5cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IG51bGw7XHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZG93biBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGRvd24gZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZURvd25dKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMubWlnaHREcmFnKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOZWVkIHdvcmthcm91bmQgZm9yIHJlYWwgY2xpY2tcclxuICAgIC8vIENhbmNlbCBwb3RlbnRpYWwgZHJhZyBldmVudHNcclxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgbW92ZSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGZvcmNlIHdpbGwgYmVnaW4gZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZU1vdmVdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ01vdmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ01vdmVTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGZvcmNlIGNoYW5nZSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGZvcmNlIGNoYW5nZSBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRm9yY2VDaGFuZ2VdKGV2ZW50KSB7XHJcbiAgICBpZiAodGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gZXZlbnQuY3VycmVudFRhcmdldDtcclxuXHJcbiAgICBjb25zdCBkcmFnUHJlc3N1cmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQoe1xyXG4gICAgICBwcmVzc3VyZTogZXZlbnQud2Via2l0Rm9yY2UsXHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGNvbnRhaW5lciwgZHJhZ1ByZXNzdXJlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZm9yY2UgZ2xvYmFsIGNoYW5nZSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGZvcmNlIGdsb2JhbCBjaGFuZ2UgZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZUZvcmNlR2xvYmFsQ2hhbmdlXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XHJcblxyXG4gICAgY29uc3QgZHJhZ1ByZXNzdXJlRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdQcmVzc3VyZVNlbnNvckV2ZW50KHtcclxuICAgICAgcHJlc3N1cmU6IGV2ZW50LndlYmtpdEZvcmNlLFxyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1ByZXNzdXJlRXZlbnQpO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBGb3JjZVRvdWNoU2Vuc29yO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Gb3JjZVRvdWNoU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcblxyXG52YXIgX0ZvcmNlVG91Y2hTZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRm9yY2VUb3VjaFNlbnNvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0ZvcmNlVG91Y2hTZW5zb3IyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcbnZhciBfU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbnZhciBfU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcik7XHJcblxyXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbk1vdXNlRG93biA9IFN5bWJvbCgnb25Nb3VzZURvd24nKTtcclxuY29uc3Qgb25Nb3VzZVVwID0gU3ltYm9sKCdvbk1vdXNlVXAnKTtcclxuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XHJcbmNvbnN0IG9uRHJhZ092ZXIgPSBTeW1ib2woJ29uRHJhZ092ZXInKTtcclxuY29uc3Qgb25EcmFnRW5kID0gU3ltYm9sKCdvbkRyYWdFbmQnKTtcclxuY29uc3Qgb25Ecm9wID0gU3ltYm9sKCdvbkRyb3AnKTtcclxuY29uc3QgcmVzZXQgPSBTeW1ib2woJ3Jlc2V0Jyk7XHJcblxyXG4vKipcclxuICogVGhpcyBzZW5zb3IgcGlja3MgdXAgbmF0aXZlIGJyb3dzZXIgZHJhZyBldmVudHMgYW5kIGRpY3RhdGVzIGRyYWcgb3BlcmF0aW9uc1xyXG4gKiBAY2xhc3MgRHJhZ1NlbnNvclxyXG4gKiBAbW9kdWxlIERyYWdTZW5zb3JcclxuICogQGV4dGVuZHMgU2Vuc29yXHJcbiAqL1xyXG5jbGFzcyBEcmFnU2Vuc29yIGV4dGVuZHMgX1NlbnNvcjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogRHJhZ1NlbnNvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBEcmFnU2Vuc29yXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGRvd24gdGltZXIgd2hpY2ggd2lsbCBlbmQgdXAgc2V0dGluZyB0aGUgZHJhZ2dhYmxlIGF0dHJpYnV0ZSwgdW5sZXNzIGNhbmNlbGVkXHJcbiAgICAgKiBAcHJvcGVydHkgbW91c2VEb3duVGltZW91dFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZSBlbGVtZW50IG5lZWRzIHRvIGJlIHJlbWVtYmVyZWQgdG8gdW5zZXQgdGhlIGRyYWdnYWJsZSBhdHRyaWJ1dGUgYWZ0ZXIgZHJhZyBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZFxyXG4gICAgICogQHByb3BlcnR5IGRyYWdnYWJsZUVsZW1lbnRcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5hdGl2ZSBkcmFnZ2FibGUgZWxlbWVudCBjb3VsZCBiZSBsaW5rcyBvciBpbWFnZXMsIHRoZWlyIGRyYWdnYWJsZSBzdGF0ZSB3aWxsIGJlIGRpc2FibGVkIGR1cmluZyBkcmFnIG9wZXJhdGlvblxyXG4gICAgICogQHByb3BlcnR5IG5hdGl2ZURyYWdnYWJsZUVsZW1lbnRcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uTW91c2VEb3duXSA9IHRoaXNbb25Nb3VzZURvd25dLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VVcF0gPSB0aGlzW29uTW91c2VVcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnT3Zlcl0gPSB0aGlzW29uRHJhZ092ZXJdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ0VuZF0gPSB0aGlzW29uRHJhZ0VuZF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Ecm9wXSA9IHRoaXNbb25Ecm9wXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRHJhZyBzdGFydCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcclxuICAgIC8vIE5lZWQgZm9yIGZpcmVmb3guIFwidGV4dFwiIGtleSBpcyBuZWVkZWQgZm9yIElFXHJcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YSgndGV4dCcsICcnKTtcclxuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gdGhpcy5vcHRpb25zLnR5cGU7XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xyXG5cclxuICAgIGlmICghdGhpcy5jdXJyZW50Q29udGFpbmVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gV29ya2Fyb3VuZFxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcclxuXHJcbiAgICAgIGlmIChkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9LCAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgb3ZlciBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERyYWcgb3ZlciBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdmVyXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jdXJyZW50Q29udGFpbmVyO1xyXG5cclxuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdNb3ZlU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xyXG5cclxuICAgIGlmICghZHJhZ01vdmVFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gdGhpcy5vcHRpb25zLnR5cGU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIGVuZCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERyYWcgZW5kIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ0VuZF0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSwgdHJ1ZSk7XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbnRhaW5lcjtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RvcFNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnU3RvcEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbcmVzZXRdKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcm9wIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRHJvcCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyb3BdKGV2ZW50KSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBkb3duIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZG93biBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRG93bl0oZXZlbnQpIHtcclxuICAgIC8vIEZpcmVmb3ggYnVnIGZvciBpbnB1dHMgd2l0aGluIGRyYWdnYWJsZXMgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzM5MDcxXHJcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICYmIChldmVudC50YXJnZXQuZm9ybSB8fCBldmVudC50YXJnZXQuY29udGVudGVkaXRhYmxlKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZXZlbnQudGFyZ2V0LCBlbGVtZW50ID0+IGVsZW1lbnQuZHJhZ2dhYmxlKTtcclxuXHJcbiAgICBpZiAobmF0aXZlRHJhZ2dhYmxlRWxlbWVudCkge1xyXG4gICAgICBuYXRpdmVEcmFnZ2FibGVFbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQgPSBuYXRpdmVEcmFnZ2FibGVFbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0sIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIHRoaXNbb25EcmFnRW5kXSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXNbb25Ecm9wXSwgZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZXZlbnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcclxuXHJcbiAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdGFydEV2ZW50ID0gZXZlbnQ7XHJcblxyXG4gICAgdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xyXG4gICAgICB0aGlzLmRyYWdnYWJsZUVsZW1lbnQgPSB0YXJnZXQ7XHJcbiAgICB9LCB0aGlzLmRlbGF5LmRyYWcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgdXAgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlVXBdKCkge1xyXG4gICAgdGhpc1tyZXNldF0oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIHVwIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgdXAgZXZlbnRcclxuICAgKi9cclxuICBbcmVzZXRdKCkge1xyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzW29uRHJhZ092ZXJdLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpc1tvbkRyYWdFbmRdLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpc1tvbkRyb3BdLCBmYWxzZSk7XHJcblxyXG4gICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCkge1xyXG4gICAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuICAgICAgdGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5kcmFnZ2FibGVFbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuZHJhZ2dhYmxlRWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcclxuICAgICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ1NlbnNvcjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRHJhZ1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG5cclxudmFyIF9EcmFnU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RyYWdTZW5zb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9EcmFnU2Vuc29yMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG52YXIgX1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpO1xyXG5cclxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Ub3VjaFN0YXJ0ID0gU3ltYm9sKCdvblRvdWNoU3RhcnQnKTtcclxuY29uc3Qgb25Ub3VjaEVuZCA9IFN5bWJvbCgnb25Ub3VjaEVuZCcpO1xyXG5jb25zdCBvblRvdWNoTW92ZSA9IFN5bWJvbCgnb25Ub3VjaE1vdmUnKTtcclxuY29uc3Qgc3RhcnREcmFnID0gU3ltYm9sKCdzdGFydERyYWcnKTtcclxuY29uc3Qgb25EaXN0YW5jZUNoYW5nZSA9IFN5bWJvbCgnb25EaXN0YW5jZUNoYW5nZScpO1xyXG5cclxuLyoqXHJcbiAqIFByZXZlbnRzIHNjcm9sbGluZyB3aGVuIHNldCB0byB0cnVlXHJcbiAqIEB2YXIge0Jvb2xlYW59IHByZXZlbnRTY3JvbGxpbmdcclxuICovXHJcbmxldCBwcmV2ZW50U2Nyb2xsaW5nID0gZmFsc2U7XHJcblxyXG4vLyBXZWJLaXQgcmVxdWlyZXMgY2FuY2VsYWJsZSBgdG91Y2htb3ZlYCBldmVudHMgdG8gYmUgYWRkZWQgYXMgZWFybHkgYXMgcG9zc2libGVcclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGV2ZW50ID0+IHtcclxuICBpZiAoIXByZXZlbnRTY3JvbGxpbmcpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIFByZXZlbnQgc2Nyb2xsaW5nXHJcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxufSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHNlbnNvciBwaWNrcyB1cCBuYXRpdmUgYnJvd3NlciB0b3VjaCBldmVudHMgYW5kIGRpY3RhdGVzIGRyYWcgb3BlcmF0aW9uc1xyXG4gKiBAY2xhc3MgVG91Y2hTZW5zb3JcclxuICogQG1vZHVsZSBUb3VjaFNlbnNvclxyXG4gKiBAZXh0ZW5kcyBTZW5zb3JcclxuICovXHJcbmNsYXNzIFRvdWNoU2Vuc29yIGV4dGVuZHMgX1NlbnNvcjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogVG91Y2hTZW5zb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgVG91Y2hTZW5zb3JcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lcnMsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzdCBzY3JvbGxhYmxlIGNvbnRhaW5lciBzbyBhY2NpZGVudGFsIHNjcm9sbCBjYW4gY2FuY2VsIGxvbmcgdG91Y2hcclxuICAgICAqIEBwcm9wZXJ0eSBjdXJyZW50U2Nyb2xsYWJsZVBhcmVudFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRTY3JvbGxhYmxlUGFyZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRpbWVvdXRJRCBmb3IgbWFuYWdpbmcgZGVsYXlcclxuICAgICAqIEBwcm9wZXJ0eSB0YXBUaW1lb3V0XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRhcFRpbWVvdXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogdG91Y2hNb3ZlZCBpbmRpY2F0ZXMgaWYgdG91Y2ggaGFzIG1vdmVkIGR1cmluZyB0YXBUaW1lb3V0XHJcbiAgICAgKiBAcHJvcGVydHkgdG91Y2hNb3ZlZFxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMudG91Y2hNb3ZlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2F2ZSBwYWdlWCBjb29yZGluYXRlcyBmb3IgZGVsYXkgZHJhZ1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1icmV9IHBhZ2VYXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBhZ2VYID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNhdmUgcGFnZVkgY29vcmRpbmF0ZXMgZm9yIGRlbGF5IGRyYWdcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYnJlfSBwYWdlWVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5wYWdlWSA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvblRvdWNoU3RhcnRdID0gdGhpc1tvblRvdWNoU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uVG91Y2hFbmRdID0gdGhpc1tvblRvdWNoRW5kXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvblRvdWNoTW92ZV0gPSB0aGlzW29uVG91Y2hNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tzdGFydERyYWddID0gdGhpc1tzdGFydERyYWddLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdID0gdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzW29uVG91Y2hTdGFydF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzW29uVG91Y2hTdGFydF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVG91Y2ggc3RhcnQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUb3VjaCBzdGFydCBldmVudFxyXG4gICAqL1xyXG4gIFtvblRvdWNoU3RhcnRdKGV2ZW50KSB7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGV2ZW50LnRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcclxuXHJcbiAgICBpZiAoIWNvbnRhaW5lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGRpc3RhbmNlID0gMCB9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgY29uc3QgeyBkZWxheSB9ID0gdGhpcztcclxuICAgIGNvbnN0IHsgcGFnZVgsIHBhZ2VZIH0gPSAoMCwgX3V0aWxzLnRvdWNoQ29vcmRzKShldmVudCk7XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IHBhZ2VYLCBwYWdlWSB9KTtcclxuICAgIHRoaXMub25Ub3VjaFN0YXJ0QXQgPSBEYXRlLm5vdygpO1xyXG4gICAgdGhpcy5zdGFydEV2ZW50ID0gZXZlbnQ7XHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBjb250YWluZXI7XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzW29uVG91Y2hFbmRdKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpc1tvblRvdWNoRW5kXSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUpO1xyXG5cclxuICAgIGlmIChkaXN0YW5jZSkge1xyXG4gICAgICBwcmV2ZW50U2Nyb2xsaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRhcFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0oeyB0b3VjaGVzOiBbeyBwYWdlWDogdGhpcy5wYWdlWCwgcGFnZVk6IHRoaXMucGFnZVkgfV0gfSk7XHJcbiAgICB9LCBkZWxheS50b3VjaCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCB0aGUgZHJhZ1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW3N0YXJ0RHJhZ10oKSB7XHJcbiAgICBjb25zdCBzdGFydEV2ZW50ID0gdGhpcy5zdGFydEV2ZW50O1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jdXJyZW50Q29udGFpbmVyO1xyXG4gICAgY29uc3QgdG91Y2ggPSAoMCwgX3V0aWxzLnRvdWNoQ29vcmRzKShzdGFydEV2ZW50KTtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiB0b3VjaC5wYWdlWCxcclxuICAgICAgY2xpZW50WTogdG91Y2gucGFnZVksXHJcbiAgICAgIHRhcmdldDogc3RhcnRFdmVudC50YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogc3RhcnRFdmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0YXJ0RXZlbnQpO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dpbmcgPSAhZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKTtcclxuXHJcbiAgICBpZiAodGhpcy5kcmFnZ2luZykge1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uVG91Y2hNb3ZlXSk7XHJcbiAgICB9XHJcbiAgICBwcmV2ZW50U2Nyb2xsaW5nID0gdGhpcy5kcmFnZ2luZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRvdWNoIG1vdmUgaGFuZGxlciBwcmlvciB0byBkcmFnIHN0YXJ0LlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUb3VjaCBtb3ZlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRGlzdGFuY2VDaGFuZ2VdKGV2ZW50KSB7XHJcbiAgICBjb25zdCB7IGRpc3RhbmNlIH0gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCB7IHN0YXJ0RXZlbnQsIGRlbGF5IH0gPSB0aGlzO1xyXG4gICAgY29uc3Qgc3RhcnQgPSAoMCwgX3V0aWxzLnRvdWNoQ29vcmRzKShzdGFydEV2ZW50KTtcclxuICAgIGNvbnN0IGN1cnJlbnQgPSAoMCwgX3V0aWxzLnRvdWNoQ29vcmRzKShldmVudCk7XHJcbiAgICBjb25zdCB0aW1lRWxhcHNlZCA9IERhdGUubm93KCkgLSB0aGlzLm9uVG91Y2hTdGFydEF0O1xyXG4gICAgY29uc3QgZGlzdGFuY2VUcmF2ZWxsZWQgPSAoMCwgX3V0aWxzLmRpc3RhbmNlKShzdGFydC5wYWdlWCwgc3RhcnQucGFnZVksIGN1cnJlbnQucGFnZVgsIGN1cnJlbnQucGFnZVkpO1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY3VycmVudCk7XHJcblxyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGFwVGltZW91dCk7XHJcblxyXG4gICAgaWYgKHRpbWVFbGFwc2VkIDwgZGVsYXkudG91Y2gpIHtcclxuICAgICAgLy8gbW92ZWQgZHVyaW5nIGRlbGF5XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZVRyYXZlbGxlZCA+PSBkaXN0YW5jZSkge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuICAgICAgdGhpc1tzdGFydERyYWddKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXIgd2hpbGUgZHJhZ2dpbmdcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVG91Y2ggbW92ZSBldmVudFxyXG4gICAqL1xyXG4gIFtvblRvdWNoTW92ZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHBhZ2VYLCBwYWdlWSB9ID0gKDAsIF91dGlscy50b3VjaENvb3JkcykoZXZlbnQpO1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChwYWdlWCAtIHdpbmRvdy5zY3JvbGxYLCBwYWdlWSAtIHdpbmRvdy5zY3JvbGxZKTtcclxuXHJcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnTW92ZVNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogcGFnZVgsXHJcbiAgICAgIGNsaWVudFk6IHBhZ2VZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ01vdmVFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUb3VjaCBlbmQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUb3VjaCBlbmQgZXZlbnRcclxuICAgKi9cclxuICBbb25Ub3VjaEVuZF0oZXZlbnQpIHtcclxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRhcFRpbWVvdXQpO1xyXG4gICAgcHJldmVudFNjcm9sbGluZyA9IGZhbHNlO1xyXG5cclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpc1tvblRvdWNoRW5kXSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudENvbnRhaW5lcikge1xyXG4gICAgICB0aGlzLmN1cnJlbnRDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25Ub3VjaE1vdmVdKTtcclxuXHJcbiAgICBjb25zdCB7IHBhZ2VYLCBwYWdlWSB9ID0gKDAsIF91dGlscy50b3VjaENvb3JkcykoZXZlbnQpO1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChwYWdlWCAtIHdpbmRvdy5zY3JvbGxYLCBwYWdlWSAtIHdpbmRvdy5zY3JvbGxZKTtcclxuXHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdG9wU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBwYWdlWCxcclxuICAgICAgY2xpZW50WTogcGFnZVksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RvcEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBudWxsO1xyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5zdGFydEV2ZW50ID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRvdWNoU2Vuc29yO1xyXG5mdW5jdGlvbiBvbkNvbnRleHRNZW51KGV2ZW50KSB7XHJcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Ub3VjaFNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG5cclxudmFyIF9Ub3VjaFNlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ub3VjaFNlbnNvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX1RvdWNoU2Vuc29yMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkRyYWdQcmVzc3VyZVNlbnNvckV2ZW50ID0gZXhwb3J0cy5EcmFnU3RvcFNlbnNvckV2ZW50ID0gZXhwb3J0cy5EcmFnTW92ZVNlbnNvckV2ZW50ID0gZXhwb3J0cy5EcmFnU3RhcnRTZW5zb3JFdmVudCA9IGV4cG9ydHMuU2Vuc29yRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIHNlbnNvciBldmVudFxyXG4gKiBAY2xhc3MgU2Vuc29yRXZlbnRcclxuICogQG1vZHVsZSBTZW5zb3JFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBTZW5zb3JFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBicm93c2VyIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIGEgc2Vuc29yXHJcbiAgICogQHByb3BlcnR5IG9yaWdpbmFsRXZlbnRcclxuICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9yaWdpbmFsRXZlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9yaWdpbmFsRXZlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOb3JtYWxpemVkIGNsaWVudFggZm9yIGJvdGggdG91Y2ggYW5kIG1vdXNlIGV2ZW50c1xyXG4gICAqIEBwcm9wZXJ0eSBjbGllbnRYXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgY2xpZW50WCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuY2xpZW50WDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZWQgY2xpZW50WSBmb3IgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzXHJcbiAgICogQHByb3BlcnR5IGNsaWVudFlcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjbGllbnRZKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jbGllbnRZO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplZCB0YXJnZXQgZm9yIGJvdGggdG91Y2ggYW5kIG1vdXNlIGV2ZW50c1xyXG4gICAqIFJldHVybnMgdGhlIGVsZW1lbnQgdGhhdCBpcyBiZWhpbmQgY3Vyc29yIG9yIHRvdWNoIHBvaW50ZXJcclxuICAgKiBAcHJvcGVydHkgdGFyZ2V0XHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCB0YXJnZXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnRhcmdldDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnRhaW5lciB0aGF0IGluaXRpYXRlZCB0aGUgc2Vuc29yXHJcbiAgICogQHByb3BlcnR5IGNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgY29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFja3BhZCBwcmVzc3VyZVxyXG4gICAqIEBwcm9wZXJ0eSBwcmVzc3VyZVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHByZXNzdXJlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wcmVzc3VyZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuU2Vuc29yRXZlbnQgPSBTZW5zb3JFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdGFydCBzZW5zb3IgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1N0YXJ0U2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdTdGFydFNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmNsYXNzIERyYWdTdGFydFNlbnNvckV2ZW50IGV4dGVuZHMgU2Vuc29yRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQgPSBEcmFnU3RhcnRTZW5zb3JFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBtb3ZlIHNlbnNvciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnTW92ZVNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnTW92ZVNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdTdGFydFNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzpzdGFydCc7XHJcbmNsYXNzIERyYWdNb3ZlU2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5EcmFnTW92ZVNlbnNvckV2ZW50ID0gRHJhZ01vdmVTZW5zb3JFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgc3RvcCBzZW5zb3IgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdTdG9wU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnU3RvcFNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ01vdmVTZW5zb3JFdmVudC50eXBlID0gJ2RyYWc6bW92ZSc7XHJcbmNsYXNzIERyYWdTdG9wU2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5EcmFnU3RvcFNlbnNvckV2ZW50ID0gRHJhZ1N0b3BTZW5zb3JFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgcHJlc3N1cmUgc2Vuc29yIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnUHJlc3N1cmVTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdQcmVzc3VyZVNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ1N0b3BTZW5zb3JFdmVudC50eXBlID0gJ2RyYWc6c3RvcCc7XHJcbmNsYXNzIERyYWdQcmVzc3VyZVNlbnNvckV2ZW50IGV4dGVuZHMgU2Vuc29yRXZlbnQge31cclxuZXhwb3J0cy5EcmFnUHJlc3N1cmVTZW5zb3JFdmVudCA9IERyYWdQcmVzc3VyZVNlbnNvckV2ZW50O1xyXG5EcmFnUHJlc3N1cmVTZW5zb3JFdmVudC50eXBlID0gJ2RyYWc6cHJlc3N1cmUnO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG52YXIgX1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpO1xyXG5cclxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmcgPSBTeW1ib2woJ29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nJyk7XHJcbmNvbnN0IG9uTW91c2VEb3duID0gU3ltYm9sKCdvbk1vdXNlRG93bicpO1xyXG5jb25zdCBvbk1vdXNlTW92ZSA9IFN5bWJvbCgnb25Nb3VzZU1vdmUnKTtcclxuY29uc3Qgb25Nb3VzZVVwID0gU3ltYm9sKCdvbk1vdXNlVXAnKTtcclxuY29uc3Qgc3RhcnREcmFnID0gU3ltYm9sKCdzdGFydERyYWcnKTtcclxuY29uc3Qgb25EaXN0YW5jZUNoYW5nZSA9IFN5bWJvbCgnb25EaXN0YW5jZUNoYW5nZScpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgc2Vuc29yIHBpY2tzIHVwIG5hdGl2ZSBicm93c2VyIG1vdXNlIGV2ZW50cyBhbmQgZGljdGF0ZXMgZHJhZyBvcGVyYXRpb25zXHJcbiAqIEBjbGFzcyBNb3VzZVNlbnNvclxyXG4gKiBAbW9kdWxlIE1vdXNlU2Vuc29yXHJcbiAqIEBleHRlbmRzIFNlbnNvclxyXG4gKi9cclxuY2xhc3MgTW91c2VTZW5zb3IgZXh0ZW5kcyBfU2Vuc29yMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBNb3VzZVNlbnNvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBNb3VzZVNlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBkb3duIHRpbWVyIHdoaWNoIHdpbGwgZW5kIHVwIHRyaWdnZXJpbmcgdGhlIGRyYWcgc3RhcnQgb3BlcmF0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkgbW91c2VEb3duVGltZW91dFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNhdmUgcGFnZVggY29vcmRpbmF0ZXMgZm9yIGRlbGF5IGRyYWdcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYnJlfSBwYWdlWFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5wYWdlWCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTYXZlIHBhZ2VZIGNvb3JkaW5hdGVzIGZvciBkZWxheSBkcmFnXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJyZX0gcGFnZVlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFnZVkgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddID0gdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Nb3VzZURvd25dID0gdGhpc1tvbk1vdXNlRG93bl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Nb3VzZU1vdmVdID0gdGhpc1tvbk1vdXNlTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Nb3VzZVVwXSA9IHRoaXNbb25Nb3VzZVVwXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tzdGFydERyYWddID0gdGhpc1tzdGFydERyYWddLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdID0gdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBkb3duIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZG93biBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRG93bl0oZXZlbnQpIHtcclxuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xyXG5cclxuICAgIGlmICghY29udGFpbmVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IGRlbGF5IH0gPSB0aGlzO1xyXG4gICAgY29uc3QgeyBwYWdlWCwgcGFnZVkgfSA9IGV2ZW50O1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBwYWdlWCwgcGFnZVkgfSk7XHJcbiAgICB0aGlzLm9uTW91c2VEb3duQXQgPSBEYXRlLm5vdygpO1xyXG4gICAgdGhpcy5zdGFydEV2ZW50ID0gZXZlbnQ7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBwcmV2ZW50TmF0aXZlRHJhZ1N0YXJ0KTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG5cclxuICAgIHRoaXMubW91c2VEb3duVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSh7IHBhZ2VYOiB0aGlzLnBhZ2VYLCBwYWdlWTogdGhpcy5wYWdlWSB9KTtcclxuICAgIH0sIGRlbGF5Lm1vdXNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IHRoZSBkcmFnXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbc3RhcnREcmFnXSgpIHtcclxuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSB0aGlzLnN0YXJ0RXZlbnQ7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdGFydFNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogc3RhcnRFdmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBzdGFydEV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldDogc3RhcnRFdmVudC50YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogc3RhcnRFdmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0YXJ0RXZlbnQpO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dpbmcgPSAhZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKTtcclxuXHJcbiAgICBpZiAodGhpcy5kcmFnZ2luZykge1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXNbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddLCB0cnVlKTtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZWN0IGNoYW5nZSBpbiBkaXN0YW5jZSwgc3RhcnRpbmcgZHJhZyB3aGVuIGJvdGhcclxuICAgKiBkZWxheSBhbmQgZGlzdGFuY2UgcmVxdWlyZW1lbnRzIGFyZSBtZXRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgbW92ZSBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRpc3RhbmNlQ2hhbmdlXShldmVudCkge1xyXG4gICAgY29uc3QgeyBwYWdlWCwgcGFnZVkgfSA9IGV2ZW50O1xyXG4gICAgY29uc3QgeyBkaXN0YW5jZSB9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgY29uc3QgeyBzdGFydEV2ZW50LCBkZWxheSB9ID0gdGhpcztcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgcGFnZVgsIHBhZ2VZIH0pO1xyXG5cclxuICAgIGlmICghdGhpcy5jdXJyZW50Q29udGFpbmVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0aW1lRWxhcHNlZCA9IERhdGUubm93KCkgLSB0aGlzLm9uTW91c2VEb3duQXQ7XHJcbiAgICBjb25zdCBkaXN0YW5jZVRyYXZlbGxlZCA9ICgwLCBfdXRpbHMuZGlzdGFuY2UpKHN0YXJ0RXZlbnQucGFnZVgsIHN0YXJ0RXZlbnQucGFnZVksIHBhZ2VYLCBwYWdlWSkgfHwgMDtcclxuXHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy5tb3VzZURvd25UaW1lb3V0KTtcclxuXHJcbiAgICBpZiAodGltZUVsYXBzZWQgPCBkZWxheS5tb3VzZSkge1xyXG4gICAgICAvLyBtb3ZlZCBkdXJpbmcgZGVsYXlcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlVHJhdmVsbGVkID49IGRpc3RhbmNlKSB7XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG4gICAgICB0aGlzW3N0YXJ0RHJhZ10oKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIG1vdmUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBtb3ZlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VNb3ZlXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdNb3ZlU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ01vdmVFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSB1cCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIHVwIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VVcF0oZXZlbnQpIHtcclxuICAgIGNsZWFyVGltZW91dCh0aGlzLm1vdXNlRG93blRpbWVvdXQpO1xyXG5cclxuICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0pO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgcHJldmVudE5hdGl2ZURyYWdTdGFydCk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0b3BTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RvcEV2ZW50KTtcclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXNbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25Nb3VzZU1vdmVdKTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBudWxsO1xyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5zdGFydEV2ZW50ID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnRleHQgbWVudSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIENvbnRleHQgbWVudSBldmVudFxyXG4gICAqL1xyXG4gIFtvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10oZXZlbnQpIHtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBNb3VzZVNlbnNvcjtcclxuZnVuY3Rpb24gcHJldmVudE5hdGl2ZURyYWdTdGFydChldmVudCkge1xyXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfTW91c2VTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuXHJcbnZhciBfTW91c2VTZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW91c2VTZW5zb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Nb3VzZVNlbnNvcjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG5jb25zdCBkZWZhdWx0RGVhbHkgPSB7XHJcbiAgbW91c2U6IDAsXHJcbiAgZHJhZzogMCxcclxuICB0b3VjaDogMTAwXHJcbn07XHJcblxyXG4vKipcclxuICogQmFzZSBzZW5zb3IgY2xhc3MuIEV4dGVuZCBmcm9tIHRoaXMgY2xhc3MgdG8gY3JlYXRlIGEgbmV3IG9yIGN1c3RvbSBzZW5zb3JcclxuICogQGNsYXNzIFNlbnNvclxyXG4gKiBAbW9kdWxlIFNlbnNvclxyXG4gKi9cclxuY2xhc3MgU2Vuc29yIHtcclxuICAvKipcclxuICAgKiBTZW5zb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgU2Vuc29yXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgY29udGFpbmVyc1xyXG4gICAgICogQHByb3BlcnR5IGNvbnRhaW5lcnNcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudFtdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSBbLi4uY29udGFpbmVyc107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGRyYWcgc3RhdGVcclxuICAgICAqIEBwcm9wZXJ0eSBkcmFnZ2luZ1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgY29udGFpbmVyXHJcbiAgICAgKiBAcHJvcGVydHkgY3VycmVudENvbnRhaW5lclxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGV2ZW50IG9mIHRoZSBpbml0aWFsIHNlbnNvciBkb3duXHJcbiAgICAgKiBAcHJvcGVydHkgc3RhcnRFdmVudFxyXG4gICAgICogQHR5cGUge0V2ZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlbGF5IG9mIGVhY2ggc2Vuc29yXHJcbiAgICAgKiBAcHJvcGVydHkgZGVsYXlcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGVsYXkgPSBjYWxjRGVsYXkob3B0aW9ucy5kZWxheSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICogQHJldHVybiB7U2Vuc29yfVxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqIEByZXR1cm4ge1NlbnNvcn1cclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgY29udGFpbmVyIHRvIHRoaXMgc2Vuc29yIGluc3RhbmNlXHJcbiAgICogQHBhcmFtIHsuLi5IVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnMgeW91IHdhbnQgdG8gYWRkIHRvIHRoaXMgc2Vuc29yXHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLmFkZENvbnRhaW5lcihkb2N1bWVudC5ib2R5KVxyXG4gICAqL1xyXG4gIGFkZENvbnRhaW5lciguLi5jb250YWluZXJzKSB7XHJcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSBbLi4udGhpcy5jb250YWluZXJzLCAuLi5jb250YWluZXJzXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgY29udGFpbmVyIGZyb20gdGhpcyBzZW5zb3IgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0gey4uLkhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVycyB5b3Ugd2FudCB0byByZW1vdmUgZnJvbSB0aGlzIHNlbnNvclxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5yZW1vdmVDb250YWluZXIoZG9jdW1lbnQuYm9keSlcclxuICAgKi9cclxuICByZW1vdmVDb250YWluZXIoLi4uY29udGFpbmVycykge1xyXG4gICAgdGhpcy5jb250YWluZXJzID0gdGhpcy5jb250YWluZXJzLmZpbHRlcihjb250YWluZXIgPT4gIWNvbnRhaW5lcnMuaW5jbHVkZXMoY29udGFpbmVyKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmlnZ2VycyBldmVudCBvbiB0YXJnZXQgZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIHRyaWdnZXIgZXZlbnQgb25cclxuICAgKiBAcGFyYW0ge1NlbnNvckV2ZW50fSBzZW5zb3JFdmVudCAtIFNlbnNvciBldmVudCB0byB0cmlnZ2VyXHJcbiAgICovXHJcbiAgdHJpZ2dlcihlbGVtZW50LCBzZW5zb3JFdmVudCkge1xyXG4gICAgY29uc3QgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxuICAgIGV2ZW50LmRldGFpbCA9IHNlbnNvckV2ZW50O1xyXG4gICAgZXZlbnQuaW5pdEV2ZW50KHNlbnNvckV2ZW50LnR5cGUsIHRydWUsIHRydWUpO1xyXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIHRoaXMubGFzdEV2ZW50ID0gc2Vuc29yRXZlbnQ7XHJcblxyXG4gICAgcmV0dXJuIHNlbnNvckV2ZW50O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gU2Vuc29yOyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDYWxjdWxhdGUgdGhlIGRlbGF5IG9mIGVhY2ggc2Vuc29yIHRocm91Z2ggdGhlIGRlbGF5IGluIHRoZSBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHt1bmRlZmluZWR8TnVtYmVyfE9iamVjdH0gb3B0aW9uc0RlbGF5IC0gdGhlIGRlbGF5IGluIHRoZSBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuZnVuY3Rpb24gY2FsY0RlbGF5KG9wdGlvbnNEZWxheSkge1xyXG4gIGNvbnN0IGRlbGF5ID0ge307XHJcblxyXG4gIGlmIChvcHRpb25zRGVsYXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkZWZhdWx0RGVhbHkpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBvcHRpb25zRGVsYXkgPT09ICdudW1iZXInKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0RGVhbHkpIHtcclxuICAgICAgaWYgKGRlZmF1bHREZWFseS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgZGVsYXlba2V5XSA9IG9wdGlvbnNEZWxheTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlbGF5O1xyXG4gIH1cclxuXHJcbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdERlYWx5KSB7XHJcbiAgICBpZiAoZGVmYXVsdERlYWx5Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgaWYgKG9wdGlvbnNEZWxheVtrZXldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBkZWxheVtrZXldID0gZGVmYXVsdERlYWx5W2tleV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGVsYXlba2V5XSA9IG9wdGlvbnNEZWxheVtrZXldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGVsYXk7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gdG91Y2hDb29yZHM7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCB0b3VjaCBldmVudCBmb3VuZCBpbiB0b3VjaGVzIG9yIGNoYW5nZWRUb3VjaGVzIG9mIGEgdG91Y2ggZXZlbnRzLlxyXG4gKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2ZW50IGEgdG91Y2ggZXZlbnRcclxuICogQHJldHVybiB7VG91Y2h9IGEgdG91Y2ggb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiB0b3VjaENvb3JkcyhldmVudCA9IHt9KSB7XHJcbiAgY29uc3QgeyB0b3VjaGVzLCBjaGFuZ2VkVG91Y2hlcyB9ID0gZXZlbnQ7XHJcbiAgcmV0dXJuIHRvdWNoZXMgJiYgdG91Y2hlc1swXSB8fCBjaGFuZ2VkVG91Y2hlcyAmJiBjaGFuZ2VkVG91Y2hlc1swXTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF90b3VjaENvb3JkcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xyXG5cclxudmFyIF90b3VjaENvb3JkczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b3VjaENvb3Jkcyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX3RvdWNoQ29vcmRzMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBkaXN0YW5jZTtcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHgxIFRoZSBYIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHkxIFRoZSBZIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHgyIFRoZSBYIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnRcclxuICogQHBhcmFtICB7TnVtYmVyfSB5MiBUaGUgWSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50XHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XHJcbiAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiogMiArICh5MiAtIHkxKSAqKiAyKTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9kaXN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xyXG5cclxudmFyIF9kaXN0YW5jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXN0YW5jZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX2Rpc3RhbmNlMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSByZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lO1xyXG5mdW5jdGlvbiByZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XHJcbiAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcclxuXHJcbnZhciBfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gY2xvc2VzdDtcclxuY29uc3QgbWF0Y2hGdW5jdGlvbiA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvcjtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGNsb3Nlc3QgcGFyZW50IGVsZW1lbnQgb2YgYSBnaXZlbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW5cclxuICogc2VsZWN0b3Igc3RyaW5nIG9yIG1hdGNoaW5nIGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgY2hpbGQgZWxlbWVudCB0byBmaW5kIGEgcGFyZW50IG9mXHJcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBUaGUgc3RyaW5nIG9yIGZ1bmN0aW9uIHRvIHVzZSB0byBtYXRjaFxyXG4gKiAgICAgdGhlIHBhcmVudCBlbGVtZW50XHJcbiAqIEByZXR1cm4ge0VsZW1lbnR8bnVsbH1cclxuICovXHJcbmZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgdmFsdWUpIHtcclxuICBpZiAoIWVsZW1lbnQpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc2VsZWN0b3IgPSB2YWx1ZTtcclxuICBjb25zdCBjYWxsYmFjayA9IHZhbHVlO1xyXG4gIGNvbnN0IG5vZGVMaXN0ID0gdmFsdWU7XHJcbiAgY29uc3Qgc2luZ2xlRWxlbWVudCA9IHZhbHVlO1xyXG5cclxuICBjb25zdCBpc1NlbGVjdG9yID0gQm9vbGVhbih0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKTtcclxuICBjb25zdCBpc0Z1bmN0aW9uID0gQm9vbGVhbih0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpO1xyXG4gIGNvbnN0IGlzTm9kZUxpc3QgPSBCb29sZWFuKHZhbHVlIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBBcnJheSk7XHJcbiAgY29uc3QgaXNFbGVtZW50ID0gQm9vbGVhbih2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KTtcclxuXHJcbiAgZnVuY3Rpb24gY29uZGl0aW9uRm4oY3VycmVudEVsZW1lbnQpIHtcclxuICAgIGlmICghY3VycmVudEVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtZW50O1xyXG4gICAgfSBlbHNlIGlmIChpc1NlbGVjdG9yKSB7XHJcbiAgICAgIHJldHVybiBtYXRjaEZ1bmN0aW9uLmNhbGwoY3VycmVudEVsZW1lbnQsIHNlbGVjdG9yKTtcclxuICAgIH0gZWxzZSBpZiAoaXNOb2RlTGlzdCkge1xyXG4gICAgICByZXR1cm4gWy4uLm5vZGVMaXN0XS5pbmNsdWRlcyhjdXJyZW50RWxlbWVudCk7XHJcbiAgICB9IGVsc2UgaWYgKGlzRWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gc2luZ2xlRWxlbWVudCA9PT0gY3VycmVudEVsZW1lbnQ7XHJcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24pIHtcclxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGN1cnJlbnRFbGVtZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbGV0IGN1cnJlbnQgPSBlbGVtZW50O1xyXG5cclxuICBkbyB7XHJcbiAgICBjdXJyZW50ID0gY3VycmVudC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCB8fCBjdXJyZW50LmNvcnJlc3BvbmRpbmdFbGVtZW50IHx8IGN1cnJlbnQ7XHJcblxyXG4gICAgaWYgKGNvbmRpdGlvbkZuKGN1cnJlbnQpKSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XHJcbiAgfSB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50KTtcclxuXHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfY2xvc2VzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xyXG5cclxudmFyIF9jbG9zZXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb3Nlc3QpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9jbG9zZXN0Mi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5zY3JvbGwgPSBleHBvcnRzLm9uRHJhZ1N0b3AgPSBleHBvcnRzLm9uRHJhZ01vdmUgPSBleHBvcnRzLm9uRHJhZ1N0YXJ0ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkRyYWdTdGFydCA9IGV4cG9ydHMub25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XHJcbmNvbnN0IG9uRHJhZ01vdmUgPSBleHBvcnRzLm9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcclxuY29uc3Qgb25EcmFnU3RvcCA9IGV4cG9ydHMub25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xyXG5jb25zdCBzY3JvbGwgPSBleHBvcnRzLnNjcm9sbCA9IFN5bWJvbCgnc2Nyb2xsJyk7XHJcblxyXG4vKipcclxuICogU2Nyb2xsYWJsZSBkZWZhdWx0IG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWZhdWx0T3B0aW9ucy5zcGVlZFxyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMuc2Vuc2l0aXZpdHlcclxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudFtdfSBkZWZhdWx0T3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHNcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcclxuICBzcGVlZDogNixcclxuICBzZW5zaXRpdml0eTogNTAsXHJcbiAgc2Nyb2xsYWJsZUVsZW1lbnRzOiBbXVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNjcm9sbGFibGUgcGx1Z2luIHdoaWNoIHNjcm9sbHMgdGhlIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBwYXJlbnRcclxuICogQGNsYXNzIFNjcm9sbGFibGVcclxuICogQG1vZHVsZSBTY3JvbGxhYmxlXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBTY3JvbGxhYmxlIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBTY3JvbGxhYmxlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFNjcm9sbGFibGVcclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2Nyb2xsYWJsZSBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG9wdGlvbnMuc3BlZWRcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBvcHRpb25zLnNlbnNpdGl2aXR5XHJcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50W119IG9wdGlvbnMuc2Nyb2xsYWJsZUVsZW1lbnRzXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIHRoaXMuZ2V0T3B0aW9ucygpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtlZXBzIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjdXJyZW50TW91c2VQb3NpdGlvblxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGN1cnJlbnRNb3VzZVBvc2l0aW9uLmNsaWVudFhcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRZXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2Nyb2xsIGFuaW1hdGlvbiBmcmFtZVxyXG4gICAgICogQHByb3BlcnR5IHNjcm9sbEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzdCBzY3JvbGxhYmxlIGVsZW1lbnRcclxuICAgICAqIEBwcm9wZXJ0eSBzY3JvbGxhYmxlRWxlbWVudFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW5pbWF0aW9uIGZyYW1lIGxvb2tpbmcgZm9yIHRoZSBjbG9zZXN0IHNjcm9sbGFibGUgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IGZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnTW92ZV0gPSB0aGlzW29uRHJhZ01vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tzY3JvbGxdID0gdGhpc1tzY3JvbGxdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9uKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vZmYoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5zY3JvbGxhYmxlIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjbG9zZXN0IHNjcm9sbGFibGUgZWxlbWVudHMgYnkgZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gICAqL1xyXG4gIGdldFNjcm9sbGFibGVFbGVtZW50KHRhcmdldCkge1xyXG4gICAgaWYgKHRoaXMuaGFzRGVmaW5lZFNjcm9sbGFibGVFbGVtZW50cygpKSB7XHJcbiAgICAgIHJldHVybiAoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgdGhpcy5vcHRpb25zLnNjcm9sbGFibGVFbGVtZW50cykgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGNsb3Nlc3RTY3JvbGxhYmxlRWxlbWVudCh0YXJnZXQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIGF0IGxlYXN0IG9uZSBzY3JvbGxhYmxlIGVsZW1lbnQgaGF2ZSBiZWVuIGRlZmluZWQgdmlhIG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGhhc0RlZmluZWRTY3JvbGxhYmxlRWxlbWVudHMoKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLm9wdGlvbnMuc2Nyb2xsYWJsZUVsZW1lbnRzLmxlbmd0aCAhPT0gMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXIuIEZpbmRzIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBwYXJlbnQgaW4gc2VwYXJhdGUgZnJhbWVcclxuICAgKiBAcGFyYW0ge0RyYWdTdGFydEV2ZW50fSBkcmFnRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdGFydF0oZHJhZ0V2ZW50KSB7XHJcbiAgICB0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgdGhpcy5zY3JvbGxhYmxlRWxlbWVudCA9IHRoaXMuZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZHJhZ0V2ZW50LnNvdXJjZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgbW92ZSBoYW5kbGVyLiBSZW1lbWJlcnMgbW91c2UgcG9zaXRpb24gYW5kIGluaXRpYXRlcyBzY3JvbGxpbmdcclxuICAgKiBAcGFyYW0ge0RyYWdNb3ZlRXZlbnR9IGRyYWdFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRHJhZ01vdmVdKGRyYWdFdmVudCkge1xyXG4gICAgdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSB0aGlzLmdldFNjcm9sbGFibGVFbGVtZW50KGRyYWdFdmVudC5zZW5zb3JFdmVudC50YXJnZXQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCF0aGlzLnNjcm9sbGFibGVFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZW5zb3JFdmVudCA9IGRyYWdFdmVudC5zZW5zb3JFdmVudDtcclxuICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcclxuICAgICAgc2Nyb2xsT2Zmc2V0LnkgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCB8fCAwO1xyXG4gICAgICBzY3JvbGxPZmZzZXQueCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHwgMDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uID0ge1xyXG4gICAgICBjbGllbnRYOiBzZW5zb3JFdmVudC5jbGllbnRYIC0gc2Nyb2xsT2Zmc2V0LngsXHJcbiAgICAgIGNsaWVudFk6IHNlbnNvckV2ZW50LmNsaWVudFkgLSBzY3JvbGxPZmZzZXQueVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXNbc2Nyb2xsXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0b3AgaGFuZGxlci4gQ2FuY2VscyBzY3JvbGwgYW5pbWF0aW9ucyBhbmQgcmVzZXRzIHN0YXRlXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25EcmFnU3RvcF0oKSB7XHJcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lKTtcclxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUpO1xyXG5cclxuICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSBudWxsO1xyXG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IG51bGw7XHJcbiAgICB0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lID0gbnVsbDtcclxuICAgIHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24gPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsIGZ1bmN0aW9uIHRoYXQgZG9lcyB0aGUgaGVhdnlsaWZ0aW5nXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbc2Nyb2xsXSgpIHtcclxuICAgIGlmICghdGhpcy5zY3JvbGxhYmxlRWxlbWVudCB8fCAhdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSk7XHJcblxyXG4gICAgY29uc3QgeyBzcGVlZCwgc2Vuc2l0aXZpdHkgfSA9IHRoaXMub3B0aW9ucztcclxuXHJcbiAgICBjb25zdCByZWN0ID0gdGhpcy5zY3JvbGxhYmxlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGNvbnN0IGJvdHRvbUN1dE9mZiA9IHJlY3QuYm90dG9tID4gd2luZG93LmlubmVySGVpZ2h0O1xyXG4gICAgY29uc3QgdG9wQ3V0T2ZmID0gcmVjdC50b3AgPCAwO1xyXG4gICAgY29uc3QgY3V0T2ZmID0gdG9wQ3V0T2ZmIHx8IGJvdHRvbUN1dE9mZjtcclxuXHJcbiAgICBjb25zdCBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQgPSBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKTtcclxuICAgIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50ID0gdGhpcy5zY3JvbGxhYmxlRWxlbWVudDtcclxuICAgIGNvbnN0IGNsaWVudFggPSB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uLmNsaWVudFg7XHJcbiAgICBjb25zdCBjbGllbnRZID0gdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRZO1xyXG5cclxuICAgIGlmIChzY3JvbGxhYmxlRWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBzY3JvbGxhYmxlRWxlbWVudCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICFjdXRPZmYpIHtcclxuICAgICAgY29uc3QgeyBvZmZzZXRIZWlnaHQsIG9mZnNldFdpZHRoIH0gPSBzY3JvbGxhYmxlRWxlbWVudDtcclxuXHJcbiAgICAgIGlmIChyZWN0LnRvcCArIG9mZnNldEhlaWdodCAtIGNsaWVudFkgPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbFRvcCArPSBzcGVlZDtcclxuICAgICAgfSBlbHNlIGlmIChjbGllbnRZIC0gcmVjdC50b3AgPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbFRvcCAtPSBzcGVlZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlY3QubGVmdCArIG9mZnNldFdpZHRoIC0gY2xpZW50WCA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsTGVmdCArPSBzcGVlZDtcclxuICAgICAgfSBlbHNlIGlmIChjbGllbnRYIC0gcmVjdC5sZWZ0IDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxMZWZ0IC09IHNwZWVkO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCB7IGlubmVySGVpZ2h0LCBpbm5lcldpZHRoIH0gPSB3aW5kb3c7XHJcblxyXG4gICAgICBpZiAoY2xpZW50WSA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCAtPSBzcGVlZDtcclxuICAgICAgfSBlbHNlIGlmIChpbm5lckhlaWdodCAtIGNsaWVudFkgPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgKz0gc3BlZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjbGllbnRYIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCAtPSBzcGVlZDtcclxuICAgICAgfSBlbHNlIGlmIChpbm5lcldpZHRoIC0gY2xpZW50WCA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgKz0gc3BlZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXNbc2Nyb2xsXSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBTY3JvbGxhYmxlOyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgZWxlbWVudCBoYXMgb3ZlcmZsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmZ1bmN0aW9uIGhhc092ZXJmbG93KGVsZW1lbnQpIHtcclxuICBjb25zdCBvdmVyZmxvd1JlZ2V4ID0gLyhhdXRvfHNjcm9sbCkvO1xyXG4gIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcclxuXHJcbiAgY29uc3Qgb3ZlcmZsb3cgPSBjb21wdXRlZFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdycpICsgY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cteScpICsgY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cteCcpO1xyXG5cclxuICByZXR1cm4gb3ZlcmZsb3dSZWdleC50ZXN0KG92ZXJmbG93KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIGVsZW1lbnQgaXMgc3RhdGljYWxseSBwb3NpdGlvbmVkXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGlzU3RhdGljYWxseVBvc2l0aW9uZWQoZWxlbWVudCkge1xyXG4gIGNvbnN0IHBvc2l0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xyXG4gIHJldHVybiBwb3NpdGlvbiA9PT0gJ3N0YXRpYyc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kcyBjbG9zZXN0IHNjcm9sbGFibGUgZWxlbWVudFxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY2xvc2VzdFNjcm9sbGFibGVFbGVtZW50KGVsZW1lbnQpIHtcclxuICBpZiAoIWVsZW1lbnQpIHtcclxuICAgIHJldHVybiBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHBvc2l0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xyXG4gIGNvbnN0IGV4Y2x1ZGVTdGF0aWNQYXJlbnRzID0gcG9zaXRpb24gPT09ICdhYnNvbHV0ZSc7XHJcblxyXG4gIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50ID0gKDAsIF91dGlscy5jbG9zZXN0KShlbGVtZW50LCBwYXJlbnQgPT4ge1xyXG4gICAgaWYgKGV4Y2x1ZGVTdGF0aWNQYXJlbnRzICYmIGlzU3RhdGljYWxseVBvc2l0aW9uZWQocGFyZW50KSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzT3ZlcmZsb3cocGFyZW50KTtcclxuICB9KTtcclxuXHJcbiAgaWYgKHBvc2l0aW9uID09PSAnZml4ZWQnIHx8ICFzY3JvbGxhYmxlRWxlbWVudCkge1xyXG4gICAgcmV0dXJuIGdldERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gc2Nyb2xsYWJsZUVsZW1lbnQ7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBlbGVtZW50IHRoYXQgc2Nyb2xscyBkb2N1bWVudFxyXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCgpIHtcclxuICByZXR1cm4gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfU2Nyb2xsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xyXG5cclxudmFyIF9TY3JvbGxhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Njcm9sbGFibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9TY3JvbGxhYmxlMi5kZWZhdWx0O1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gX1Njcm9sbGFibGUuZGVmYXVsdE9wdGlvbnM7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuTWlycm9yRGVzdHJveUV2ZW50ID0gZXhwb3J0cy5NaXJyb3JNb3ZlRXZlbnQgPSBleHBvcnRzLk1pcnJvckF0dGFjaGVkRXZlbnQgPSBleHBvcnRzLk1pcnJvckNyZWF0ZWRFdmVudCA9IGV4cG9ydHMuTWlycm9yQ3JlYXRlRXZlbnQgPSBleHBvcnRzLk1pcnJvckV2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKipcclxuICogQmFzZSBtaXJyb3IgZXZlbnRcclxuICogQGNsYXNzIE1pcnJvckV2ZW50XHJcbiAqIEBtb2R1bGUgTWlycm9yRXZlbnRcclxuICogQGV4dGVuZHMgQWJzdHJhY3RFdmVudFxyXG4gKi9cclxuY2xhc3MgTWlycm9yRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBzb3VyY2UgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBzb3VyY2VcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNvdXJjZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBvcmlnaW5hbCBzb3VyY2UgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbFNvdXJjZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3JpZ2luYWxTb3VyY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9yaWdpbmFsU291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBzb3VyY2UgY29udGFpbmVyIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgc291cmNlQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzb3VyY2VDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZUNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbnNvciBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBzZW5zb3JFdmVudFxyXG4gICAqIEB0eXBlIHtTZW5zb3JFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc2Vuc29yRXZlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNlbnNvckV2ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBkcmFnRXZlbnRcclxuICAgKiBAdHlwZSB7RHJhZ0V2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkcmFnRXZlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9yaWdpbmFsIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHNlbnNvciBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbEV2ZW50XHJcbiAgICogQHR5cGUge0V2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvcmlnaW5hbEV2ZW50KCkge1xyXG4gICAgaWYgKHRoaXMuc2Vuc29yRXZlbnQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2Vuc29yRXZlbnQub3JpZ2luYWxFdmVudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuTWlycm9yRXZlbnQgPSBNaXJyb3JFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWlycm9yIGNyZWF0ZSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBNaXJyb3JDcmVhdGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgTWlycm9yQ3JlYXRlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBNaXJyb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuY2xhc3MgTWlycm9yQ3JlYXRlRXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5NaXJyb3JDcmVhdGVFdmVudCA9IE1pcnJvckNyZWF0ZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNaXJyb3IgY3JlYXRlZCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBNaXJyb3JDcmVhdGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIE1pcnJvckNyZWF0ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIE1pcnJvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5NaXJyb3JDcmVhdGVFdmVudC50eXBlID0gJ21pcnJvcjpjcmVhdGUnO1xyXG5jbGFzcyBNaXJyb3JDcmVhdGVkRXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgbWlycm9yIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbWlycm9yXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBtaXJyb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuTWlycm9yQ3JlYXRlZEV2ZW50ID0gTWlycm9yQ3JlYXRlZEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1pcnJvciBhdHRhY2hlZCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIE1pcnJvckF0dGFjaGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgTWlycm9yQXR0YWNoZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgTWlycm9yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuTWlycm9yQ3JlYXRlZEV2ZW50LnR5cGUgPSAnbWlycm9yOmNyZWF0ZWQnO1xyXG5jbGFzcyBNaXJyb3JBdHRhY2hlZEV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG1pcnJvclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbWlycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLk1pcnJvckF0dGFjaGVkRXZlbnQgPSBNaXJyb3JBdHRhY2hlZEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWlycm9yIG1vdmUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIE1pcnJvck1vdmVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIE1pcnJvck1vdmVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBNaXJyb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbk1pcnJvckF0dGFjaGVkRXZlbnQudHlwZSA9ICdtaXJyb3I6YXR0YWNoZWQnO1xyXG5jbGFzcyBNaXJyb3JNb3ZlRXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgbWlycm9yIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbWlycm9yXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBtaXJyb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbnNvciBoYXMgZXhjZWVkZWQgbWlycm9yJ3MgdGhyZXNob2xkIG9uIHggYXhpc1xyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBwYXNzZWRUaHJlc2hYKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wYXNzZWRUaHJlc2hYO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Vuc29yIGhhcyBleGNlZWRlZCBtaXJyb3IncyB0aHJlc2hvbGQgb24geSBheGlzXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHBhc3NlZFRocmVzaFkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnBhc3NlZFRocmVzaFk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLk1pcnJvck1vdmVFdmVudCA9IE1pcnJvck1vdmVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNaXJyb3IgZGVzdHJveSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIE1pcnJvckRlc3Ryb3lFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JEZXN0cm95RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIE1pcnJvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbk1pcnJvck1vdmVFdmVudC50eXBlID0gJ21pcnJvcjptb3ZlJztcclxuTWlycm9yTW92ZUV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBNaXJyb3JEZXN0cm95RXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgbWlycm9yIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbWlycm9yXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBtaXJyb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5NaXJyb3JEZXN0cm95RXZlbnQgPSBNaXJyb3JEZXN0cm95RXZlbnQ7XHJcbk1pcnJvckRlc3Ryb3lFdmVudC50eXBlID0gJ21pcnJvcjpkZXN0cm95JztcclxuTWlycm9yRGVzdHJveUV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9NaXJyb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xyXG5cclxuT2JqZWN0LmtleXMoX01pcnJvckV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX01pcnJvckV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5nZXRBcHBlbmRhYmxlQ29udGFpbmVyID0gZXhwb3J0cy5vblNjcm9sbCA9IGV4cG9ydHMub25NaXJyb3JNb3ZlID0gZXhwb3J0cy5vbk1pcnJvckNyZWF0ZWQgPSBleHBvcnRzLm9uRHJhZ1N0b3AgPSBleHBvcnRzLm9uRHJhZ01vdmUgPSBleHBvcnRzLm9uRHJhZ1N0YXJ0ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG52YXIgX01pcnJvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5cclxuY29uc3Qgb25EcmFnU3RhcnQgPSBleHBvcnRzLm9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdNb3ZlID0gZXhwb3J0cy5vbkRyYWdNb3ZlID0gU3ltYm9sKCdvbkRyYWdNb3ZlJyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBleHBvcnRzLm9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3Qgb25NaXJyb3JDcmVhdGVkID0gZXhwb3J0cy5vbk1pcnJvckNyZWF0ZWQgPSBTeW1ib2woJ29uTWlycm9yQ3JlYXRlZCcpO1xyXG5jb25zdCBvbk1pcnJvck1vdmUgPSBleHBvcnRzLm9uTWlycm9yTW92ZSA9IFN5bWJvbCgnb25NaXJyb3JNb3ZlJyk7XHJcbmNvbnN0IG9uU2Nyb2xsID0gZXhwb3J0cy5vblNjcm9sbCA9IFN5bWJvbCgnb25TY3JvbGwnKTtcclxuY29uc3QgZ2V0QXBwZW5kYWJsZUNvbnRhaW5lciA9IGV4cG9ydHMuZ2V0QXBwZW5kYWJsZUNvbnRhaW5lciA9IFN5bWJvbCgnZ2V0QXBwZW5kYWJsZUNvbnRhaW5lcicpO1xyXG5cclxuLyoqXHJcbiAqIE1pcnJvciBkZWZhdWx0IG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVmYXVsdE9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9uc1xyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRlZmF1bHRPcHRpb25zLnhBeGlzXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVmYXVsdE9wdGlvbnMueUF4aXNcclxuICogQHByb3BlcnR5IHtudWxsfSBkZWZhdWx0T3B0aW9ucy5jdXJzb3JPZmZzZXRYXHJcbiAqIEBwcm9wZXJ0eSB7bnVsbH0gZGVmYXVsdE9wdGlvbnMuY3Vyc29yT2Zmc2V0WVxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xyXG4gIGNvbnN0cmFpbkRpbWVuc2lvbnM6IGZhbHNlLFxyXG4gIHhBeGlzOiB0cnVlLFxyXG4gIHlBeGlzOiB0cnVlLFxyXG4gIGN1cnNvck9mZnNldFg6IG51bGwsXHJcbiAgY3Vyc29yT2Zmc2V0WTogbnVsbCxcclxuICB0aHJlc2hvbGRYOiBudWxsLFxyXG4gIHRocmVzaG9sZFk6IG51bGxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXJyb3IgcGx1Z2luIHdoaWNoIGNvbnRyb2xzIHRoZSBtaXJyb3IgcG9zaXRpb25pbmcgd2hpbGUgZHJhZ2dpbmdcclxuICogQGNsYXNzIE1pcnJvclxyXG4gKiBAbW9kdWxlIE1pcnJvclxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgTWlycm9yIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBNaXJyb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgTWlycm9yXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1pcnJvciBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBvcHRpb25zLmNvbnN0cmFpbkRpbWVuc2lvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gb3B0aW9ucy54QXhpc1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBvcHRpb25zLnlBeGlzXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxudWxsfSBvcHRpb25zLmN1cnNvck9mZnNldFhcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfG51bGx9IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WVxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb259IG9wdGlvbnMuYXBwZW5kVG9cclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2Nyb2xsIG9mZnNldCBmb3IgdG91Y2ggZGV2aWNlcyBiZWNhdXNlIHRoZSBtaXJyb3IgaXMgcG9zaXRpb25lZCBmaXhlZFxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHNjcm9sbE9mZnNldFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjcm9sbE9mZnNldC54XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc2Nyb2xsT2Zmc2V0LnlcclxuICAgICAqL1xyXG4gICAgdGhpcy5zY3JvbGxPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWwgc2Nyb2xsIG9mZnNldCBmb3IgdG91Y2ggZGV2aWNlcyBiZWNhdXNlIHRoZSBtaXJyb3IgaXMgcG9zaXRpb25lZCBmaXhlZFxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHNjcm9sbE9mZnNldFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjcm9sbE9mZnNldC54XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc2Nyb2xsT2Zmc2V0LnlcclxuICAgICAqL1xyXG4gICAgdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0ID0ge1xyXG4gICAgICB4OiB3aW5kb3cuc2Nyb2xsWCxcclxuICAgICAgeTogd2luZG93LnNjcm9sbFlcclxuICAgIH07XHJcblxyXG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTWlycm9yQ3JlYXRlZF0gPSB0aGlzW29uTWlycm9yQ3JlYXRlZF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25NaXJyb3JNb3ZlXSA9IHRoaXNbb25NaXJyb3JNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvblNjcm9sbF0gPSB0aGlzW29uU2Nyb2xsXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9uKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub24oJ21pcnJvcjptb3ZlJywgdGhpc1tvbk1pcnJvck1vdmVdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKS5vZmYoJ21pcnJvcjpjcmVhdGVkJywgdGhpc1tvbk1pcnJvckNyZWF0ZWRdKS5vZmYoJ21pcnJvcjptb3ZlJywgdGhpc1tvbk1pcnJvck1vdmVdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgb3B0aW9ucyBwYXNzZWQgdGhyb3VnaCBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXHJcbiAgZ2V0T3B0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLm1pcnJvciB8fCB7fTtcclxuICB9XHJcblxyXG4gIFtvbkRyYWdTdGFydF0oZHJhZ0V2ZW50KSB7XHJcbiAgICBpZiAoZHJhZ0V2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpc1tvblNjcm9sbF0sIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldCA9IHtcclxuICAgICAgeDogd2luZG93LnNjcm9sbFgsXHJcbiAgICAgIHk6IHdpbmRvdy5zY3JvbGxZXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHsgc291cmNlLCBvcmlnaW5hbFNvdXJjZSwgc291cmNlQ29udGFpbmVyLCBzZW5zb3JFdmVudCB9ID0gZHJhZ0V2ZW50O1xyXG5cclxuICAgIC8vIExhc3Qgc2Vuc29yIHBvc2l0aW9uIG9mIG1pcnJvciBtb3ZlXHJcbiAgICB0aGlzLmxhc3RNaXJyb3JNb3ZlZENsaWVudCA9IHtcclxuICAgICAgeDogc2Vuc29yRXZlbnQuY2xpZW50WCxcclxuICAgICAgeTogc2Vuc29yRXZlbnQuY2xpZW50WVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBtaXJyb3JDcmVhdGVFdmVudCA9IG5ldyBfTWlycm9yRXZlbnQuTWlycm9yQ3JlYXRlRXZlbnQoe1xyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzb3VyY2VDb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBkcmFnRXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yQ3JlYXRlRXZlbnQpO1xyXG5cclxuICAgIGlmIChpc05hdGl2ZURyYWdFdmVudChzZW5zb3JFdmVudCkgfHwgbWlycm9yQ3JlYXRlRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYXBwZW5kYWJsZUNvbnRhaW5lciA9IHRoaXNbZ2V0QXBwZW5kYWJsZUNvbnRhaW5lcl0oc291cmNlKSB8fCBzb3VyY2VDb250YWluZXI7XHJcbiAgICB0aGlzLm1pcnJvciA9IHNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XHJcblxyXG4gICAgY29uc3QgbWlycm9yQ3JlYXRlZEV2ZW50ID0gbmV3IF9NaXJyb3JFdmVudC5NaXJyb3JDcmVhdGVkRXZlbnQoe1xyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzb3VyY2VDb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBkcmFnRXZlbnQsXHJcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG1pcnJvckF0dGFjaGVkRXZlbnQgPSBuZXcgX01pcnJvckV2ZW50Lk1pcnJvckF0dGFjaGVkRXZlbnQoe1xyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzb3VyY2VDb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBkcmFnRXZlbnQsXHJcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yQ3JlYXRlZEV2ZW50KTtcclxuICAgIGFwcGVuZGFibGVDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5taXJyb3IpO1xyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JBdHRhY2hlZEV2ZW50KTtcclxuICB9XHJcblxyXG4gIFtvbkRyYWdNb3ZlXShkcmFnRXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5taXJyb3IgfHwgZHJhZ0V2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgc291cmNlLCBvcmlnaW5hbFNvdXJjZSwgc291cmNlQ29udGFpbmVyLCBzZW5zb3JFdmVudCB9ID0gZHJhZ0V2ZW50O1xyXG5cclxuICAgIGxldCBwYXNzZWRUaHJlc2hYID0gdHJ1ZTtcclxuICAgIGxldCBwYXNzZWRUaHJlc2hZID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnRocmVzaG9sZFggfHwgdGhpcy5vcHRpb25zLnRocmVzaG9sZFkpIHtcclxuICAgICAgY29uc3QgeyB4OiBsYXN0WCwgeTogbGFzdFkgfSA9IHRoaXMubGFzdE1pcnJvck1vdmVkQ2xpZW50O1xyXG5cclxuICAgICAgaWYgKE1hdGguYWJzKGxhc3RYIC0gc2Vuc29yRXZlbnQuY2xpZW50WCkgPCB0aGlzLm9wdGlvbnMudGhyZXNob2xkWCkge1xyXG4gICAgICAgIHBhc3NlZFRocmVzaFggPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmxhc3RNaXJyb3JNb3ZlZENsaWVudC54ID0gc2Vuc29yRXZlbnQuY2xpZW50WDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKE1hdGguYWJzKGxhc3RZIC0gc2Vuc29yRXZlbnQuY2xpZW50WSkgPCB0aGlzLm9wdGlvbnMudGhyZXNob2xkWSkge1xyXG4gICAgICAgIHBhc3NlZFRocmVzaFkgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmxhc3RNaXJyb3JNb3ZlZENsaWVudC55ID0gc2Vuc29yRXZlbnQuY2xpZW50WTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFwYXNzZWRUaHJlc2hYICYmICFwYXNzZWRUaHJlc2hZKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWlycm9yTW92ZUV2ZW50ID0gbmV3IF9NaXJyb3JFdmVudC5NaXJyb3JNb3ZlRXZlbnQoe1xyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzb3VyY2VDb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBkcmFnRXZlbnQsXHJcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXHJcbiAgICAgIHBhc3NlZFRocmVzaFgsXHJcbiAgICAgIHBhc3NlZFRocmVzaFlcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yTW92ZUV2ZW50KTtcclxuICB9XHJcblxyXG4gIFtvbkRyYWdTdG9wXShkcmFnRXZlbnQpIHtcclxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpc1tvblNjcm9sbF0sIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgdGhpcy5zY3JvbGxPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICBpZiAoIXRoaXMubWlycm9yKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHNvdXJjZSwgc291cmNlQ29udGFpbmVyLCBzZW5zb3JFdmVudCB9ID0gZHJhZ0V2ZW50O1xyXG5cclxuICAgIGNvbnN0IG1pcnJvckRlc3Ryb3lFdmVudCA9IG5ldyBfTWlycm9yRXZlbnQuTWlycm9yRGVzdHJveUV2ZW50KHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxyXG4gICAgICBzb3VyY2VDb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBkcmFnRXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yRGVzdHJveUV2ZW50KTtcclxuXHJcbiAgICBpZiAoIW1pcnJvckRlc3Ryb3lFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHRoaXMubWlycm9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5taXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgW29uU2Nyb2xsXSgpIHtcclxuICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0ge1xyXG4gICAgICB4OiB3aW5kb3cuc2Nyb2xsWCAtIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldC54LFxyXG4gICAgICB5OiB3aW5kb3cuc2Nyb2xsWSAtIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldC55XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlycm9yIGNyZWF0ZWQgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7TWlycm9yQ3JlYXRlZEV2ZW50fSBtaXJyb3JFdmVudFxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25NaXJyb3JDcmVhdGVkXSh7IG1pcnJvciwgc291cmNlLCBzZW5zb3JFdmVudCB9KSB7XHJcbiAgICBjb25zdCBtaXJyb3JDbGFzc2VzID0gdGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0ZvcignbWlycm9yJyk7XHJcblxyXG4gICAgY29uc3Qgc2V0U3RhdGUgPSAoX3JlZikgPT4ge1xyXG4gICAgICBsZXQgeyBtaXJyb3JPZmZzZXQsIGluaXRpYWxYLCBpbml0aWFsWSB9ID0gX3JlZixcclxuICAgICAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydtaXJyb3JPZmZzZXQnLCAnaW5pdGlhbFgnLCAnaW5pdGlhbFknXSk7XHJcblxyXG4gICAgICB0aGlzLm1pcnJvck9mZnNldCA9IG1pcnJvck9mZnNldDtcclxuICAgICAgdGhpcy5pbml0aWFsWCA9IGluaXRpYWxYO1xyXG4gICAgICB0aGlzLmluaXRpYWxZID0gaW5pdGlhbFk7XHJcbiAgICAgIHRoaXMubGFzdE1vdmVkWCA9IGluaXRpYWxYO1xyXG4gICAgICB0aGlzLmxhc3RNb3ZlZFkgPSBpbml0aWFsWTtcclxuICAgICAgcmV0dXJuIF9leHRlbmRzKHsgbWlycm9yT2Zmc2V0LCBpbml0aWFsWCwgaW5pdGlhbFkgfSwgYXJncyk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1pcnJvci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcclxuICAgICAgbWlycm9yLFxyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBtaXJyb3JDbGFzc2VzLFxyXG4gICAgICBzY3JvbGxPZmZzZXQ6IHRoaXMuc2Nyb2xsT2Zmc2V0LFxyXG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXHJcbiAgICAgIHBhc3NlZFRocmVzaFg6IHRydWUsXHJcbiAgICAgIHBhc3NlZFRocmVzaFk6IHRydWVcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbml0aWFsU3RhdGUpXHJcbiAgICAvLyBGaXggcmVmbG93IGhlcmVcclxuICAgIC50aGVuKGNvbXB1dGVNaXJyb3JEaW1lbnNpb25zKS50aGVuKGNhbGN1bGF0ZU1pcnJvck9mZnNldCkudGhlbihyZXNldE1pcnJvcikudGhlbihhZGRNaXJyb3JDbGFzc2VzKS50aGVuKHBvc2l0aW9uTWlycm9yKHsgaW5pdGlhbDogdHJ1ZSB9KSkudGhlbihyZW1vdmVNaXJyb3JJRCkudGhlbihzZXRTdGF0ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNaXJyb3IgbW92ZSBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtNaXJyb3JNb3ZlRXZlbnR9IG1pcnJvckV2ZW50XHJcbiAgICogQHJldHVybiB7UHJvbWlzZXxudWxsfVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uTWlycm9yTW92ZV0obWlycm9yRXZlbnQpIHtcclxuICAgIGlmIChtaXJyb3JFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNldFN0YXRlID0gKF9yZWYyKSA9PiB7XHJcbiAgICAgIGxldCB7IGxhc3RNb3ZlZFgsIGxhc3RNb3ZlZFkgfSA9IF9yZWYyLFxyXG4gICAgICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydsYXN0TW92ZWRYJywgJ2xhc3RNb3ZlZFknXSk7XHJcblxyXG4gICAgICB0aGlzLmxhc3RNb3ZlZFggPSBsYXN0TW92ZWRYO1xyXG4gICAgICB0aGlzLmxhc3RNb3ZlZFkgPSBsYXN0TW92ZWRZO1xyXG5cclxuICAgICAgcmV0dXJuIF9leHRlbmRzKHsgbGFzdE1vdmVkWCwgbGFzdE1vdmVkWSB9LCBhcmdzKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xyXG4gICAgICBtaXJyb3I6IG1pcnJvckV2ZW50Lm1pcnJvcixcclxuICAgICAgc2Vuc29yRXZlbnQ6IG1pcnJvckV2ZW50LnNlbnNvckV2ZW50LFxyXG4gICAgICBtaXJyb3JPZmZzZXQ6IHRoaXMubWlycm9yT2Zmc2V0LFxyXG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXHJcbiAgICAgIGluaXRpYWxYOiB0aGlzLmluaXRpYWxYLFxyXG4gICAgICBpbml0aWFsWTogdGhpcy5pbml0aWFsWSxcclxuICAgICAgc2Nyb2xsT2Zmc2V0OiB0aGlzLnNjcm9sbE9mZnNldCxcclxuICAgICAgcGFzc2VkVGhyZXNoWDogbWlycm9yRXZlbnQucGFzc2VkVGhyZXNoWCxcclxuICAgICAgcGFzc2VkVGhyZXNoWTogbWlycm9yRXZlbnQucGFzc2VkVGhyZXNoWSxcclxuICAgICAgbGFzdE1vdmVkWDogdGhpcy5sYXN0TW92ZWRYLFxyXG4gICAgICBsYXN0TW92ZWRZOiB0aGlzLmxhc3RNb3ZlZFlcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbml0aWFsU3RhdGUpLnRoZW4ocG9zaXRpb25NaXJyb3IoeyByYWY6IHRydWUgfSkpLnRoZW4oc2V0U3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhcHBlbmRhYmxlIGNvbnRhaW5lciBmb3IgbWlycm9yIGJhc2VkIG9uIHRoZSBhcHBlbmRUbyBvcHRpb25cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5zb3VyY2UgLSBDdXJyZW50IHNvdXJjZVxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gICAqL1xyXG4gIFtnZXRBcHBlbmRhYmxlQ29udGFpbmVyXShzb3VyY2UpIHtcclxuICAgIGNvbnN0IGFwcGVuZFRvID0gdGhpcy5vcHRpb25zLmFwcGVuZFRvO1xyXG5cclxuICAgIGlmICh0eXBlb2YgYXBwZW5kVG8gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGFwcGVuZFRvKTtcclxuICAgIH0gZWxzZSBpZiAoYXBwZW5kVG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gYXBwZW5kVG87XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcHBlbmRUbyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gYXBwZW5kVG8oc291cmNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBzb3VyY2UucGFyZW50Tm9kZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1pcnJvcjsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29tcHV0ZXMgbWlycm9yIGRpbWVuc2lvbnMgYmFzZWQgb24gdGhlIHNvdXJjZSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQWRkcyBzb3VyY2VSZWN0IHRvIHN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUuc291cmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuZnVuY3Rpb24gY29tcHV0ZU1pcnJvckRpbWVuc2lvbnMoX3JlZjMpIHtcclxuICBsZXQgeyBzb3VyY2UgfSA9IF9yZWYzLFxyXG4gICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYzLCBbJ3NvdXJjZSddKTtcclxuXHJcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgY29uc3Qgc291cmNlUmVjdCA9IHNvdXJjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHJlc29sdmUoX2V4dGVuZHMoeyBzb3VyY2UsIHNvdXJjZVJlY3QgfSwgYXJncykpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBtaXJyb3Igb2Zmc2V0XHJcbiAqIEFkZHMgbWlycm9yT2Zmc2V0IHRvIHN0YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gKiBAcGFyYW0ge1NlbnNvckV2ZW50fSBzdGF0ZS5zZW5zb3JFdmVudFxyXG4gKiBAcGFyYW0ge0RPTVJlY3R9IHN0YXRlLnNvdXJjZVJlY3RcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZU1pcnJvck9mZnNldChfcmVmNCkge1xyXG4gIGxldCB7IHNlbnNvckV2ZW50LCBzb3VyY2VSZWN0LCBvcHRpb25zIH0gPSBfcmVmNCxcclxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNCwgWydzZW5zb3JFdmVudCcsICdzb3VyY2VSZWN0JywgJ29wdGlvbnMnXSk7XHJcblxyXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIGNvbnN0IHRvcCA9IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WSA9PT0gbnVsbCA/IHNlbnNvckV2ZW50LmNsaWVudFkgLSBzb3VyY2VSZWN0LnRvcCA6IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WTtcclxuICAgIGNvbnN0IGxlZnQgPSBvcHRpb25zLmN1cnNvck9mZnNldFggPT09IG51bGwgPyBzZW5zb3JFdmVudC5jbGllbnRYIC0gc291cmNlUmVjdC5sZWZ0IDogb3B0aW9ucy5jdXJzb3JPZmZzZXRYO1xyXG5cclxuICAgIGNvbnN0IG1pcnJvck9mZnNldCA9IHsgdG9wLCBsZWZ0IH07XHJcblxyXG4gICAgcmVzb2x2ZShfZXh0ZW5kcyh7IHNlbnNvckV2ZW50LCBzb3VyY2VSZWN0LCBtaXJyb3JPZmZzZXQsIG9wdGlvbnMgfSwgYXJncykpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQXBwbHlzIG1pcnJvciBzdHlsZXNcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLm1pcnJvclxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5zb3VyY2VcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlLm9wdGlvbnNcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc2V0TWlycm9yKF9yZWY1KSB7XHJcbiAgbGV0IHsgbWlycm9yLCBzb3VyY2UsIG9wdGlvbnMgfSA9IF9yZWY1LFxyXG4gICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY1LCBbJ21pcnJvcicsICdzb3VyY2UnLCAnb3B0aW9ucyddKTtcclxuXHJcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgbGV0IG9mZnNldEhlaWdodDtcclxuICAgIGxldCBvZmZzZXRXaWR0aDtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5jb25zdHJhaW5EaW1lbnNpb25zKSB7XHJcbiAgICAgIGNvbnN0IGNvbXB1dGVkU291cmNlU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShzb3VyY2UpO1xyXG4gICAgICBvZmZzZXRIZWlnaHQgPSBjb21wdXRlZFNvdXJjZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKTtcclxuICAgICAgb2Zmc2V0V2lkdGggPSBjb21wdXRlZFNvdXJjZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCd3aWR0aCcpO1xyXG4gICAgfVxyXG5cclxuICAgIG1pcnJvci5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcclxuICAgIG1pcnJvci5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XHJcbiAgICBtaXJyb3Iuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcclxuICAgIG1pcnJvci5zdHlsZS50b3AgPSAwO1xyXG4gICAgbWlycm9yLnN0eWxlLmxlZnQgPSAwO1xyXG4gICAgbWlycm9yLnN0eWxlLm1hcmdpbiA9IDA7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9ucykge1xyXG4gICAgICBtaXJyb3Iuc3R5bGUuaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0O1xyXG4gICAgICBtaXJyb3Iuc3R5bGUud2lkdGggPSBvZmZzZXRXaWR0aDtcclxuICAgIH1cclxuXHJcbiAgICByZXNvbHZlKF9leHRlbmRzKHsgbWlycm9yLCBzb3VyY2UsIG9wdGlvbnMgfSwgYXJncykpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQXBwbHlzIG1pcnJvciBjbGFzcyBvbiBtaXJyb3IgZWxlbWVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUubWlycm9yXHJcbiAqIEBwYXJhbSB7U3RyaW5nW119IHN0YXRlLm1pcnJvckNsYXNzZXNcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGFkZE1pcnJvckNsYXNzZXMoX3JlZjYpIHtcclxuICBsZXQgeyBtaXJyb3IsIG1pcnJvckNsYXNzZXMgfSA9IF9yZWY2LFxyXG4gICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY2LCBbJ21pcnJvcicsICdtaXJyb3JDbGFzc2VzJ10pO1xyXG5cclxuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBtaXJyb3IuY2xhc3NMaXN0LmFkZCguLi5taXJyb3JDbGFzc2VzKTtcclxuICAgIHJlc29sdmUoX2V4dGVuZHMoeyBtaXJyb3IsIG1pcnJvckNsYXNzZXMgfSwgYXJncykpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBzb3VyY2UgSUQgZnJvbSBjbG9uZWQgbWlycm9yIGVsZW1lbnRcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLm1pcnJvclxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlTWlycm9ySUQoX3JlZjcpIHtcclxuICBsZXQgeyBtaXJyb3IgfSA9IF9yZWY3LFxyXG4gICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY3LCBbJ21pcnJvciddKTtcclxuXHJcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgbWlycm9yLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcclxuICAgIGRlbGV0ZSBtaXJyb3IuaWQ7XHJcbiAgICByZXNvbHZlKF9leHRlbmRzKHsgbWlycm9yIH0sIGFyZ3MpKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBvc2l0aW9ucyBtaXJyb3Igd2l0aCB0cmFuc2xhdGUzZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUubWlycm9yXHJcbiAqIEBwYXJhbSB7U2Vuc29yRXZlbnR9IHN0YXRlLnNlbnNvckV2ZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZS5taXJyb3JPZmZzZXRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXRlLmluaXRpYWxZXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0ZS5pbml0aWFsWFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUub3B0aW9uc1xyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcG9zaXRpb25NaXJyb3IoeyB3aXRoRnJhbWUgPSBmYWxzZSwgaW5pdGlhbCA9IGZhbHNlIH0gPSB7fSkge1xyXG4gIHJldHVybiAoX3JlZjgpID0+IHtcclxuICAgIGxldCB7XHJcbiAgICAgIG1pcnJvcixcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIG1pcnJvck9mZnNldCxcclxuICAgICAgaW5pdGlhbFksXHJcbiAgICAgIGluaXRpYWxYLFxyXG4gICAgICBzY3JvbGxPZmZzZXQsXHJcbiAgICAgIG9wdGlvbnMsXHJcbiAgICAgIHBhc3NlZFRocmVzaFgsXHJcbiAgICAgIHBhc3NlZFRocmVzaFksXHJcbiAgICAgIGxhc3RNb3ZlZFgsXHJcbiAgICAgIGxhc3RNb3ZlZFlcclxuICAgIH0gPSBfcmVmOCxcclxuICAgICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY4LCBbJ21pcnJvcicsICdzZW5zb3JFdmVudCcsICdtaXJyb3JPZmZzZXQnLCAnaW5pdGlhbFknLCAnaW5pdGlhbFgnLCAnc2Nyb2xsT2Zmc2V0JywgJ29wdGlvbnMnLCAncGFzc2VkVGhyZXNoWCcsICdwYXNzZWRUaHJlc2hZJywgJ2xhc3RNb3ZlZFgnLCAnbGFzdE1vdmVkWSddKTtcclxuXHJcbiAgICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IF9leHRlbmRzKHtcclxuICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgICAgbWlycm9yT2Zmc2V0LFxyXG4gICAgICAgIG9wdGlvbnNcclxuICAgICAgfSwgYXJncyk7XHJcblxyXG4gICAgICBpZiAobWlycm9yT2Zmc2V0KSB7XHJcbiAgICAgICAgY29uc3QgeCA9IHBhc3NlZFRocmVzaFggPyBNYXRoLnJvdW5kKChzZW5zb3JFdmVudC5jbGllbnRYIC0gbWlycm9yT2Zmc2V0LmxlZnQgLSBzY3JvbGxPZmZzZXQueCkgLyAob3B0aW9ucy50aHJlc2hvbGRYIHx8IDEpKSAqIChvcHRpb25zLnRocmVzaG9sZFggfHwgMSkgOiBNYXRoLnJvdW5kKGxhc3RNb3ZlZFgpO1xyXG4gICAgICAgIGNvbnN0IHkgPSBwYXNzZWRUaHJlc2hZID8gTWF0aC5yb3VuZCgoc2Vuc29yRXZlbnQuY2xpZW50WSAtIG1pcnJvck9mZnNldC50b3AgLSBzY3JvbGxPZmZzZXQueSkgLyAob3B0aW9ucy50aHJlc2hvbGRZIHx8IDEpKSAqIChvcHRpb25zLnRocmVzaG9sZFkgfHwgMSkgOiBNYXRoLnJvdW5kKGxhc3RNb3ZlZFkpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy54QXhpcyAmJiBvcHRpb25zLnlBeGlzIHx8IGluaXRpYWwpIHtcclxuICAgICAgICAgIG1pcnJvci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt4fXB4LCAke3l9cHgsIDApYDtcclxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMueEF4aXMgJiYgIW9wdGlvbnMueUF4aXMpIHtcclxuICAgICAgICAgIG1pcnJvci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt4fXB4LCAke2luaXRpYWxZfXB4LCAwKWA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnlBeGlzICYmICFvcHRpb25zLnhBeGlzKSB7XHJcbiAgICAgICAgICBtaXJyb3Iuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7aW5pdGlhbFh9cHgsICR7eX1weCwgMClgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGluaXRpYWwpIHtcclxuICAgICAgICAgIHJlc3VsdC5pbml0aWFsWCA9IHg7XHJcbiAgICAgICAgICByZXN1bHQuaW5pdGlhbFkgPSB5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0Lmxhc3RNb3ZlZFggPSB4O1xyXG4gICAgICAgIHJlc3VsdC5sYXN0TW92ZWRZID0geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgfSwgeyBmcmFtZTogd2l0aEZyYW1lIH0pO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXcmFwcyBmdW5jdGlvbnMgaW4gcHJvbWlzZSB3aXRoIHBvdGVudGlhbCBhbmltYXRpb24gZnJhbWUgb3B0aW9uXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yYWZcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhQcm9taXNlKGNhbGxiYWNrLCB7IHJhZiA9IGZhbHNlIH0gPSB7fSkge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBpZiAocmFmKSB7XHJcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgY2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjYWxsYmFjayhyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzZW5zb3IgZXZlbnQgd2FzIHRyaWdnZXJlZCBieSBhIG5hdGl2ZSBicm93c2VyIGRyYWcgZXZlbnRcclxuICogQHBhcmFtIHtTZW5zb3JFdmVudH0gc2Vuc29yRXZlbnRcclxuICovXHJcbmZ1bmN0aW9uIGlzTmF0aXZlRHJhZ0V2ZW50KHNlbnNvckV2ZW50KSB7XHJcbiAgcmV0dXJuICgvXmRyYWcvLnRlc3Qoc2Vuc29yRXZlbnQub3JpZ2luYWxFdmVudC50eXBlKVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfTWlycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XHJcblxyXG52YXIgX01pcnJvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NaXJyb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9NaXJyb3IyLmRlZmF1bHQ7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfTWlycm9yLmRlZmF1bHRPcHRpb25zO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Jbml0aWFsaXplID0gU3ltYm9sKCdvbkluaXRpYWxpemUnKTtcclxuY29uc3Qgb25EZXN0cm95ID0gU3ltYm9sKCdvbkRlc3Ryb3knKTtcclxuXHJcbi8qKlxyXG4gKiBGb2N1c2FibGUgZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBGb2N1c2FibGUgcGx1Z2luXHJcbiAqIEBjbGFzcyBGb2N1c2FibGVcclxuICogQG1vZHVsZSBGb2N1c2FibGVcclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIEZvY3VzYWJsZSBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogRm9jdXNhYmxlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIEZvY3VzYWJsZVxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb2N1c2FibGUgb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIHRoaXNbb25Jbml0aWFsaXplXSA9IHRoaXNbb25Jbml0aWFsaXplXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRlc3Ryb3ldID0gdGhpc1tvbkRlc3Ryb3ldLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBsaXN0ZW5lcnMgdG8gZHJhZ2dhYmxlXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWdnYWJsZTppbml0aWFsaXplJywgdGhpc1tvbkluaXRpYWxpemVdKS5vbignZHJhZ2dhYmxlOmRlc3Ryb3knLCB0aGlzW29uRGVzdHJveV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgbGlzdGVuZXJzIGZyb20gZHJhZ2dhYmxlXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnZ2FibGU6aW5pdGlhbGl6ZScsIHRoaXNbb25Jbml0aWFsaXplXSkub2ZmKCdkcmFnZ2FibGU6ZGVzdHJveScsIHRoaXNbb25EZXN0cm95XSk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIG1vZGlmaWVkIGVsZW1lbnRzIHdoZW4gZGV0YWNoXHJcbiAgICB0aGlzW29uRGVzdHJveV0oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgb3B0aW9ucyBwYXNzZWQgdGhyb3VnaCBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXHJcbiAgZ2V0T3B0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLmZvY3VzYWJsZSB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgZHJhZ2dhYmxlIGNvbnRhaW5lcnMgYW5kIGVsZW1lbnRzXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnRbXX1cclxuICAgKi9cclxuICBnZXRFbGVtZW50cygpIHtcclxuICAgIHJldHVybiBbLi4udGhpcy5kcmFnZ2FibGUuY29udGFpbmVycywgLi4udGhpcy5kcmFnZ2FibGUuZ2V0RHJhZ2dhYmxlRWxlbWVudHMoKV07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnRpYWxpemUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uSW5pdGlhbGl6ZV0oKSB7XHJcbiAgICAvLyBDYW4gd2FpdCB1bnRpbCB0aGUgbmV4dCBiZXN0IGZyYW1lIGlzIGF2YWlsYWJsZVxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgdGhpcy5nZXRFbGVtZW50cygpLmZvckVhY2goZWxlbWVudCA9PiBkZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkRlc3Ryb3ldKCkge1xyXG4gICAgLy8gQ2FuIHdhaXQgdW50aWwgdGhlIG5leHQgYmVzdCBmcmFtZSBpcyBhdmFpbGFibGVcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMuZ2V0RWxlbWVudHMoKS5mb3JFYWNoKGVsZW1lbnQgPT4gc3RyaXBFbGVtZW50KGVsZW1lbnQpKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gRm9jdXNhYmxlOyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIG1pc3NpbmcgdGFiaW5kZXggYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHNvIHRoZXkgY2FuIGJlIHJlc2V0IHdoZW4gZHJhZ2dhYmxlIGdldHMgZGVzdHJveWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0IHtIVE1MRWxlbWVudFtdfSBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmNvbnN0IGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleCA9IFtdO1xyXG5cclxuLyoqXHJcbiAqIERlY29yYXRlcyBlbGVtZW50IHdpdGggdGFiaW5kZXggYXR0cmlidXRlc1xyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGRlY29yYXRlRWxlbWVudChlbGVtZW50KSB7XHJcbiAgY29uc3QgaGFzTWlzc2luZ1RhYkluZGV4ID0gQm9vbGVhbighZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgJiYgZWxlbWVudC50YWJJbmRleCA9PT0gLTEpO1xyXG5cclxuICBpZiAoaGFzTWlzc2luZ1RhYkluZGV4KSB7XHJcbiAgICBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXgucHVzaChlbGVtZW50KTtcclxuICAgIGVsZW1lbnQudGFiSW5kZXggPSAwO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgZWxlbWVudHMgdGFiaW5kZXggYXR0cmlidXRlc1xyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpcEVsZW1lbnQoZWxlbWVudCkge1xyXG4gIGNvbnN0IHRhYkluZGV4RWxlbWVudFBvc2l0aW9uID0gZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4LmluZGV4T2YoZWxlbWVudCk7XHJcblxyXG4gIGlmICh0YWJJbmRleEVsZW1lbnRQb3NpdGlvbiAhPT0gLTEpIHtcclxuICAgIGVsZW1lbnQudGFiSW5kZXggPSAtMTtcclxuICAgIGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleC5zcGxpY2UodGFiSW5kZXhFbGVtZW50UG9zaXRpb24sIDEpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Gb2N1c2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcclxuXHJcbnZhciBfRm9jdXNhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZvY3VzYWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0ZvY3VzYWJsZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuLyoqXHJcbiAqIEFsbCBkcmFnZ2FibGUgcGx1Z2lucyBpbmhlcml0IGZyb20gdGhpcyBjbGFzcy5cclxuICogQGFic3RyYWN0XHJcbiAqIEBjbGFzcyBBYnN0cmFjdFBsdWdpblxyXG4gKiBAbW9kdWxlIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBBYnN0cmFjdFBsdWdpbiB7XHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3RQbHVnaW4gY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgQWJzdHJhY3RQbHVnaW5cclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAgICogQHByb3BlcnR5IGRyYWdnYWJsZVxyXG4gICAgICogQHR5cGUge0RyYWdnYWJsZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPdmVycmlkZSB0byBhZGQgbGlzdGVuZXJzXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRlIHRvIHJlbW92ZSBsaXN0ZW5lcnNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdFBsdWdpbjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uSW5pdGlhbGl6ZSA9IFN5bWJvbCgnb25Jbml0aWFsaXplJyk7XHJcbmNvbnN0IG9uRGVzdHJveSA9IFN5bWJvbCgnb25EZXN0cm95Jyk7XHJcbmNvbnN0IGFubm91bmNlRXZlbnQgPSBTeW1ib2woJ2Fubm91bmNlRXZlbnQnKTtcclxuY29uc3QgYW5ub3VuY2VNZXNzYWdlID0gU3ltYm9sKCdhbm5vdW5jZU1lc3NhZ2UnKTtcclxuXHJcbmNvbnN0IEFSSUFfUkVMRVZBTlQgPSAnYXJpYS1yZWxldmFudCc7XHJcbmNvbnN0IEFSSUFfQVRPTUlDID0gJ2FyaWEtYXRvbWljJztcclxuY29uc3QgQVJJQV9MSVZFID0gJ2FyaWEtbGl2ZSc7XHJcbmNvbnN0IFJPTEUgPSAncm9sZSc7XHJcblxyXG4vKipcclxuICogQW5ub3VuY2VtZW50IGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLmV4cGlyZVxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xyXG4gIGV4cGlyZTogNzAwMFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFubm91bmNlbWVudCBwbHVnaW5cclxuICogQGNsYXNzIEFubm91bmNlbWVudFxyXG4gKiBAbW9kdWxlIEFubm91bmNlbWVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgQW5ub3VuY2VtZW50IGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBBbm5vdW5jZW1lbnQgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgQW5ub3VuY2VtZW50XHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBsdWdpbiBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcmlnaW5hbCBkcmFnZ2FibGUgdHJpZ2dlciBtZXRob2QuIEhhY2sgdW50aWwgd2UgaGF2ZSBvbkFsbCBvciBvbignYWxsJylcclxuICAgICAqIEBwcm9wZXJ0eSBvcmlnaW5hbFRyaWdnZXJNZXRob2RcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcmlnaW5hbFRyaWdnZXJNZXRob2QgPSB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyO1xyXG5cclxuICAgIHRoaXNbb25Jbml0aWFsaXplXSA9IHRoaXNbb25Jbml0aWFsaXplXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRlc3Ryb3ldID0gdGhpc1tvbkRlc3Ryb3ldLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBsaXN0ZW5lcnMgdG8gZHJhZ2dhYmxlXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWdnYWJsZTppbml0aWFsaXplJywgdGhpc1tvbkluaXRpYWxpemVdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIGxpc3RlbmVycyBmcm9tIGRyYWdnYWJsZVxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZ2dhYmxlOmRlc3Ryb3knLCB0aGlzW29uRGVzdHJveV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBwYXNzZWQgaW4gb3B0aW9uc1xyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5hbm5vdW5jZW1lbnRzIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW5ub3VuY2VzIGV2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0Fic3RyYWN0RXZlbnR9IGV2ZW50XHJcbiAgICovXHJcbiAgW2Fubm91bmNlRXZlbnRdKGV2ZW50KSB7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5vcHRpb25zW2V2ZW50LnR5cGVdO1xyXG5cclxuICAgIGlmIChtZXNzYWdlICYmIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xyXG4gICAgICB0aGlzW2Fubm91bmNlTWVzc2FnZV0obWVzc2FnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpc1thbm5vdW5jZU1lc3NhZ2VdKG1lc3NhZ2UoZXZlbnQpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFubm91bmNlcyBtZXNzYWdlIHRvIHNjcmVlbiByZWFkZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXHJcbiAgICovXHJcbiAgW2Fubm91bmNlTWVzc2FnZV0obWVzc2FnZSkge1xyXG4gICAgYW5ub3VuY2UobWVzc2FnZSwgeyBleHBpcmU6IHRoaXMub3B0aW9ucy5leHBpcmUgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplIGhhbmRlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uSW5pdGlhbGl6ZV0oKSB7XHJcbiAgICAvLyBIYWNrIHVudGlsIHRoZXJlIGlzIGFuIGFwaSBmb3IgbGlzdGVuaW5nIGZvciBhbGwgZXZlbnRzXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyID0gZXZlbnQgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRoaXNbYW5ub3VuY2VFdmVudF0oZXZlbnQpO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IG9yaWdpbmFsIHRyaWdnZXIgaXMgY2FsbGVkXHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbFRyaWdnZXJNZXRob2QuY2FsbCh0aGlzLmRyYWdnYWJsZSwgZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzdHJveSBoYW5kZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkRlc3Ryb3ldKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlciA9IHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gQW5ub3VuY2VtZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3Qge0hUTUxFbGVtZW50fSBsaXZlUmVnaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5jb25zdCBsaXZlUmVnaW9uID0gY3JlYXRlUmVnaW9uKCk7XHJcblxyXG4vKipcclxuICogQW5ub3VuY2VzIG1lc3NhZ2UgdmlhIGxpdmUgcmVnaW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmV4cGlyZVxyXG4gKi9cclxuZnVuY3Rpb24gYW5ub3VuY2UobWVzc2FnZSwgeyBleHBpcmUgfSkge1xyXG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcbiAgZWxlbWVudC50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XHJcbiAgbGl2ZVJlZ2lvbi5hcHBlbmRDaGlsZChlbGVtZW50KTtcclxuXHJcbiAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgbGl2ZVJlZ2lvbi5yZW1vdmVDaGlsZChlbGVtZW50KTtcclxuICB9LCBleHBpcmUpO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyByZWdpb24gZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlZ2lvbigpIHtcclxuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsICdkcmFnZ2FibGUtbGl2ZS1yZWdpb24nKTtcclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZShBUklBX1JFTEVWQU5ULCAnYWRkaXRpb25zJyk7XHJcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoQVJJQV9BVE9NSUMsICd0cnVlJyk7XHJcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoQVJJQV9MSVZFLCAnYXNzZXJ0aXZlJyk7XHJcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoUk9MRSwgJ2xvZycpO1xyXG5cclxuICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcclxuICBlbGVtZW50LnN0eWxlLndpZHRoID0gJzFweCc7XHJcbiAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMXB4JztcclxuICBlbGVtZW50LnN0eWxlLnRvcCA9ICctMXB4JztcclxuICBlbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcblxyXG4gIHJldHVybiBlbGVtZW50O1xyXG59XHJcblxyXG4vLyBBcHBlbmQgbGl2ZSByZWdpb24gZWxlbWVudCBhcyBlYXJseSBhcyBwb3NzaWJsZVxyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xyXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGl2ZVJlZ2lvbik7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9Bbm5vdW5jZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcclxuXHJcbnZhciBfQW5ub3VuY2VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fubm91bmNlbWVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0Fubm91bmNlbWVudDIuZGVmYXVsdDtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IF9Bbm5vdW5jZW1lbnQuZGVmYXVsdE9wdGlvbnM7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuRHJhZ2dhYmxlRGVzdHJveUV2ZW50ID0gZXhwb3J0cy5EcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50ID0gZXhwb3J0cy5EcmFnZ2FibGVFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgZHJhZ2dhYmxlIGV2ZW50XHJcbiAqIEBjbGFzcyBEcmFnZ2FibGVFdmVudFxyXG4gKiBAbW9kdWxlIERyYWdnYWJsZUV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIERyYWdnYWJsZUV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKiBAcHJvcGVydHkgZHJhZ2dhYmxlXHJcbiAgICogQHR5cGUge0RyYWdnYWJsZX1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ2dhYmxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnZ2FibGU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdnYWJsZUV2ZW50ID0gRHJhZ2dhYmxlRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWdnYWJsZSBpbml0aWFsaXplZCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ2dhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdnYWJsZUV2ZW50LnR5cGUgPSAnZHJhZ2dhYmxlJztcclxuY2xhc3MgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCBleHRlbmRzIERyYWdnYWJsZUV2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQgPSBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZ2dhYmxlIGRlc3RvcnkgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnZ2FibGVEZXN0cm95RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ2dhYmxlRGVzdHJveUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudC50eXBlID0gJ2RyYWdnYWJsZTppbml0aWFsaXplJztcclxuY2xhc3MgRHJhZ2dhYmxlRGVzdHJveUV2ZW50IGV4dGVuZHMgRHJhZ2dhYmxlRXZlbnQge31cclxuZXhwb3J0cy5EcmFnZ2FibGVEZXN0cm95RXZlbnQgPSBEcmFnZ2FibGVEZXN0cm95RXZlbnQ7XHJcbkRyYWdnYWJsZURlc3Ryb3lFdmVudC50eXBlID0gJ2RyYWdnYWJsZTpkZXN0cm95JztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG5jb25zdCBjYW5jZWxlZCA9IFN5bWJvbCgnY2FuY2VsZWQnKTtcclxuXHJcbi8qKlxyXG4gKiBBbGwgZXZlbnRzIGZpcmVkIGJ5IGRyYWdnYWJsZSBpbmhlcml0IHRoaXMgY2xhc3MuIFlvdSBjYW4gY2FsbCBgY2FuY2VsKClgIHRvXHJcbiAqIGNhbmNlbCBhIHNwZWNpZmljIGV2ZW50IG9yIHlvdSBjYW4gY2hlY2sgaWYgYW4gZXZlbnQgaGFzIGJlZW4gY2FuY2VsZWQgYnlcclxuICogY2FsbGluZyBgY2FuY2VsZWQoKWAuXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAY2xhc3MgQWJzdHJhY3RFdmVudFxyXG4gKiBAbW9kdWxlIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIEFic3RyYWN0RXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBBYnN0cmFjdEV2ZW50IGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIEFic3RyYWN0RXZlbnRcclxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIEV2ZW50IGRhdGFcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogRXZlbnQgdHlwZVxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcHJvcGVydHkgdHlwZVxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZGF0YSkge1xyXG4gICAgdGhpc1tjYW5jZWxlZF0gPSBmYWxzZTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFkLW9ubHkgdHlwZVxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW50IGNhbmNlbGFibGVcclxuICAgKiBAc3RhdGljXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgdHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnR5cGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFkLW9ubHkgY2FuY2VsYWJsZVxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IGNhbmNlbGFibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jYW5jZWxhYmxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FuY2VscyB0aGUgZXZlbnQgaW5zdGFuY2VcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuICBjYW5jZWwoKSB7XHJcbiAgICB0aGlzW2NhbmNlbGVkXSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBldmVudCBoYXMgYmVlbiBjYW5jZWxlZFxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgY2FuY2VsZWQoKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzW2NhbmNlbGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG5ldyBldmVudCBpbnN0YW5jZSB3aXRoIGV4aXN0aW5nIGV2ZW50IGRhdGEuXHJcbiAgICogVGhpcyBtZXRob2QgYWxsb3dzIGZvciBvdmVycmlkaW5nIG9mIGV2ZW50IGRhdGEuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdEV2ZW50fVxyXG4gICAqL1xyXG4gIGNsb25lKGRhdGEpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihfZXh0ZW5kcyh7fSwgdGhpcy5kYXRhLCBkYXRhKSk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0RXZlbnQ7XHJcbkFic3RyYWN0RXZlbnQudHlwZSA9ICdldmVudCc7XHJcbkFic3RyYWN0RXZlbnQuY2FuY2VsYWJsZSA9IGZhbHNlO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkRyYWdTdG9wcGVkRXZlbnQgPSBleHBvcnRzLkRyYWdTdG9wRXZlbnQgPSBleHBvcnRzLkRyYWdQcmVzc3VyZUV2ZW50ID0gZXhwb3J0cy5EcmFnT3V0Q29udGFpbmVyRXZlbnQgPSBleHBvcnRzLkRyYWdPdmVyQ29udGFpbmVyRXZlbnQgPSBleHBvcnRzLkRyYWdPdXRFdmVudCA9IGV4cG9ydHMuRHJhZ092ZXJFdmVudCA9IGV4cG9ydHMuRHJhZ01vdmVFdmVudCA9IGV4cG9ydHMuRHJhZ1N0YXJ0RXZlbnQgPSBleHBvcnRzLkRyYWdFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgZHJhZyBldmVudFxyXG4gKiBAY2xhc3MgRHJhZ0V2ZW50XHJcbiAqIEBtb2R1bGUgRHJhZ0V2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIERyYWdFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBzb3VyY2UgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBzb3VyY2VcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNvdXJjZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBvcmlnaW5hbCBzb3VyY2UgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbFNvdXJjZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3JpZ2luYWxTb3VyY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9yaWdpbmFsU291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBtaXJyb3IgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG1pcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBzb3VyY2UgY29udGFpbmVyIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgc291cmNlQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzb3VyY2VDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZUNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbnNvciBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBzZW5zb3JFdmVudFxyXG4gICAqIEB0eXBlIHtTZW5zb3JFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc2Vuc29yRXZlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNlbnNvckV2ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgc2Vuc29yIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IG9yaWdpbmFsRXZlbnRcclxuICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9yaWdpbmFsRXZlbnQoKSB7XHJcbiAgICBpZiAodGhpcy5zZW5zb3JFdmVudCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnRXZlbnQgPSBEcmFnRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdGFydCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdTdGFydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdTdGFydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ0V2ZW50LnR5cGUgPSAnZHJhZyc7XHJcbmNsYXNzIERyYWdTdGFydEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdTdGFydEV2ZW50ID0gRHJhZ1N0YXJ0RXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgbW92ZSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnTW92ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnTW92ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnU3RhcnRFdmVudC50eXBlID0gJ2RyYWc6c3RhcnQnO1xyXG5EcmFnU3RhcnRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgRHJhZ01vdmVFdmVudCBleHRlbmRzIERyYWdFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5EcmFnTW92ZUV2ZW50ID0gRHJhZ01vdmVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgb3ZlciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ092ZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdPdmVyRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ01vdmVFdmVudC50eXBlID0gJ2RyYWc6bW92ZSc7XHJcbmNsYXNzIERyYWdPdmVyRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIHlvdSBhcmUgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGVsZW1lbnQgeW91IGFyZSBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXI7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdPdmVyRXZlbnQgPSBEcmFnT3ZlckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBvdXQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdPdXRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdPdXRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnT3ZlckV2ZW50LnR5cGUgPSAnZHJhZzpvdmVyJztcclxuRHJhZ092ZXJFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgRHJhZ091dEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciB5b3UgYXJlIG92ZXJcclxuICAgKiBAcHJvcGVydHkgb3ZlckNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBlbGVtZW50IHlvdSBsZWZ0XHJcbiAgICogQHByb3BlcnR5IG92ZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXI7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdPdXRFdmVudCA9IERyYWdPdXRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG92ZXIgY29udGFpbmVyIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ092ZXJDb250YWluZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnT3ZlckNvbnRhaW5lckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ091dEV2ZW50LnR5cGUgPSAnZHJhZzpvdXQnO1xyXG5jbGFzcyBEcmFnT3ZlckNvbnRhaW5lckV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciB5b3UgYXJlIG92ZXJcclxuICAgKiBAcHJvcGVydHkgb3ZlckNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ092ZXJDb250YWluZXJFdmVudCA9IERyYWdPdmVyQ29udGFpbmVyRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG91dCBjb250YWluZXIgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdPdXRDb250YWluZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdPdXRDb250YWluZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnT3ZlckNvbnRhaW5lckV2ZW50LnR5cGUgPSAnZHJhZzpvdmVyOmNvbnRhaW5lcic7XHJcbmNsYXNzIERyYWdPdXRDb250YWluZXJFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBjb250YWluZXIgeW91IGxlZnRcclxuICAgKiBAcHJvcGVydHkgb3ZlckNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ091dENvbnRhaW5lckV2ZW50ID0gRHJhZ091dENvbnRhaW5lckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgcHJlc3N1cmUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnUHJlc3N1cmVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnUHJlc3N1cmVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdPdXRDb250YWluZXJFdmVudC50eXBlID0gJ2RyYWc6b3V0OmNvbnRhaW5lcic7XHJcbmNsYXNzIERyYWdQcmVzc3VyZUV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogUHJlc3N1cmUgYXBwbGllZCBvbiBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBwcmVzc3VyZVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHByZXNzdXJlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wcmVzc3VyZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ1ByZXNzdXJlRXZlbnQgPSBEcmFnUHJlc3N1cmVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdG9wIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdQcmVzc3VyZUV2ZW50LnR5cGUgPSAnZHJhZzpwcmVzc3VyZSc7XHJcbmNsYXNzIERyYWdTdG9wRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ1N0b3BFdmVudCA9IERyYWdTdG9wRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHN0b3BwZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdTdG9wcGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnU3RvcHBlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdTdG9wRXZlbnQudHlwZSA9ICdkcmFnOnN0b3AnO1xyXG5jbGFzcyBEcmFnU3RvcHBlZEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XHJcbmV4cG9ydHMuRHJhZ1N0b3BwZWRFdmVudCA9IERyYWdTdG9wcGVkRXZlbnQ7XHJcbkRyYWdTdG9wcGVkRXZlbnQudHlwZSA9ICdkcmFnOnN0b3BwZWQnO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9EcmFnRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cclxuT2JqZWN0LmtleXMoX0RyYWdFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9EcmFnRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX0RyYWdnYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuXHJcbk9iamVjdC5rZXlzKF9EcmFnZ2FibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9EcmFnZ2FibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbnZhciBfUGx1Z2lucyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG5PYmplY3Qua2V5cyhfUGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9QbHVnaW5zW2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcbk9iamVjdC5rZXlzKF9TZW5zb3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1NlbnNvcnNba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX0RyYWdnYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5cclxudmFyIF9EcmFnZ2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ2dhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfRHJhZ2dhYmxlMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSlcclxuLyoqKioqKi8gXSk7XHJcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@shopify/draggable/lib/draggable.js\n");

/***/ }),

/***/ "./node_modules/@shopify/draggable/lib/droppable.js":
/*!**********************************************************!*\
  !*** ./node_modules/@shopify/draggable/lib/droppable.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(true)\r\n\t\tmodule.exports = factory();\r\n\telse {}\r\n})(window, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __nested_webpack_require_571__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId]) {\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_571__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__nested_webpack_require_571__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__nested_webpack_require_571__.c = installedModules;\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__nested_webpack_require_571__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__nested_webpack_require_571__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// define __esModule on exports\r\n/******/ \t__nested_webpack_require_571__.r = function(exports) {\r\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\r\n/******/ \t\t}\r\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\r\n/******/ \t};\r\n/******/\r\n/******/ \t// create a fake namespace object\r\n/******/ \t// mode & 1: value is a module id, require it\r\n/******/ \t// mode & 2: merge all properties of value into the ns\r\n/******/ \t// mode & 4: return value when already ns object\r\n/******/ \t// mode & 8|1: behave like require\r\n/******/ \t__nested_webpack_require_571__.t = function(value, mode) {\r\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_571__(value);\r\n/******/ \t\tif(mode & 8) return value;\r\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\r\n/******/ \t\tvar ns = Object.create(null);\r\n/******/ \t\t__nested_webpack_require_571__.r(ns);\r\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\r\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_571__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\r\n/******/ \t\treturn ns;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__nested_webpack_require_571__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__nested_webpack_require_571__.d(getter, 'a', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__nested_webpack_require_571__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__nested_webpack_require_571__.p = \"\";\r\n/******/\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __nested_webpack_require_571__(__nested_webpack_require_571__.s = 48);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __nested_webpack_require_4119__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_4119__(44);\r\n\r\nObject.defineProperty(exports, 'closest', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_closest).default;\r\n  }\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_4119__(42);\r\n\r\nObject.defineProperty(exports, 'requestNextAnimationFrame', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_requestNextAnimationFrame).default;\r\n  }\r\n});\r\n\r\nvar _distance = __nested_webpack_require_4119__(40);\r\n\r\nObject.defineProperty(exports, 'distance', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_distance).default;\r\n  }\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_4119__(38);\r\n\r\nObject.defineProperty(exports, 'touchCoords', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_touchCoords).default;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports, __nested_webpack_require_5243__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SensorEvent = __nested_webpack_require_5243__(19);\r\n\r\nObject.keys(_SensorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SensorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports, __nested_webpack_require_5710__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_5710__(22);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Sensor2.default;\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports, __nested_webpack_require_6109__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractEvent = __nested_webpack_require_6109__(46);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractEvent2.default;\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports, __nested_webpack_require_6536__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_6536__(31);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractPlugin2.default;\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports, __nested_webpack_require_6967__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_6967__(2);\r\n\r\nObject.defineProperty(exports, 'Sensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Sensor).default;\r\n  }\r\n});\r\n\r\nvar _MouseSensor = __nested_webpack_require_6967__(21);\r\n\r\nObject.defineProperty(exports, 'MouseSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_MouseSensor).default;\r\n  }\r\n});\r\n\r\nvar _TouchSensor = __nested_webpack_require_6967__(18);\r\n\r\nObject.defineProperty(exports, 'TouchSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_TouchSensor).default;\r\n  }\r\n});\r\n\r\nvar _DragSensor = __nested_webpack_require_6967__(16);\r\n\r\nObject.defineProperty(exports, 'DragSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_DragSensor).default;\r\n  }\r\n});\r\n\r\nvar _ForceTouchSensor = __nested_webpack_require_6967__(14);\r\n\r\nObject.defineProperty(exports, 'ForceTouchSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_ForceTouchSensor).default;\r\n  }\r\n});\r\n\r\nvar _SensorEvent = __nested_webpack_require_6967__(1);\r\n\r\nObject.keys(_SensorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SensorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports, __nested_webpack_require_8573__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Announcement = __nested_webpack_require_8573__(33);\r\n\r\nObject.defineProperty(exports, 'Announcement', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Announcement).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultAnnouncementOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Announcement.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Focusable = __nested_webpack_require_8573__(30);\r\n\r\nObject.defineProperty(exports, 'Focusable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Focusable).default;\r\n  }\r\n});\r\n\r\nvar _Mirror = __nested_webpack_require_8573__(28);\r\n\r\nObject.defineProperty(exports, 'Mirror', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Mirror).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultMirrorOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Mirror.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Scrollable = __nested_webpack_require_8573__(24);\r\n\r\nObject.defineProperty(exports, 'Scrollable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Scrollable).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultScrollableOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Scrollable.defaultOptions;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports, __nested_webpack_require_10116__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DraggableEvent = __nested_webpack_require_10116__(34);\r\n\r\nObject.keys(_DraggableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DraggableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ (function(module, exports, __nested_webpack_require_10592__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragEvent = __nested_webpack_require_10592__(35);\r\n\r\nObject.keys(_DragEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DragEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ (function(module, exports, __nested_webpack_require_11053__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DroppableEvent = __nested_webpack_require_11053__(47);\r\n\r\nObject.keys(_DroppableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DroppableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * The Emitter is a simple emitter class that provides you with `on()`, `off()` and `trigger()` methods\r\n * @class Emitter\r\n * @module Emitter\r\n */\r\nclass Emitter {\r\n  constructor() {\r\n    this.callbacks = {};\r\n  }\r\n\r\n  /**\r\n   * Registers callbacks by event name\r\n   * @param {String} type\r\n   * @param {...Function} callbacks\r\n   */\r\n  on(type, ...callbacks) {\r\n    if (!this.callbacks[type]) {\r\n      this.callbacks[type] = [];\r\n    }\r\n\r\n    this.callbacks[type].push(...callbacks);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Unregisters callbacks by event name\r\n   * @param {String} type\r\n   * @param {Function} callback\r\n   */\r\n  off(type, callback) {\r\n    if (!this.callbacks[type]) {\r\n      return null;\r\n    }\r\n\r\n    const copy = this.callbacks[type].slice(0);\r\n\r\n    for (let i = 0; i < copy.length; i++) {\r\n      if (callback === copy[i]) {\r\n        this.callbacks[type].splice(i, 1);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Triggers event callbacks by event object\r\n   * @param {AbstractEvent} event\r\n   */\r\n  trigger(event) {\r\n    if (!this.callbacks[event.type]) {\r\n      return null;\r\n    }\r\n\r\n    const callbacks = [...this.callbacks[event.type]];\r\n    const caughtErrors = [];\r\n\r\n    for (let i = callbacks.length - 1; i >= 0; i--) {\r\n      const callback = callbacks[i];\r\n\r\n      try {\r\n        callback(event);\r\n      } catch (error) {\r\n        caughtErrors.push(error);\r\n      }\r\n    }\r\n\r\n    if (caughtErrors.length) {\r\n      /* eslint-disable no-console */\r\n      console.error(`Draggable caught errors while triggering '${event.type}'`, caughtErrors);\r\n      /* eslint-disable no-console */\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\nexports.default = Emitter;\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ (function(module, exports, __nested_webpack_require_13394__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Emitter = __nested_webpack_require_13394__(10);\r\n\r\nvar _Emitter2 = _interopRequireDefault(_Emitter);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Emitter2.default;\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ (function(module, exports, __nested_webpack_require_13798__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _utils = __nested_webpack_require_13798__(0);\r\n\r\nvar _Plugins = __nested_webpack_require_13798__(6);\r\n\r\nvar _Emitter = __nested_webpack_require_13798__(11);\r\n\r\nvar _Emitter2 = _interopRequireDefault(_Emitter);\r\n\r\nvar _Sensors = __nested_webpack_require_13798__(5);\r\n\r\nvar _DraggableEvent = __nested_webpack_require_13798__(7);\r\n\r\nvar _DragEvent = __nested_webpack_require_13798__(8);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragMove = Symbol('onDragMove');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst onDragPressure = Symbol('onDragPressure');\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['drag:start']\r\n * @const {Function} defaultAnnouncements['drag:stop']\r\n */\r\nconst defaultAnnouncements = {\r\n  'drag:start': event => `Picked up ${event.source.textContent.trim() || event.source.id || 'draggable element'}`,\r\n  'drag:stop': event => `Released ${event.source.textContent.trim() || event.source.id || 'draggable element'}`\r\n};\r\n\r\nconst defaultClasses = {\r\n  'container:dragging': 'draggable-container--is-dragging',\r\n  'source:dragging': 'draggable-source--is-dragging',\r\n  'source:placed': 'draggable-source--placed',\r\n  'container:placed': 'draggable-container--placed',\r\n  'body:dragging': 'draggable--is-dragging',\r\n  'draggable:over': 'draggable--over',\r\n  'container:over': 'draggable-container--over',\r\n  'source:original': 'draggable--original',\r\n  mirror: 'draggable-mirror'\r\n};\r\n\r\nconst defaultOptions = exports.defaultOptions = {\r\n  draggable: '.draggable-source',\r\n  handle: null,\r\n  delay: {},\r\n  distance: 0,\r\n  placedTimeout: 800,\r\n  plugins: [],\r\n  sensors: [],\r\n  exclude: {\r\n    plugins: [],\r\n    sensors: []\r\n  }\r\n};\r\n\r\n/**\r\n * This is the core draggable library that does the heavy lifting\r\n * @class Draggable\r\n * @module Draggable\r\n */\r\nclass Draggable {\r\n\r\n  /**\r\n   * Draggable constructor.\r\n   * @constructs Draggable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Draggable containers\r\n   * @param {Object} options - Options for draggable\r\n   */\r\n\r\n  /**\r\n   * Default plugins draggable uses\r\n   * @static\r\n   * @property {Object} Plugins\r\n   * @property {Announcement} Plugins.Announcement\r\n   * @property {Focusable} Plugins.Focusable\r\n   * @property {Mirror} Plugins.Mirror\r\n   * @property {Scrollable} Plugins.Scrollable\r\n   * @type {Object}\r\n   */\r\n  constructor(containers = [document.body], options = {}) {\r\n    /**\r\n     * Draggable containers\r\n     * @property containers\r\n     * @type {HTMLElement[]}\r\n     */\r\n    if (containers instanceof NodeList || containers instanceof Array) {\r\n      this.containers = [...containers];\r\n    } else if (containers instanceof HTMLElement) {\r\n      this.containers = [containers];\r\n    } else {\r\n      throw new Error('Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`');\r\n    }\r\n\r\n    this.options = _extends({}, defaultOptions, options, {\r\n      classes: _extends({}, defaultClasses, options.classes || {}),\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {}),\r\n      exclude: {\r\n        plugins: options.exclude && options.exclude.plugins || [],\r\n        sensors: options.exclude && options.exclude.sensors || []\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Draggables event emitter\r\n     * @property emitter\r\n     * @type {Emitter}\r\n     */\r\n    this.emitter = new _Emitter2.default();\r\n\r\n    /**\r\n     * Current drag state\r\n     * @property dragging\r\n     * @type {Boolean}\r\n     */\r\n    this.dragging = false;\r\n\r\n    /**\r\n     * Active plugins\r\n     * @property plugins\r\n     * @type {Plugin[]}\r\n     */\r\n    this.plugins = [];\r\n\r\n    /**\r\n     * Active sensors\r\n     * @property sensors\r\n     * @type {Sensor[]}\r\n     */\r\n    this.sensors = [];\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onDragPressure] = this[onDragPressure].bind(this);\r\n\r\n    document.addEventListener('drag:start', this[onDragStart], true);\r\n    document.addEventListener('drag:move', this[onDragMove], true);\r\n    document.addEventListener('drag:stop', this[onDragStop], true);\r\n    document.addEventListener('drag:pressure', this[onDragPressure], true);\r\n\r\n    const defaultPlugins = Object.values(Draggable.Plugins).filter(Plugin => !this.options.exclude.plugins.includes(Plugin));\r\n    const defaultSensors = Object.values(Draggable.Sensors).filter(sensor => !this.options.exclude.sensors.includes(sensor));\r\n\r\n    this.addPlugin(...[...defaultPlugins, ...this.options.plugins]);\r\n    this.addSensor(...[...defaultSensors, ...this.options.sensors]);\r\n\r\n    const draggableInitializedEvent = new _DraggableEvent.DraggableInitializedEvent({\r\n      draggable: this\r\n    });\r\n\r\n    this.on('mirror:created', ({ mirror }) => this.mirror = mirror);\r\n    this.on('mirror:destroy', () => this.mirror = null);\r\n\r\n    this.trigger(draggableInitializedEvent);\r\n  }\r\n\r\n  /**\r\n   * Destroys Draggable instance. This removes all internal event listeners and\r\n   * deactivates sensors and plugins\r\n   */\r\n\r\n\r\n  /**\r\n   * Default sensors draggable uses\r\n   * @static\r\n   * @property {Object} Sensors\r\n   * @property {MouseSensor} Sensors.MouseSensor\r\n   * @property {TouchSensor} Sensors.TouchSensor\r\n   * @type {Object}\r\n   */\r\n  destroy() {\r\n    document.removeEventListener('drag:start', this[onDragStart], true);\r\n    document.removeEventListener('drag:move', this[onDragMove], true);\r\n    document.removeEventListener('drag:stop', this[onDragStop], true);\r\n    document.removeEventListener('drag:pressure', this[onDragPressure], true);\r\n\r\n    const draggableDestroyEvent = new _DraggableEvent.DraggableDestroyEvent({\r\n      draggable: this\r\n    });\r\n\r\n    this.trigger(draggableDestroyEvent);\r\n\r\n    this.removePlugin(...this.plugins.map(plugin => plugin.constructor));\r\n    this.removeSensor(...this.sensors.map(sensor => sensor.constructor));\r\n  }\r\n\r\n  /**\r\n   * Adds plugin to this draggable instance. This will end up calling the attach method of the plugin\r\n   * @param {...typeof Plugin} plugins - Plugins that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addPlugin(CustomA11yPlugin, CustomMirrorPlugin)\r\n   */\r\n  addPlugin(...plugins) {\r\n    const activePlugins = plugins.map(Plugin => new Plugin(this));\r\n\r\n    activePlugins.forEach(plugin => plugin.attach());\r\n    this.plugins = [...this.plugins, ...activePlugins];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes plugins that are already attached to this draggable instance. This will end up calling\r\n   * the detach method of the plugin\r\n   * @param {...typeof Plugin} plugins - Plugins that you want detached from draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removePlugin(MirrorPlugin, CustomMirrorPlugin)\r\n   */\r\n  removePlugin(...plugins) {\r\n    const removedPlugins = this.plugins.filter(plugin => plugins.includes(plugin.constructor));\r\n\r\n    removedPlugins.forEach(plugin => plugin.detach());\r\n    this.plugins = this.plugins.filter(plugin => !plugins.includes(plugin.constructor));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds sensors to this draggable instance. This will end up calling the attach method of the sensor\r\n   * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addSensor(ForceTouchSensor, CustomSensor)\r\n   */\r\n  addSensor(...sensors) {\r\n    const activeSensors = sensors.map(Sensor => new Sensor(this.containers, this.options));\r\n\r\n    activeSensors.forEach(sensor => sensor.attach());\r\n    this.sensors = [...this.sensors, ...activeSensors];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes sensors that are already attached to this draggable instance. This will end up calling\r\n   * the detach method of the sensor\r\n   * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removeSensor(TouchSensor, DragSensor)\r\n   */\r\n  removeSensor(...sensors) {\r\n    const removedSensors = this.sensors.filter(sensor => sensors.includes(sensor.constructor));\r\n\r\n    removedSensors.forEach(sensor => sensor.detach());\r\n    this.sensors = this.sensors.filter(sensor => !sensors.includes(sensor.constructor));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds container to this draggable instance\r\n   * @param {...HTMLElement} containers - Containers you want to add to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addContainer(document.body)\r\n   */\r\n  addContainer(...containers) {\r\n    this.containers = [...this.containers, ...containers];\r\n    this.sensors.forEach(sensor => sensor.addContainer(...containers));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes container from this draggable instance\r\n   * @param {...HTMLElement} containers - Containers you want to remove from draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removeContainer(document.body)\r\n   */\r\n  removeContainer(...containers) {\r\n    this.containers = this.containers.filter(container => !containers.includes(container));\r\n    this.sensors.forEach(sensor => sensor.removeContainer(...containers));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds listener for draggable events\r\n   * @param {String} type - Event name\r\n   * @param {...Function} callbacks - Event callbacks\r\n   * @return {Draggable}\r\n   * @example draggable.on('drag:start', (dragEvent) => dragEvent.cancel());\r\n   */\r\n  on(type, ...callbacks) {\r\n    this.emitter.on(type, ...callbacks);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes listener from draggable\r\n   * @param {String} type - Event name\r\n   * @param {Function} callback - Event callback\r\n   * @return {Draggable}\r\n   * @example draggable.off('drag:start', handlerFunction);\r\n   */\r\n  off(type, callback) {\r\n    this.emitter.off(type, callback);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Triggers draggable event\r\n   * @param {AbstractEvent} event - Event instance\r\n   * @return {Draggable}\r\n   * @example draggable.trigger(event);\r\n   */\r\n  trigger(event) {\r\n    this.emitter.trigger(event);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns class name for class identifier\r\n   * @param {String} name - Name of class identifier\r\n   * @return {String|null}\r\n   */\r\n  getClassNameFor(name) {\r\n    return this.getClassNamesFor(name)[0];\r\n  }\r\n\r\n  /**\r\n   * Returns class names for class identifier\r\n   * @return {String[]}\r\n   */\r\n  getClassNamesFor(name) {\r\n    const classNames = this.options.classes[name];\r\n\r\n    if (classNames instanceof Array) {\r\n      return classNames;\r\n    } else if (typeof classNames === 'string' || classNames instanceof String) {\r\n      return [classNames];\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if this draggable instance is currently dragging\r\n   * @return {Boolean}\r\n   */\r\n  isDragging() {\r\n    return Boolean(this.dragging);\r\n  }\r\n\r\n  /**\r\n   * Returns all draggable elements\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getDraggableElements() {\r\n    return this.containers.reduce((current, container) => {\r\n      return [...current, ...this.getDraggableElementsForContainer(container)];\r\n    }, []);\r\n  }\r\n\r\n  /**\r\n   * Returns draggable elements for a given container, excluding the mirror and\r\n   * original source element if present\r\n   * @param {HTMLElement} container\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getDraggableElementsForContainer(container) {\r\n    const allDraggableElements = container.querySelectorAll(this.options.draggable);\r\n\r\n    return [...allDraggableElements].filter(childElement => {\r\n      return childElement !== this.originalSource && childElement !== this.mirror;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragStart](event) {\r\n    const sensorEvent = getSensorEvent(event);\r\n    const { target, container } = sensorEvent;\r\n\r\n    if (!this.containers.includes(container)) {\r\n      return;\r\n    }\r\n\r\n    if (this.options.handle && target && !(0, _utils.closest)(target, this.options.handle)) {\r\n      sensorEvent.cancel();\r\n      return;\r\n    }\r\n\r\n    // Find draggable source element\r\n    this.originalSource = (0, _utils.closest)(target, this.options.draggable);\r\n    this.sourceContainer = container;\r\n\r\n    if (!this.originalSource) {\r\n      sensorEvent.cancel();\r\n      return;\r\n    }\r\n\r\n    if (this.lastPlacedSource && this.lastPlacedContainer) {\r\n      clearTimeout(this.placedTimeoutID);\r\n      this.lastPlacedSource.classList.remove(...this.getClassNamesFor('source:placed'));\r\n      this.lastPlacedContainer.classList.remove(...this.getClassNamesFor('container:placed'));\r\n    }\r\n\r\n    this.source = this.originalSource.cloneNode(true);\r\n    this.originalSource.parentNode.insertBefore(this.source, this.originalSource);\r\n    this.originalSource.style.display = 'none';\r\n\r\n    const dragEvent = new _DragEvent.DragStartEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sourceContainer: container,\r\n      sensorEvent\r\n    });\r\n\r\n    this.trigger(dragEvent);\r\n\r\n    this.dragging = !dragEvent.canceled();\r\n\r\n    if (dragEvent.canceled()) {\r\n      this.source.parentNode.removeChild(this.source);\r\n      this.originalSource.style.display = null;\r\n      return;\r\n    }\r\n\r\n    this.originalSource.classList.add(...this.getClassNamesFor('source:original'));\r\n    this.source.classList.add(...this.getClassNamesFor('source:dragging'));\r\n    this.sourceContainer.classList.add(...this.getClassNamesFor('container:dragging'));\r\n    document.body.classList.add(...this.getClassNamesFor('body:dragging'));\r\n    applyUserSelect(document.body, 'none');\r\n\r\n    requestAnimationFrame(() => {\r\n      const oldSensorEvent = getSensorEvent(event);\r\n      const newSensorEvent = oldSensorEvent.clone({ target: this.source });\r\n\r\n      this[onDragMove](_extends({}, event, {\r\n        detail: newSensorEvent\r\n      }));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag move handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = getSensorEvent(event);\r\n    const { container } = sensorEvent;\r\n    let target = sensorEvent.target;\r\n\r\n    const dragMoveEvent = new _DragEvent.DragMoveEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sourceContainer: container,\r\n      sensorEvent\r\n    });\r\n\r\n    this.trigger(dragMoveEvent);\r\n\r\n    if (dragMoveEvent.canceled()) {\r\n      sensorEvent.cancel();\r\n    }\r\n\r\n    target = (0, _utils.closest)(target, this.options.draggable);\r\n    const withinCorrectContainer = (0, _utils.closest)(sensorEvent.target, this.containers);\r\n    const overContainer = sensorEvent.overContainer || withinCorrectContainer;\r\n    const isLeavingContainer = this.currentOverContainer && overContainer !== this.currentOverContainer;\r\n    const isLeavingDraggable = this.currentOver && target !== this.currentOver;\r\n    const isOverContainer = overContainer && this.currentOverContainer !== overContainer;\r\n    const isOverDraggable = withinCorrectContainer && target && this.currentOver !== target;\r\n\r\n    if (isLeavingDraggable) {\r\n      const dragOutEvent = new _DragEvent.DragOutEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        over: this.currentOver,\r\n        overContainer: this.currentOverContainer\r\n      });\r\n\r\n      this.currentOver.classList.remove(...this.getClassNamesFor('draggable:over'));\r\n      this.currentOver = null;\r\n\r\n      this.trigger(dragOutEvent);\r\n    }\r\n\r\n    if (isLeavingContainer) {\r\n      const dragOutContainerEvent = new _DragEvent.DragOutContainerEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer: this.currentOverContainer\r\n      });\r\n\r\n      this.currentOverContainer.classList.remove(...this.getClassNamesFor('container:over'));\r\n      this.currentOverContainer = null;\r\n\r\n      this.trigger(dragOutContainerEvent);\r\n    }\r\n\r\n    if (isOverContainer) {\r\n      overContainer.classList.add(...this.getClassNamesFor('container:over'));\r\n\r\n      const dragOverContainerEvent = new _DragEvent.DragOverContainerEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer\r\n      });\r\n\r\n      this.currentOverContainer = overContainer;\r\n\r\n      this.trigger(dragOverContainerEvent);\r\n    }\r\n\r\n    if (isOverDraggable) {\r\n      target.classList.add(...this.getClassNamesFor('draggable:over'));\r\n\r\n      const dragOverEvent = new _DragEvent.DragOverEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer,\r\n        over: target\r\n      });\r\n\r\n      this.currentOver = target;\r\n\r\n      this.trigger(dragOverEvent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragStop](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    this.dragging = false;\r\n\r\n    const dragStopEvent = new _DragEvent.DragStopEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sensorEvent: event.sensorEvent,\r\n      sourceContainer: this.sourceContainer\r\n    });\r\n\r\n    this.trigger(dragStopEvent);\r\n\r\n    this.source.parentNode.insertBefore(this.originalSource, this.source);\r\n    this.source.parentNode.removeChild(this.source);\r\n    this.originalSource.style.display = '';\r\n\r\n    this.source.classList.remove(...this.getClassNamesFor('source:dragging'));\r\n    this.originalSource.classList.remove(...this.getClassNamesFor('source:original'));\r\n    this.originalSource.classList.add(...this.getClassNamesFor('source:placed'));\r\n    this.sourceContainer.classList.add(...this.getClassNamesFor('container:placed'));\r\n    this.sourceContainer.classList.remove(...this.getClassNamesFor('container:dragging'));\r\n    document.body.classList.remove(...this.getClassNamesFor('body:dragging'));\r\n    applyUserSelect(document.body, '');\r\n\r\n    if (this.currentOver) {\r\n      this.currentOver.classList.remove(...this.getClassNamesFor('draggable:over'));\r\n    }\r\n\r\n    if (this.currentOverContainer) {\r\n      this.currentOverContainer.classList.remove(...this.getClassNamesFor('container:over'));\r\n    }\r\n\r\n    this.lastPlacedSource = this.originalSource;\r\n    this.lastPlacedContainer = this.sourceContainer;\r\n\r\n    this.placedTimeoutID = setTimeout(() => {\r\n      if (this.lastPlacedSource) {\r\n        this.lastPlacedSource.classList.remove(...this.getClassNamesFor('source:placed'));\r\n      }\r\n\r\n      if (this.lastPlacedContainer) {\r\n        this.lastPlacedContainer.classList.remove(...this.getClassNamesFor('container:placed'));\r\n      }\r\n\r\n      this.lastPlacedSource = null;\r\n      this.lastPlacedContainer = null;\r\n    }, this.options.placedTimeout);\r\n\r\n    const dragStoppedEvent = new _DragEvent.DragStoppedEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sensorEvent: event.sensorEvent,\r\n      sourceContainer: this.sourceContainer\r\n    });\r\n\r\n    this.trigger(dragStoppedEvent);\r\n\r\n    this.source = null;\r\n    this.originalSource = null;\r\n    this.currentOverContainer = null;\r\n    this.currentOver = null;\r\n    this.sourceContainer = null;\r\n  }\r\n\r\n  /**\r\n   * Drag pressure handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragPressure](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = getSensorEvent(event);\r\n    const source = this.source || (0, _utils.closest)(sensorEvent.originalEvent.target, this.options.draggable);\r\n\r\n    const dragPressureEvent = new _DragEvent.DragPressureEvent({\r\n      sensorEvent,\r\n      source,\r\n      pressure: sensorEvent.pressure\r\n    });\r\n\r\n    this.trigger(dragPressureEvent);\r\n  }\r\n}\r\n\r\nexports.default = Draggable;\r\nDraggable.Plugins = { Announcement: _Plugins.Announcement, Focusable: _Plugins.Focusable, Mirror: _Plugins.Mirror, Scrollable: _Plugins.Scrollable };\r\nDraggable.Sensors = { MouseSensor: _Sensors.MouseSensor, TouchSensor: _Sensors.TouchSensor };\r\nfunction getSensorEvent(event) {\r\n  return event.detail;\r\n}\r\n\r\nfunction applyUserSelect(element, value) {\r\n  element.style.webkitUserSelect = value;\r\n  element.style.mozUserSelect = value;\r\n  element.style.msUserSelect = value;\r\n  element.style.oUserSelect = value;\r\n  element.style.userSelect = value;\r\n}\r\n\r\n/***/ }),\r\n/* 13 */\r\n/***/ (function(module, exports, __nested_webpack_require_34931__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_34931__(2);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_34931__(1);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMouseForceWillBegin = Symbol('onMouseForceWillBegin');\r\nconst onMouseForceDown = Symbol('onMouseForceDown');\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseForceChange = Symbol('onMouseForceChange');\r\nconst onMouseMove = Symbol('onMouseMove');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst onMouseForceGlobalChange = Symbol('onMouseForceGlobalChange');\r\n\r\n/**\r\n * This sensor picks up native force touch events and dictates drag operations\r\n * @class ForceTouchSensor\r\n * @module ForceTouchSensor\r\n * @extends Sensor\r\n */\r\nclass ForceTouchSensor extends _Sensor2.default {\r\n  /**\r\n   * ForceTouchSensor constructor.\r\n   * @constructs ForceTouchSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed\r\n     * @property mightDrag\r\n     * @type {Boolean}\r\n     */\r\n    this.mightDrag = false;\r\n\r\n    this[onMouseForceWillBegin] = this[onMouseForceWillBegin].bind(this);\r\n    this[onMouseForceDown] = this[onMouseForceDown].bind(this);\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseForceChange] = this[onMouseForceChange].bind(this);\r\n    this[onMouseMove] = this[onMouseMove].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    for (const container of this.containers) {\r\n      container.addEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\r\n      container.addEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\r\n      container.addEventListener('mousedown', this[onMouseDown], true);\r\n      container.addEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\r\n    }\r\n\r\n    document.addEventListener('mousemove', this[onMouseMove]);\r\n    document.addEventListener('mouseup', this[onMouseUp]);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    for (const container of this.containers) {\r\n      container.removeEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\r\n      container.removeEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\r\n      container.removeEventListener('mousedown', this[onMouseDown], true);\r\n      container.removeEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\r\n    }\r\n\r\n    document.removeEventListener('mousemove', this[onMouseMove]);\r\n    document.removeEventListener('mouseup', this[onMouseUp]);\r\n  }\r\n\r\n  /**\r\n   * Mouse force will begin handler\r\n   * @private\r\n   * @param {Event} event - Mouse force will begin event\r\n   */\r\n  [onMouseForceWillBegin](event) {\r\n    event.preventDefault();\r\n    this.mightDrag = true;\r\n  }\r\n\r\n  /**\r\n   * Mouse force down handler\r\n   * @private\r\n   * @param {Event} event - Mouse force down event\r\n   */\r\n  [onMouseForceDown](event) {\r\n    if (this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = event.currentTarget;\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragStartEvent);\r\n\r\n    this.currentContainer = container;\r\n    this.dragging = !dragStartEvent.canceled();\r\n    this.mightDrag = false;\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target: null,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.mightDrag = false;\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    if (!this.mightDrag) {\r\n      return;\r\n    }\r\n\r\n    // Need workaround for real click\r\n    // Cancel potential drag events\r\n    event.stopPropagation();\r\n    event.stopImmediatePropagation();\r\n    event.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler\r\n   * @private\r\n   * @param {Event} event - Mouse force will begin event\r\n   */\r\n  [onMouseMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse force change handler\r\n   * @private\r\n   * @param {Event} event - Mouse force change event\r\n   */\r\n  [onMouseForceChange](event) {\r\n    if (this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = event.target;\r\n    const container = event.currentTarget;\r\n\r\n    const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({\r\n      pressure: event.webkitForce,\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragPressureEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse force global change handler\r\n   * @private\r\n   * @param {Event} event - Mouse force global change event\r\n   */\r\n  [onMouseForceGlobalChange](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = event.target;\r\n\r\n    const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({\r\n      pressure: event.webkitForce,\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragPressureEvent);\r\n  }\r\n}\r\nexports.default = ForceTouchSensor;\r\n\r\n/***/ }),\r\n/* 14 */\r\n/***/ (function(module, exports, __nested_webpack_require_41671__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _ForceTouchSensor = __nested_webpack_require_41671__(13);\r\n\r\nvar _ForceTouchSensor2 = _interopRequireDefault(_ForceTouchSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _ForceTouchSensor2.default;\r\n\r\n/***/ }),\r\n/* 15 */\r\n/***/ (function(module, exports, __nested_webpack_require_42111__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_42111__(0);\r\n\r\nvar _Sensor = __nested_webpack_require_42111__(2);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_42111__(1);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragEnd = Symbol('onDragEnd');\r\nconst onDrop = Symbol('onDrop');\r\nconst reset = Symbol('reset');\r\n\r\n/**\r\n * This sensor picks up native browser drag events and dictates drag operations\r\n * @class DragSensor\r\n * @module DragSensor\r\n * @extends Sensor\r\n */\r\nclass DragSensor extends _Sensor2.default {\r\n  /**\r\n   * DragSensor constructor.\r\n   * @constructs DragSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Mouse down timer which will end up setting the draggable attribute, unless canceled\r\n     * @property mouseDownTimeout\r\n     * @type {Number}\r\n     */\r\n    this.mouseDownTimeout = null;\r\n\r\n    /**\r\n     * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed\r\n     * @property draggableElement\r\n     * @type {HTMLElement}\r\n     */\r\n    this.draggableElement = null;\r\n\r\n    /**\r\n     * Native draggable element could be links or images, their draggable state will be disabled during drag operation\r\n     * @property nativeDraggableElement\r\n     * @type {HTMLElement}\r\n     */\r\n    this.nativeDraggableElement = null;\r\n\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragEnd] = this[onDragEnd].bind(this);\r\n    this[onDrop] = this[onDrop].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {Event} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    // Need for firefox. \"text\" key is needed for IE\r\n    event.dataTransfer.setData('text', '');\r\n    event.dataTransfer.effectAllowed = this.options.type;\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    this.currentContainer = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!this.currentContainer) {\r\n      return;\r\n    }\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    // Workaround\r\n    setTimeout(() => {\r\n      this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n      if (dragStartEvent.canceled()) {\r\n        this.dragging = false;\r\n      } else {\r\n        this.dragging = true;\r\n      }\r\n    }, 0);\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {Event} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = this.currentContainer;\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragMoveEvent);\r\n\r\n    if (!dragMoveEvent.canceled()) {\r\n      event.preventDefault();\r\n      event.dataTransfer.dropEffect = this.options.type;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag end handler\r\n   * @private\r\n   * @param {Event} event - Drag end event\r\n   */\r\n  [onDragEnd](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp], true);\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = this.currentContainer;\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragStopEvent);\r\n\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n\r\n    this[reset]();\r\n  }\r\n\r\n  /**\r\n   * Drop handler\r\n   * @private\r\n   * @param {Event} event - Drop event\r\n   */\r\n  [onDrop](event) {\r\n    // eslint-disable-line class-methods-use-this\r\n    event.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    // Firefox bug for inputs within draggables https://bugzilla.mozilla.org/show_bug.cgi?id=739071\r\n    if (event.target && (event.target.form || event.target.contenteditable)) {\r\n      return;\r\n    }\r\n\r\n    const nativeDraggableElement = (0, _utils.closest)(event.target, element => element.draggable);\r\n\r\n    if (nativeDraggableElement) {\r\n      nativeDraggableElement.draggable = false;\r\n      this.nativeDraggableElement = nativeDraggableElement;\r\n    }\r\n\r\n    document.addEventListener('mouseup', this[onMouseUp], true);\r\n    document.addEventListener('dragstart', this[onDragStart], false);\r\n    document.addEventListener('dragover', this[onDragOver], false);\r\n    document.addEventListener('dragend', this[onDragEnd], false);\r\n    document.addEventListener('drop', this[onDrop], false);\r\n\r\n    const target = (0, _utils.closest)(event.target, this.options.draggable);\r\n\r\n    if (!target) {\r\n      return;\r\n    }\r\n\r\n    this.startEvent = event;\r\n\r\n    this.mouseDownTimeout = setTimeout(() => {\r\n      target.draggable = true;\r\n      this.draggableElement = target;\r\n    }, this.delay.drag);\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp]() {\r\n    this[reset]();\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [reset]() {\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp], true);\r\n    document.removeEventListener('dragstart', this[onDragStart], false);\r\n    document.removeEventListener('dragover', this[onDragOver], false);\r\n    document.removeEventListener('dragend', this[onDragEnd], false);\r\n    document.removeEventListener('drop', this[onDrop], false);\r\n\r\n    if (this.nativeDraggableElement) {\r\n      this.nativeDraggableElement.draggable = true;\r\n      this.nativeDraggableElement = null;\r\n    }\r\n\r\n    if (this.draggableElement) {\r\n      this.draggableElement.draggable = false;\r\n      this.draggableElement = null;\r\n    }\r\n  }\r\n}\r\nexports.default = DragSensor;\r\n\r\n/***/ }),\r\n/* 16 */\r\n/***/ (function(module, exports, __nested_webpack_require_49384__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragSensor = __nested_webpack_require_49384__(15);\r\n\r\nvar _DragSensor2 = _interopRequireDefault(_DragSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _DragSensor2.default;\r\n\r\n/***/ }),\r\n/* 17 */\r\n/***/ (function(module, exports, __nested_webpack_require_49800__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_49800__(0);\r\n\r\nvar _Sensor = __nested_webpack_require_49800__(2);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_49800__(1);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onTouchStart = Symbol('onTouchStart');\r\nconst onTouchEnd = Symbol('onTouchEnd');\r\nconst onTouchMove = Symbol('onTouchMove');\r\nconst startDrag = Symbol('startDrag');\r\nconst onDistanceChange = Symbol('onDistanceChange');\r\n\r\n/**\r\n * Prevents scrolling when set to true\r\n * @var {Boolean} preventScrolling\r\n */\r\nlet preventScrolling = false;\r\n\r\n// WebKit requires cancelable `touchmove` events to be added as early as possible\r\nwindow.addEventListener('touchmove', event => {\r\n  if (!preventScrolling) {\r\n    return;\r\n  }\r\n\r\n  // Prevent scrolling\r\n  event.preventDefault();\r\n}, { passive: false });\r\n\r\n/**\r\n * This sensor picks up native browser touch events and dictates drag operations\r\n * @class TouchSensor\r\n * @module TouchSensor\r\n * @extends Sensor\r\n */\r\nclass TouchSensor extends _Sensor2.default {\r\n  /**\r\n   * TouchSensor constructor.\r\n   * @constructs TouchSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Closest scrollable container so accidental scroll can cancel long touch\r\n     * @property currentScrollableParent\r\n     * @type {HTMLElement}\r\n     */\r\n    this.currentScrollableParent = null;\r\n\r\n    /**\r\n     * TimeoutID for managing delay\r\n     * @property tapTimeout\r\n     * @type {Number}\r\n     */\r\n    this.tapTimeout = null;\r\n\r\n    /**\r\n     * touchMoved indicates if touch has moved during tapTimeout\r\n     * @property touchMoved\r\n     * @type {Boolean}\r\n     */\r\n    this.touchMoved = false;\r\n\r\n    /**\r\n     * Save pageX coordinates for delay drag\r\n     * @property {Numbre} pageX\r\n     * @private\r\n     */\r\n    this.pageX = null;\r\n\r\n    /**\r\n     * Save pageY coordinates for delay drag\r\n     * @property {Numbre} pageY\r\n     * @private\r\n     */\r\n    this.pageY = null;\r\n\r\n    this[onTouchStart] = this[onTouchStart].bind(this);\r\n    this[onTouchEnd] = this[onTouchEnd].bind(this);\r\n    this[onTouchMove] = this[onTouchMove].bind(this);\r\n    this[startDrag] = this[startDrag].bind(this);\r\n    this[onDistanceChange] = this[onDistanceChange].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('touchstart', this[onTouchStart]);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('touchstart', this[onTouchStart]);\r\n  }\r\n\r\n  /**\r\n   * Touch start handler\r\n   * @private\r\n   * @param {Event} event - Touch start event\r\n   */\r\n  [onTouchStart](event) {\r\n    const container = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!container) {\r\n      return;\r\n    }\r\n    const { distance = 0 } = this.options;\r\n    const { delay } = this;\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n    this.onTouchStartAt = Date.now();\r\n    this.startEvent = event;\r\n    this.currentContainer = container;\r\n\r\n    document.addEventListener('touchend', this[onTouchEnd]);\r\n    document.addEventListener('touchcancel', this[onTouchEnd]);\r\n    document.addEventListener('touchmove', this[onDistanceChange]);\r\n    container.addEventListener('contextmenu', onContextMenu);\r\n\r\n    if (distance) {\r\n      preventScrolling = true;\r\n    }\r\n\r\n    this.tapTimeout = window.setTimeout(() => {\r\n      this[onDistanceChange]({ touches: [{ pageX: this.pageX, pageY: this.pageY }] });\r\n    }, delay.touch);\r\n  }\r\n\r\n  /**\r\n   * Start the drag\r\n   * @private\r\n   */\r\n  [startDrag]() {\r\n    const startEvent = this.startEvent;\r\n    const container = this.currentContainer;\r\n    const touch = (0, _utils.touchCoords)(startEvent);\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: touch.pageX,\r\n      clientY: touch.pageY,\r\n      target: startEvent.target,\r\n      container,\r\n      originalEvent: startEvent\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n    this.dragging = !dragStartEvent.canceled();\r\n\r\n    if (this.dragging) {\r\n      document.addEventListener('touchmove', this[onTouchMove]);\r\n    }\r\n    preventScrolling = this.dragging;\r\n  }\r\n\r\n  /**\r\n   * Touch move handler prior to drag start.\r\n   * @private\r\n   * @param {Event} event - Touch move event\r\n   */\r\n  [onDistanceChange](event) {\r\n    const { distance } = this.options;\r\n    const { startEvent, delay } = this;\r\n    const start = (0, _utils.touchCoords)(startEvent);\r\n    const current = (0, _utils.touchCoords)(event);\r\n    const timeElapsed = Date.now() - this.onTouchStartAt;\r\n    const distanceTravelled = (0, _utils.distance)(start.pageX, start.pageY, current.pageX, current.pageY);\r\n\r\n    Object.assign(this, current);\r\n\r\n    clearTimeout(this.tapTimeout);\r\n\r\n    if (timeElapsed < delay.touch) {\r\n      // moved during delay\r\n      document.removeEventListener('touchmove', this[onDistanceChange]);\r\n    } else if (distanceTravelled >= distance) {\r\n      document.removeEventListener('touchmove', this[onDistanceChange]);\r\n      this[startDrag]();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler while dragging\r\n   * @private\r\n   * @param {Event} event - Touch move event\r\n   */\r\n  [onTouchMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n    const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: pageX,\r\n      clientY: pageY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Touch end handler\r\n   * @private\r\n   * @param {Event} event - Touch end event\r\n   */\r\n  [onTouchEnd](event) {\r\n    clearTimeout(this.tapTimeout);\r\n    preventScrolling = false;\r\n\r\n    document.removeEventListener('touchend', this[onTouchEnd]);\r\n    document.removeEventListener('touchcancel', this[onTouchEnd]);\r\n    document.removeEventListener('touchmove', this[onDistanceChange]);\r\n\r\n    if (this.currentContainer) {\r\n      this.currentContainer.removeEventListener('contextmenu', onContextMenu);\r\n    }\r\n\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('touchmove', this[onTouchMove]);\r\n\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n    const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);\r\n\r\n    event.preventDefault();\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: pageX,\r\n      clientY: pageY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n  }\r\n}\r\n\r\nexports.default = TouchSensor;\r\nfunction onContextMenu(event) {\r\n  event.preventDefault();\r\n  event.stopPropagation();\r\n}\r\n\r\n/***/ }),\r\n/* 18 */\r\n/***/ (function(module, exports, __nested_webpack_require_57280__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _TouchSensor = __nested_webpack_require_57280__(17);\r\n\r\nvar _TouchSensor2 = _interopRequireDefault(_TouchSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _TouchSensor2.default;\r\n\r\n/***/ }),\r\n/* 19 */\r\n/***/ (function(module, exports, __nested_webpack_require_57700__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DragPressureSensorEvent = exports.DragStopSensorEvent = exports.DragMoveSensorEvent = exports.DragStartSensorEvent = exports.SensorEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_57700__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base sensor event\r\n * @class SensorEvent\r\n * @module SensorEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SensorEvent extends _AbstractEvent2.default {\r\n  /**\r\n   * Original browser event that triggered a sensor\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    return this.data.originalEvent;\r\n  }\r\n\r\n  /**\r\n   * Normalized clientX for both touch and mouse events\r\n   * @property clientX\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get clientX() {\r\n    return this.data.clientX;\r\n  }\r\n\r\n  /**\r\n   * Normalized clientY for both touch and mouse events\r\n   * @property clientY\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get clientY() {\r\n    return this.data.clientY;\r\n  }\r\n\r\n  /**\r\n   * Normalized target for both touch and mouse events\r\n   * Returns the element that is behind cursor or touch pointer\r\n   * @property target\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get target() {\r\n    return this.data.target;\r\n  }\r\n\r\n  /**\r\n   * Container that initiated the sensor\r\n   * @property container\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get container() {\r\n    return this.data.container;\r\n  }\r\n\r\n  /**\r\n   * Trackpad pressure\r\n   * @property pressure\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get pressure() {\r\n    return this.data.pressure;\r\n  }\r\n}\r\n\r\nexports.SensorEvent = SensorEvent; /**\r\n                                    * Drag start sensor event\r\n                                    * @class DragStartSensorEvent\r\n                                    * @module DragStartSensorEvent\r\n                                    * @extends SensorEvent\r\n                                    */\r\n\r\nclass DragStartSensorEvent extends SensorEvent {}\r\n\r\nexports.DragStartSensorEvent = DragStartSensorEvent; /**\r\n                                                      * Drag move sensor event\r\n                                                      * @class DragMoveSensorEvent\r\n                                                      * @module DragMoveSensorEvent\r\n                                                      * @extends SensorEvent\r\n                                                      */\r\n\r\nDragStartSensorEvent.type = 'drag:start';\r\nclass DragMoveSensorEvent extends SensorEvent {}\r\n\r\nexports.DragMoveSensorEvent = DragMoveSensorEvent; /**\r\n                                                    * Drag stop sensor event\r\n                                                    * @class DragStopSensorEvent\r\n                                                    * @module DragStopSensorEvent\r\n                                                    * @extends SensorEvent\r\n                                                    */\r\n\r\nDragMoveSensorEvent.type = 'drag:move';\r\nclass DragStopSensorEvent extends SensorEvent {}\r\n\r\nexports.DragStopSensorEvent = DragStopSensorEvent; /**\r\n                                                    * Drag pressure sensor event\r\n                                                    * @class DragPressureSensorEvent\r\n                                                    * @module DragPressureSensorEvent\r\n                                                    * @extends SensorEvent\r\n                                                    */\r\n\r\nDragStopSensorEvent.type = 'drag:stop';\r\nclass DragPressureSensorEvent extends SensorEvent {}\r\nexports.DragPressureSensorEvent = DragPressureSensorEvent;\r\nDragPressureSensorEvent.type = 'drag:pressure';\r\n\r\n/***/ }),\r\n/* 20 */\r\n/***/ (function(module, exports, __nested_webpack_require_61691__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_61691__(0);\r\n\r\nvar _Sensor = __nested_webpack_require_61691__(2);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_61691__(1);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onContextMenuWhileDragging = Symbol('onContextMenuWhileDragging');\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseMove = Symbol('onMouseMove');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst startDrag = Symbol('startDrag');\r\nconst onDistanceChange = Symbol('onDistanceChange');\r\n\r\n/**\r\n * This sensor picks up native browser mouse events and dictates drag operations\r\n * @class MouseSensor\r\n * @module MouseSensor\r\n * @extends Sensor\r\n */\r\nclass MouseSensor extends _Sensor2.default {\r\n  /**\r\n   * MouseSensor constructor.\r\n   * @constructs MouseSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Mouse down timer which will end up triggering the drag start operation\r\n     * @property mouseDownTimeout\r\n     * @type {Number}\r\n     */\r\n    this.mouseDownTimeout = null;\r\n\r\n    /**\r\n     * Save pageX coordinates for delay drag\r\n     * @property {Numbre} pageX\r\n     * @private\r\n     */\r\n    this.pageX = null;\r\n\r\n    /**\r\n     * Save pageY coordinates for delay drag\r\n     * @property {Numbre} pageY\r\n     * @private\r\n     */\r\n    this.pageY = null;\r\n\r\n    this[onContextMenuWhileDragging] = this[onContextMenuWhileDragging].bind(this);\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseMove] = this[onMouseMove].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n    this[startDrag] = this[startDrag].bind(this);\r\n    this[onDistanceChange] = this[onDistanceChange].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    if (event.button !== 0 || event.ctrlKey || event.metaKey) {\r\n      return;\r\n    }\r\n    const container = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!container) {\r\n      return;\r\n    }\r\n\r\n    const { delay } = this;\r\n    const { pageX, pageY } = event;\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n    this.onMouseDownAt = Date.now();\r\n    this.startEvent = event;\r\n\r\n    this.currentContainer = container;\r\n    document.addEventListener('mouseup', this[onMouseUp]);\r\n    document.addEventListener('dragstart', preventNativeDragStart);\r\n    document.addEventListener('mousemove', this[onDistanceChange]);\r\n\r\n    this.mouseDownTimeout = window.setTimeout(() => {\r\n      this[onDistanceChange]({ pageX: this.pageX, pageY: this.pageY });\r\n    }, delay.mouse);\r\n  }\r\n\r\n  /**\r\n   * Start the drag\r\n   * @private\r\n   */\r\n  [startDrag]() {\r\n    const startEvent = this.startEvent;\r\n    const container = this.currentContainer;\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: startEvent.clientX,\r\n      clientY: startEvent.clientY,\r\n      target: startEvent.target,\r\n      container,\r\n      originalEvent: startEvent\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n    this.dragging = !dragStartEvent.canceled();\r\n\r\n    if (this.dragging) {\r\n      document.addEventListener('contextmenu', this[onContextMenuWhileDragging], true);\r\n      document.addEventListener('mousemove', this[onMouseMove]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect change in distance, starting drag when both\r\n   * delay and distance requirements are met\r\n   * @private\r\n   * @param {Event} event - Mouse move event\r\n   */\r\n  [onDistanceChange](event) {\r\n    const { pageX, pageY } = event;\r\n    const { distance } = this.options;\r\n    const { startEvent, delay } = this;\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n\r\n    if (!this.currentContainer) {\r\n      return;\r\n    }\r\n\r\n    const timeElapsed = Date.now() - this.onMouseDownAt;\r\n    const distanceTravelled = (0, _utils.distance)(startEvent.pageX, startEvent.pageY, pageX, pageY) || 0;\r\n\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    if (timeElapsed < delay.mouse) {\r\n      // moved during delay\r\n      document.removeEventListener('mousemove', this[onDistanceChange]);\r\n    } else if (distanceTravelled >= distance) {\r\n      document.removeEventListener('mousemove', this[onDistanceChange]);\r\n      this[startDrag]();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler\r\n   * @private\r\n   * @param {Event} event - Mouse move event\r\n   */\r\n  [onMouseMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp](event) {\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    if (event.button !== 0) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp]);\r\n    document.removeEventListener('dragstart', preventNativeDragStart);\r\n    document.removeEventListener('mousemove', this[onDistanceChange]);\r\n\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    document.removeEventListener('contextmenu', this[onContextMenuWhileDragging], true);\r\n    document.removeEventListener('mousemove', this[onMouseMove]);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n  }\r\n\r\n  /**\r\n   * Context menu handler\r\n   * @private\r\n   * @param {Event} event - Context menu event\r\n   */\r\n  [onContextMenuWhileDragging](event) {\r\n    event.preventDefault();\r\n  }\r\n}\r\n\r\nexports.default = MouseSensor;\r\nfunction preventNativeDragStart(event) {\r\n  event.preventDefault();\r\n}\r\n\r\n/***/ }),\r\n/* 21 */\r\n/***/ (function(module, exports, __nested_webpack_require_68563__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _MouseSensor = __nested_webpack_require_68563__(20);\r\n\r\nvar _MouseSensor2 = _interopRequireDefault(_MouseSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _MouseSensor2.default;\r\n\r\n/***/ }),\r\n/* 22 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst defaultDealy = {\r\n  mouse: 0,\r\n  drag: 0,\r\n  touch: 100\r\n};\r\n\r\n/**\r\n * Base sensor class. Extend from this class to create a new or custom sensor\r\n * @class Sensor\r\n * @module Sensor\r\n */\r\nclass Sensor {\r\n  /**\r\n   * Sensor constructor.\r\n   * @constructs Sensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    /**\r\n     * Current containers\r\n     * @property containers\r\n     * @type {HTMLElement[]}\r\n     */\r\n    this.containers = [...containers];\r\n\r\n    /**\r\n     * Current options\r\n     * @property options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, options);\r\n\r\n    /**\r\n     * Current drag state\r\n     * @property dragging\r\n     * @type {Boolean}\r\n     */\r\n    this.dragging = false;\r\n\r\n    /**\r\n     * Current container\r\n     * @property currentContainer\r\n     * @type {HTMLElement}\r\n     */\r\n    this.currentContainer = null;\r\n\r\n    /**\r\n     * The event of the initial sensor down\r\n     * @property startEvent\r\n     * @type {Event}\r\n     */\r\n    this.startEvent = null;\r\n\r\n    /**\r\n     * The delay of each sensor\r\n     * @property delay\r\n     * @type {Object}\r\n     */\r\n    this.delay = calcDelay(options.delay);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   * @return {Sensor}\r\n   */\r\n  attach() {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   * @return {Sensor}\r\n   */\r\n  detach() {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds container to this sensor instance\r\n   * @param {...HTMLElement} containers - Containers you want to add to this sensor\r\n   * @example draggable.addContainer(document.body)\r\n   */\r\n  addContainer(...containers) {\r\n    this.containers = [...this.containers, ...containers];\r\n  }\r\n\r\n  /**\r\n   * Removes container from this sensor instance\r\n   * @param {...HTMLElement} containers - Containers you want to remove from this sensor\r\n   * @example draggable.removeContainer(document.body)\r\n   */\r\n  removeContainer(...containers) {\r\n    this.containers = this.containers.filter(container => !containers.includes(container));\r\n  }\r\n\r\n  /**\r\n   * Triggers event on target element\r\n   * @param {HTMLElement} element - Element to trigger event on\r\n   * @param {SensorEvent} sensorEvent - Sensor event to trigger\r\n   */\r\n  trigger(element, sensorEvent) {\r\n    const event = document.createEvent('Event');\r\n    event.detail = sensorEvent;\r\n    event.initEvent(sensorEvent.type, true, true);\r\n    element.dispatchEvent(event);\r\n    this.lastEvent = sensorEvent;\r\n\r\n    return sensorEvent;\r\n  }\r\n}\r\n\r\nexports.default = Sensor; /**\r\n                           * Calculate the delay of each sensor through the delay in the options\r\n                           * @param {undefined|Number|Object} optionsDelay - the delay in the options\r\n                           * @return {Object}\r\n                           */\r\n\r\nfunction calcDelay(optionsDelay) {\r\n  const delay = {};\r\n\r\n  if (optionsDelay === undefined) {\r\n    return _extends({}, defaultDealy);\r\n  }\r\n\r\n  if (typeof optionsDelay === 'number') {\r\n    for (const key in defaultDealy) {\r\n      if (defaultDealy.hasOwnProperty(key)) {\r\n        delay[key] = optionsDelay;\r\n      }\r\n    }\r\n    return delay;\r\n  }\r\n\r\n  for (const key in defaultDealy) {\r\n    if (defaultDealy.hasOwnProperty(key)) {\r\n      if (optionsDelay[key] === undefined) {\r\n        delay[key] = defaultDealy[key];\r\n      } else {\r\n        delay[key] = optionsDelay[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  return delay;\r\n}\r\n\r\n/***/ }),\r\n/* 23 */\r\n/***/ (function(module, exports, __nested_webpack_require_72985__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = exports.scroll = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_72985__(4);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _utils = __nested_webpack_require_72985__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = exports.onDragStart = Symbol('onDragStart');\r\nconst onDragMove = exports.onDragMove = Symbol('onDragMove');\r\nconst onDragStop = exports.onDragStop = Symbol('onDragStop');\r\nconst scroll = exports.scroll = Symbol('scroll');\r\n\r\n/**\r\n * Scrollable default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.speed\r\n * @property {Number} defaultOptions.sensitivity\r\n * @property {HTMLElement[]} defaultOptions.scrollableElements\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  speed: 6,\r\n  sensitivity: 50,\r\n  scrollableElements: []\r\n};\r\n\r\n/**\r\n * Scrollable plugin which scrolls the closest scrollable parent\r\n * @class Scrollable\r\n * @module Scrollable\r\n * @extends AbstractPlugin\r\n */\r\nclass Scrollable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Scrollable constructor.\r\n   * @constructs Scrollable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Scrollable options\r\n     * @property {Object} options\r\n     * @property {Number} options.speed\r\n     * @property {Number} options.sensitivity\r\n     * @property {HTMLElement[]} options.scrollableElements\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Keeps current mouse position\r\n     * @property {Object} currentMousePosition\r\n     * @property {Number} currentMousePosition.clientX\r\n     * @property {Number} currentMousePosition.clientY\r\n     * @type {Object|null}\r\n     */\r\n    this.currentMousePosition = null;\r\n\r\n    /**\r\n     * Scroll animation frame\r\n     * @property scrollAnimationFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.scrollAnimationFrame = null;\r\n\r\n    /**\r\n     * Closest scrollable element\r\n     * @property scrollableElement\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.scrollableElement = null;\r\n\r\n    /**\r\n     * Animation frame looking for the closest scrollable element\r\n     * @property findScrollableElementFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.findScrollableElementFrame = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[scroll] = this[scroll].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.scrollable || {};\r\n  }\r\n\r\n  /**\r\n   * Returns closest scrollable elements by element\r\n   * @param {HTMLElement} target\r\n   * @return {HTMLElement}\r\n   */\r\n  getScrollableElement(target) {\r\n    if (this.hasDefinedScrollableElements()) {\r\n      return (0, _utils.closest)(target, this.options.scrollableElements) || document.documentElement;\r\n    } else {\r\n      return closestScrollableElement(target);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if at least one scrollable element have been defined via options\r\n   * @param {HTMLElement} target\r\n   * @return {Boolean}\r\n   */\r\n  hasDefinedScrollableElements() {\r\n    return Boolean(this.options.scrollableElements.length !== 0);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler. Finds closest scrollable parent in separate frame\r\n   * @param {DragStartEvent} dragEvent\r\n   * @private\r\n   */\r\n  [onDragStart](dragEvent) {\r\n    this.findScrollableElementFrame = requestAnimationFrame(() => {\r\n      this.scrollableElement = this.getScrollableElement(dragEvent.source);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag move handler. Remembers mouse position and initiates scrolling\r\n   * @param {DragMoveEvent} dragEvent\r\n   * @private\r\n   */\r\n  [onDragMove](dragEvent) {\r\n    this.findScrollableElementFrame = requestAnimationFrame(() => {\r\n      this.scrollableElement = this.getScrollableElement(dragEvent.sensorEvent.target);\r\n    });\r\n\r\n    if (!this.scrollableElement) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = dragEvent.sensorEvent;\r\n    const scrollOffset = { x: 0, y: 0 };\r\n\r\n    if ('ontouchstart' in window) {\r\n      scrollOffset.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\r\n      scrollOffset.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;\r\n    }\r\n\r\n    this.currentMousePosition = {\r\n      clientX: sensorEvent.clientX - scrollOffset.x,\r\n      clientY: sensorEvent.clientY - scrollOffset.y\r\n    };\r\n\r\n    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler. Cancels scroll animations and resets state\r\n   * @private\r\n   */\r\n  [onDragStop]() {\r\n    cancelAnimationFrame(this.scrollAnimationFrame);\r\n    cancelAnimationFrame(this.findScrollableElementFrame);\r\n\r\n    this.scrollableElement = null;\r\n    this.scrollAnimationFrame = null;\r\n    this.findScrollableElementFrame = null;\r\n    this.currentMousePosition = null;\r\n  }\r\n\r\n  /**\r\n   * Scroll function that does the heavylifting\r\n   * @private\r\n   */\r\n  [scroll]() {\r\n    if (!this.scrollableElement || !this.currentMousePosition) {\r\n      return;\r\n    }\r\n\r\n    cancelAnimationFrame(this.scrollAnimationFrame);\r\n\r\n    const { speed, sensitivity } = this.options;\r\n\r\n    const rect = this.scrollableElement.getBoundingClientRect();\r\n    const bottomCutOff = rect.bottom > window.innerHeight;\r\n    const topCutOff = rect.top < 0;\r\n    const cutOff = topCutOff || bottomCutOff;\r\n\r\n    const documentScrollingElement = getDocumentScrollingElement();\r\n    const scrollableElement = this.scrollableElement;\r\n    const clientX = this.currentMousePosition.clientX;\r\n    const clientY = this.currentMousePosition.clientY;\r\n\r\n    if (scrollableElement !== document.body && scrollableElement !== document.documentElement && !cutOff) {\r\n      const { offsetHeight, offsetWidth } = scrollableElement;\r\n\r\n      if (rect.top + offsetHeight - clientY < sensitivity) {\r\n        scrollableElement.scrollTop += speed;\r\n      } else if (clientY - rect.top < sensitivity) {\r\n        scrollableElement.scrollTop -= speed;\r\n      }\r\n\r\n      if (rect.left + offsetWidth - clientX < sensitivity) {\r\n        scrollableElement.scrollLeft += speed;\r\n      } else if (clientX - rect.left < sensitivity) {\r\n        scrollableElement.scrollLeft -= speed;\r\n      }\r\n    } else {\r\n      const { innerHeight, innerWidth } = window;\r\n\r\n      if (clientY < sensitivity) {\r\n        documentScrollingElement.scrollTop -= speed;\r\n      } else if (innerHeight - clientY < sensitivity) {\r\n        documentScrollingElement.scrollTop += speed;\r\n      }\r\n\r\n      if (clientX < sensitivity) {\r\n        documentScrollingElement.scrollLeft -= speed;\r\n      } else if (innerWidth - clientX < sensitivity) {\r\n        documentScrollingElement.scrollLeft += speed;\r\n      }\r\n    }\r\n\r\n    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\r\n  }\r\n}\r\n\r\nexports.default = Scrollable; /**\r\n                               * Returns true if the passed element has overflow\r\n                               * @param {HTMLElement} element\r\n                               * @return {Boolean}\r\n                               * @private\r\n                               */\r\n\r\nfunction hasOverflow(element) {\r\n  const overflowRegex = /(auto|scroll)/;\r\n  const computedStyles = getComputedStyle(element, null);\r\n\r\n  const overflow = computedStyles.getPropertyValue('overflow') + computedStyles.getPropertyValue('overflow-y') + computedStyles.getPropertyValue('overflow-x');\r\n\r\n  return overflowRegex.test(overflow);\r\n}\r\n\r\n/**\r\n * Returns true if the passed element is statically positioned\r\n * @param {HTMLElement} element\r\n * @return {Boolean}\r\n * @private\r\n */\r\nfunction isStaticallyPositioned(element) {\r\n  const position = getComputedStyle(element).getPropertyValue('position');\r\n  return position === 'static';\r\n}\r\n\r\n/**\r\n * Finds closest scrollable element\r\n * @param {HTMLElement} element\r\n * @return {HTMLElement}\r\n * @private\r\n */\r\nfunction closestScrollableElement(element) {\r\n  if (!element) {\r\n    return getDocumentScrollingElement();\r\n  }\r\n\r\n  const position = getComputedStyle(element).getPropertyValue('position');\r\n  const excludeStaticParents = position === 'absolute';\r\n\r\n  const scrollableElement = (0, _utils.closest)(element, parent => {\r\n    if (excludeStaticParents && isStaticallyPositioned(parent)) {\r\n      return false;\r\n    }\r\n    return hasOverflow(parent);\r\n  });\r\n\r\n  if (position === 'fixed' || !scrollableElement) {\r\n    return getDocumentScrollingElement();\r\n  } else {\r\n    return scrollableElement;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns element that scrolls document\r\n * @return {HTMLElement}\r\n * @private\r\n */\r\nfunction getDocumentScrollingElement() {\r\n  return document.scrollingElement || document.documentElement;\r\n}\r\n\r\n/***/ }),\r\n/* 24 */\r\n/***/ (function(module, exports, __nested_webpack_require_82907__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Scrollable = __nested_webpack_require_82907__(23);\r\n\r\nvar _Scrollable2 = _interopRequireDefault(_Scrollable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Scrollable2.default;\r\nexports.defaultOptions = _Scrollable.defaultOptions;\r\n\r\n/***/ }),\r\n/* 25 */\r\n/***/ (function(module, exports, __nested_webpack_require_83414__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.MirrorDestroyEvent = exports.MirrorMoveEvent = exports.MirrorAttachedEvent = exports.MirrorCreatedEvent = exports.MirrorCreateEvent = exports.MirrorEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_83414__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base mirror event\r\n * @class MirrorEvent\r\n * @module MirrorEvent\r\n * @extends AbstractEvent\r\n */\r\nclass MirrorEvent extends _AbstractEvent2.default {\r\n  /**\r\n   * Draggables source element\r\n   * @property source\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get source() {\r\n    return this.data.source;\r\n  }\r\n\r\n  /**\r\n   * Draggables original source element\r\n   * @property originalSource\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get originalSource() {\r\n    return this.data.originalSource;\r\n  }\r\n\r\n  /**\r\n   * Draggables source container element\r\n   * @property sourceContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get sourceContainer() {\r\n    return this.data.sourceContainer;\r\n  }\r\n\r\n  /**\r\n   * Sensor event\r\n   * @property sensorEvent\r\n   * @type {SensorEvent}\r\n   * @readonly\r\n   */\r\n  get sensorEvent() {\r\n    return this.data.sensorEvent;\r\n  }\r\n\r\n  /**\r\n   * Drag event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n\r\n  /**\r\n   * Original event that triggered sensor event\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    if (this.sensorEvent) {\r\n      return this.sensorEvent.originalEvent;\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexports.MirrorEvent = MirrorEvent; /**\r\n                                    * Mirror create event\r\n                                    * @class MirrorCreateEvent\r\n                                    * @module MirrorCreateEvent\r\n                                    * @extends MirrorEvent\r\n                                    */\r\n\r\nclass MirrorCreateEvent extends MirrorEvent {}\r\n\r\nexports.MirrorCreateEvent = MirrorCreateEvent; /**\r\n                                                * Mirror created event\r\n                                                * @class MirrorCreatedEvent\r\n                                                * @module MirrorCreatedEvent\r\n                                                * @extends MirrorEvent\r\n                                                */\r\n\r\nMirrorCreateEvent.type = 'mirror:create';\r\nclass MirrorCreatedEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\n\r\nexports.MirrorCreatedEvent = MirrorCreatedEvent; /**\r\n                                                  * Mirror attached event\r\n                                                  * @class MirrorAttachedEvent\r\n                                                  * @module MirrorAttachedEvent\r\n                                                  * @extends MirrorEvent\r\n                                                  */\r\n\r\nMirrorCreatedEvent.type = 'mirror:created';\r\nclass MirrorAttachedEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\n\r\nexports.MirrorAttachedEvent = MirrorAttachedEvent; /**\r\n                                                    * Mirror move event\r\n                                                    * @class MirrorMoveEvent\r\n                                                    * @module MirrorMoveEvent\r\n                                                    * @extends MirrorEvent\r\n                                                    */\r\n\r\nMirrorAttachedEvent.type = 'mirror:attached';\r\nclass MirrorMoveEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n\r\n  /**\r\n   * Sensor has exceeded mirror's threshold on x axis\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  get passedThreshX() {\r\n    return this.data.passedThreshX;\r\n  }\r\n\r\n  /**\r\n   * Sensor has exceeded mirror's threshold on y axis\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  get passedThreshY() {\r\n    return this.data.passedThreshY;\r\n  }\r\n}\r\n\r\nexports.MirrorMoveEvent = MirrorMoveEvent; /**\r\n                                            * Mirror destroy event\r\n                                            * @class MirrorDestroyEvent\r\n                                            * @module MirrorDestroyEvent\r\n                                            * @extends MirrorEvent\r\n                                            */\r\n\r\nMirrorMoveEvent.type = 'mirror:move';\r\nMirrorMoveEvent.cancelable = true;\r\nclass MirrorDestroyEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\nexports.MirrorDestroyEvent = MirrorDestroyEvent;\r\nMirrorDestroyEvent.type = 'mirror:destroy';\r\nMirrorDestroyEvent.cancelable = true;\r\n\r\n/***/ }),\r\n/* 26 */\r\n/***/ (function(module, exports, __nested_webpack_require_88866__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _MirrorEvent = __nested_webpack_require_88866__(25);\r\n\r\nObject.keys(_MirrorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _MirrorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 27 */\r\n/***/ (function(module, exports, __nested_webpack_require_89334__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = exports.getAppendableContainer = exports.onScroll = exports.onMirrorMove = exports.onMirrorCreated = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_89334__(4);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _MirrorEvent = __nested_webpack_require_89334__(26);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\r\n\r\nconst onDragStart = exports.onDragStart = Symbol('onDragStart');\r\nconst onDragMove = exports.onDragMove = Symbol('onDragMove');\r\nconst onDragStop = exports.onDragStop = Symbol('onDragStop');\r\nconst onMirrorCreated = exports.onMirrorCreated = Symbol('onMirrorCreated');\r\nconst onMirrorMove = exports.onMirrorMove = Symbol('onMirrorMove');\r\nconst onScroll = exports.onScroll = Symbol('onScroll');\r\nconst getAppendableContainer = exports.getAppendableContainer = Symbol('getAppendableContainer');\r\n\r\n/**\r\n * Mirror default options\r\n * @property {Object} defaultOptions\r\n * @property {Boolean} defaultOptions.constrainDimensions\r\n * @property {Boolean} defaultOptions.xAxis\r\n * @property {Boolean} defaultOptions.yAxis\r\n * @property {null} defaultOptions.cursorOffsetX\r\n * @property {null} defaultOptions.cursorOffsetY\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  constrainDimensions: false,\r\n  xAxis: true,\r\n  yAxis: true,\r\n  cursorOffsetX: null,\r\n  cursorOffsetY: null,\r\n  thresholdX: null,\r\n  thresholdY: null\r\n};\r\n\r\n/**\r\n * Mirror plugin which controls the mirror positioning while dragging\r\n * @class Mirror\r\n * @module Mirror\r\n * @extends AbstractPlugin\r\n */\r\nclass Mirror extends _AbstractPlugin2.default {\r\n  /**\r\n   * Mirror constructor.\r\n   * @constructs Mirror\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Mirror options\r\n     * @property {Object} options\r\n     * @property {Boolean} options.constrainDimensions\r\n     * @property {Boolean} options.xAxis\r\n     * @property {Boolean} options.yAxis\r\n     * @property {Number|null} options.cursorOffsetX\r\n     * @property {Number|null} options.cursorOffsetY\r\n     * @property {String|HTMLElement|Function} options.appendTo\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Scroll offset for touch devices because the mirror is positioned fixed\r\n     * @property {Object} scrollOffset\r\n     * @property {Number} scrollOffset.x\r\n     * @property {Number} scrollOffset.y\r\n     */\r\n    this.scrollOffset = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Initial scroll offset for touch devices because the mirror is positioned fixed\r\n     * @property {Object} scrollOffset\r\n     * @property {Number} scrollOffset.x\r\n     * @property {Number} scrollOffset.y\r\n     */\r\n    this.initialScrollOffset = {\r\n      x: window.scrollX,\r\n      y: window.scrollY\r\n    };\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\r\n    this[onMirrorMove] = this[onMirrorMove].bind(this);\r\n    this[onScroll] = this[onScroll].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]).on('mirror:created', this[onMirrorCreated]).on('mirror:move', this[onMirrorMove]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]).off('mirror:created', this[onMirrorCreated]).off('mirror:move', this[onMirrorMove]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.mirror || {};\r\n  }\r\n\r\n  [onDragStart](dragEvent) {\r\n    if (dragEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    if ('ontouchstart' in window) {\r\n      document.addEventListener('scroll', this[onScroll], true);\r\n    }\r\n\r\n    this.initialScrollOffset = {\r\n      x: window.scrollX,\r\n      y: window.scrollY\r\n    };\r\n\r\n    const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    // Last sensor position of mirror move\r\n    this.lastMirrorMovedClient = {\r\n      x: sensorEvent.clientX,\r\n      y: sensorEvent.clientY\r\n    };\r\n\r\n    const mirrorCreateEvent = new _MirrorEvent.MirrorCreateEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent\r\n    });\r\n\r\n    this.draggable.trigger(mirrorCreateEvent);\r\n\r\n    if (isNativeDragEvent(sensorEvent) || mirrorCreateEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const appendableContainer = this[getAppendableContainer](source) || sourceContainer;\r\n    this.mirror = source.cloneNode(true);\r\n\r\n    const mirrorCreatedEvent = new _MirrorEvent.MirrorCreatedEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror\r\n    });\r\n\r\n    const mirrorAttachedEvent = new _MirrorEvent.MirrorAttachedEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror\r\n    });\r\n\r\n    this.draggable.trigger(mirrorCreatedEvent);\r\n    appendableContainer.appendChild(this.mirror);\r\n    this.draggable.trigger(mirrorAttachedEvent);\r\n  }\r\n\r\n  [onDragMove](dragEvent) {\r\n    if (!this.mirror || dragEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    let passedThreshX = true;\r\n    let passedThreshY = true;\r\n\r\n    if (this.options.thresholdX || this.options.thresholdY) {\r\n      const { x: lastX, y: lastY } = this.lastMirrorMovedClient;\r\n\r\n      if (Math.abs(lastX - sensorEvent.clientX) < this.options.thresholdX) {\r\n        passedThreshX = false;\r\n      } else {\r\n        this.lastMirrorMovedClient.x = sensorEvent.clientX;\r\n      }\r\n\r\n      if (Math.abs(lastY - sensorEvent.clientY) < this.options.thresholdY) {\r\n        passedThreshY = false;\r\n      } else {\r\n        this.lastMirrorMovedClient.y = sensorEvent.clientY;\r\n      }\r\n\r\n      if (!passedThreshX && !passedThreshY) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const mirrorMoveEvent = new _MirrorEvent.MirrorMoveEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror,\r\n      passedThreshX,\r\n      passedThreshY\r\n    });\r\n\r\n    this.draggable.trigger(mirrorMoveEvent);\r\n  }\r\n\r\n  [onDragStop](dragEvent) {\r\n    if ('ontouchstart' in window) {\r\n      document.removeEventListener('scroll', this[onScroll], true);\r\n    }\r\n\r\n    this.initialScrollOffset = { x: 0, y: 0 };\r\n    this.scrollOffset = { x: 0, y: 0 };\r\n\r\n    if (!this.mirror) {\r\n      return;\r\n    }\r\n\r\n    const { source, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    const mirrorDestroyEvent = new _MirrorEvent.MirrorDestroyEvent({\r\n      source,\r\n      mirror: this.mirror,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent\r\n    });\r\n\r\n    this.draggable.trigger(mirrorDestroyEvent);\r\n\r\n    if (!mirrorDestroyEvent.canceled()) {\r\n      this.mirror.parentNode.removeChild(this.mirror);\r\n    }\r\n  }\r\n\r\n  [onScroll]() {\r\n    this.scrollOffset = {\r\n      x: window.scrollX - this.initialScrollOffset.x,\r\n      y: window.scrollY - this.initialScrollOffset.y\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Mirror created handler\r\n   * @param {MirrorCreatedEvent} mirrorEvent\r\n   * @return {Promise}\r\n   * @private\r\n   */\r\n  [onMirrorCreated]({ mirror, source, sensorEvent }) {\r\n    const mirrorClasses = this.draggable.getClassNamesFor('mirror');\r\n\r\n    const setState = (_ref) => {\r\n      let { mirrorOffset, initialX, initialY } = _ref,\r\n          args = _objectWithoutProperties(_ref, ['mirrorOffset', 'initialX', 'initialY']);\r\n\r\n      this.mirrorOffset = mirrorOffset;\r\n      this.initialX = initialX;\r\n      this.initialY = initialY;\r\n      this.lastMovedX = initialX;\r\n      this.lastMovedY = initialY;\r\n      return _extends({ mirrorOffset, initialX, initialY }, args);\r\n    };\r\n\r\n    mirror.style.display = 'none';\r\n\r\n    const initialState = {\r\n      mirror,\r\n      source,\r\n      sensorEvent,\r\n      mirrorClasses,\r\n      scrollOffset: this.scrollOffset,\r\n      options: this.options,\r\n      passedThreshX: true,\r\n      passedThreshY: true\r\n    };\r\n\r\n    return Promise.resolve(initialState)\r\n    // Fix reflow here\r\n    .then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({ initial: true })).then(removeMirrorID).then(setState);\r\n  }\r\n\r\n  /**\r\n   * Mirror move handler\r\n   * @param {MirrorMoveEvent} mirrorEvent\r\n   * @return {Promise|null}\r\n   * @private\r\n   */\r\n  [onMirrorMove](mirrorEvent) {\r\n    if (mirrorEvent.canceled()) {\r\n      return null;\r\n    }\r\n\r\n    const setState = (_ref2) => {\r\n      let { lastMovedX, lastMovedY } = _ref2,\r\n          args = _objectWithoutProperties(_ref2, ['lastMovedX', 'lastMovedY']);\r\n\r\n      this.lastMovedX = lastMovedX;\r\n      this.lastMovedY = lastMovedY;\r\n\r\n      return _extends({ lastMovedX, lastMovedY }, args);\r\n    };\r\n\r\n    const initialState = {\r\n      mirror: mirrorEvent.mirror,\r\n      sensorEvent: mirrorEvent.sensorEvent,\r\n      mirrorOffset: this.mirrorOffset,\r\n      options: this.options,\r\n      initialX: this.initialX,\r\n      initialY: this.initialY,\r\n      scrollOffset: this.scrollOffset,\r\n      passedThreshX: mirrorEvent.passedThreshX,\r\n      passedThreshY: mirrorEvent.passedThreshY,\r\n      lastMovedX: this.lastMovedX,\r\n      lastMovedY: this.lastMovedY\r\n    };\r\n\r\n    return Promise.resolve(initialState).then(positionMirror({ raf: true })).then(setState);\r\n  }\r\n\r\n  /**\r\n   * Returns appendable container for mirror based on the appendTo option\r\n   * @private\r\n   * @param {Object} options\r\n   * @param {HTMLElement} options.source - Current source\r\n   * @return {HTMLElement}\r\n   */\r\n  [getAppendableContainer](source) {\r\n    const appendTo = this.options.appendTo;\r\n\r\n    if (typeof appendTo === 'string') {\r\n      return document.querySelector(appendTo);\r\n    } else if (appendTo instanceof HTMLElement) {\r\n      return appendTo;\r\n    } else if (typeof appendTo === 'function') {\r\n      return appendTo(source);\r\n    } else {\r\n      return source.parentNode;\r\n    }\r\n  }\r\n}\r\n\r\nexports.default = Mirror; /**\r\n                           * Computes mirror dimensions based on the source element\r\n                           * Adds sourceRect to state\r\n                           * @param {Object} state\r\n                           * @param {HTMLElement} state.source\r\n                           * @return {Promise}\r\n                           * @private\r\n                           */\r\n\r\nfunction computeMirrorDimensions(_ref3) {\r\n  let { source } = _ref3,\r\n      args = _objectWithoutProperties(_ref3, ['source']);\r\n\r\n  return withPromise(resolve => {\r\n    const sourceRect = source.getBoundingClientRect();\r\n    resolve(_extends({ source, sourceRect }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Calculates mirror offset\r\n * Adds mirrorOffset to state\r\n * @param {Object} state\r\n * @param {SensorEvent} state.sensorEvent\r\n * @param {DOMRect} state.sourceRect\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction calculateMirrorOffset(_ref4) {\r\n  let { sensorEvent, sourceRect, options } = _ref4,\r\n      args = _objectWithoutProperties(_ref4, ['sensorEvent', 'sourceRect', 'options']);\r\n\r\n  return withPromise(resolve => {\r\n    const top = options.cursorOffsetY === null ? sensorEvent.clientY - sourceRect.top : options.cursorOffsetY;\r\n    const left = options.cursorOffsetX === null ? sensorEvent.clientX - sourceRect.left : options.cursorOffsetX;\r\n\r\n    const mirrorOffset = { top, left };\r\n\r\n    resolve(_extends({ sensorEvent, sourceRect, mirrorOffset, options }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Applys mirror styles\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {HTMLElement} state.source\r\n * @param {Object} state.options\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction resetMirror(_ref5) {\r\n  let { mirror, source, options } = _ref5,\r\n      args = _objectWithoutProperties(_ref5, ['mirror', 'source', 'options']);\r\n\r\n  return withPromise(resolve => {\r\n    let offsetHeight;\r\n    let offsetWidth;\r\n\r\n    if (options.constrainDimensions) {\r\n      const computedSourceStyles = getComputedStyle(source);\r\n      offsetHeight = computedSourceStyles.getPropertyValue('height');\r\n      offsetWidth = computedSourceStyles.getPropertyValue('width');\r\n    }\r\n\r\n    mirror.style.display = null;\r\n    mirror.style.position = 'fixed';\r\n    mirror.style.pointerEvents = 'none';\r\n    mirror.style.top = 0;\r\n    mirror.style.left = 0;\r\n    mirror.style.margin = 0;\r\n\r\n    if (options.constrainDimensions) {\r\n      mirror.style.height = offsetHeight;\r\n      mirror.style.width = offsetWidth;\r\n    }\r\n\r\n    resolve(_extends({ mirror, source, options }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Applys mirror class on mirror element\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {String[]} state.mirrorClasses\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction addMirrorClasses(_ref6) {\r\n  let { mirror, mirrorClasses } = _ref6,\r\n      args = _objectWithoutProperties(_ref6, ['mirror', 'mirrorClasses']);\r\n\r\n  return withPromise(resolve => {\r\n    mirror.classList.add(...mirrorClasses);\r\n    resolve(_extends({ mirror, mirrorClasses }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Removes source ID from cloned mirror element\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction removeMirrorID(_ref7) {\r\n  let { mirror } = _ref7,\r\n      args = _objectWithoutProperties(_ref7, ['mirror']);\r\n\r\n  return withPromise(resolve => {\r\n    mirror.removeAttribute('id');\r\n    delete mirror.id;\r\n    resolve(_extends({ mirror }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Positions mirror with translate3d\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {SensorEvent} state.sensorEvent\r\n * @param {Object} state.mirrorOffset\r\n * @param {Number} state.initialY\r\n * @param {Number} state.initialX\r\n * @param {Object} state.options\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction positionMirror({ withFrame = false, initial = false } = {}) {\r\n  return (_ref8) => {\r\n    let {\r\n      mirror,\r\n      sensorEvent,\r\n      mirrorOffset,\r\n      initialY,\r\n      initialX,\r\n      scrollOffset,\r\n      options,\r\n      passedThreshX,\r\n      passedThreshY,\r\n      lastMovedX,\r\n      lastMovedY\r\n    } = _ref8,\r\n        args = _objectWithoutProperties(_ref8, ['mirror', 'sensorEvent', 'mirrorOffset', 'initialY', 'initialX', 'scrollOffset', 'options', 'passedThreshX', 'passedThreshY', 'lastMovedX', 'lastMovedY']);\r\n\r\n    return withPromise(resolve => {\r\n      const result = _extends({\r\n        mirror,\r\n        sensorEvent,\r\n        mirrorOffset,\r\n        options\r\n      }, args);\r\n\r\n      if (mirrorOffset) {\r\n        const x = passedThreshX ? Math.round((sensorEvent.clientX - mirrorOffset.left - scrollOffset.x) / (options.thresholdX || 1)) * (options.thresholdX || 1) : Math.round(lastMovedX);\r\n        const y = passedThreshY ? Math.round((sensorEvent.clientY - mirrorOffset.top - scrollOffset.y) / (options.thresholdY || 1)) * (options.thresholdY || 1) : Math.round(lastMovedY);\r\n\r\n        if (options.xAxis && options.yAxis || initial) {\r\n          mirror.style.transform = `translate3d(${x}px, ${y}px, 0)`;\r\n        } else if (options.xAxis && !options.yAxis) {\r\n          mirror.style.transform = `translate3d(${x}px, ${initialY}px, 0)`;\r\n        } else if (options.yAxis && !options.xAxis) {\r\n          mirror.style.transform = `translate3d(${initialX}px, ${y}px, 0)`;\r\n        }\r\n\r\n        if (initial) {\r\n          result.initialX = x;\r\n          result.initialY = y;\r\n        }\r\n\r\n        result.lastMovedX = x;\r\n        result.lastMovedY = y;\r\n      }\r\n\r\n      resolve(result);\r\n    }, { frame: withFrame });\r\n  };\r\n}\r\n\r\n/**\r\n * Wraps functions in promise with potential animation frame option\r\n * @param {Function} callback\r\n * @param {Object} options\r\n * @param {Boolean} options.raf\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction withPromise(callback, { raf = false } = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    if (raf) {\r\n      requestAnimationFrame(() => {\r\n        callback(resolve, reject);\r\n      });\r\n    } else {\r\n      callback(resolve, reject);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Returns true if the sensor event was triggered by a native browser drag event\r\n * @param {SensorEvent} sensorEvent\r\n */\r\nfunction isNativeDragEvent(sensorEvent) {\r\n  return (/^drag/.test(sensorEvent.originalEvent.type)\r\n  );\r\n}\r\n\r\n/***/ }),\r\n/* 28 */\r\n/***/ (function(module, exports, __nested_webpack_require_106848__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Mirror = __nested_webpack_require_106848__(27);\r\n\r\nvar _Mirror2 = _interopRequireDefault(_Mirror);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Mirror2.default;\r\nexports.defaultOptions = _Mirror.defaultOptions;\r\n\r\n/***/ }),\r\n/* 29 */\r\n/***/ (function(module, exports, __nested_webpack_require_107335__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_107335__(4);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onInitialize = Symbol('onInitialize');\r\nconst onDestroy = Symbol('onDestroy');\r\n\r\n/**\r\n * Focusable default options\r\n * @property {Object} defaultOptions\r\n * @type {Object}\r\n */\r\nconst defaultOptions = {};\r\n\r\n/**\r\n * Focusable plugin\r\n * @class Focusable\r\n * @module Focusable\r\n * @extends AbstractPlugin\r\n */\r\nclass Focusable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Focusable constructor.\r\n   * @constructs Focusable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Focusable options\r\n     * @property {Object} options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    this[onInitialize] = this[onInitialize].bind(this);\r\n    this[onDestroy] = this[onDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches listeners to draggable\r\n   */\r\n  attach() {\r\n    this.draggable.on('draggable:initialize', this[onInitialize]).on('draggable:destroy', this[onDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Detaches listeners from draggable\r\n   */\r\n  detach() {\r\n    this.draggable.off('draggable:initialize', this[onInitialize]).off('draggable:destroy', this[onDestroy]);\r\n\r\n    // Remove modified elements when detach\r\n    this[onDestroy]();\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.focusable || {};\r\n  }\r\n\r\n  /**\r\n   * Returns draggable containers and elements\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getElements() {\r\n    return [...this.draggable.containers, ...this.draggable.getDraggableElements()];\r\n  }\r\n\r\n  /**\r\n   * Intialize handler\r\n   * @private\r\n   */\r\n  [onInitialize]() {\r\n    // Can wait until the next best frame is available\r\n    requestAnimationFrame(() => {\r\n      this.getElements().forEach(element => decorateElement(element));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Destroy handler\r\n   * @private\r\n   */\r\n  [onDestroy]() {\r\n    // Can wait until the next best frame is available\r\n    requestAnimationFrame(() => {\r\n      this.getElements().forEach(element => stripElement(element));\r\n    });\r\n  }\r\n}\r\n\r\nexports.default = Focusable; /**\r\n                              * Keeps track of all the elements that are missing tabindex attributes\r\n                              * so they can be reset when draggable gets destroyed\r\n                              * @const {HTMLElement[]} elementsWithMissingTabIndex\r\n                              */\r\n\r\nconst elementsWithMissingTabIndex = [];\r\n\r\n/**\r\n * Decorates element with tabindex attributes\r\n * @param {HTMLElement} element\r\n * @return {Object}\r\n * @private\r\n */\r\nfunction decorateElement(element) {\r\n  const hasMissingTabIndex = Boolean(!element.getAttribute('tabindex') && element.tabIndex === -1);\r\n\r\n  if (hasMissingTabIndex) {\r\n    elementsWithMissingTabIndex.push(element);\r\n    element.tabIndex = 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Removes elements tabindex attributes\r\n * @param {HTMLElement} element\r\n * @private\r\n */\r\nfunction stripElement(element) {\r\n  const tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);\r\n\r\n  if (tabIndexElementPosition !== -1) {\r\n    element.tabIndex = -1;\r\n    elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);\r\n  }\r\n}\r\n\r\n/***/ }),\r\n/* 30 */\r\n/***/ (function(module, exports, __nested_webpack_require_111247__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Focusable = __nested_webpack_require_111247__(29);\r\n\r\nvar _Focusable2 = _interopRequireDefault(_Focusable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Focusable2.default;\r\n\r\n/***/ }),\r\n/* 31 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * All draggable plugins inherit from this class.\r\n * @abstract\r\n * @class AbstractPlugin\r\n * @module AbstractPlugin\r\n */\r\nclass AbstractPlugin {\r\n  /**\r\n   * AbstractPlugin constructor.\r\n   * @constructs AbstractPlugin\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    /**\r\n     * Draggable instance\r\n     * @property draggable\r\n     * @type {Draggable}\r\n     */\r\n    this.draggable = draggable;\r\n  }\r\n\r\n  /**\r\n   * Override to add listeners\r\n   * @abstract\r\n   */\r\n  attach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n\r\n  /**\r\n   * Override to remove listeners\r\n   * @abstract\r\n   */\r\n  detach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n}\r\nexports.default = AbstractPlugin;\r\n\r\n/***/ }),\r\n/* 32 */\r\n/***/ (function(module, exports, __nested_webpack_require_112571__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_112571__(4);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onInitialize = Symbol('onInitialize');\r\nconst onDestroy = Symbol('onDestroy');\r\nconst announceEvent = Symbol('announceEvent');\r\nconst announceMessage = Symbol('announceMessage');\r\n\r\nconst ARIA_RELEVANT = 'aria-relevant';\r\nconst ARIA_ATOMIC = 'aria-atomic';\r\nconst ARIA_LIVE = 'aria-live';\r\nconst ROLE = 'role';\r\n\r\n/**\r\n * Announcement default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.expire\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  expire: 7000\r\n};\r\n\r\n/**\r\n * Announcement plugin\r\n * @class Announcement\r\n * @module Announcement\r\n * @extends AbstractPlugin\r\n */\r\nclass Announcement extends _AbstractPlugin2.default {\r\n  /**\r\n   * Announcement constructor.\r\n   * @constructs Announcement\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Plugin options\r\n     * @property options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Original draggable trigger method. Hack until we have onAll or on('all')\r\n     * @property originalTriggerMethod\r\n     * @type {Function}\r\n     */\r\n    this.originalTriggerMethod = this.draggable.trigger;\r\n\r\n    this[onInitialize] = this[onInitialize].bind(this);\r\n    this[onDestroy] = this[onDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches listeners to draggable\r\n   */\r\n  attach() {\r\n    this.draggable.on('draggable:initialize', this[onInitialize]);\r\n  }\r\n\r\n  /**\r\n   * Detaches listeners from draggable\r\n   */\r\n  detach() {\r\n    this.draggable.off('draggable:destroy', this[onDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Returns passed in options\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.announcements || {};\r\n  }\r\n\r\n  /**\r\n   * Announces event\r\n   * @private\r\n   * @param {AbstractEvent} event\r\n   */\r\n  [announceEvent](event) {\r\n    const message = this.options[event.type];\r\n\r\n    if (message && typeof message === 'string') {\r\n      this[announceMessage](message);\r\n    }\r\n\r\n    if (message && typeof message === 'function') {\r\n      this[announceMessage](message(event));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Announces message to screen reader\r\n   * @private\r\n   * @param {String} message\r\n   */\r\n  [announceMessage](message) {\r\n    announce(message, { expire: this.options.expire });\r\n  }\r\n\r\n  /**\r\n   * Initialize hander\r\n   * @private\r\n   */\r\n  [onInitialize]() {\r\n    // Hack until there is an api for listening for all events\r\n    this.draggable.trigger = event => {\r\n      try {\r\n        this[announceEvent](event);\r\n      } finally {\r\n        // Ensure that original trigger is called\r\n        this.originalTriggerMethod.call(this.draggable, event);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Destroy hander\r\n   * @private\r\n   */\r\n  [onDestroy]() {\r\n    this.draggable.trigger = this.originalTriggerMethod;\r\n  }\r\n}\r\n\r\nexports.default = Announcement; /**\r\n                                 * @const {HTMLElement} liveRegion\r\n                                 */\r\n\r\nconst liveRegion = createRegion();\r\n\r\n/**\r\n * Announces message via live region\r\n * @param {String} message\r\n * @param {Object} options\r\n * @param {Number} options.expire\r\n */\r\nfunction announce(message, { expire }) {\r\n  const element = document.createElement('div');\r\n\r\n  element.textContent = message;\r\n  liveRegion.appendChild(element);\r\n\r\n  return setTimeout(() => {\r\n    liveRegion.removeChild(element);\r\n  }, expire);\r\n}\r\n\r\n/**\r\n * Creates region element\r\n * @return {HTMLElement}\r\n */\r\nfunction createRegion() {\r\n  const element = document.createElement('div');\r\n\r\n  element.setAttribute('id', 'draggable-live-region');\r\n  element.setAttribute(ARIA_RELEVANT, 'additions');\r\n  element.setAttribute(ARIA_ATOMIC, 'true');\r\n  element.setAttribute(ARIA_LIVE, 'assertive');\r\n  element.setAttribute(ROLE, 'log');\r\n\r\n  element.style.position = 'fixed';\r\n  element.style.width = '1px';\r\n  element.style.height = '1px';\r\n  element.style.top = '-1px';\r\n  element.style.overflow = 'hidden';\r\n\r\n  return element;\r\n}\r\n\r\n// Append live region element as early as possible\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  document.body.appendChild(liveRegion);\r\n});\r\n\r\n/***/ }),\r\n/* 33 */\r\n/***/ (function(module, exports, __nested_webpack_require_117459__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Announcement = __nested_webpack_require_117459__(32);\r\n\r\nvar _Announcement2 = _interopRequireDefault(_Announcement);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Announcement2.default;\r\nexports.defaultOptions = _Announcement.defaultOptions;\r\n\r\n/***/ }),\r\n/* 34 */\r\n/***/ (function(module, exports, __nested_webpack_require_117976__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DraggableDestroyEvent = exports.DraggableInitializedEvent = exports.DraggableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_117976__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base draggable event\r\n * @class DraggableEvent\r\n * @module DraggableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DraggableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Draggable instance\r\n   * @property draggable\r\n   * @type {Draggable}\r\n   * @readonly\r\n   */\r\n  get draggable() {\r\n    return this.data.draggable;\r\n  }\r\n}\r\n\r\nexports.DraggableEvent = DraggableEvent; /**\r\n                                          * Draggable initialized event\r\n                                          * @class DraggableInitializedEvent\r\n                                          * @module DraggableInitializedEvent\r\n                                          * @extends DraggableEvent\r\n                                          */\r\n\r\nDraggableEvent.type = 'draggable';\r\nclass DraggableInitializedEvent extends DraggableEvent {}\r\n\r\nexports.DraggableInitializedEvent = DraggableInitializedEvent; /**\r\n                                                                * Draggable destory event\r\n                                                                * @class DraggableInitializedEvent\r\n                                                                * @module DraggableDestroyEvent\r\n                                                                * @extends DraggableDestroyEvent\r\n                                                                */\r\n\r\nDraggableInitializedEvent.type = 'draggable:initialize';\r\nclass DraggableDestroyEvent extends DraggableEvent {}\r\nexports.DraggableDestroyEvent = DraggableDestroyEvent;\r\nDraggableDestroyEvent.type = 'draggable:destroy';\r\n\r\n/***/ }),\r\n/* 35 */\r\n/***/ (function(module, exports, __nested_webpack_require_120040__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DragStoppedEvent = exports.DragStopEvent = exports.DragPressureEvent = exports.DragOutContainerEvent = exports.DragOverContainerEvent = exports.DragOutEvent = exports.DragOverEvent = exports.DragMoveEvent = exports.DragStartEvent = exports.DragEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_120040__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base drag event\r\n * @class DragEvent\r\n * @module DragEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DragEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Draggables source element\r\n   * @property source\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get source() {\r\n    return this.data.source;\r\n  }\r\n\r\n  /**\r\n   * Draggables original source element\r\n   * @property originalSource\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get originalSource() {\r\n    return this.data.originalSource;\r\n  }\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n\r\n  /**\r\n   * Draggables source container element\r\n   * @property sourceContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get sourceContainer() {\r\n    return this.data.sourceContainer;\r\n  }\r\n\r\n  /**\r\n   * Sensor event\r\n   * @property sensorEvent\r\n   * @type {SensorEvent}\r\n   * @readonly\r\n   */\r\n  get sensorEvent() {\r\n    return this.data.sensorEvent;\r\n  }\r\n\r\n  /**\r\n   * Original event that triggered sensor event\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    if (this.sensorEvent) {\r\n      return this.sensorEvent.originalEvent;\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexports.DragEvent = DragEvent; /**\r\n                                * Drag start event\r\n                                * @class DragStartEvent\r\n                                * @module DragStartEvent\r\n                                * @extends DragEvent\r\n                                */\r\n\r\nDragEvent.type = 'drag';\r\nclass DragStartEvent extends DragEvent {}\r\n\r\nexports.DragStartEvent = DragStartEvent; /**\r\n                                          * Drag move event\r\n                                          * @class DragMoveEvent\r\n                                          * @module DragMoveEvent\r\n                                          * @extends DragEvent\r\n                                          */\r\n\r\nDragStartEvent.type = 'drag:start';\r\nDragStartEvent.cancelable = true;\r\nclass DragMoveEvent extends DragEvent {}\r\n\r\nexports.DragMoveEvent = DragMoveEvent; /**\r\n                                        * Drag over event\r\n                                        * @class DragOverEvent\r\n                                        * @module DragOverEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragMoveEvent.type = 'drag:move';\r\nclass DragOverEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you are over\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n}\r\n\r\nexports.DragOverEvent = DragOverEvent; /**\r\n                                        * Drag out event\r\n                                        * @class DragOutEvent\r\n                                        * @module DragOutEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragOverEvent.type = 'drag:over';\r\nDragOverEvent.cancelable = true;\r\nclass DragOutEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you left\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n}\r\n\r\nexports.DragOutEvent = DragOutEvent; /**\r\n                                      * Drag over container event\r\n                                      * @class DragOverContainerEvent\r\n                                      * @module DragOverContainerEvent\r\n                                      * @extends DragEvent\r\n                                      */\r\n\r\nDragOutEvent.type = 'drag:out';\r\nclass DragOverContainerEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.DragOverContainerEvent = DragOverContainerEvent; /**\r\n                                                          * Drag out container event\r\n                                                          * @class DragOutContainerEvent\r\n                                                          * @module DragOutContainerEvent\r\n                                                          * @extends DragEvent\r\n                                                          */\r\n\r\nDragOverContainerEvent.type = 'drag:over:container';\r\nclass DragOutContainerEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you left\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.DragOutContainerEvent = DragOutContainerEvent; /**\r\n                                                        * Drag pressure event\r\n                                                        * @class DragPressureEvent\r\n                                                        * @module DragPressureEvent\r\n                                                        * @extends DragEvent\r\n                                                        */\r\n\r\nDragOutContainerEvent.type = 'drag:out:container';\r\nclass DragPressureEvent extends DragEvent {\r\n\r\n  /**\r\n   * Pressure applied on draggable element\r\n   * @property pressure\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get pressure() {\r\n    return this.data.pressure;\r\n  }\r\n}\r\n\r\nexports.DragPressureEvent = DragPressureEvent; /**\r\n                                                * Drag stop event\r\n                                                * @class DragStopEvent\r\n                                                * @module DragStopEvent\r\n                                                * @extends DragEvent\r\n                                                */\r\n\r\nDragPressureEvent.type = 'drag:pressure';\r\nclass DragStopEvent extends DragEvent {}\r\n\r\nexports.DragStopEvent = DragStopEvent; /**\r\n                                        * Drag stopped event\r\n                                        * @class DragStoppedEvent\r\n                                        * @module DragStoppedEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragStopEvent.type = 'drag:stop';\r\nclass DragStoppedEvent extends DragEvent {}\r\nexports.DragStoppedEvent = DragStoppedEvent;\r\nDragStoppedEvent.type = 'drag:stopped';\r\n\r\n/***/ }),\r\n/* 36 */\r\n/***/ (function(module, exports, __nested_webpack_require_127565__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragEvent = __nested_webpack_require_127565__(8);\r\n\r\nObject.keys(_DragEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DragEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _DraggableEvent = __nested_webpack_require_127565__(7);\r\n\r\nObject.keys(_DraggableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DraggableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Plugins = __nested_webpack_require_127565__(6);\r\n\r\nObject.keys(_Plugins).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _Plugins[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Sensors = __nested_webpack_require_127565__(5);\r\n\r\nObject.keys(_Sensors).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _Sensors[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Draggable = __nested_webpack_require_127565__(12);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Draggable2.default;\r\n\r\n/***/ }),\r\n/* 37 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = touchCoords;\r\n/**\r\n * Returns the first touch event found in touches or changedTouches of a touch events.\r\n * @param {TouchEvent} event a touch event\r\n * @return {Touch} a touch object\r\n */\r\nfunction touchCoords(event = {}) {\r\n  const { touches, changedTouches } = event;\r\n  return touches && touches[0] || changedTouches && changedTouches[0];\r\n}\r\n\r\n/***/ }),\r\n/* 38 */\r\n/***/ (function(module, exports, __nested_webpack_require_129683__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_129683__(37);\r\n\r\nvar _touchCoords2 = _interopRequireDefault(_touchCoords);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _touchCoords2.default;\r\n\r\n/***/ }),\r\n/* 39 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = distance;\r\n/**\r\n * Returns the distance between two points\r\n * @param  {Number} x1 The X position of the first point\r\n * @param  {Number} y1 The Y position of the first point\r\n * @param  {Number} x2 The X position of the second point\r\n * @param  {Number} y2 The Y position of the second point\r\n * @return {Number}\r\n */\r\nfunction distance(x1, y1, x2, y2) {\r\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\r\n}\r\n\r\n/***/ }),\r\n/* 40 */\r\n/***/ (function(module, exports, __nested_webpack_require_130704__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _distance = __nested_webpack_require_130704__(39);\r\n\r\nvar _distance2 = _interopRequireDefault(_distance);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _distance2.default;\r\n\r\n/***/ }),\r\n/* 41 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = requestNextAnimationFrame;\r\nfunction requestNextAnimationFrame(callback) {\r\n  return requestAnimationFrame(() => {\r\n    requestAnimationFrame(callback);\r\n  });\r\n}\r\n\r\n/***/ }),\r\n/* 42 */\r\n/***/ (function(module, exports, __nested_webpack_require_131463__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_131463__(41);\r\n\r\nvar _requestNextAnimationFrame2 = _interopRequireDefault(_requestNextAnimationFrame);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _requestNextAnimationFrame2.default;\r\n\r\n/***/ }),\r\n/* 43 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = closest;\r\nconst matchFunction = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector;\r\n\r\n/**\r\n * Get the closest parent element of a given element that matches the given\r\n * selector string or matching function\r\n *\r\n * @param {Element} element The child element to find a parent of\r\n * @param {String|Function} selector The string or function to use to match\r\n *     the parent element\r\n * @return {Element|null}\r\n */\r\nfunction closest(element, value) {\r\n  if (!element) {\r\n    return null;\r\n  }\r\n\r\n  const selector = value;\r\n  const callback = value;\r\n  const nodeList = value;\r\n  const singleElement = value;\r\n\r\n  const isSelector = Boolean(typeof value === 'string');\r\n  const isFunction = Boolean(typeof value === 'function');\r\n  const isNodeList = Boolean(value instanceof NodeList || value instanceof Array);\r\n  const isElement = Boolean(value instanceof HTMLElement);\r\n\r\n  function conditionFn(currentElement) {\r\n    if (!currentElement) {\r\n      return currentElement;\r\n    } else if (isSelector) {\r\n      return matchFunction.call(currentElement, selector);\r\n    } else if (isNodeList) {\r\n      return [...nodeList].includes(currentElement);\r\n    } else if (isElement) {\r\n      return singleElement === currentElement;\r\n    } else if (isFunction) {\r\n      return callback(currentElement);\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  let current = element;\r\n\r\n  do {\r\n    current = current.correspondingUseElement || current.correspondingElement || current;\r\n\r\n    if (conditionFn(current)) {\r\n      return current;\r\n    }\r\n\r\n    current = current.parentNode;\r\n  } while (current && current !== document.body && current !== document);\r\n\r\n  return null;\r\n}\r\n\r\n/***/ }),\r\n/* 44 */\r\n/***/ (function(module, exports, __nested_webpack_require_133893__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_133893__(43);\r\n\r\nvar _closest2 = _interopRequireDefault(_closest);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _closest2.default;\r\n\r\n/***/ }),\r\n/* 45 */\r\n/***/ (function(module, exports, __nested_webpack_require_134297__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _utils = __nested_webpack_require_134297__(0);\r\n\r\nvar _Draggable = __nested_webpack_require_134297__(36);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nvar _DroppableEvent = __nested_webpack_require_134297__(9);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragMove = Symbol('onDragMove');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst dropInDropzone = Symbol('dropInDropZone');\r\nconst returnToOriginalDropzone = Symbol('returnToOriginalDropzone');\r\nconst closestDropzone = Symbol('closestDropzone');\r\nconst getDropzones = Symbol('getDropzones');\r\n\r\n/**\r\n * Returns an announcement message when the Draggable element is dropped into a dropzone element\r\n * @param {DroppableDroppedEvent} droppableEvent\r\n * @return {String}\r\n */\r\nfunction onDroppableDroppedDefaultAnnouncement({ dragEvent, dropzone }) {\r\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'draggable element';\r\n  const dropzoneText = dropzone.textContent.trim() || dropzone.id || 'droppable element';\r\n\r\n  return `Dropped ${sourceText} into ${dropzoneText}`;\r\n}\r\n\r\n/**\r\n * Returns an announcement message when the Draggable element has returned to its original dropzone element\r\n * @param {DroppableReturnedEvent} droppableEvent\r\n * @return {String}\r\n */\r\nfunction onDroppableReturnedDefaultAnnouncement({ dragEvent, dropzone }) {\r\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'draggable element';\r\n  const dropzoneText = dropzone.textContent.trim() || dropzone.id || 'droppable element';\r\n\r\n  return `Returned ${sourceText} from ${dropzoneText}`;\r\n}\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['droppable:dropped']\r\n * @const {Function} defaultAnnouncements['droppable:returned']\r\n */\r\nconst defaultAnnouncements = {\r\n  'droppable:dropped': onDroppableDroppedDefaultAnnouncement,\r\n  'droppable:returned': onDroppableReturnedDefaultAnnouncement\r\n};\r\n\r\nconst defaultClasses = {\r\n  'droppable:active': 'draggable-dropzone--active',\r\n  'droppable:occupied': 'draggable-dropzone--occupied'\r\n};\r\n\r\nconst defaultOptions = {\r\n  dropzone: '.draggable-droppable'\r\n};\r\n\r\n/**\r\n * Droppable is built on top of Draggable and allows dropping draggable elements\r\n * into dropzone element\r\n * @class Droppable\r\n * @module Droppable\r\n * @extends Draggable\r\n */\r\nclass Droppable extends _Draggable2.default {\r\n  /**\r\n   * Droppable constructor.\r\n   * @constructs Droppable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Droppable containers\r\n   * @param {Object} options - Options for Droppable\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, _extends({}, defaultOptions, options, {\r\n      classes: _extends({}, defaultClasses, options.classes || {}),\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {})\r\n    }));\r\n\r\n    /**\r\n     * All dropzone elements on drag start\r\n     * @property dropzones\r\n     * @type {HTMLElement[]}\r\n     */\r\n    this.dropzones = null;\r\n\r\n    /**\r\n     * Last dropzone element that the source was dropped into\r\n     * @property lastDropzone\r\n     * @type {HTMLElement}\r\n     */\r\n    this.lastDropzone = null;\r\n\r\n    /**\r\n     * Initial dropzone element that the source was drag from\r\n     * @property initialDropzone\r\n     * @type {HTMLElement}\r\n     */\r\n    this.initialDropzone = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n\r\n    this.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Destroys Droppable instance.\r\n   */\r\n  destroy() {\r\n    super.destroy();\r\n\r\n    this.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {DragStartEvent} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    this.dropzones = [...this[getDropzones]()];\r\n    const dropzone = (0, _utils.closest)(event.sensorEvent.target, this.options.dropzone);\r\n\r\n    if (!dropzone) {\r\n      event.cancel();\r\n      return;\r\n    }\r\n\r\n    const droppableStartEvent = new _DroppableEvent.DroppableStartEvent({\r\n      dragEvent: event,\r\n      dropzone\r\n    });\r\n\r\n    this.trigger(droppableStartEvent);\r\n\r\n    if (droppableStartEvent.canceled()) {\r\n      event.cancel();\r\n      return;\r\n    }\r\n\r\n    this.initialDropzone = dropzone;\r\n\r\n    for (const dropzoneElement of this.dropzones) {\r\n      if (dropzoneElement.classList.contains(this.getClassNameFor('droppable:occupied'))) {\r\n        continue;\r\n      }\r\n\r\n      dropzoneElement.classList.add(...this.getClassNamesFor('droppable:active'));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag move handler\r\n   * @private\r\n   * @param {DragMoveEvent} event - Drag move event\r\n   */\r\n  [onDragMove](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const dropzone = this[closestDropzone](event.sensorEvent.target);\r\n    const overEmptyDropzone = dropzone && !dropzone.classList.contains(this.getClassNameFor('droppable:occupied'));\r\n\r\n    if (overEmptyDropzone && this[dropInDropzone](event, dropzone)) {\r\n      this.lastDropzone = dropzone;\r\n    } else if ((!dropzone || dropzone === this.initialDropzone) && this.lastDropzone) {\r\n      this[returnToOriginalDropzone](event);\r\n      this.lastDropzone = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop](event) {\r\n    const droppableStopEvent = new _DroppableEvent.DroppableStopEvent({\r\n      dragEvent: event,\r\n      dropzone: this.lastDropzone || this.initialDropzone\r\n    });\r\n\r\n    this.trigger(droppableStopEvent);\r\n\r\n    const occupiedClasses = this.getClassNamesFor('droppable:occupied');\r\n\r\n    for (const dropzone of this.dropzones) {\r\n      dropzone.classList.remove(...this.getClassNamesFor('droppable:active'));\r\n    }\r\n\r\n    if (this.lastDropzone && this.lastDropzone !== this.initialDropzone) {\r\n      this.initialDropzone.classList.remove(...occupiedClasses);\r\n    }\r\n\r\n    this.dropzones = null;\r\n    this.lastDropzone = null;\r\n    this.initialDropzone = null;\r\n  }\r\n\r\n  /**\r\n   * Drops a draggable element into a dropzone element\r\n   * @private\r\n   * @param {DragMoveEvent} event - Drag move event\r\n   * @param {HTMLElement} dropzone - Dropzone element to drop draggable into\r\n   */\r\n  [dropInDropzone](event, dropzone) {\r\n    const droppableDroppedEvent = new _DroppableEvent.DroppableDroppedEvent({\r\n      dragEvent: event,\r\n      dropzone\r\n    });\r\n\r\n    this.trigger(droppableDroppedEvent);\r\n\r\n    if (droppableDroppedEvent.canceled()) {\r\n      return false;\r\n    }\r\n\r\n    const occupiedClasses = this.getClassNamesFor('droppable:occupied');\r\n\r\n    if (this.lastDropzone) {\r\n      this.lastDropzone.classList.remove(...occupiedClasses);\r\n    }\r\n\r\n    dropzone.appendChild(event.source);\r\n    dropzone.classList.add(...occupiedClasses);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Moves the previously dropped element back into its original dropzone\r\n   * @private\r\n   * @param {DragMoveEvent} event - Drag move event\r\n   */\r\n  [returnToOriginalDropzone](event) {\r\n    const droppableReturnedEvent = new _DroppableEvent.DroppableReturnedEvent({\r\n      dragEvent: event,\r\n      dropzone: this.lastDropzone\r\n    });\r\n\r\n    this.trigger(droppableReturnedEvent);\r\n\r\n    if (droppableReturnedEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    this.initialDropzone.appendChild(event.source);\r\n    this.lastDropzone.classList.remove(...this.getClassNamesFor('droppable:occupied'));\r\n  }\r\n\r\n  /**\r\n   * Returns closest dropzone element for even target\r\n   * @private\r\n   * @param {HTMLElement} target - Event target\r\n   * @return {HTMLElement|null}\r\n   */\r\n  [closestDropzone](target) {\r\n    if (!this.dropzones) {\r\n      return null;\r\n    }\r\n\r\n    return (0, _utils.closest)(target, this.dropzones);\r\n  }\r\n\r\n  /**\r\n   * Returns all current dropzone elements for this draggable instance\r\n   * @private\r\n   * @return {NodeList|HTMLElement[]|Array}\r\n   */\r\n  [getDropzones]() {\r\n    const dropzone = this.options.dropzone;\r\n\r\n    if (typeof dropzone === 'string') {\r\n      return document.querySelectorAll(dropzone);\r\n    } else if (dropzone instanceof NodeList || dropzone instanceof Array) {\r\n      return dropzone;\r\n    } else if (typeof dropzone === 'function') {\r\n      return dropzone();\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n}\r\nexports.default = Droppable;\r\n\r\n/***/ }),\r\n/* 46 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst canceled = Symbol('canceled');\r\n\r\n/**\r\n * All events fired by draggable inherit this class. You can call `cancel()` to\r\n * cancel a specific event or you can check if an event has been canceled by\r\n * calling `canceled()`.\r\n * @abstract\r\n * @class AbstractEvent\r\n * @module AbstractEvent\r\n */\r\nclass AbstractEvent {\r\n\r\n  /**\r\n   * AbstractEvent constructor.\r\n   * @constructs AbstractEvent\r\n   * @param {object} data - Event data\r\n   */\r\n\r\n  /**\r\n   * Event type\r\n   * @static\r\n   * @abstract\r\n   * @property type\r\n   * @type {String}\r\n   */\r\n  constructor(data) {\r\n    this[canceled] = false;\r\n    this.data = data;\r\n  }\r\n\r\n  /**\r\n   * Read-only type\r\n   * @abstract\r\n   * @return {String}\r\n   */\r\n\r\n\r\n  /**\r\n   * Event cancelable\r\n   * @static\r\n   * @abstract\r\n   * @property cancelable\r\n   * @type {Boolean}\r\n   */\r\n  get type() {\r\n    return this.constructor.type;\r\n  }\r\n\r\n  /**\r\n   * Read-only cancelable\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  get cancelable() {\r\n    return this.constructor.cancelable;\r\n  }\r\n\r\n  /**\r\n   * Cancels the event instance\r\n   * @abstract\r\n   */\r\n  cancel() {\r\n    this[canceled] = true;\r\n  }\r\n\r\n  /**\r\n   * Check if event has been canceled\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  canceled() {\r\n    return Boolean(this[canceled]);\r\n  }\r\n\r\n  /**\r\n   * Returns new event instance with existing event data.\r\n   * This method allows for overriding of event data.\r\n   * @param {Object} data\r\n   * @return {AbstractEvent}\r\n   */\r\n  clone(data) {\r\n    return new this.constructor(_extends({}, this.data, data));\r\n  }\r\n}\r\nexports.default = AbstractEvent;\r\nAbstractEvent.type = 'event';\r\nAbstractEvent.cancelable = false;\r\n\r\n/***/ }),\r\n/* 47 */\r\n/***/ (function(module, exports, __nested_webpack_require_145515__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DroppableStopEvent = exports.DroppableReturnedEvent = exports.DroppableDroppedEvent = exports.DroppableStartEvent = exports.DroppableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_145515__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base droppable event\r\n * @class DroppableEvent\r\n * @module DroppableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DroppableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Original drag event that triggered this droppable event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n}\r\n\r\nexports.DroppableEvent = DroppableEvent; /**\r\n                                          * Droppable start event\r\n                                          * @class DroppableStartEvent\r\n                                          * @module DroppableStartEvent\r\n                                          * @extends DroppableEvent\r\n                                          */\r\n\r\nDroppableEvent.type = 'droppable';\r\nclass DroppableStartEvent extends DroppableEvent {\r\n\r\n  /**\r\n   * The initial dropzone element of the currently dragging draggable element\r\n   * @property dropzone\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get dropzone() {\r\n    return this.data.dropzone;\r\n  }\r\n}\r\n\r\nexports.DroppableStartEvent = DroppableStartEvent; /**\r\n                                                    * Droppable dropped event\r\n                                                    * @class DroppableDroppedEvent\r\n                                                    * @module DroppableDroppedEvent\r\n                                                    * @extends DroppableEvent\r\n                                                    */\r\n\r\nDroppableStartEvent.type = 'droppable:start';\r\nDroppableStartEvent.cancelable = true;\r\nclass DroppableDroppedEvent extends DroppableEvent {\r\n\r\n  /**\r\n   * The dropzone element you dropped the draggable element into\r\n   * @property dropzone\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get dropzone() {\r\n    return this.data.dropzone;\r\n  }\r\n}\r\n\r\nexports.DroppableDroppedEvent = DroppableDroppedEvent; /**\r\n                                                        * Droppable returned event\r\n                                                        * @class DroppableReturnedEvent\r\n                                                        * @module DroppableReturnedEvent\r\n                                                        * @extends DroppableEvent\r\n                                                        */\r\n\r\nDroppableDroppedEvent.type = 'droppable:dropped';\r\nDroppableDroppedEvent.cancelable = true;\r\nclass DroppableReturnedEvent extends DroppableEvent {\r\n\r\n  /**\r\n   * The dropzone element you dragged away from\r\n   * @property dropzone\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get dropzone() {\r\n    return this.data.dropzone;\r\n  }\r\n}\r\n\r\nexports.DroppableReturnedEvent = DroppableReturnedEvent; /**\r\n                                                          * Droppable stop event\r\n                                                          * @class DroppableStopEvent\r\n                                                          * @module DroppableStopEvent\r\n                                                          * @extends DroppableEvent\r\n                                                          */\r\n\r\nDroppableReturnedEvent.type = 'droppable:returned';\r\nDroppableReturnedEvent.cancelable = true;\r\nclass DroppableStopEvent extends DroppableEvent {\r\n\r\n  /**\r\n   * The final dropzone element of the draggable element\r\n   * @property dropzone\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get dropzone() {\r\n    return this.data.dropzone;\r\n  }\r\n}\r\nexports.DroppableStopEvent = DroppableStopEvent;\r\nDroppableStopEvent.type = 'droppable:stop';\r\nDroppableStopEvent.cancelable = true;\r\n\r\n/***/ }),\r\n/* 48 */\r\n/***/ (function(module, exports, __nested_webpack_require_149678__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DroppableEvent = __nested_webpack_require_149678__(9);\r\n\r\nObject.keys(_DroppableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DroppableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Droppable = __nested_webpack_require_149678__(45);\r\n\r\nvar _Droppable2 = _interopRequireDefault(_Droppable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Droppable2.default;\r\n\r\n/***/ })\r\n/******/ ]);\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9kcm9wcGFibGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUswQjtBQUNoQyxDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw4QkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGVBQWUsOEJBQW1CO0FBQ2xDLG1EQUFtRCwrQkFBK0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLGlFQUFpRSxpQkFBaUI7QUFDbEY7QUFDQSwwREFBMEQsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGdDQUFnQyw4QkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBbUI7QUFDOUIsa0RBQWtELGdDQUFnQztBQUNsRiwwRUFBMEUsOEJBQW1CLDRCQUE0QixvQkFBb0I7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsMENBQTBDO0FBQzFDLFdBQVcsOEJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQW1CLENBQUMsOEJBQW1C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Q3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGNBQWMsZ0NBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBbUI7QUFDdEM7QUFDQSx1Q0FBdUMsdUNBQXVDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3QkFBd0IsZ0NBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQXVEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBdUQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1Q0FBdUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7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QUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCLGlDQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLGlCQUFpQixpQ0FBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9saWIvZHJvcHBhYmxlLmpzP2I3ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuXHRcdGRlZmluZShcIkRyb3BwYWJsZVwiLCBbXSwgZmFjdG9yeSk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcblx0XHRleHBvcnRzW1wiRHJvcHBhYmxlXCJdID0gZmFjdG9yeSgpO1xyXG5cdGVsc2VcclxuXHRcdHJvb3RbXCJEcm9wcGFibGVcIl0gPSBmYWN0b3J5KCk7XHJcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XHJcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXHJcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcclxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XHJcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcclxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcclxuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXHJcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxyXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxyXG4vKioqKioqLyBcdFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXHJcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxyXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG4vKioqKioqLyBcdH1cclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xyXG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XHJcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcclxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XHJcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xyXG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XHJcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcclxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA0OCk7XHJcbi8qKioqKiovIH0pXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKioqKiovIChbXHJcbi8qIDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2Nsb3Nlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY2xvc2VzdCcsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb3Nlc3QpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9kaXN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkaXN0YW5jZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc3RhbmNlKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX3RvdWNoQ29vcmRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3RvdWNoQ29vcmRzJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG91Y2hDb29yZHMpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKioqLyB9KSxcclxuLyogMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuXHJcbk9iamVjdC5rZXlzKF9TZW5zb3JFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9TZW5zb3JFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxuXHJcbnZhciBfU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX1NlbnNvcjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTZW5zb3InLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfTW91c2VTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTW91c2VTZW5zb3InLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Nb3VzZVNlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Ub3VjaFNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdUb3VjaFNlbnNvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RvdWNoU2Vuc29yKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX0RyYWdTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRHJhZ1NlbnNvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RyYWdTZW5zb3IpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfRm9yY2VUb3VjaFNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdGb3JjZVRvdWNoU2Vuc29yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRm9yY2VUb3VjaFNlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG5PYmplY3Qua2V5cyhfU2Vuc29yRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfU2Vuc29yRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fubm91bmNlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdBbm5vdW5jZW1lbnQnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Bbm5vdW5jZW1lbnQpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0QW5ub3VuY2VtZW50T3B0aW9ucycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9Bbm5vdW5jZW1lbnQuZGVmYXVsdE9wdGlvbnM7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfRm9jdXNhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0ZvY3VzYWJsZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZvY3VzYWJsZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9NaXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTWlycm9yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWlycm9yKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGVmYXVsdE1pcnJvck9wdGlvbnMnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfTWlycm9yLmRlZmF1bHRPcHRpb25zO1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1Njcm9sbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU2Nyb2xsYWJsZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Njcm9sbGFibGUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0U2Nyb2xsYWJsZU9wdGlvbnMnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfU2Nyb2xsYWJsZS5kZWZhdWx0T3B0aW9ucztcclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9EcmFnZ2FibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG5cclxuT2JqZWN0LmtleXMoX0RyYWdnYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX0RyYWdnYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0RyYWdFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG5cclxuT2JqZWN0LmtleXMoX0RyYWdFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9EcmFnRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRHJvcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcclxuXHJcbk9iamVjdC5rZXlzKF9Ecm9wcGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9Ecm9wcGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuLyoqXHJcbiAqIFRoZSBFbWl0dGVyIGlzIGEgc2ltcGxlIGVtaXR0ZXIgY2xhc3MgdGhhdCBwcm92aWRlcyB5b3Ugd2l0aCBgb24oKWAsIGBvZmYoKWAgYW5kIGB0cmlnZ2VyKClgIG1ldGhvZHNcclxuICogQGNsYXNzIEVtaXR0ZXJcclxuICogQG1vZHVsZSBFbWl0dGVyXHJcbiAqL1xyXG5jbGFzcyBFbWl0dGVyIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGJ5IGV2ZW50IG5hbWVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxyXG4gICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGNhbGxiYWNrc1xyXG4gICAqL1xyXG4gIG9uKHR5cGUsIC4uLmNhbGxiYWNrcykge1xyXG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1t0eXBlXSkge1xyXG4gICAgICB0aGlzLmNhbGxiYWNrc1t0eXBlXSA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdLnB1c2goLi4uY2FsbGJhY2tzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVucmVnaXN0ZXJzIGNhbGxiYWNrcyBieSBldmVudCBuYW1lXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIG9mZih0eXBlLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1t0eXBlXSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb3B5ID0gdGhpcy5jYWxsYmFja3NbdHlwZV0uc2xpY2UoMCk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3B5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChjYWxsYmFjayA9PT0gY29weVtpXSkge1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdLnNwbGljZShpLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlcnMgZXZlbnQgY2FsbGJhY2tzIGJ5IGV2ZW50IG9iamVjdFxyXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RFdmVudH0gZXZlbnRcclxuICAgKi9cclxuICB0cmlnZ2VyKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50LnR5cGVdKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNhbGxiYWNrcyA9IFsuLi50aGlzLmNhbGxiYWNrc1tldmVudC50eXBlXV07XHJcbiAgICBjb25zdCBjYXVnaHRFcnJvcnMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjYWxsYmFjayhldmVudCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY2F1Z2h0RXJyb3JzLnB1c2goZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNhdWdodEVycm9ycy5sZW5ndGgpIHtcclxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBEcmFnZ2FibGUgY2F1Z2h0IGVycm9ycyB3aGlsZSB0cmlnZ2VyaW5nICcke2V2ZW50LnR5cGV9J2AsIGNhdWdodEVycm9ycyk7XHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gRW1pdHRlcjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cclxudmFyIF9FbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VtaXR0ZXIpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9FbWl0dGVyMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxudmFyIF9QbHVnaW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcbnZhciBfRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5cclxudmFyIF9FbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VtaXR0ZXIpO1xyXG5cclxudmFyIF9TZW5zb3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcbnZhciBfRHJhZ2dhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5cclxudmFyIF9EcmFnRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdNb3ZlID0gU3ltYm9sKCdvbkRyYWdNb3ZlJyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3Qgb25EcmFnUHJlc3N1cmUgPSBTeW1ib2woJ29uRHJhZ1ByZXNzdXJlJyk7XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtPYmplY3R9IGRlZmF1bHRBbm5vdW5jZW1lbnRzXHJcbiAqIEBjb25zdCB7RnVuY3Rpb259IGRlZmF1bHRBbm5vdW5jZW1lbnRzWydkcmFnOnN0YXJ0J11cclxuICogQGNvbnN0IHtGdW5jdGlvbn0gZGVmYXVsdEFubm91bmNlbWVudHNbJ2RyYWc6c3RvcCddXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0QW5ub3VuY2VtZW50cyA9IHtcclxuICAnZHJhZzpzdGFydCc6IGV2ZW50ID0+IGBQaWNrZWQgdXAgJHtldmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGV2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnfWAsXHJcbiAgJ2RyYWc6c3RvcCc6IGV2ZW50ID0+IGBSZWxlYXNlZCAke2V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZXZlbnQuc291cmNlLmlkIHx8ICdkcmFnZ2FibGUgZWxlbWVudCd9YFxyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdENsYXNzZXMgPSB7XHJcbiAgJ2NvbnRhaW5lcjpkcmFnZ2luZyc6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1pcy1kcmFnZ2luZycsXHJcbiAgJ3NvdXJjZTpkcmFnZ2luZyc6ICdkcmFnZ2FibGUtc291cmNlLS1pcy1kcmFnZ2luZycsXHJcbiAgJ3NvdXJjZTpwbGFjZWQnOiAnZHJhZ2dhYmxlLXNvdXJjZS0tcGxhY2VkJyxcclxuICAnY29udGFpbmVyOnBsYWNlZCc6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1wbGFjZWQnLFxyXG4gICdib2R5OmRyYWdnaW5nJzogJ2RyYWdnYWJsZS0taXMtZHJhZ2dpbmcnLFxyXG4gICdkcmFnZ2FibGU6b3Zlcic6ICdkcmFnZ2FibGUtLW92ZXInLFxyXG4gICdjb250YWluZXI6b3Zlcic6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1vdmVyJyxcclxuICAnc291cmNlOm9yaWdpbmFsJzogJ2RyYWdnYWJsZS0tb3JpZ2luYWwnLFxyXG4gIG1pcnJvcjogJ2RyYWdnYWJsZS1taXJyb3InXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgZHJhZ2dhYmxlOiAnLmRyYWdnYWJsZS1zb3VyY2UnLFxyXG4gIGhhbmRsZTogbnVsbCxcclxuICBkZWxheToge30sXHJcbiAgZGlzdGFuY2U6IDAsXHJcbiAgcGxhY2VkVGltZW91dDogODAwLFxyXG4gIHBsdWdpbnM6IFtdLFxyXG4gIHNlbnNvcnM6IFtdLFxyXG4gIGV4Y2x1ZGU6IHtcclxuICAgIHBsdWdpbnM6IFtdLFxyXG4gICAgc2Vuc29yczogW11cclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB0aGUgY29yZSBkcmFnZ2FibGUgbGlicmFyeSB0aGF0IGRvZXMgdGhlIGhlYXZ5IGxpZnRpbmdcclxuICogQGNsYXNzIERyYWdnYWJsZVxyXG4gKiBAbW9kdWxlIERyYWdnYWJsZVxyXG4gKi9cclxuY2xhc3MgRHJhZ2dhYmxlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIERyYWdnYWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIERyYWdnYWJsZSBjb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciBkcmFnZ2FibGVcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogRGVmYXVsdCBwbHVnaW5zIGRyYWdnYWJsZSB1c2VzXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBQbHVnaW5zXHJcbiAgICogQHByb3BlcnR5IHtBbm5vdW5jZW1lbnR9IFBsdWdpbnMuQW5ub3VuY2VtZW50XHJcbiAgICogQHByb3BlcnR5IHtGb2N1c2FibGV9IFBsdWdpbnMuRm9jdXNhYmxlXHJcbiAgICogQHByb3BlcnR5IHtNaXJyb3J9IFBsdWdpbnMuTWlycm9yXHJcbiAgICogQHByb3BlcnR5IHtTY3JvbGxhYmxlfSBQbHVnaW5zLlNjcm9sbGFibGVcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbZG9jdW1lbnQuYm9keV0sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmFnZ2FibGUgY29udGFpbmVyc1xyXG4gICAgICogQHByb3BlcnR5IGNvbnRhaW5lcnNcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudFtdfVxyXG4gICAgICovXHJcbiAgICBpZiAoY29udGFpbmVycyBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGNvbnRhaW5lcnMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICB0aGlzLmNvbnRhaW5lcnMgPSBbLi4uY29udGFpbmVyc107XHJcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5lcnMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICB0aGlzLmNvbnRhaW5lcnMgPSBbY29udGFpbmVyc107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyYWdnYWJsZSBjb250YWluZXJzIGFyZSBleHBlY3RlZCB0byBiZSBvZiB0eXBlIGBOb2RlTGlzdGAsIGBIVE1MRWxlbWVudFtdYCBvciBgSFRNTEVsZW1lbnRgJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zLCB7XHJcbiAgICAgIGNsYXNzZXM6IF9leHRlbmRzKHt9LCBkZWZhdWx0Q2xhc3Nlcywgb3B0aW9ucy5jbGFzc2VzIHx8IHt9KSxcclxuICAgICAgYW5ub3VuY2VtZW50czogX2V4dGVuZHMoe30sIGRlZmF1bHRBbm5vdW5jZW1lbnRzLCBvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pLFxyXG4gICAgICBleGNsdWRlOiB7XHJcbiAgICAgICAgcGx1Z2luczogb3B0aW9ucy5leGNsdWRlICYmIG9wdGlvbnMuZXhjbHVkZS5wbHVnaW5zIHx8IFtdLFxyXG4gICAgICAgIHNlbnNvcnM6IG9wdGlvbnMuZXhjbHVkZSAmJiBvcHRpb25zLmV4Y2x1ZGUuc2Vuc29ycyB8fCBbXVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZXMgZXZlbnQgZW1pdHRlclxyXG4gICAgICogQHByb3BlcnR5IGVtaXR0ZXJcclxuICAgICAqIEB0eXBlIHtFbWl0dGVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgX0VtaXR0ZXIyLmRlZmF1bHQoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgZHJhZyBzdGF0ZVxyXG4gICAgICogQHByb3BlcnR5IGRyYWdnaW5nXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWN0aXZlIHBsdWdpbnNcclxuICAgICAqIEBwcm9wZXJ0eSBwbHVnaW5zXHJcbiAgICAgKiBAdHlwZSB7UGx1Z2luW119XHJcbiAgICAgKi9cclxuICAgIHRoaXMucGx1Z2lucyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWN0aXZlIHNlbnNvcnNcclxuICAgICAqIEBwcm9wZXJ0eSBzZW5zb3JzXHJcbiAgICAgKiBAdHlwZSB7U2Vuc29yW119XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2Vuc29ycyA9IFtdO1xyXG5cclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnTW92ZV0gPSB0aGlzW29uRHJhZ01vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdQcmVzc3VyZV0gPSB0aGlzW29uRHJhZ1ByZXNzdXJlXS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZzpwcmVzc3VyZScsIHRoaXNbb25EcmFnUHJlc3N1cmVdLCB0cnVlKTtcclxuXHJcbiAgICBjb25zdCBkZWZhdWx0UGx1Z2lucyA9IE9iamVjdC52YWx1ZXMoRHJhZ2dhYmxlLlBsdWdpbnMpLmZpbHRlcihQbHVnaW4gPT4gIXRoaXMub3B0aW9ucy5leGNsdWRlLnBsdWdpbnMuaW5jbHVkZXMoUGx1Z2luKSk7XHJcbiAgICBjb25zdCBkZWZhdWx0U2Vuc29ycyA9IE9iamVjdC52YWx1ZXMoRHJhZ2dhYmxlLlNlbnNvcnMpLmZpbHRlcihzZW5zb3IgPT4gIXRoaXMub3B0aW9ucy5leGNsdWRlLnNlbnNvcnMuaW5jbHVkZXMoc2Vuc29yKSk7XHJcblxyXG4gICAgdGhpcy5hZGRQbHVnaW4oLi4uWy4uLmRlZmF1bHRQbHVnaW5zLCAuLi50aGlzLm9wdGlvbnMucGx1Z2luc10pO1xyXG4gICAgdGhpcy5hZGRTZW5zb3IoLi4uWy4uLmRlZmF1bHRTZW5zb3JzLCAuLi50aGlzLm9wdGlvbnMuc2Vuc29yc10pO1xyXG5cclxuICAgIGNvbnN0IGRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQgPSBuZXcgX0RyYWdnYWJsZUV2ZW50LkRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQoe1xyXG4gICAgICBkcmFnZ2FibGU6IHRoaXNcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMub24oJ21pcnJvcjpjcmVhdGVkJywgKHsgbWlycm9yIH0pID0+IHRoaXMubWlycm9yID0gbWlycm9yKTtcclxuICAgIHRoaXMub24oJ21pcnJvcjpkZXN0cm95JywgKCkgPT4gdGhpcy5taXJyb3IgPSBudWxsKTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95cyBEcmFnZ2FibGUgaW5zdGFuY2UuIFRoaXMgcmVtb3ZlcyBhbGwgaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXJzIGFuZFxyXG4gICAqIGRlYWN0aXZhdGVzIHNlbnNvcnMgYW5kIHBsdWdpbnNcclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmF1bHQgc2Vuc29ycyBkcmFnZ2FibGUgdXNlc1xyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcHJvcGVydHkge09iamVjdH0gU2Vuc29yc1xyXG4gICAqIEBwcm9wZXJ0eSB7TW91c2VTZW5zb3J9IFNlbnNvcnMuTW91c2VTZW5zb3JcclxuICAgKiBAcHJvcGVydHkge1RvdWNoU2Vuc29yfSBTZW5zb3JzLlRvdWNoU2Vuc29yXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnOnByZXNzdXJlJywgdGhpc1tvbkRyYWdQcmVzc3VyZV0sIHRydWUpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdnYWJsZURlc3Ryb3lFdmVudCA9IG5ldyBfRHJhZ2dhYmxlRXZlbnQuRHJhZ2dhYmxlRGVzdHJveUV2ZW50KHtcclxuICAgICAgZHJhZ2dhYmxlOiB0aGlzXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ2dhYmxlRGVzdHJveUV2ZW50KTtcclxuXHJcbiAgICB0aGlzLnJlbW92ZVBsdWdpbiguLi50aGlzLnBsdWdpbnMubWFwKHBsdWdpbiA9PiBwbHVnaW4uY29uc3RydWN0b3IpKTtcclxuICAgIHRoaXMucmVtb3ZlU2Vuc29yKC4uLnRoaXMuc2Vuc29ycy5tYXAoc2Vuc29yID0+IHNlbnNvci5jb25zdHJ1Y3RvcikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBwbHVnaW4gdG8gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2UuIFRoaXMgd2lsbCBlbmQgdXAgY2FsbGluZyB0aGUgYXR0YWNoIG1ldGhvZCBvZiB0aGUgcGx1Z2luXHJcbiAgICogQHBhcmFtIHsuLi50eXBlb2YgUGx1Z2lufSBwbHVnaW5zIC0gUGx1Z2lucyB0aGF0IHlvdSB3YW50IGF0dGFjaGVkIHRvIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUuYWRkUGx1Z2luKEN1c3RvbUExMXlQbHVnaW4sIEN1c3RvbU1pcnJvclBsdWdpbilcclxuICAgKi9cclxuICBhZGRQbHVnaW4oLi4ucGx1Z2lucykge1xyXG4gICAgY29uc3QgYWN0aXZlUGx1Z2lucyA9IHBsdWdpbnMubWFwKFBsdWdpbiA9PiBuZXcgUGx1Z2luKHRoaXMpKTtcclxuXHJcbiAgICBhY3RpdmVQbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHBsdWdpbi5hdHRhY2goKSk7XHJcbiAgICB0aGlzLnBsdWdpbnMgPSBbLi4udGhpcy5wbHVnaW5zLCAuLi5hY3RpdmVQbHVnaW5zXTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgcGx1Z2lucyB0aGF0IGFyZSBhbHJlYWR5IGF0dGFjaGVkIHRvIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlLiBUaGlzIHdpbGwgZW5kIHVwIGNhbGxpbmdcclxuICAgKiB0aGUgZGV0YWNoIG1ldGhvZCBvZiB0aGUgcGx1Z2luXHJcbiAgICogQHBhcmFtIHsuLi50eXBlb2YgUGx1Z2lufSBwbHVnaW5zIC0gUGx1Z2lucyB0aGF0IHlvdSB3YW50IGRldGFjaGVkIGZyb20gZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5yZW1vdmVQbHVnaW4oTWlycm9yUGx1Z2luLCBDdXN0b21NaXJyb3JQbHVnaW4pXHJcbiAgICovXHJcbiAgcmVtb3ZlUGx1Z2luKC4uLnBsdWdpbnMpIHtcclxuICAgIGNvbnN0IHJlbW92ZWRQbHVnaW5zID0gdGhpcy5wbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gcGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4uY29uc3RydWN0b3IpKTtcclxuXHJcbiAgICByZW1vdmVkUGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiBwbHVnaW4uZGV0YWNoKCkpO1xyXG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gIXBsdWdpbnMuaW5jbHVkZXMocGx1Z2luLmNvbnN0cnVjdG9yKSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIHNlbnNvcnMgdG8gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2UuIFRoaXMgd2lsbCBlbmQgdXAgY2FsbGluZyB0aGUgYXR0YWNoIG1ldGhvZCBvZiB0aGUgc2Vuc29yXHJcbiAgICogQHBhcmFtIHsuLi50eXBlb2YgU2Vuc29yfSBzZW5zb3JzIC0gU2Vuc29ycyB0aGF0IHlvdSB3YW50IGF0dGFjaGVkIHRvIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUuYWRkU2Vuc29yKEZvcmNlVG91Y2hTZW5zb3IsIEN1c3RvbVNlbnNvcilcclxuICAgKi9cclxuICBhZGRTZW5zb3IoLi4uc2Vuc29ycykge1xyXG4gICAgY29uc3QgYWN0aXZlU2Vuc29ycyA9IHNlbnNvcnMubWFwKFNlbnNvciA9PiBuZXcgU2Vuc29yKHRoaXMuY29udGFpbmVycywgdGhpcy5vcHRpb25zKSk7XHJcblxyXG4gICAgYWN0aXZlU2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IuYXR0YWNoKCkpO1xyXG4gICAgdGhpcy5zZW5zb3JzID0gWy4uLnRoaXMuc2Vuc29ycywgLi4uYWN0aXZlU2Vuc29yc107XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIHNlbnNvcnMgdGhhdCBhcmUgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZS4gVGhpcyB3aWxsIGVuZCB1cCBjYWxsaW5nXHJcbiAgICogdGhlIGRldGFjaCBtZXRob2Qgb2YgdGhlIHNlbnNvclxyXG4gICAqIEBwYXJhbSB7Li4udHlwZW9mIFNlbnNvcn0gc2Vuc29ycyAtIFNlbnNvcnMgdGhhdCB5b3Ugd2FudCBhdHRhY2hlZCB0byBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLnJlbW92ZVNlbnNvcihUb3VjaFNlbnNvciwgRHJhZ1NlbnNvcilcclxuICAgKi9cclxuICByZW1vdmVTZW5zb3IoLi4uc2Vuc29ycykge1xyXG4gICAgY29uc3QgcmVtb3ZlZFNlbnNvcnMgPSB0aGlzLnNlbnNvcnMuZmlsdGVyKHNlbnNvciA9PiBzZW5zb3JzLmluY2x1ZGVzKHNlbnNvci5jb25zdHJ1Y3RvcikpO1xyXG5cclxuICAgIHJlbW92ZWRTZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5kZXRhY2goKSk7XHJcbiAgICB0aGlzLnNlbnNvcnMgPSB0aGlzLnNlbnNvcnMuZmlsdGVyKHNlbnNvciA9PiAhc2Vuc29ycy5pbmNsdWRlcyhzZW5zb3IuY29uc3RydWN0b3IpKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgY29udGFpbmVyIHRvIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICogQHBhcmFtIHsuLi5IVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnMgeW91IHdhbnQgdG8gYWRkIHRvIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUuYWRkQ29udGFpbmVyKGRvY3VtZW50LmJvZHkpXHJcbiAgICovXHJcbiAgYWRkQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcclxuICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi50aGlzLmNvbnRhaW5lcnMsIC4uLmNvbnRhaW5lcnNdO1xyXG4gICAgdGhpcy5zZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5hZGRDb250YWluZXIoLi4uY29udGFpbmVycykpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGNvbnRhaW5lciBmcm9tIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICogQHBhcmFtIHsuLi5IVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnMgeW91IHdhbnQgdG8gcmVtb3ZlIGZyb20gZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5yZW1vdmVDb250YWluZXIoZG9jdW1lbnQuYm9keSlcclxuICAgKi9cclxuICByZW1vdmVDb250YWluZXIoLi4uY29udGFpbmVycykge1xyXG4gICAgdGhpcy5jb250YWluZXJzID0gdGhpcy5jb250YWluZXJzLmZpbHRlcihjb250YWluZXIgPT4gIWNvbnRhaW5lcnMuaW5jbHVkZXMoY29udGFpbmVyKSk7XHJcbiAgICB0aGlzLnNlbnNvcnMuZm9yRWFjaChzZW5zb3IgPT4gc2Vuc29yLnJlbW92ZUNvbnRhaW5lciguLi5jb250YWluZXJzKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgbGlzdGVuZXIgZm9yIGRyYWdnYWJsZSBldmVudHNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIEV2ZW50IG5hbWVcclxuICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBjYWxsYmFja3MgLSBFdmVudCBjYWxsYmFja3NcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLm9uKCdkcmFnOnN0YXJ0JywgKGRyYWdFdmVudCkgPT4gZHJhZ0V2ZW50LmNhbmNlbCgpKTtcclxuICAgKi9cclxuICBvbih0eXBlLCAuLi5jYWxsYmFja3MpIHtcclxuICAgIHRoaXMuZW1pdHRlci5vbih0eXBlLCAuLi5jYWxsYmFja3MpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGxpc3RlbmVyIGZyb20gZHJhZ2dhYmxlXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBFdmVudCBuYW1lXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBFdmVudCBjYWxsYmFja1xyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUub2ZmKCdkcmFnOnN0YXJ0JywgaGFuZGxlckZ1bmN0aW9uKTtcclxuICAgKi9cclxuICBvZmYodHlwZSwgY2FsbGJhY2spIHtcclxuICAgIHRoaXMuZW1pdHRlci5vZmYodHlwZSwgY2FsbGJhY2spO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmlnZ2VycyBkcmFnZ2FibGUgZXZlbnRcclxuICAgKiBAcGFyYW0ge0Fic3RyYWN0RXZlbnR9IGV2ZW50IC0gRXZlbnQgaW5zdGFuY2VcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLnRyaWdnZXIoZXZlbnQpO1xyXG4gICAqL1xyXG4gIHRyaWdnZXIoZXZlbnQpIHtcclxuICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKGV2ZW50KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjbGFzcyBuYW1lIGZvciBjbGFzcyBpZGVudGlmaWVyXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIGNsYXNzIGlkZW50aWZpZXJcclxuICAgKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cclxuICAgKi9cclxuICBnZXRDbGFzc05hbWVGb3IobmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcihuYW1lKVswXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY2xhc3MgbmFtZXMgZm9yIGNsYXNzIGlkZW50aWZpZXJcclxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cclxuICAgKi9cclxuICBnZXRDbGFzc05hbWVzRm9yKG5hbWUpIHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSB0aGlzLm9wdGlvbnMuY2xhc3Nlc1tuYW1lXTtcclxuXHJcbiAgICBpZiAoY2xhc3NOYW1lcyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ3N0cmluZycgfHwgY2xhc3NOYW1lcyBpbnN0YW5jZW9mIFN0cmluZykge1xyXG4gICAgICByZXR1cm4gW2NsYXNzTmFtZXNdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlIGlzIGN1cnJlbnRseSBkcmFnZ2luZ1xyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaXNEcmFnZ2luZygpIHtcclxuICAgIHJldHVybiBCb29sZWFuKHRoaXMuZHJhZ2dpbmcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbGwgZHJhZ2dhYmxlIGVsZW1lbnRzXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnRbXX1cclxuICAgKi9cclxuICBnZXREcmFnZ2FibGVFbGVtZW50cygpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcnMucmVkdWNlKChjdXJyZW50LCBjb250YWluZXIpID0+IHtcclxuICAgICAgcmV0dXJuIFsuLi5jdXJyZW50LCAuLi50aGlzLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKGNvbnRhaW5lcildO1xyXG4gICAgfSwgW10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBkcmFnZ2FibGUgZWxlbWVudHMgZm9yIGEgZ2l2ZW4gY29udGFpbmVyLCBleGNsdWRpbmcgdGhlIG1pcnJvciBhbmRcclxuICAgKiBvcmlnaW5hbCBzb3VyY2UgZWxlbWVudCBpZiBwcmVzZW50XHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnRbXX1cclxuICAgKi9cclxuICBnZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihjb250YWluZXIpIHtcclxuICAgIGNvbnN0IGFsbERyYWdnYWJsZUVsZW1lbnRzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XHJcblxyXG4gICAgcmV0dXJuIFsuLi5hbGxEcmFnZ2FibGVFbGVtZW50c10uZmlsdGVyKGNoaWxkRWxlbWVudCA9PiB7XHJcbiAgICAgIHJldHVybiBjaGlsZEVsZW1lbnQgIT09IHRoaXMub3JpZ2luYWxTb3VyY2UgJiYgY2hpbGRFbGVtZW50ICE9PSB0aGlzLm1pcnJvcjtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdGFydCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERPTSBEcmFnIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xyXG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XHJcbiAgICBjb25zdCB7IHRhcmdldCwgY29udGFpbmVyIH0gPSBzZW5zb3JFdmVudDtcclxuXHJcbiAgICBpZiAoIXRoaXMuY29udGFpbmVycy5pbmNsdWRlcyhjb250YWluZXIpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmhhbmRsZSAmJiB0YXJnZXQgJiYgISgwLCBfdXRpbHMuY2xvc2VzdCkodGFyZ2V0LCB0aGlzLm9wdGlvbnMuaGFuZGxlKSkge1xyXG4gICAgICBzZW5zb3JFdmVudC5jYW5jZWwoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbmQgZHJhZ2dhYmxlIHNvdXJjZSBlbGVtZW50XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlID0gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xyXG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIgPSBjb250YWluZXI7XHJcblxyXG4gICAgaWYgKCF0aGlzLm9yaWdpbmFsU291cmNlKSB7XHJcbiAgICAgIHNlbnNvckV2ZW50LmNhbmNlbCgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubGFzdFBsYWNlZFNvdXJjZSAmJiB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGxhY2VkVGltZW91dElEKTtcclxuICAgICAgdGhpcy5sYXN0UGxhY2VkU291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xyXG4gICAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpwbGFjZWQnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zb3VyY2UgPSB0aGlzLm9yaWdpbmFsU291cmNlLmNsb25lTm9kZSh0cnVlKTtcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5zb3VyY2UsIHRoaXMub3JpZ2luYWxTb3VyY2UpO1xyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuICAgIGNvbnN0IGRyYWdFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdTdGFydEV2ZW50KHtcclxuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdFdmVudCk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2luZyA9ICFkcmFnRXZlbnQuY2FuY2VsZWQoKTtcclxuXHJcbiAgICBpZiAoZHJhZ0V2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgdGhpcy5zb3VyY2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNvdXJjZSk7XHJcbiAgICAgIHRoaXMub3JpZ2luYWxTb3VyY2Uuc3R5bGUuZGlzcGxheSA9IG51bGw7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6b3JpZ2luYWwnKSk7XHJcbiAgICB0aGlzLnNvdXJjZS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOmRyYWdnaW5nJykpO1xyXG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpkcmFnZ2luZycpKTtcclxuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2JvZHk6ZHJhZ2dpbmcnKSk7XHJcbiAgICBhcHBseVVzZXJTZWxlY3QoZG9jdW1lbnQuYm9keSwgJ25vbmUnKTtcclxuXHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICBjb25zdCBvbGRTZW5zb3JFdmVudCA9IGdldFNlbnNvckV2ZW50KGV2ZW50KTtcclxuICAgICAgY29uc3QgbmV3U2Vuc29yRXZlbnQgPSBvbGRTZW5zb3JFdmVudC5jbG9uZSh7IHRhcmdldDogdGhpcy5zb3VyY2UgfSk7XHJcblxyXG4gICAgICB0aGlzW29uRHJhZ01vdmVdKF9leHRlbmRzKHt9LCBldmVudCwge1xyXG4gICAgICAgIGRldGFpbDogbmV3U2Vuc29yRXZlbnRcclxuICAgICAgfSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG1vdmUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBET00gRHJhZyBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdNb3ZlXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZW5zb3JFdmVudCA9IGdldFNlbnNvckV2ZW50KGV2ZW50KTtcclxuICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSBzZW5zb3JFdmVudDtcclxuICAgIGxldCB0YXJnZXQgPSBzZW5zb3JFdmVudC50YXJnZXQ7XHJcblxyXG4gICAgY29uc3QgZHJhZ01vdmVFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdNb3ZlRXZlbnQoe1xyXG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ01vdmVFdmVudCk7XHJcblxyXG4gICAgaWYgKGRyYWdNb3ZlRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICBzZW5zb3JFdmVudC5jYW5jZWwoKTtcclxuICAgIH1cclxuXHJcbiAgICB0YXJnZXQgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XHJcbiAgICBjb25zdCB3aXRoaW5Db3JyZWN0Q29udGFpbmVyID0gKDAsIF91dGlscy5jbG9zZXN0KShzZW5zb3JFdmVudC50YXJnZXQsIHRoaXMuY29udGFpbmVycyk7XHJcbiAgICBjb25zdCBvdmVyQ29udGFpbmVyID0gc2Vuc29yRXZlbnQub3ZlckNvbnRhaW5lciB8fCB3aXRoaW5Db3JyZWN0Q29udGFpbmVyO1xyXG4gICAgY29uc3QgaXNMZWF2aW5nQ29udGFpbmVyID0gdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciAmJiBvdmVyQ29udGFpbmVyICE9PSB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyO1xyXG4gICAgY29uc3QgaXNMZWF2aW5nRHJhZ2dhYmxlID0gdGhpcy5jdXJyZW50T3ZlciAmJiB0YXJnZXQgIT09IHRoaXMuY3VycmVudE92ZXI7XHJcbiAgICBjb25zdCBpc092ZXJDb250YWluZXIgPSBvdmVyQ29udGFpbmVyICYmIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgIT09IG92ZXJDb250YWluZXI7XHJcbiAgICBjb25zdCBpc092ZXJEcmFnZ2FibGUgPSB3aXRoaW5Db3JyZWN0Q29udGFpbmVyICYmIHRhcmdldCAmJiB0aGlzLmN1cnJlbnRPdmVyICE9PSB0YXJnZXQ7XHJcblxyXG4gICAgaWYgKGlzTGVhdmluZ0RyYWdnYWJsZSkge1xyXG4gICAgICBjb25zdCBkcmFnT3V0RXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnT3V0RXZlbnQoe1xyXG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgICAgb3ZlcjogdGhpcy5jdXJyZW50T3ZlcixcclxuICAgICAgICBvdmVyQ29udGFpbmVyOiB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5jdXJyZW50T3Zlci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJhZ2dhYmxlOm92ZXInKSk7XHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXIgPSBudWxsO1xyXG5cclxuICAgICAgdGhpcy50cmlnZ2VyKGRyYWdPdXRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzTGVhdmluZ0NvbnRhaW5lcikge1xyXG4gICAgICBjb25zdCBkcmFnT3V0Q29udGFpbmVyRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnT3V0Q29udGFpbmVyRXZlbnQoe1xyXG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgICAgb3ZlckNvbnRhaW5lcjogdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lclxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpvdmVyJykpO1xyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyID0gbnVsbDtcclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3V0Q29udGFpbmVyRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc092ZXJDb250YWluZXIpIHtcclxuICAgICAgb3ZlckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOm92ZXInKSk7XHJcblxyXG4gICAgICBjb25zdCBkcmFnT3ZlckNvbnRhaW5lckV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ092ZXJDb250YWluZXJFdmVudCh7XHJcbiAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcclxuICAgICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgICBvdmVyQ29udGFpbmVyXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciA9IG92ZXJDb250YWluZXI7XHJcblxyXG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ092ZXJDb250YWluZXJFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzT3ZlckRyYWdnYWJsZSkge1xyXG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2RyYWdnYWJsZTpvdmVyJykpO1xyXG5cclxuICAgICAgY29uc3QgZHJhZ092ZXJFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdPdmVyRXZlbnQoe1xyXG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgICAgb3ZlckNvbnRhaW5lcixcclxuICAgICAgICBvdmVyOiB0YXJnZXRcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyID0gdGFyZ2V0O1xyXG5cclxuICAgICAgdGhpcy50cmlnZ2VyKGRyYWdPdmVyRXZlbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdG9wIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRE9NIERyYWcgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RvcF0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnU3RvcEV2ZW50KHtcclxuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNlbnNvckV2ZW50OiBldmVudC5zZW5zb3JFdmVudCxcclxuICAgICAgc291cmNlQ29udGFpbmVyOiB0aGlzLnNvdXJjZUNvbnRhaW5lclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdTdG9wRXZlbnQpO1xyXG5cclxuICAgIHRoaXMuc291cmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMub3JpZ2luYWxTb3VyY2UsIHRoaXMuc291cmNlKTtcclxuICAgIHRoaXMuc291cmNlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zb3VyY2UpO1xyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcblxyXG4gICAgdGhpcy5zb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpkcmFnZ2luZycpKTtcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpvcmlnaW5hbCcpKTtcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XHJcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOnBsYWNlZCcpKTtcclxuICAgIHRoaXMuc291cmNlQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6ZHJhZ2dpbmcnKSk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdib2R5OmRyYWdnaW5nJykpO1xyXG4gICAgYXBwbHlVc2VyU2VsZWN0KGRvY3VtZW50LmJvZHksICcnKTtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50T3Zlcikge1xyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcmFnZ2FibGU6b3ZlcicpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lcikge1xyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6b3ZlcicpKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxhc3RQbGFjZWRTb3VyY2UgPSB0aGlzLm9yaWdpbmFsU291cmNlO1xyXG4gICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyID0gdGhpcy5zb3VyY2VDb250YWluZXI7XHJcblxyXG4gICAgdGhpcy5wbGFjZWRUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKHRoaXMubGFzdFBsYWNlZFNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMubGFzdFBsYWNlZENvbnRhaW5lcikge1xyXG4gICAgICAgIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOnBsYWNlZCcpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5sYXN0UGxhY2VkU291cmNlID0gbnVsbDtcclxuICAgICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyID0gbnVsbDtcclxuICAgIH0sIHRoaXMub3B0aW9ucy5wbGFjZWRUaW1lb3V0KTtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RvcHBlZEV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ1N0b3BwZWRFdmVudCh7XHJcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzZW5zb3JFdmVudDogZXZlbnQuc2Vuc29yRXZlbnQsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogdGhpcy5zb3VyY2VDb250YWluZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnU3RvcHBlZEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlID0gbnVsbDtcclxuICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgPSBudWxsO1xyXG4gICAgdGhpcy5jdXJyZW50T3ZlciA9IG51bGw7XHJcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHByZXNzdXJlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRE9NIERyYWcgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnUHJlc3N1cmVdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xyXG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2UgfHwgKDAsIF91dGlscy5jbG9zZXN0KShzZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50LnRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ1ByZXNzdXJlRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnUHJlc3N1cmVFdmVudCh7XHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIHByZXNzdXJlOiBzZW5zb3JFdmVudC5wcmVzc3VyZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdQcmVzc3VyZUV2ZW50KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IERyYWdnYWJsZTtcclxuRHJhZ2dhYmxlLlBsdWdpbnMgPSB7IEFubm91bmNlbWVudDogX1BsdWdpbnMuQW5ub3VuY2VtZW50LCBGb2N1c2FibGU6IF9QbHVnaW5zLkZvY3VzYWJsZSwgTWlycm9yOiBfUGx1Z2lucy5NaXJyb3IsIFNjcm9sbGFibGU6IF9QbHVnaW5zLlNjcm9sbGFibGUgfTtcclxuRHJhZ2dhYmxlLlNlbnNvcnMgPSB7IE1vdXNlU2Vuc29yOiBfU2Vuc29ycy5Nb3VzZVNlbnNvciwgVG91Y2hTZW5zb3I6IF9TZW5zb3JzLlRvdWNoU2Vuc29yIH07XHJcbmZ1bmN0aW9uIGdldFNlbnNvckV2ZW50KGV2ZW50KSB7XHJcbiAgcmV0dXJuIGV2ZW50LmRldGFpbDtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlVc2VyU2VsZWN0KGVsZW1lbnQsIHZhbHVlKSB7XHJcbiAgZWxlbWVudC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gdmFsdWU7XHJcbiAgZWxlbWVudC5zdHlsZS5tb3pVc2VyU2VsZWN0ID0gdmFsdWU7XHJcbiAgZWxlbWVudC5zdHlsZS5tc1VzZXJTZWxlY3QgPSB2YWx1ZTtcclxuICBlbGVtZW50LnN0eWxlLm9Vc2VyU2VsZWN0ID0gdmFsdWU7XHJcbiAgZWxlbWVudC5zdHlsZS51c2VyU2VsZWN0ID0gdmFsdWU7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcbnZhciBfU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcik7XHJcblxyXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbk1vdXNlRm9yY2VXaWxsQmVnaW4gPSBTeW1ib2woJ29uTW91c2VGb3JjZVdpbGxCZWdpbicpO1xyXG5jb25zdCBvbk1vdXNlRm9yY2VEb3duID0gU3ltYm9sKCdvbk1vdXNlRm9yY2VEb3duJyk7XHJcbmNvbnN0IG9uTW91c2VEb3duID0gU3ltYm9sKCdvbk1vdXNlRG93bicpO1xyXG5jb25zdCBvbk1vdXNlRm9yY2VDaGFuZ2UgPSBTeW1ib2woJ29uTW91c2VGb3JjZUNoYW5nZScpO1xyXG5jb25zdCBvbk1vdXNlTW92ZSA9IFN5bWJvbCgnb25Nb3VzZU1vdmUnKTtcclxuY29uc3Qgb25Nb3VzZVVwID0gU3ltYm9sKCdvbk1vdXNlVXAnKTtcclxuY29uc3Qgb25Nb3VzZUZvcmNlR2xvYmFsQ2hhbmdlID0gU3ltYm9sKCdvbk1vdXNlRm9yY2VHbG9iYWxDaGFuZ2UnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHNlbnNvciBwaWNrcyB1cCBuYXRpdmUgZm9yY2UgdG91Y2ggZXZlbnRzIGFuZCBkaWN0YXRlcyBkcmFnIG9wZXJhdGlvbnNcclxuICogQGNsYXNzIEZvcmNlVG91Y2hTZW5zb3JcclxuICogQG1vZHVsZSBGb3JjZVRvdWNoU2Vuc29yXHJcbiAqIEBleHRlbmRzIFNlbnNvclxyXG4gKi9cclxuY2xhc3MgRm9yY2VUb3VjaFNlbnNvciBleHRlbmRzIF9TZW5zb3IyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIEZvcmNlVG91Y2hTZW5zb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgRm9yY2VUb3VjaFNlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmFnZ2FibGUgZWxlbWVudCBuZWVkcyB0byBiZSByZW1lbWJlcmVkIHRvIHVuc2V0IHRoZSBkcmFnZ2FibGUgYXR0cmlidXRlIGFmdGVyIGRyYWcgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWRcclxuICAgICAqIEBwcm9wZXJ0eSBtaWdodERyYWdcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXNbb25Nb3VzZUZvcmNlV2lsbEJlZ2luXSA9IHRoaXNbb25Nb3VzZUZvcmNlV2lsbEJlZ2luXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlRm9yY2VEb3duXSA9IHRoaXNbb25Nb3VzZUZvcmNlRG93bl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Nb3VzZURvd25dID0gdGhpc1tvbk1vdXNlRG93bl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Nb3VzZUZvcmNlQ2hhbmdlXSA9IHRoaXNbb25Nb3VzZUZvcmNlQ2hhbmdlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlTW92ZV0gPSB0aGlzW29uTW91c2VNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlVXBdID0gdGhpc1tvbk1vdXNlVXBdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgdGhpcy5jb250YWluZXJzKSB7XHJcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luJywgdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dLCBmYWxzZSk7XHJcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNlZG93bicsIHRoaXNbb25Nb3VzZUZvcmNlRG93bl0sIGZhbHNlKTtcclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2VjaGFuZ2VkJywgdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgdGhpcy5jb250YWluZXJzKSB7XHJcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luJywgdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dLCBmYWxzZSk7XHJcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNlZG93bicsIHRoaXNbb25Nb3VzZUZvcmNlRG93bl0sIGZhbHNlKTtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2VjaGFuZ2VkJywgdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBmb3JjZSB3aWxsIGJlZ2luIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2Ugd2lsbCBiZWdpbiBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRm9yY2VXaWxsQmVnaW5dKGV2ZW50KSB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgdGhpcy5taWdodERyYWcgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZm9yY2UgZG93biBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGZvcmNlIGRvd24gZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZUZvcmNlRG93bl0oZXZlbnQpIHtcclxuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gZXZlbnQuY3VycmVudFRhcmdldDtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCk7XHJcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgdXAgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlVXBdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdG9wU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQ6IG51bGwsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMubWlnaHREcmFnID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBkb3duIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZG93biBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRG93bl0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5taWdodERyYWcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5lZWQgd29ya2Fyb3VuZCBmb3IgcmVhbCBjbGlja1xyXG4gICAgLy8gQ2FuY2VsIHBvdGVudGlhbCBkcmFnIGV2ZW50c1xyXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2Ugd2lsbCBiZWdpbiBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlTW92ZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuXHJcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnTW92ZVNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZm9yY2UgY2hhbmdlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2UgY2hhbmdlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VGb3JjZUNoYW5nZV0oZXZlbnQpIHtcclxuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xyXG5cclxuICAgIGNvbnN0IGRyYWdQcmVzc3VyZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnUHJlc3N1cmVTZW5zb3JFdmVudCh7XHJcbiAgICAgIHByZXNzdXJlOiBldmVudC53ZWJraXRGb3JjZSxcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnUHJlc3N1cmVFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBmb3JjZSBnbG9iYWwgY2hhbmdlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2UgZ2xvYmFsIGNoYW5nZSBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRm9yY2VHbG9iYWxDaGFuZ2VdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuXHJcbiAgICBjb25zdCBkcmFnUHJlc3N1cmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQoe1xyXG4gICAgICBwcmVzc3VyZTogZXZlbnQud2Via2l0Rm9yY2UsXHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnUHJlc3N1cmVFdmVudCk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEZvcmNlVG91Y2hTZW5zb3I7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0ZvcmNlVG91Y2hTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHJcbnZhciBfRm9yY2VUb3VjaFNlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Gb3JjZVRvdWNoU2Vuc29yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfRm9yY2VUb3VjaFNlbnNvcjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uTW91c2VEb3duID0gU3ltYm9sKCdvbk1vdXNlRG93bicpO1xyXG5jb25zdCBvbk1vdXNlVXAgPSBTeW1ib2woJ29uTW91c2VVcCcpO1xyXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcclxuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xyXG5jb25zdCBvbkRyYWdFbmQgPSBTeW1ib2woJ29uRHJhZ0VuZCcpO1xyXG5jb25zdCBvbkRyb3AgPSBTeW1ib2woJ29uRHJvcCcpO1xyXG5jb25zdCByZXNldCA9IFN5bWJvbCgncmVzZXQnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHNlbnNvciBwaWNrcyB1cCBuYXRpdmUgYnJvd3NlciBkcmFnIGV2ZW50cyBhbmQgZGljdGF0ZXMgZHJhZyBvcGVyYXRpb25zXHJcbiAqIEBjbGFzcyBEcmFnU2Vuc29yXHJcbiAqIEBtb2R1bGUgRHJhZ1NlbnNvclxyXG4gKiBAZXh0ZW5kcyBTZW5zb3JcclxuICovXHJcbmNsYXNzIERyYWdTZW5zb3IgZXh0ZW5kcyBfU2Vuc29yMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBEcmFnU2Vuc29yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIERyYWdTZW5zb3JcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lcnMsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgZG93biB0aW1lciB3aGljaCB3aWxsIGVuZCB1cCBzZXR0aW5nIHRoZSBkcmFnZ2FibGUgYXR0cmlidXRlLCB1bmxlc3MgY2FuY2VsZWRcclxuICAgICAqIEBwcm9wZXJ0eSBtb3VzZURvd25UaW1lb3V0XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhZ2dhYmxlIGVsZW1lbnQgbmVlZHMgdG8gYmUgcmVtZW1iZXJlZCB0byB1bnNldCB0aGUgZHJhZ2dhYmxlIGF0dHJpYnV0ZSBhZnRlciBkcmFnIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkXHJcbiAgICAgKiBAcHJvcGVydHkgZHJhZ2dhYmxlRWxlbWVudFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYWdnYWJsZUVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTmF0aXZlIGRyYWdnYWJsZSBlbGVtZW50IGNvdWxkIGJlIGxpbmtzIG9yIGltYWdlcywgdGhlaXIgZHJhZ2dhYmxlIHN0YXRlIHdpbGwgYmUgZGlzYWJsZWQgZHVyaW5nIGRyYWcgb3BlcmF0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkgbmF0aXZlRHJhZ2dhYmxlRWxlbWVudFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25Nb3VzZURvd25dID0gdGhpc1tvbk1vdXNlRG93bl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Nb3VzZVVwXSA9IHRoaXNbb25Nb3VzZVVwXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnRW5kXSA9IHRoaXNbb25EcmFnRW5kXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyb3BdID0gdGhpc1tvbkRyb3BdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBEcmFnIHN0YXJ0IGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xyXG4gICAgLy8gTmVlZCBmb3IgZmlyZWZveC4gXCJ0ZXh0XCIga2V5IGlzIG5lZWRlZCBmb3IgSUVcclxuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKCd0ZXh0JywgJycpO1xyXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSB0aGlzLm9wdGlvbnMudHlwZTtcclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC50YXJnZXQsIHRoaXMuY29udGFpbmVycyk7XHJcblxyXG4gICAgaWYgKCF0aGlzLmN1cnJlbnRDb250YWluZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RhcnRTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBXb3JrYXJvdW5kXHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0YXJ0RXZlbnQpO1xyXG5cclxuICAgICAgaWYgKGRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0sIDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBvdmVyIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRHJhZyBvdmVyIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ092ZXJdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XHJcblxyXG4gICAgY29uc3QgZHJhZ01vdmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ01vdmVTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGNvbnRhaW5lciwgZHJhZ01vdmVFdmVudCk7XHJcblxyXG4gICAgaWYgKCFkcmFnTW92ZUV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSB0aGlzLm9wdGlvbnMudHlwZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgZW5kIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRHJhZyBlbmQgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnRW5kXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdLCB0cnVlKTtcclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jdXJyZW50Q29udGFpbmVyO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdG9wU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdTdG9wRXZlbnQpO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tyZXNldF0oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyb3AgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBEcm9wIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJvcF0oZXZlbnQpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGRvd24gaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBkb3duIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VEb3duXShldmVudCkge1xyXG4gICAgLy8gRmlyZWZveCBidWcgZm9yIGlucHV0cyB3aXRoaW4gZHJhZ2dhYmxlcyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03MzkwNzFcclxuICAgIGlmIChldmVudC50YXJnZXQgJiYgKGV2ZW50LnRhcmdldC5mb3JtIHx8IGV2ZW50LnRhcmdldC5jb250ZW50ZWRpdGFibGUpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC50YXJnZXQsIGVsZW1lbnQgPT4gZWxlbWVudC5kcmFnZ2FibGUpO1xyXG5cclxuICAgIGlmIChuYXRpdmVEcmFnZ2FibGVFbGVtZW50KSB7XHJcbiAgICAgIG5hdGl2ZURyYWdnYWJsZUVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9IG5hdGl2ZURyYWdnYWJsZUVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzW29uRHJhZ092ZXJdLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpc1tvbkRyYWdFbmRdLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpc1tvbkRyb3BdLCBmYWxzZSk7XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xyXG5cclxuICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBldmVudDtcclxuXHJcbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGFyZ2V0LmRyYWdnYWJsZSA9IHRydWU7XHJcbiAgICAgIHRoaXMuZHJhZ2dhYmxlRWxlbWVudCA9IHRhcmdldDtcclxuICAgIH0sIHRoaXMuZGVsYXkuZHJhZyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSB1cCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIHVwIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VVcF0oKSB7XHJcbiAgICB0aGlzW3Jlc2V0XSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgdXAgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxyXG4gICAqL1xyXG4gIFtyZXNldF0oKSB7XHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy5tb3VzZURvd25UaW1lb3V0KTtcclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0sIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCB0aGlzW29uRHJhZ0VuZF0sIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzW29uRHJvcF0sIGZhbHNlKTtcclxuXHJcbiAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50KSB7XHJcbiAgICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudC5kcmFnZ2FibGUgPSB0cnVlO1xyXG4gICAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmRyYWdnYWJsZUVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmRyYWdnYWJsZUVsZW1lbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnU2Vuc29yO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9EcmFnU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcblxyXG52YXIgX0RyYWdTZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ1NlbnNvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0RyYWdTZW5zb3IyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbnZhciBfU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcbnZhciBfU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcik7XHJcblxyXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvblRvdWNoU3RhcnQgPSBTeW1ib2woJ29uVG91Y2hTdGFydCcpO1xyXG5jb25zdCBvblRvdWNoRW5kID0gU3ltYm9sKCdvblRvdWNoRW5kJyk7XHJcbmNvbnN0IG9uVG91Y2hNb3ZlID0gU3ltYm9sKCdvblRvdWNoTW92ZScpO1xyXG5jb25zdCBzdGFydERyYWcgPSBTeW1ib2woJ3N0YXJ0RHJhZycpO1xyXG5jb25zdCBvbkRpc3RhbmNlQ2hhbmdlID0gU3ltYm9sKCdvbkRpc3RhbmNlQ2hhbmdlJyk7XHJcblxyXG4vKipcclxuICogUHJldmVudHMgc2Nyb2xsaW5nIHdoZW4gc2V0IHRvIHRydWVcclxuICogQHZhciB7Qm9vbGVhbn0gcHJldmVudFNjcm9sbGluZ1xyXG4gKi9cclxubGV0IHByZXZlbnRTY3JvbGxpbmcgPSBmYWxzZTtcclxuXHJcbi8vIFdlYktpdCByZXF1aXJlcyBjYW5jZWxhYmxlIGB0b3VjaG1vdmVgIGV2ZW50cyB0byBiZSBhZGRlZCBhcyBlYXJseSBhcyBwb3NzaWJsZVxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZXZlbnQgPT4ge1xyXG4gIGlmICghcHJldmVudFNjcm9sbGluZykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gUHJldmVudCBzY3JvbGxpbmdcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG59LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgc2Vuc29yIHBpY2tzIHVwIG5hdGl2ZSBicm93c2VyIHRvdWNoIGV2ZW50cyBhbmQgZGljdGF0ZXMgZHJhZyBvcGVyYXRpb25zXHJcbiAqIEBjbGFzcyBUb3VjaFNlbnNvclxyXG4gKiBAbW9kdWxlIFRvdWNoU2Vuc29yXHJcbiAqIEBleHRlbmRzIFNlbnNvclxyXG4gKi9cclxuY2xhc3MgVG91Y2hTZW5zb3IgZXh0ZW5kcyBfU2Vuc29yMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBUb3VjaFNlbnNvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBUb3VjaFNlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXN0IHNjcm9sbGFibGUgY29udGFpbmVyIHNvIGFjY2lkZW50YWwgc2Nyb2xsIGNhbiBjYW5jZWwgbG9uZyB0b3VjaFxyXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRTY3JvbGxhYmxlUGFyZW50XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudFNjcm9sbGFibGVQYXJlbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGltZW91dElEIGZvciBtYW5hZ2luZyBkZWxheVxyXG4gICAgICogQHByb3BlcnR5IHRhcFRpbWVvdXRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudGFwVGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0b3VjaE1vdmVkIGluZGljYXRlcyBpZiB0b3VjaCBoYXMgbW92ZWQgZHVyaW5nIHRhcFRpbWVvdXRcclxuICAgICAqIEBwcm9wZXJ0eSB0b3VjaE1vdmVkXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy50b3VjaE1vdmVkID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTYXZlIHBhZ2VYIGNvb3JkaW5hdGVzIGZvciBkZWxheSBkcmFnXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJyZX0gcGFnZVhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFnZVggPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2F2ZSBwYWdlWSBjb29yZGluYXRlcyBmb3IgZGVsYXkgZHJhZ1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1icmV9IHBhZ2VZXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBhZ2VZID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uVG91Y2hTdGFydF0gPSB0aGlzW29uVG91Y2hTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Ub3VjaEVuZF0gPSB0aGlzW29uVG91Y2hFbmRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uVG91Y2hNb3ZlXSA9IHRoaXNbb25Ub3VjaE1vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW3N0YXJ0RHJhZ10gPSB0aGlzW3N0YXJ0RHJhZ10uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0gPSB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXNbb25Ub3VjaFN0YXJ0XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXNbb25Ub3VjaFN0YXJ0XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUb3VjaCBzdGFydCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRvdWNoIHN0YXJ0IGV2ZW50XHJcbiAgICovXHJcbiAgW29uVG91Y2hTdGFydF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xyXG5cclxuICAgIGlmICghY29udGFpbmVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgZGlzdGFuY2UgPSAwIH0gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCB7IGRlbGF5IH0gPSB0aGlzO1xyXG4gICAgY29uc3QgeyBwYWdlWCwgcGFnZVkgfSA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKGV2ZW50KTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgcGFnZVgsIHBhZ2VZIH0pO1xyXG4gICAgdGhpcy5vblRvdWNoU3RhcnRBdCA9IERhdGUubm93KCk7XHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBldmVudDtcclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzW29uVG91Y2hFbmRdKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSk7XHJcblxyXG4gICAgaWYgKGRpc3RhbmNlKSB7XHJcbiAgICAgIHByZXZlbnRTY3JvbGxpbmcgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudGFwVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSh7IHRvdWNoZXM6IFt7IHBhZ2VYOiB0aGlzLnBhZ2VYLCBwYWdlWTogdGhpcy5wYWdlWSB9XSB9KTtcclxuICAgIH0sIGRlbGF5LnRvdWNoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IHRoZSBkcmFnXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbc3RhcnREcmFnXSgpIHtcclxuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSB0aGlzLnN0YXJ0RXZlbnQ7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XHJcbiAgICBjb25zdCB0b3VjaCA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKHN0YXJ0RXZlbnQpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RhcnRTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IHRvdWNoLnBhZ2VYLFxyXG4gICAgICBjbGllbnRZOiB0b3VjaC5wYWdlWSxcclxuICAgICAgdGFyZ2V0OiBzdGFydEV2ZW50LnRhcmdldCxcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBzdGFydEV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2luZyA9ICFkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpO1xyXG5cclxuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25Ub3VjaE1vdmVdKTtcclxuICAgIH1cclxuICAgIHByZXZlbnRTY3JvbGxpbmcgPSB0aGlzLmRyYWdnaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVG91Y2ggbW92ZSBoYW5kbGVyIHByaW9yIHRvIGRyYWcgc3RhcnQuXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRvdWNoIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25EaXN0YW5jZUNoYW5nZV0oZXZlbnQpIHtcclxuICAgIGNvbnN0IHsgZGlzdGFuY2UgfSA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IHsgc3RhcnRFdmVudCwgZGVsYXkgfSA9IHRoaXM7XHJcbiAgICBjb25zdCBzdGFydCA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKHN0YXJ0RXZlbnQpO1xyXG4gICAgY29uc3QgY3VycmVudCA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKGV2ZW50KTtcclxuICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gRGF0ZS5ub3coKSAtIHRoaXMub25Ub3VjaFN0YXJ0QXQ7XHJcbiAgICBjb25zdCBkaXN0YW5jZVRyYXZlbGxlZCA9ICgwLCBfdXRpbHMuZGlzdGFuY2UpKHN0YXJ0LnBhZ2VYLCBzdGFydC5wYWdlWSwgY3VycmVudC5wYWdlWCwgY3VycmVudC5wYWdlWSk7XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjdXJyZW50KTtcclxuXHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy50YXBUaW1lb3V0KTtcclxuXHJcbiAgICBpZiAodGltZUVsYXBzZWQgPCBkZWxheS50b3VjaCkge1xyXG4gICAgICAvLyBtb3ZlZCBkdXJpbmcgZGVsYXlcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlVHJhdmVsbGVkID49IGRpc3RhbmNlKSB7XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG4gICAgICB0aGlzW3N0YXJ0RHJhZ10oKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIG1vdmUgaGFuZGxlciB3aGlsZSBkcmFnZ2luZ1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUb3VjaCBtb3ZlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uVG91Y2hNb3ZlXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgcGFnZVgsIHBhZ2VZIH0gPSAoMCwgX3V0aWxzLnRvdWNoQ29vcmRzKShldmVudCk7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHBhZ2VYIC0gd2luZG93LnNjcm9sbFgsIHBhZ2VZIC0gd2luZG93LnNjcm9sbFkpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdNb3ZlU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBwYWdlWCxcclxuICAgICAgY2xpZW50WTogcGFnZVksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRvdWNoIGVuZCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRvdWNoIGVuZCBldmVudFxyXG4gICAqL1xyXG4gIFtvblRvdWNoRW5kXShldmVudCkge1xyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGFwVGltZW91dCk7XHJcbiAgICBwcmV2ZW50U2Nyb2xsaW5nID0gZmFsc2U7XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzW29uVG91Y2hFbmRdKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpc1tvblRvdWNoRW5kXSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50Q29udGFpbmVyKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudENvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvblRvdWNoTW92ZV0pO1xyXG5cclxuICAgIGNvbnN0IHsgcGFnZVgsIHBhZ2VZIH0gPSAoMCwgX3V0aWxzLnRvdWNoQ29vcmRzKShldmVudCk7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHBhZ2VYIC0gd2luZG93LnNjcm9sbFgsIHBhZ2VZIC0gd2luZG93LnNjcm9sbFkpO1xyXG5cclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0b3BTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IHBhZ2VYLFxyXG4gICAgICBjbGllbnRZOiBwYWdlWSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdG9wRXZlbnQpO1xyXG5cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IG51bGw7XHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gVG91Y2hTZW5zb3I7XHJcbmZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1RvdWNoU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcblxyXG52YXIgX1RvdWNoU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RvdWNoU2Vuc29yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfVG91Y2hTZW5zb3IyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdTdG9wU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdNb3ZlU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdTdGFydFNlbnNvckV2ZW50ID0gZXhwb3J0cy5TZW5zb3JFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2Ugc2Vuc29yIGV2ZW50XHJcbiAqIEBjbGFzcyBTZW5zb3JFdmVudFxyXG4gKiBAbW9kdWxlIFNlbnNvckV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIFNlbnNvckV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIE9yaWdpbmFsIGJyb3dzZXIgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgYSBzZW5zb3JcclxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxFdmVudFxyXG4gICAqIEB0eXBlIHtFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3JpZ2luYWxFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxFdmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZWQgY2xpZW50WCBmb3IgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzXHJcbiAgICogQHByb3BlcnR5IGNsaWVudFhcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjbGllbnRYKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jbGllbnRYO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplZCBjbGllbnRZIGZvciBib3RoIHRvdWNoIGFuZCBtb3VzZSBldmVudHNcclxuICAgKiBAcHJvcGVydHkgY2xpZW50WVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGNsaWVudFkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNsaWVudFk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOb3JtYWxpemVkIHRhcmdldCBmb3IgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzXHJcbiAgICogUmV0dXJucyB0aGUgZWxlbWVudCB0aGF0IGlzIGJlaGluZCBjdXJzb3Igb3IgdG91Y2ggcG9pbnRlclxyXG4gICAqIEBwcm9wZXJ0eSB0YXJnZXRcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHRhcmdldCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEudGFyZ2V0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udGFpbmVyIHRoYXQgaW5pdGlhdGVkIHRoZSBzZW5zb3JcclxuICAgKiBAcHJvcGVydHkgY29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYWNrcGFkIHByZXNzdXJlXHJcbiAgICogQHByb3BlcnR5IHByZXNzdXJlXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcHJlc3N1cmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnByZXNzdXJlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5TZW5zb3JFdmVudCA9IFNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHN0YXJ0IHNlbnNvciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RhcnRTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1N0YXJ0U2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuY2xhc3MgRHJhZ1N0YXJ0U2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5EcmFnU3RhcnRTZW5zb3JFdmVudCA9IERyYWdTdGFydFNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG1vdmUgc2Vuc29yIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdNb3ZlU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdNb3ZlU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQudHlwZSA9ICdkcmFnOnN0YXJ0JztcclxuY2xhc3MgRHJhZ01vdmVTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdNb3ZlU2Vuc29yRXZlbnQgPSBEcmFnTW92ZVNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdG9wIHNlbnNvciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1N0b3BTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdTdG9wU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnTW92ZVNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzptb3ZlJztcclxuY2xhc3MgRHJhZ1N0b3BTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdTdG9wU2Vuc29yRXZlbnQgPSBEcmFnU3RvcFNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBwcmVzc3VyZSBzZW5zb3IgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdQcmVzc3VyZVNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnU3RvcFNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzpzdG9wJztcclxuY2xhc3MgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxyXG5leHBvcnRzLkRyYWdQcmVzc3VyZVNlbnNvckV2ZW50ID0gRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQ7XHJcbkRyYWdQcmVzc3VyZVNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzpwcmVzc3VyZSc7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbnZhciBfU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcbnZhciBfU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcik7XHJcblxyXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZyA9IFN5bWJvbCgnb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmcnKTtcclxuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XHJcbmNvbnN0IG9uTW91c2VNb3ZlID0gU3ltYm9sKCdvbk1vdXNlTW92ZScpO1xyXG5jb25zdCBvbk1vdXNlVXAgPSBTeW1ib2woJ29uTW91c2VVcCcpO1xyXG5jb25zdCBzdGFydERyYWcgPSBTeW1ib2woJ3N0YXJ0RHJhZycpO1xyXG5jb25zdCBvbkRpc3RhbmNlQ2hhbmdlID0gU3ltYm9sKCdvbkRpc3RhbmNlQ2hhbmdlJyk7XHJcblxyXG4vKipcclxuICogVGhpcyBzZW5zb3IgcGlja3MgdXAgbmF0aXZlIGJyb3dzZXIgbW91c2UgZXZlbnRzIGFuZCBkaWN0YXRlcyBkcmFnIG9wZXJhdGlvbnNcclxuICogQGNsYXNzIE1vdXNlU2Vuc29yXHJcbiAqIEBtb2R1bGUgTW91c2VTZW5zb3JcclxuICogQGV4dGVuZHMgU2Vuc29yXHJcbiAqL1xyXG5jbGFzcyBNb3VzZVNlbnNvciBleHRlbmRzIF9TZW5zb3IyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIE1vdXNlU2Vuc29yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIE1vdXNlU2Vuc29yXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGRvd24gdGltZXIgd2hpY2ggd2lsbCBlbmQgdXAgdHJpZ2dlcmluZyB0aGUgZHJhZyBzdGFydCBvcGVyYXRpb25cclxuICAgICAqIEBwcm9wZXJ0eSBtb3VzZURvd25UaW1lb3V0XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2F2ZSBwYWdlWCBjb29yZGluYXRlcyBmb3IgZGVsYXkgZHJhZ1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1icmV9IHBhZ2VYXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBhZ2VYID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNhdmUgcGFnZVkgY29vcmRpbmF0ZXMgZm9yIGRlbGF5IGRyYWdcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYnJlfSBwYWdlWVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5wYWdlWSA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10gPSB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlRG93bl0gPSB0aGlzW29uTW91c2VEb3duXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlTW92ZV0gPSB0aGlzW29uTW91c2VNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlVXBdID0gdGhpc1tvbk1vdXNlVXBdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW3N0YXJ0RHJhZ10gPSB0aGlzW3N0YXJ0RHJhZ10uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0gPSB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGRvd24gaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBkb3duIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VEb3duXShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29udGFpbmVyID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC50YXJnZXQsIHRoaXMuY29udGFpbmVycyk7XHJcblxyXG4gICAgaWYgKCFjb250YWluZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgZGVsYXkgfSA9IHRoaXM7XHJcbiAgICBjb25zdCB7IHBhZ2VYLCBwYWdlWSB9ID0gZXZlbnQ7XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IHBhZ2VYLCBwYWdlWSB9KTtcclxuICAgIHRoaXMub25Nb3VzZURvd25BdCA9IERhdGUubm93KCk7XHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBldmVudDtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHByZXZlbnROYXRpdmVEcmFnU3RhcnQpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcblxyXG4gICAgdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKHsgcGFnZVg6IHRoaXMucGFnZVgsIHBhZ2VZOiB0aGlzLnBhZ2VZIH0pO1xyXG4gICAgfSwgZGVsYXkubW91c2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdGhlIGRyYWdcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtzdGFydERyYWddKCkge1xyXG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IHRoaXMuc3RhcnRFdmVudDtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbnRhaW5lcjtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBzdGFydEV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IHN0YXJ0RXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0OiBzdGFydEV2ZW50LnRhcmdldCxcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBzdGFydEV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2luZyA9ICFkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpO1xyXG5cclxuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10sIHRydWUpO1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uTW91c2VNb3ZlXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlY3QgY2hhbmdlIGluIGRpc3RhbmNlLCBzdGFydGluZyBkcmFnIHdoZW4gYm90aFxyXG4gICAqIGRlbGF5IGFuZCBkaXN0YW5jZSByZXF1aXJlbWVudHMgYXJlIG1ldFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBtb3ZlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRGlzdGFuY2VDaGFuZ2VdKGV2ZW50KSB7XHJcbiAgICBjb25zdCB7IHBhZ2VYLCBwYWdlWSB9ID0gZXZlbnQ7XHJcbiAgICBjb25zdCB7IGRpc3RhbmNlIH0gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCB7IHN0YXJ0RXZlbnQsIGRlbGF5IH0gPSB0aGlzO1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBwYWdlWCwgcGFnZVkgfSk7XHJcblxyXG4gICAgaWYgKCF0aGlzLmN1cnJlbnRDb250YWluZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gRGF0ZS5ub3coKSAtIHRoaXMub25Nb3VzZURvd25BdDtcclxuICAgIGNvbnN0IGRpc3RhbmNlVHJhdmVsbGVkID0gKDAsIF91dGlscy5kaXN0YW5jZSkoc3RhcnRFdmVudC5wYWdlWCwgc3RhcnRFdmVudC5wYWdlWSwgcGFnZVgsIHBhZ2VZKSB8fCAwO1xyXG5cclxuICAgIGNsZWFyVGltZW91dCh0aGlzLm1vdXNlRG93blRpbWVvdXQpO1xyXG5cclxuICAgIGlmICh0aW1lRWxhcHNlZCA8IGRlbGF5Lm1vdXNlKSB7XHJcbiAgICAgIC8vIG1vdmVkIGR1cmluZyBkZWxheVxyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2VUcmF2ZWxsZWQgPj0gZGlzdGFuY2UpIHtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcbiAgICAgIHRoaXNbc3RhcnREcmFnXSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgbW92ZSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZU1vdmVdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ01vdmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ01vdmVTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIHVwIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgdXAgZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZVVwXShldmVudCkge1xyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XHJcblxyXG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBwcmV2ZW50TmF0aXZlRHJhZ1N0YXJ0KTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG5cclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RvcFNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdG9wRXZlbnQpO1xyXG5cclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xyXG5cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IG51bGw7XHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udGV4dCBtZW51IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gQ29udGV4dCBtZW51IGV2ZW50XHJcbiAgICovXHJcbiAgW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXShldmVudCkge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1vdXNlU2Vuc29yO1xyXG5mdW5jdGlvbiBwcmV2ZW50TmF0aXZlRHJhZ1N0YXJ0KGV2ZW50KSB7XHJcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Nb3VzZVNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG5cclxudmFyIF9Nb3VzZVNlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Nb3VzZVNlbnNvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX01vdXNlU2Vuc29yMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbmNvbnN0IGRlZmF1bHREZWFseSA9IHtcclxuICBtb3VzZTogMCxcclxuICBkcmFnOiAwLFxyXG4gIHRvdWNoOiAxMDBcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCYXNlIHNlbnNvciBjbGFzcy4gRXh0ZW5kIGZyb20gdGhpcyBjbGFzcyB0byBjcmVhdGUgYSBuZXcgb3IgY3VzdG9tIHNlbnNvclxyXG4gKiBAY2xhc3MgU2Vuc29yXHJcbiAqIEBtb2R1bGUgU2Vuc29yXHJcbiAqL1xyXG5jbGFzcyBTZW5zb3Ige1xyXG4gIC8qKlxyXG4gICAqIFNlbnNvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBTZW5zb3JcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBjb250YWluZXJzXHJcbiAgICAgKiBAcHJvcGVydHkgY29udGFpbmVyc1xyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi5jb250YWluZXJzXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgZHJhZyBzdGF0ZVxyXG4gICAgICogQHByb3BlcnR5IGRyYWdnaW5nXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBjb250YWluZXJcclxuICAgICAqIEBwcm9wZXJ0eSBjdXJyZW50Q29udGFpbmVyXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZXZlbnQgb2YgdGhlIGluaXRpYWwgc2Vuc29yIGRvd25cclxuICAgICAqIEBwcm9wZXJ0eSBzdGFydEV2ZW50XHJcbiAgICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVsYXkgb2YgZWFjaCBzZW5zb3JcclxuICAgICAqIEBwcm9wZXJ0eSBkZWxheVxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kZWxheSA9IGNhbGNEZWxheShvcHRpb25zLmRlbGF5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKiBAcmV0dXJuIHtTZW5zb3J9XHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICogQHJldHVybiB7U2Vuc29yfVxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBjb250YWluZXIgdG8gdGhpcyBzZW5zb3IgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0gey4uLkhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVycyB5b3Ugd2FudCB0byBhZGQgdG8gdGhpcyBzZW5zb3JcclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUuYWRkQ29udGFpbmVyKGRvY3VtZW50LmJvZHkpXHJcbiAgICovXHJcbiAgYWRkQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcclxuICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi50aGlzLmNvbnRhaW5lcnMsIC4uLmNvbnRhaW5lcnNdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBjb250YWluZXIgZnJvbSB0aGlzIHNlbnNvciBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7Li4uSFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzIHlvdSB3YW50IHRvIHJlbW92ZSBmcm9tIHRoaXMgc2Vuc29yXHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLnJlbW92ZUNvbnRhaW5lcihkb2N1bWVudC5ib2R5KVxyXG4gICAqL1xyXG4gIHJlbW92ZUNvbnRhaW5lciguLi5jb250YWluZXJzKSB7XHJcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSB0aGlzLmNvbnRhaW5lcnMuZmlsdGVyKGNvbnRhaW5lciA9PiAhY29udGFpbmVycy5pbmNsdWRlcyhjb250YWluZXIpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXJzIGV2ZW50IG9uIHRhcmdldCBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gdHJpZ2dlciBldmVudCBvblxyXG4gICAqIEBwYXJhbSB7U2Vuc29yRXZlbnR9IHNlbnNvckV2ZW50IC0gU2Vuc29yIGV2ZW50IHRvIHRyaWdnZXJcclxuICAgKi9cclxuICB0cmlnZ2VyKGVsZW1lbnQsIHNlbnNvckV2ZW50KSB7XHJcbiAgICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xyXG4gICAgZXZlbnQuZGV0YWlsID0gc2Vuc29yRXZlbnQ7XHJcbiAgICBldmVudC5pbml0RXZlbnQoc2Vuc29yRXZlbnQudHlwZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgdGhpcy5sYXN0RXZlbnQgPSBzZW5zb3JFdmVudDtcclxuXHJcbiAgICByZXR1cm4gc2Vuc29yRXZlbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBTZW5zb3I7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIENhbGN1bGF0ZSB0aGUgZGVsYXkgb2YgZWFjaCBzZW5zb3IgdGhyb3VnaCB0aGUgZGVsYXkgaW4gdGhlIG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3VuZGVmaW5lZHxOdW1iZXJ8T2JqZWN0fSBvcHRpb25zRGVsYXkgLSB0aGUgZGVsYXkgaW4gdGhlIG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5mdW5jdGlvbiBjYWxjRGVsYXkob3B0aW9uc0RlbGF5KSB7XHJcbiAgY29uc3QgZGVsYXkgPSB7fTtcclxuXHJcbiAgaWYgKG9wdGlvbnNEZWxheSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRlZmF1bHREZWFseSk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIG9wdGlvbnNEZWxheSA9PT0gJ251bWJlcicpIHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHREZWFseSkge1xyXG4gICAgICBpZiAoZGVmYXVsdERlYWx5Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICBkZWxheVtrZXldID0gb3B0aW9uc0RlbGF5O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVsYXk7XHJcbiAgfVxyXG5cclxuICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0RGVhbHkpIHtcclxuICAgIGlmIChkZWZhdWx0RGVhbHkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICBpZiAob3B0aW9uc0RlbGF5W2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGRlbGF5W2tleV0gPSBkZWZhdWx0RGVhbHlba2V5XTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkZWxheVtrZXldID0gb3B0aW9uc0RlbGF5W2tleV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBkZWxheTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5zY3JvbGwgPSBleHBvcnRzLm9uRHJhZ1N0b3AgPSBleHBvcnRzLm9uRHJhZ01vdmUgPSBleHBvcnRzLm9uRHJhZ1N0YXJ0ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkRyYWdTdGFydCA9IGV4cG9ydHMub25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XHJcbmNvbnN0IG9uRHJhZ01vdmUgPSBleHBvcnRzLm9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcclxuY29uc3Qgb25EcmFnU3RvcCA9IGV4cG9ydHMub25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xyXG5jb25zdCBzY3JvbGwgPSBleHBvcnRzLnNjcm9sbCA9IFN5bWJvbCgnc2Nyb2xsJyk7XHJcblxyXG4vKipcclxuICogU2Nyb2xsYWJsZSBkZWZhdWx0IG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWZhdWx0T3B0aW9ucy5zcGVlZFxyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMuc2Vuc2l0aXZpdHlcclxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudFtdfSBkZWZhdWx0T3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHNcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcclxuICBzcGVlZDogNixcclxuICBzZW5zaXRpdml0eTogNTAsXHJcbiAgc2Nyb2xsYWJsZUVsZW1lbnRzOiBbXVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNjcm9sbGFibGUgcGx1Z2luIHdoaWNoIHNjcm9sbHMgdGhlIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBwYXJlbnRcclxuICogQGNsYXNzIFNjcm9sbGFibGVcclxuICogQG1vZHVsZSBTY3JvbGxhYmxlXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBTY3JvbGxhYmxlIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBTY3JvbGxhYmxlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFNjcm9sbGFibGVcclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2Nyb2xsYWJsZSBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG9wdGlvbnMuc3BlZWRcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBvcHRpb25zLnNlbnNpdGl2aXR5XHJcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50W119IG9wdGlvbnMuc2Nyb2xsYWJsZUVsZW1lbnRzXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIHRoaXMuZ2V0T3B0aW9ucygpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtlZXBzIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjdXJyZW50TW91c2VQb3NpdGlvblxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGN1cnJlbnRNb3VzZVBvc2l0aW9uLmNsaWVudFhcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRZXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2Nyb2xsIGFuaW1hdGlvbiBmcmFtZVxyXG4gICAgICogQHByb3BlcnR5IHNjcm9sbEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzdCBzY3JvbGxhYmxlIGVsZW1lbnRcclxuICAgICAqIEBwcm9wZXJ0eSBzY3JvbGxhYmxlRWxlbWVudFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW5pbWF0aW9uIGZyYW1lIGxvb2tpbmcgZm9yIHRoZSBjbG9zZXN0IHNjcm9sbGFibGUgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IGZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnTW92ZV0gPSB0aGlzW29uRHJhZ01vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tzY3JvbGxdID0gdGhpc1tzY3JvbGxdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9uKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vZmYoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5zY3JvbGxhYmxlIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjbG9zZXN0IHNjcm9sbGFibGUgZWxlbWVudHMgYnkgZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gICAqL1xyXG4gIGdldFNjcm9sbGFibGVFbGVtZW50KHRhcmdldCkge1xyXG4gICAgaWYgKHRoaXMuaGFzRGVmaW5lZFNjcm9sbGFibGVFbGVtZW50cygpKSB7XHJcbiAgICAgIHJldHVybiAoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgdGhpcy5vcHRpb25zLnNjcm9sbGFibGVFbGVtZW50cykgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGNsb3Nlc3RTY3JvbGxhYmxlRWxlbWVudCh0YXJnZXQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIGF0IGxlYXN0IG9uZSBzY3JvbGxhYmxlIGVsZW1lbnQgaGF2ZSBiZWVuIGRlZmluZWQgdmlhIG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGhhc0RlZmluZWRTY3JvbGxhYmxlRWxlbWVudHMoKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLm9wdGlvbnMuc2Nyb2xsYWJsZUVsZW1lbnRzLmxlbmd0aCAhPT0gMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXIuIEZpbmRzIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBwYXJlbnQgaW4gc2VwYXJhdGUgZnJhbWVcclxuICAgKiBAcGFyYW0ge0RyYWdTdGFydEV2ZW50fSBkcmFnRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdGFydF0oZHJhZ0V2ZW50KSB7XHJcbiAgICB0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgdGhpcy5zY3JvbGxhYmxlRWxlbWVudCA9IHRoaXMuZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZHJhZ0V2ZW50LnNvdXJjZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgbW92ZSBoYW5kbGVyLiBSZW1lbWJlcnMgbW91c2UgcG9zaXRpb24gYW5kIGluaXRpYXRlcyBzY3JvbGxpbmdcclxuICAgKiBAcGFyYW0ge0RyYWdNb3ZlRXZlbnR9IGRyYWdFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRHJhZ01vdmVdKGRyYWdFdmVudCkge1xyXG4gICAgdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSB0aGlzLmdldFNjcm9sbGFibGVFbGVtZW50KGRyYWdFdmVudC5zZW5zb3JFdmVudC50YXJnZXQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCF0aGlzLnNjcm9sbGFibGVFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZW5zb3JFdmVudCA9IGRyYWdFdmVudC5zZW5zb3JFdmVudDtcclxuICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcclxuICAgICAgc2Nyb2xsT2Zmc2V0LnkgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCB8fCAwO1xyXG4gICAgICBzY3JvbGxPZmZzZXQueCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHwgMDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uID0ge1xyXG4gICAgICBjbGllbnRYOiBzZW5zb3JFdmVudC5jbGllbnRYIC0gc2Nyb2xsT2Zmc2V0LngsXHJcbiAgICAgIGNsaWVudFk6IHNlbnNvckV2ZW50LmNsaWVudFkgLSBzY3JvbGxPZmZzZXQueVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXNbc2Nyb2xsXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0b3AgaGFuZGxlci4gQ2FuY2VscyBzY3JvbGwgYW5pbWF0aW9ucyBhbmQgcmVzZXRzIHN0YXRlXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25EcmFnU3RvcF0oKSB7XHJcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lKTtcclxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUpO1xyXG5cclxuICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSBudWxsO1xyXG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IG51bGw7XHJcbiAgICB0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lID0gbnVsbDtcclxuICAgIHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24gPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsIGZ1bmN0aW9uIHRoYXQgZG9lcyB0aGUgaGVhdnlsaWZ0aW5nXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbc2Nyb2xsXSgpIHtcclxuICAgIGlmICghdGhpcy5zY3JvbGxhYmxlRWxlbWVudCB8fCAhdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSk7XHJcblxyXG4gICAgY29uc3QgeyBzcGVlZCwgc2Vuc2l0aXZpdHkgfSA9IHRoaXMub3B0aW9ucztcclxuXHJcbiAgICBjb25zdCByZWN0ID0gdGhpcy5zY3JvbGxhYmxlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGNvbnN0IGJvdHRvbUN1dE9mZiA9IHJlY3QuYm90dG9tID4gd2luZG93LmlubmVySGVpZ2h0O1xyXG4gICAgY29uc3QgdG9wQ3V0T2ZmID0gcmVjdC50b3AgPCAwO1xyXG4gICAgY29uc3QgY3V0T2ZmID0gdG9wQ3V0T2ZmIHx8IGJvdHRvbUN1dE9mZjtcclxuXHJcbiAgICBjb25zdCBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQgPSBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKTtcclxuICAgIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50ID0gdGhpcy5zY3JvbGxhYmxlRWxlbWVudDtcclxuICAgIGNvbnN0IGNsaWVudFggPSB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uLmNsaWVudFg7XHJcbiAgICBjb25zdCBjbGllbnRZID0gdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRZO1xyXG5cclxuICAgIGlmIChzY3JvbGxhYmxlRWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBzY3JvbGxhYmxlRWxlbWVudCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICFjdXRPZmYpIHtcclxuICAgICAgY29uc3QgeyBvZmZzZXRIZWlnaHQsIG9mZnNldFdpZHRoIH0gPSBzY3JvbGxhYmxlRWxlbWVudDtcclxuXHJcbiAgICAgIGlmIChyZWN0LnRvcCArIG9mZnNldEhlaWdodCAtIGNsaWVudFkgPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbFRvcCArPSBzcGVlZDtcclxuICAgICAgfSBlbHNlIGlmIChjbGllbnRZIC0gcmVjdC50b3AgPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbFRvcCAtPSBzcGVlZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlY3QubGVmdCArIG9mZnNldFdpZHRoIC0gY2xpZW50WCA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsTGVmdCArPSBzcGVlZDtcclxuICAgICAgfSBlbHNlIGlmIChjbGllbnRYIC0gcmVjdC5sZWZ0IDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxMZWZ0IC09IHNwZWVkO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCB7IGlubmVySGVpZ2h0LCBpbm5lcldpZHRoIH0gPSB3aW5kb3c7XHJcblxyXG4gICAgICBpZiAoY2xpZW50WSA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCAtPSBzcGVlZDtcclxuICAgICAgfSBlbHNlIGlmIChpbm5lckhlaWdodCAtIGNsaWVudFkgPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgKz0gc3BlZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjbGllbnRYIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCAtPSBzcGVlZDtcclxuICAgICAgfSBlbHNlIGlmIChpbm5lcldpZHRoIC0gY2xpZW50WCA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgKz0gc3BlZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXNbc2Nyb2xsXSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBTY3JvbGxhYmxlOyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgZWxlbWVudCBoYXMgb3ZlcmZsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmZ1bmN0aW9uIGhhc092ZXJmbG93KGVsZW1lbnQpIHtcclxuICBjb25zdCBvdmVyZmxvd1JlZ2V4ID0gLyhhdXRvfHNjcm9sbCkvO1xyXG4gIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcclxuXHJcbiAgY29uc3Qgb3ZlcmZsb3cgPSBjb21wdXRlZFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdycpICsgY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cteScpICsgY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cteCcpO1xyXG5cclxuICByZXR1cm4gb3ZlcmZsb3dSZWdleC50ZXN0KG92ZXJmbG93KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIGVsZW1lbnQgaXMgc3RhdGljYWxseSBwb3NpdGlvbmVkXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGlzU3RhdGljYWxseVBvc2l0aW9uZWQoZWxlbWVudCkge1xyXG4gIGNvbnN0IHBvc2l0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xyXG4gIHJldHVybiBwb3NpdGlvbiA9PT0gJ3N0YXRpYyc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kcyBjbG9zZXN0IHNjcm9sbGFibGUgZWxlbWVudFxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY2xvc2VzdFNjcm9sbGFibGVFbGVtZW50KGVsZW1lbnQpIHtcclxuICBpZiAoIWVsZW1lbnQpIHtcclxuICAgIHJldHVybiBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHBvc2l0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xyXG4gIGNvbnN0IGV4Y2x1ZGVTdGF0aWNQYXJlbnRzID0gcG9zaXRpb24gPT09ICdhYnNvbHV0ZSc7XHJcblxyXG4gIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50ID0gKDAsIF91dGlscy5jbG9zZXN0KShlbGVtZW50LCBwYXJlbnQgPT4ge1xyXG4gICAgaWYgKGV4Y2x1ZGVTdGF0aWNQYXJlbnRzICYmIGlzU3RhdGljYWxseVBvc2l0aW9uZWQocGFyZW50KSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzT3ZlcmZsb3cocGFyZW50KTtcclxuICB9KTtcclxuXHJcbiAgaWYgKHBvc2l0aW9uID09PSAnZml4ZWQnIHx8ICFzY3JvbGxhYmxlRWxlbWVudCkge1xyXG4gICAgcmV0dXJuIGdldERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gc2Nyb2xsYWJsZUVsZW1lbnQ7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBlbGVtZW50IHRoYXQgc2Nyb2xscyBkb2N1bWVudFxyXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCgpIHtcclxuICByZXR1cm4gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfU2Nyb2xsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG5cclxudmFyIF9TY3JvbGxhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Njcm9sbGFibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9TY3JvbGxhYmxlMi5kZWZhdWx0O1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gX1Njcm9sbGFibGUuZGVmYXVsdE9wdGlvbnM7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuTWlycm9yRGVzdHJveUV2ZW50ID0gZXhwb3J0cy5NaXJyb3JNb3ZlRXZlbnQgPSBleHBvcnRzLk1pcnJvckF0dGFjaGVkRXZlbnQgPSBleHBvcnRzLk1pcnJvckNyZWF0ZWRFdmVudCA9IGV4cG9ydHMuTWlycm9yQ3JlYXRlRXZlbnQgPSBleHBvcnRzLk1pcnJvckV2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKipcclxuICogQmFzZSBtaXJyb3IgZXZlbnRcclxuICogQGNsYXNzIE1pcnJvckV2ZW50XHJcbiAqIEBtb2R1bGUgTWlycm9yRXZlbnRcclxuICogQGV4dGVuZHMgQWJzdHJhY3RFdmVudFxyXG4gKi9cclxuY2xhc3MgTWlycm9yRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBzb3VyY2UgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBzb3VyY2VcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNvdXJjZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBvcmlnaW5hbCBzb3VyY2UgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbFNvdXJjZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3JpZ2luYWxTb3VyY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9yaWdpbmFsU291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBzb3VyY2UgY29udGFpbmVyIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgc291cmNlQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzb3VyY2VDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZUNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbnNvciBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBzZW5zb3JFdmVudFxyXG4gICAqIEB0eXBlIHtTZW5zb3JFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc2Vuc29yRXZlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNlbnNvckV2ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBkcmFnRXZlbnRcclxuICAgKiBAdHlwZSB7RHJhZ0V2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkcmFnRXZlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9yaWdpbmFsIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHNlbnNvciBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbEV2ZW50XHJcbiAgICogQHR5cGUge0V2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvcmlnaW5hbEV2ZW50KCkge1xyXG4gICAgaWYgKHRoaXMuc2Vuc29yRXZlbnQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2Vuc29yRXZlbnQub3JpZ2luYWxFdmVudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuTWlycm9yRXZlbnQgPSBNaXJyb3JFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWlycm9yIGNyZWF0ZSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBNaXJyb3JDcmVhdGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgTWlycm9yQ3JlYXRlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBNaXJyb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuY2xhc3MgTWlycm9yQ3JlYXRlRXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5NaXJyb3JDcmVhdGVFdmVudCA9IE1pcnJvckNyZWF0ZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNaXJyb3IgY3JlYXRlZCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBNaXJyb3JDcmVhdGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIE1pcnJvckNyZWF0ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIE1pcnJvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5NaXJyb3JDcmVhdGVFdmVudC50eXBlID0gJ21pcnJvcjpjcmVhdGUnO1xyXG5jbGFzcyBNaXJyb3JDcmVhdGVkRXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgbWlycm9yIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbWlycm9yXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBtaXJyb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuTWlycm9yQ3JlYXRlZEV2ZW50ID0gTWlycm9yQ3JlYXRlZEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1pcnJvciBhdHRhY2hlZCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIE1pcnJvckF0dGFjaGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgTWlycm9yQXR0YWNoZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgTWlycm9yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuTWlycm9yQ3JlYXRlZEV2ZW50LnR5cGUgPSAnbWlycm9yOmNyZWF0ZWQnO1xyXG5jbGFzcyBNaXJyb3JBdHRhY2hlZEV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG1pcnJvclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbWlycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLk1pcnJvckF0dGFjaGVkRXZlbnQgPSBNaXJyb3JBdHRhY2hlZEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWlycm9yIG1vdmUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIE1pcnJvck1vdmVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIE1pcnJvck1vdmVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBNaXJyb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbk1pcnJvckF0dGFjaGVkRXZlbnQudHlwZSA9ICdtaXJyb3I6YXR0YWNoZWQnO1xyXG5jbGFzcyBNaXJyb3JNb3ZlRXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgbWlycm9yIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbWlycm9yXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBtaXJyb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbnNvciBoYXMgZXhjZWVkZWQgbWlycm9yJ3MgdGhyZXNob2xkIG9uIHggYXhpc1xyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBwYXNzZWRUaHJlc2hYKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wYXNzZWRUaHJlc2hYO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Vuc29yIGhhcyBleGNlZWRlZCBtaXJyb3IncyB0aHJlc2hvbGQgb24geSBheGlzXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHBhc3NlZFRocmVzaFkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnBhc3NlZFRocmVzaFk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLk1pcnJvck1vdmVFdmVudCA9IE1pcnJvck1vdmVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNaXJyb3IgZGVzdHJveSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIE1pcnJvckRlc3Ryb3lFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JEZXN0cm95RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIE1pcnJvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbk1pcnJvck1vdmVFdmVudC50eXBlID0gJ21pcnJvcjptb3ZlJztcclxuTWlycm9yTW92ZUV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBNaXJyb3JEZXN0cm95RXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgbWlycm9yIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbWlycm9yXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBtaXJyb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5NaXJyb3JEZXN0cm95RXZlbnQgPSBNaXJyb3JEZXN0cm95RXZlbnQ7XHJcbk1pcnJvckRlc3Ryb3lFdmVudC50eXBlID0gJ21pcnJvcjpkZXN0cm95JztcclxuTWlycm9yRGVzdHJveUV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9NaXJyb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xyXG5cclxuT2JqZWN0LmtleXMoX01pcnJvckV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX01pcnJvckV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5nZXRBcHBlbmRhYmxlQ29udGFpbmVyID0gZXhwb3J0cy5vblNjcm9sbCA9IGV4cG9ydHMub25NaXJyb3JNb3ZlID0gZXhwb3J0cy5vbk1pcnJvckNyZWF0ZWQgPSBleHBvcnRzLm9uRHJhZ1N0b3AgPSBleHBvcnRzLm9uRHJhZ01vdmUgPSBleHBvcnRzLm9uRHJhZ1N0YXJ0ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG52YXIgX01pcnJvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5cclxuY29uc3Qgb25EcmFnU3RhcnQgPSBleHBvcnRzLm9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdNb3ZlID0gZXhwb3J0cy5vbkRyYWdNb3ZlID0gU3ltYm9sKCdvbkRyYWdNb3ZlJyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBleHBvcnRzLm9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3Qgb25NaXJyb3JDcmVhdGVkID0gZXhwb3J0cy5vbk1pcnJvckNyZWF0ZWQgPSBTeW1ib2woJ29uTWlycm9yQ3JlYXRlZCcpO1xyXG5jb25zdCBvbk1pcnJvck1vdmUgPSBleHBvcnRzLm9uTWlycm9yTW92ZSA9IFN5bWJvbCgnb25NaXJyb3JNb3ZlJyk7XHJcbmNvbnN0IG9uU2Nyb2xsID0gZXhwb3J0cy5vblNjcm9sbCA9IFN5bWJvbCgnb25TY3JvbGwnKTtcclxuY29uc3QgZ2V0QXBwZW5kYWJsZUNvbnRhaW5lciA9IGV4cG9ydHMuZ2V0QXBwZW5kYWJsZUNvbnRhaW5lciA9IFN5bWJvbCgnZ2V0QXBwZW5kYWJsZUNvbnRhaW5lcicpO1xyXG5cclxuLyoqXHJcbiAqIE1pcnJvciBkZWZhdWx0IG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVmYXVsdE9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9uc1xyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRlZmF1bHRPcHRpb25zLnhBeGlzXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVmYXVsdE9wdGlvbnMueUF4aXNcclxuICogQHByb3BlcnR5IHtudWxsfSBkZWZhdWx0T3B0aW9ucy5jdXJzb3JPZmZzZXRYXHJcbiAqIEBwcm9wZXJ0eSB7bnVsbH0gZGVmYXVsdE9wdGlvbnMuY3Vyc29yT2Zmc2V0WVxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xyXG4gIGNvbnN0cmFpbkRpbWVuc2lvbnM6IGZhbHNlLFxyXG4gIHhBeGlzOiB0cnVlLFxyXG4gIHlBeGlzOiB0cnVlLFxyXG4gIGN1cnNvck9mZnNldFg6IG51bGwsXHJcbiAgY3Vyc29yT2Zmc2V0WTogbnVsbCxcclxuICB0aHJlc2hvbGRYOiBudWxsLFxyXG4gIHRocmVzaG9sZFk6IG51bGxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXJyb3IgcGx1Z2luIHdoaWNoIGNvbnRyb2xzIHRoZSBtaXJyb3IgcG9zaXRpb25pbmcgd2hpbGUgZHJhZ2dpbmdcclxuICogQGNsYXNzIE1pcnJvclxyXG4gKiBAbW9kdWxlIE1pcnJvclxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgTWlycm9yIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBNaXJyb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgTWlycm9yXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1pcnJvciBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBvcHRpb25zLmNvbnN0cmFpbkRpbWVuc2lvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gb3B0aW9ucy54QXhpc1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBvcHRpb25zLnlBeGlzXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxudWxsfSBvcHRpb25zLmN1cnNvck9mZnNldFhcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfG51bGx9IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WVxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb259IG9wdGlvbnMuYXBwZW5kVG9cclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2Nyb2xsIG9mZnNldCBmb3IgdG91Y2ggZGV2aWNlcyBiZWNhdXNlIHRoZSBtaXJyb3IgaXMgcG9zaXRpb25lZCBmaXhlZFxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHNjcm9sbE9mZnNldFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjcm9sbE9mZnNldC54XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc2Nyb2xsT2Zmc2V0LnlcclxuICAgICAqL1xyXG4gICAgdGhpcy5zY3JvbGxPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWwgc2Nyb2xsIG9mZnNldCBmb3IgdG91Y2ggZGV2aWNlcyBiZWNhdXNlIHRoZSBtaXJyb3IgaXMgcG9zaXRpb25lZCBmaXhlZFxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHNjcm9sbE9mZnNldFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjcm9sbE9mZnNldC54XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc2Nyb2xsT2Zmc2V0LnlcclxuICAgICAqL1xyXG4gICAgdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0ID0ge1xyXG4gICAgICB4OiB3aW5kb3cuc2Nyb2xsWCxcclxuICAgICAgeTogd2luZG93LnNjcm9sbFlcclxuICAgIH07XHJcblxyXG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTWlycm9yQ3JlYXRlZF0gPSB0aGlzW29uTWlycm9yQ3JlYXRlZF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25NaXJyb3JNb3ZlXSA9IHRoaXNbb25NaXJyb3JNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvblNjcm9sbF0gPSB0aGlzW29uU2Nyb2xsXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9uKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub24oJ21pcnJvcjptb3ZlJywgdGhpc1tvbk1pcnJvck1vdmVdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKS5vZmYoJ21pcnJvcjpjcmVhdGVkJywgdGhpc1tvbk1pcnJvckNyZWF0ZWRdKS5vZmYoJ21pcnJvcjptb3ZlJywgdGhpc1tvbk1pcnJvck1vdmVdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgb3B0aW9ucyBwYXNzZWQgdGhyb3VnaCBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXHJcbiAgZ2V0T3B0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLm1pcnJvciB8fCB7fTtcclxuICB9XHJcblxyXG4gIFtvbkRyYWdTdGFydF0oZHJhZ0V2ZW50KSB7XHJcbiAgICBpZiAoZHJhZ0V2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpc1tvblNjcm9sbF0sIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldCA9IHtcclxuICAgICAgeDogd2luZG93LnNjcm9sbFgsXHJcbiAgICAgIHk6IHdpbmRvdy5zY3JvbGxZXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHsgc291cmNlLCBvcmlnaW5hbFNvdXJjZSwgc291cmNlQ29udGFpbmVyLCBzZW5zb3JFdmVudCB9ID0gZHJhZ0V2ZW50O1xyXG5cclxuICAgIC8vIExhc3Qgc2Vuc29yIHBvc2l0aW9uIG9mIG1pcnJvciBtb3ZlXHJcbiAgICB0aGlzLmxhc3RNaXJyb3JNb3ZlZENsaWVudCA9IHtcclxuICAgICAgeDogc2Vuc29yRXZlbnQuY2xpZW50WCxcclxuICAgICAgeTogc2Vuc29yRXZlbnQuY2xpZW50WVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBtaXJyb3JDcmVhdGVFdmVudCA9IG5ldyBfTWlycm9yRXZlbnQuTWlycm9yQ3JlYXRlRXZlbnQoe1xyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzb3VyY2VDb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBkcmFnRXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yQ3JlYXRlRXZlbnQpO1xyXG5cclxuICAgIGlmIChpc05hdGl2ZURyYWdFdmVudChzZW5zb3JFdmVudCkgfHwgbWlycm9yQ3JlYXRlRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYXBwZW5kYWJsZUNvbnRhaW5lciA9IHRoaXNbZ2V0QXBwZW5kYWJsZUNvbnRhaW5lcl0oc291cmNlKSB8fCBzb3VyY2VDb250YWluZXI7XHJcbiAgICB0aGlzLm1pcnJvciA9IHNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XHJcblxyXG4gICAgY29uc3QgbWlycm9yQ3JlYXRlZEV2ZW50ID0gbmV3IF9NaXJyb3JFdmVudC5NaXJyb3JDcmVhdGVkRXZlbnQoe1xyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzb3VyY2VDb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBkcmFnRXZlbnQsXHJcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG1pcnJvckF0dGFjaGVkRXZlbnQgPSBuZXcgX01pcnJvckV2ZW50Lk1pcnJvckF0dGFjaGVkRXZlbnQoe1xyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzb3VyY2VDb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBkcmFnRXZlbnQsXHJcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yQ3JlYXRlZEV2ZW50KTtcclxuICAgIGFwcGVuZGFibGVDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5taXJyb3IpO1xyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JBdHRhY2hlZEV2ZW50KTtcclxuICB9XHJcblxyXG4gIFtvbkRyYWdNb3ZlXShkcmFnRXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5taXJyb3IgfHwgZHJhZ0V2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgc291cmNlLCBvcmlnaW5hbFNvdXJjZSwgc291cmNlQ29udGFpbmVyLCBzZW5zb3JFdmVudCB9ID0gZHJhZ0V2ZW50O1xyXG5cclxuICAgIGxldCBwYXNzZWRUaHJlc2hYID0gdHJ1ZTtcclxuICAgIGxldCBwYXNzZWRUaHJlc2hZID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnRocmVzaG9sZFggfHwgdGhpcy5vcHRpb25zLnRocmVzaG9sZFkpIHtcclxuICAgICAgY29uc3QgeyB4OiBsYXN0WCwgeTogbGFzdFkgfSA9IHRoaXMubGFzdE1pcnJvck1vdmVkQ2xpZW50O1xyXG5cclxuICAgICAgaWYgKE1hdGguYWJzKGxhc3RYIC0gc2Vuc29yRXZlbnQuY2xpZW50WCkgPCB0aGlzLm9wdGlvbnMudGhyZXNob2xkWCkge1xyXG4gICAgICAgIHBhc3NlZFRocmVzaFggPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmxhc3RNaXJyb3JNb3ZlZENsaWVudC54ID0gc2Vuc29yRXZlbnQuY2xpZW50WDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKE1hdGguYWJzKGxhc3RZIC0gc2Vuc29yRXZlbnQuY2xpZW50WSkgPCB0aGlzLm9wdGlvbnMudGhyZXNob2xkWSkge1xyXG4gICAgICAgIHBhc3NlZFRocmVzaFkgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmxhc3RNaXJyb3JNb3ZlZENsaWVudC55ID0gc2Vuc29yRXZlbnQuY2xpZW50WTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFwYXNzZWRUaHJlc2hYICYmICFwYXNzZWRUaHJlc2hZKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWlycm9yTW92ZUV2ZW50ID0gbmV3IF9NaXJyb3JFdmVudC5NaXJyb3JNb3ZlRXZlbnQoe1xyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzb3VyY2VDb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBkcmFnRXZlbnQsXHJcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXHJcbiAgICAgIHBhc3NlZFRocmVzaFgsXHJcbiAgICAgIHBhc3NlZFRocmVzaFlcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yTW92ZUV2ZW50KTtcclxuICB9XHJcblxyXG4gIFtvbkRyYWdTdG9wXShkcmFnRXZlbnQpIHtcclxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpc1tvblNjcm9sbF0sIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgdGhpcy5zY3JvbGxPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICBpZiAoIXRoaXMubWlycm9yKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHNvdXJjZSwgc291cmNlQ29udGFpbmVyLCBzZW5zb3JFdmVudCB9ID0gZHJhZ0V2ZW50O1xyXG5cclxuICAgIGNvbnN0IG1pcnJvckRlc3Ryb3lFdmVudCA9IG5ldyBfTWlycm9yRXZlbnQuTWlycm9yRGVzdHJveUV2ZW50KHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxyXG4gICAgICBzb3VyY2VDb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBkcmFnRXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yRGVzdHJveUV2ZW50KTtcclxuXHJcbiAgICBpZiAoIW1pcnJvckRlc3Ryb3lFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHRoaXMubWlycm9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5taXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgW29uU2Nyb2xsXSgpIHtcclxuICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0ge1xyXG4gICAgICB4OiB3aW5kb3cuc2Nyb2xsWCAtIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldC54LFxyXG4gICAgICB5OiB3aW5kb3cuc2Nyb2xsWSAtIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldC55XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlycm9yIGNyZWF0ZWQgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7TWlycm9yQ3JlYXRlZEV2ZW50fSBtaXJyb3JFdmVudFxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25NaXJyb3JDcmVhdGVkXSh7IG1pcnJvciwgc291cmNlLCBzZW5zb3JFdmVudCB9KSB7XHJcbiAgICBjb25zdCBtaXJyb3JDbGFzc2VzID0gdGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0ZvcignbWlycm9yJyk7XHJcblxyXG4gICAgY29uc3Qgc2V0U3RhdGUgPSAoX3JlZikgPT4ge1xyXG4gICAgICBsZXQgeyBtaXJyb3JPZmZzZXQsIGluaXRpYWxYLCBpbml0aWFsWSB9ID0gX3JlZixcclxuICAgICAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydtaXJyb3JPZmZzZXQnLCAnaW5pdGlhbFgnLCAnaW5pdGlhbFknXSk7XHJcblxyXG4gICAgICB0aGlzLm1pcnJvck9mZnNldCA9IG1pcnJvck9mZnNldDtcclxuICAgICAgdGhpcy5pbml0aWFsWCA9IGluaXRpYWxYO1xyXG4gICAgICB0aGlzLmluaXRpYWxZID0gaW5pdGlhbFk7XHJcbiAgICAgIHRoaXMubGFzdE1vdmVkWCA9IGluaXRpYWxYO1xyXG4gICAgICB0aGlzLmxhc3RNb3ZlZFkgPSBpbml0aWFsWTtcclxuICAgICAgcmV0dXJuIF9leHRlbmRzKHsgbWlycm9yT2Zmc2V0LCBpbml0aWFsWCwgaW5pdGlhbFkgfSwgYXJncyk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1pcnJvci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcclxuICAgICAgbWlycm9yLFxyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBtaXJyb3JDbGFzc2VzLFxyXG4gICAgICBzY3JvbGxPZmZzZXQ6IHRoaXMuc2Nyb2xsT2Zmc2V0LFxyXG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXHJcbiAgICAgIHBhc3NlZFRocmVzaFg6IHRydWUsXHJcbiAgICAgIHBhc3NlZFRocmVzaFk6IHRydWVcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbml0aWFsU3RhdGUpXHJcbiAgICAvLyBGaXggcmVmbG93IGhlcmVcclxuICAgIC50aGVuKGNvbXB1dGVNaXJyb3JEaW1lbnNpb25zKS50aGVuKGNhbGN1bGF0ZU1pcnJvck9mZnNldCkudGhlbihyZXNldE1pcnJvcikudGhlbihhZGRNaXJyb3JDbGFzc2VzKS50aGVuKHBvc2l0aW9uTWlycm9yKHsgaW5pdGlhbDogdHJ1ZSB9KSkudGhlbihyZW1vdmVNaXJyb3JJRCkudGhlbihzZXRTdGF0ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNaXJyb3IgbW92ZSBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtNaXJyb3JNb3ZlRXZlbnR9IG1pcnJvckV2ZW50XHJcbiAgICogQHJldHVybiB7UHJvbWlzZXxudWxsfVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uTWlycm9yTW92ZV0obWlycm9yRXZlbnQpIHtcclxuICAgIGlmIChtaXJyb3JFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNldFN0YXRlID0gKF9yZWYyKSA9PiB7XHJcbiAgICAgIGxldCB7IGxhc3RNb3ZlZFgsIGxhc3RNb3ZlZFkgfSA9IF9yZWYyLFxyXG4gICAgICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydsYXN0TW92ZWRYJywgJ2xhc3RNb3ZlZFknXSk7XHJcblxyXG4gICAgICB0aGlzLmxhc3RNb3ZlZFggPSBsYXN0TW92ZWRYO1xyXG4gICAgICB0aGlzLmxhc3RNb3ZlZFkgPSBsYXN0TW92ZWRZO1xyXG5cclxuICAgICAgcmV0dXJuIF9leHRlbmRzKHsgbGFzdE1vdmVkWCwgbGFzdE1vdmVkWSB9LCBhcmdzKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xyXG4gICAgICBtaXJyb3I6IG1pcnJvckV2ZW50Lm1pcnJvcixcclxuICAgICAgc2Vuc29yRXZlbnQ6IG1pcnJvckV2ZW50LnNlbnNvckV2ZW50LFxyXG4gICAgICBtaXJyb3JPZmZzZXQ6IHRoaXMubWlycm9yT2Zmc2V0LFxyXG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXHJcbiAgICAgIGluaXRpYWxYOiB0aGlzLmluaXRpYWxYLFxyXG4gICAgICBpbml0aWFsWTogdGhpcy5pbml0aWFsWSxcclxuICAgICAgc2Nyb2xsT2Zmc2V0OiB0aGlzLnNjcm9sbE9mZnNldCxcclxuICAgICAgcGFzc2VkVGhyZXNoWDogbWlycm9yRXZlbnQucGFzc2VkVGhyZXNoWCxcclxuICAgICAgcGFzc2VkVGhyZXNoWTogbWlycm9yRXZlbnQucGFzc2VkVGhyZXNoWSxcclxuICAgICAgbGFzdE1vdmVkWDogdGhpcy5sYXN0TW92ZWRYLFxyXG4gICAgICBsYXN0TW92ZWRZOiB0aGlzLmxhc3RNb3ZlZFlcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbml0aWFsU3RhdGUpLnRoZW4ocG9zaXRpb25NaXJyb3IoeyByYWY6IHRydWUgfSkpLnRoZW4oc2V0U3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhcHBlbmRhYmxlIGNvbnRhaW5lciBmb3IgbWlycm9yIGJhc2VkIG9uIHRoZSBhcHBlbmRUbyBvcHRpb25cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5zb3VyY2UgLSBDdXJyZW50IHNvdXJjZVxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gICAqL1xyXG4gIFtnZXRBcHBlbmRhYmxlQ29udGFpbmVyXShzb3VyY2UpIHtcclxuICAgIGNvbnN0IGFwcGVuZFRvID0gdGhpcy5vcHRpb25zLmFwcGVuZFRvO1xyXG5cclxuICAgIGlmICh0eXBlb2YgYXBwZW5kVG8gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGFwcGVuZFRvKTtcclxuICAgIH0gZWxzZSBpZiAoYXBwZW5kVG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gYXBwZW5kVG87XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcHBlbmRUbyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gYXBwZW5kVG8oc291cmNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBzb3VyY2UucGFyZW50Tm9kZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1pcnJvcjsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29tcHV0ZXMgbWlycm9yIGRpbWVuc2lvbnMgYmFzZWQgb24gdGhlIHNvdXJjZSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQWRkcyBzb3VyY2VSZWN0IHRvIHN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUuc291cmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuZnVuY3Rpb24gY29tcHV0ZU1pcnJvckRpbWVuc2lvbnMoX3JlZjMpIHtcclxuICBsZXQgeyBzb3VyY2UgfSA9IF9yZWYzLFxyXG4gICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYzLCBbJ3NvdXJjZSddKTtcclxuXHJcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgY29uc3Qgc291cmNlUmVjdCA9IHNvdXJjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHJlc29sdmUoX2V4dGVuZHMoeyBzb3VyY2UsIHNvdXJjZVJlY3QgfSwgYXJncykpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBtaXJyb3Igb2Zmc2V0XHJcbiAqIEFkZHMgbWlycm9yT2Zmc2V0IHRvIHN0YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gKiBAcGFyYW0ge1NlbnNvckV2ZW50fSBzdGF0ZS5zZW5zb3JFdmVudFxyXG4gKiBAcGFyYW0ge0RPTVJlY3R9IHN0YXRlLnNvdXJjZVJlY3RcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZU1pcnJvck9mZnNldChfcmVmNCkge1xyXG4gIGxldCB7IHNlbnNvckV2ZW50LCBzb3VyY2VSZWN0LCBvcHRpb25zIH0gPSBfcmVmNCxcclxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNCwgWydzZW5zb3JFdmVudCcsICdzb3VyY2VSZWN0JywgJ29wdGlvbnMnXSk7XHJcblxyXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIGNvbnN0IHRvcCA9IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WSA9PT0gbnVsbCA/IHNlbnNvckV2ZW50LmNsaWVudFkgLSBzb3VyY2VSZWN0LnRvcCA6IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WTtcclxuICAgIGNvbnN0IGxlZnQgPSBvcHRpb25zLmN1cnNvck9mZnNldFggPT09IG51bGwgPyBzZW5zb3JFdmVudC5jbGllbnRYIC0gc291cmNlUmVjdC5sZWZ0IDogb3B0aW9ucy5jdXJzb3JPZmZzZXRYO1xyXG5cclxuICAgIGNvbnN0IG1pcnJvck9mZnNldCA9IHsgdG9wLCBsZWZ0IH07XHJcblxyXG4gICAgcmVzb2x2ZShfZXh0ZW5kcyh7IHNlbnNvckV2ZW50LCBzb3VyY2VSZWN0LCBtaXJyb3JPZmZzZXQsIG9wdGlvbnMgfSwgYXJncykpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQXBwbHlzIG1pcnJvciBzdHlsZXNcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLm1pcnJvclxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5zb3VyY2VcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlLm9wdGlvbnNcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc2V0TWlycm9yKF9yZWY1KSB7XHJcbiAgbGV0IHsgbWlycm9yLCBzb3VyY2UsIG9wdGlvbnMgfSA9IF9yZWY1LFxyXG4gICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY1LCBbJ21pcnJvcicsICdzb3VyY2UnLCAnb3B0aW9ucyddKTtcclxuXHJcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgbGV0IG9mZnNldEhlaWdodDtcclxuICAgIGxldCBvZmZzZXRXaWR0aDtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5jb25zdHJhaW5EaW1lbnNpb25zKSB7XHJcbiAgICAgIGNvbnN0IGNvbXB1dGVkU291cmNlU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShzb3VyY2UpO1xyXG4gICAgICBvZmZzZXRIZWlnaHQgPSBjb21wdXRlZFNvdXJjZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKTtcclxuICAgICAgb2Zmc2V0V2lkdGggPSBjb21wdXRlZFNvdXJjZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCd3aWR0aCcpO1xyXG4gICAgfVxyXG5cclxuICAgIG1pcnJvci5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcclxuICAgIG1pcnJvci5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XHJcbiAgICBtaXJyb3Iuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcclxuICAgIG1pcnJvci5zdHlsZS50b3AgPSAwO1xyXG4gICAgbWlycm9yLnN0eWxlLmxlZnQgPSAwO1xyXG4gICAgbWlycm9yLnN0eWxlLm1hcmdpbiA9IDA7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9ucykge1xyXG4gICAgICBtaXJyb3Iuc3R5bGUuaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0O1xyXG4gICAgICBtaXJyb3Iuc3R5bGUud2lkdGggPSBvZmZzZXRXaWR0aDtcclxuICAgIH1cclxuXHJcbiAgICByZXNvbHZlKF9leHRlbmRzKHsgbWlycm9yLCBzb3VyY2UsIG9wdGlvbnMgfSwgYXJncykpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQXBwbHlzIG1pcnJvciBjbGFzcyBvbiBtaXJyb3IgZWxlbWVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUubWlycm9yXHJcbiAqIEBwYXJhbSB7U3RyaW5nW119IHN0YXRlLm1pcnJvckNsYXNzZXNcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGFkZE1pcnJvckNsYXNzZXMoX3JlZjYpIHtcclxuICBsZXQgeyBtaXJyb3IsIG1pcnJvckNsYXNzZXMgfSA9IF9yZWY2LFxyXG4gICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY2LCBbJ21pcnJvcicsICdtaXJyb3JDbGFzc2VzJ10pO1xyXG5cclxuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBtaXJyb3IuY2xhc3NMaXN0LmFkZCguLi5taXJyb3JDbGFzc2VzKTtcclxuICAgIHJlc29sdmUoX2V4dGVuZHMoeyBtaXJyb3IsIG1pcnJvckNsYXNzZXMgfSwgYXJncykpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBzb3VyY2UgSUQgZnJvbSBjbG9uZWQgbWlycm9yIGVsZW1lbnRcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLm1pcnJvclxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlTWlycm9ySUQoX3JlZjcpIHtcclxuICBsZXQgeyBtaXJyb3IgfSA9IF9yZWY3LFxyXG4gICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY3LCBbJ21pcnJvciddKTtcclxuXHJcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgbWlycm9yLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcclxuICAgIGRlbGV0ZSBtaXJyb3IuaWQ7XHJcbiAgICByZXNvbHZlKF9leHRlbmRzKHsgbWlycm9yIH0sIGFyZ3MpKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBvc2l0aW9ucyBtaXJyb3Igd2l0aCB0cmFuc2xhdGUzZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUubWlycm9yXHJcbiAqIEBwYXJhbSB7U2Vuc29yRXZlbnR9IHN0YXRlLnNlbnNvckV2ZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZS5taXJyb3JPZmZzZXRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXRlLmluaXRpYWxZXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0ZS5pbml0aWFsWFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUub3B0aW9uc1xyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcG9zaXRpb25NaXJyb3IoeyB3aXRoRnJhbWUgPSBmYWxzZSwgaW5pdGlhbCA9IGZhbHNlIH0gPSB7fSkge1xyXG4gIHJldHVybiAoX3JlZjgpID0+IHtcclxuICAgIGxldCB7XHJcbiAgICAgIG1pcnJvcixcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIG1pcnJvck9mZnNldCxcclxuICAgICAgaW5pdGlhbFksXHJcbiAgICAgIGluaXRpYWxYLFxyXG4gICAgICBzY3JvbGxPZmZzZXQsXHJcbiAgICAgIG9wdGlvbnMsXHJcbiAgICAgIHBhc3NlZFRocmVzaFgsXHJcbiAgICAgIHBhc3NlZFRocmVzaFksXHJcbiAgICAgIGxhc3RNb3ZlZFgsXHJcbiAgICAgIGxhc3RNb3ZlZFlcclxuICAgIH0gPSBfcmVmOCxcclxuICAgICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY4LCBbJ21pcnJvcicsICdzZW5zb3JFdmVudCcsICdtaXJyb3JPZmZzZXQnLCAnaW5pdGlhbFknLCAnaW5pdGlhbFgnLCAnc2Nyb2xsT2Zmc2V0JywgJ29wdGlvbnMnLCAncGFzc2VkVGhyZXNoWCcsICdwYXNzZWRUaHJlc2hZJywgJ2xhc3RNb3ZlZFgnLCAnbGFzdE1vdmVkWSddKTtcclxuXHJcbiAgICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IF9leHRlbmRzKHtcclxuICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgICAgbWlycm9yT2Zmc2V0LFxyXG4gICAgICAgIG9wdGlvbnNcclxuICAgICAgfSwgYXJncyk7XHJcblxyXG4gICAgICBpZiAobWlycm9yT2Zmc2V0KSB7XHJcbiAgICAgICAgY29uc3QgeCA9IHBhc3NlZFRocmVzaFggPyBNYXRoLnJvdW5kKChzZW5zb3JFdmVudC5jbGllbnRYIC0gbWlycm9yT2Zmc2V0LmxlZnQgLSBzY3JvbGxPZmZzZXQueCkgLyAob3B0aW9ucy50aHJlc2hvbGRYIHx8IDEpKSAqIChvcHRpb25zLnRocmVzaG9sZFggfHwgMSkgOiBNYXRoLnJvdW5kKGxhc3RNb3ZlZFgpO1xyXG4gICAgICAgIGNvbnN0IHkgPSBwYXNzZWRUaHJlc2hZID8gTWF0aC5yb3VuZCgoc2Vuc29yRXZlbnQuY2xpZW50WSAtIG1pcnJvck9mZnNldC50b3AgLSBzY3JvbGxPZmZzZXQueSkgLyAob3B0aW9ucy50aHJlc2hvbGRZIHx8IDEpKSAqIChvcHRpb25zLnRocmVzaG9sZFkgfHwgMSkgOiBNYXRoLnJvdW5kKGxhc3RNb3ZlZFkpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy54QXhpcyAmJiBvcHRpb25zLnlBeGlzIHx8IGluaXRpYWwpIHtcclxuICAgICAgICAgIG1pcnJvci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt4fXB4LCAke3l9cHgsIDApYDtcclxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMueEF4aXMgJiYgIW9wdGlvbnMueUF4aXMpIHtcclxuICAgICAgICAgIG1pcnJvci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt4fXB4LCAke2luaXRpYWxZfXB4LCAwKWA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnlBeGlzICYmICFvcHRpb25zLnhBeGlzKSB7XHJcbiAgICAgICAgICBtaXJyb3Iuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7aW5pdGlhbFh9cHgsICR7eX1weCwgMClgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGluaXRpYWwpIHtcclxuICAgICAgICAgIHJlc3VsdC5pbml0aWFsWCA9IHg7XHJcbiAgICAgICAgICByZXN1bHQuaW5pdGlhbFkgPSB5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0Lmxhc3RNb3ZlZFggPSB4O1xyXG4gICAgICAgIHJlc3VsdC5sYXN0TW92ZWRZID0geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgfSwgeyBmcmFtZTogd2l0aEZyYW1lIH0pO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXcmFwcyBmdW5jdGlvbnMgaW4gcHJvbWlzZSB3aXRoIHBvdGVudGlhbCBhbmltYXRpb24gZnJhbWUgb3B0aW9uXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yYWZcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhQcm9taXNlKGNhbGxiYWNrLCB7IHJhZiA9IGZhbHNlIH0gPSB7fSkge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBpZiAocmFmKSB7XHJcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgY2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjYWxsYmFjayhyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzZW5zb3IgZXZlbnQgd2FzIHRyaWdnZXJlZCBieSBhIG5hdGl2ZSBicm93c2VyIGRyYWcgZXZlbnRcclxuICogQHBhcmFtIHtTZW5zb3JFdmVudH0gc2Vuc29yRXZlbnRcclxuICovXHJcbmZ1bmN0aW9uIGlzTmF0aXZlRHJhZ0V2ZW50KHNlbnNvckV2ZW50KSB7XHJcbiAgcmV0dXJuICgvXmRyYWcvLnRlc3Qoc2Vuc29yRXZlbnQub3JpZ2luYWxFdmVudC50eXBlKVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfTWlycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XHJcblxyXG52YXIgX01pcnJvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NaXJyb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9NaXJyb3IyLmRlZmF1bHQ7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfTWlycm9yLmRlZmF1bHRPcHRpb25zO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Jbml0aWFsaXplID0gU3ltYm9sKCdvbkluaXRpYWxpemUnKTtcclxuY29uc3Qgb25EZXN0cm95ID0gU3ltYm9sKCdvbkRlc3Ryb3knKTtcclxuXHJcbi8qKlxyXG4gKiBGb2N1c2FibGUgZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBGb2N1c2FibGUgcGx1Z2luXHJcbiAqIEBjbGFzcyBGb2N1c2FibGVcclxuICogQG1vZHVsZSBGb2N1c2FibGVcclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIEZvY3VzYWJsZSBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogRm9jdXNhYmxlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIEZvY3VzYWJsZVxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb2N1c2FibGUgb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIHRoaXNbb25Jbml0aWFsaXplXSA9IHRoaXNbb25Jbml0aWFsaXplXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRlc3Ryb3ldID0gdGhpc1tvbkRlc3Ryb3ldLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBsaXN0ZW5lcnMgdG8gZHJhZ2dhYmxlXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWdnYWJsZTppbml0aWFsaXplJywgdGhpc1tvbkluaXRpYWxpemVdKS5vbignZHJhZ2dhYmxlOmRlc3Ryb3knLCB0aGlzW29uRGVzdHJveV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgbGlzdGVuZXJzIGZyb20gZHJhZ2dhYmxlXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnZ2FibGU6aW5pdGlhbGl6ZScsIHRoaXNbb25Jbml0aWFsaXplXSkub2ZmKCdkcmFnZ2FibGU6ZGVzdHJveScsIHRoaXNbb25EZXN0cm95XSk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIG1vZGlmaWVkIGVsZW1lbnRzIHdoZW4gZGV0YWNoXHJcbiAgICB0aGlzW29uRGVzdHJveV0oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgb3B0aW9ucyBwYXNzZWQgdGhyb3VnaCBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXHJcbiAgZ2V0T3B0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLmZvY3VzYWJsZSB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgZHJhZ2dhYmxlIGNvbnRhaW5lcnMgYW5kIGVsZW1lbnRzXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnRbXX1cclxuICAgKi9cclxuICBnZXRFbGVtZW50cygpIHtcclxuICAgIHJldHVybiBbLi4udGhpcy5kcmFnZ2FibGUuY29udGFpbmVycywgLi4udGhpcy5kcmFnZ2FibGUuZ2V0RHJhZ2dhYmxlRWxlbWVudHMoKV07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnRpYWxpemUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uSW5pdGlhbGl6ZV0oKSB7XHJcbiAgICAvLyBDYW4gd2FpdCB1bnRpbCB0aGUgbmV4dCBiZXN0IGZyYW1lIGlzIGF2YWlsYWJsZVxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgdGhpcy5nZXRFbGVtZW50cygpLmZvckVhY2goZWxlbWVudCA9PiBkZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkRlc3Ryb3ldKCkge1xyXG4gICAgLy8gQ2FuIHdhaXQgdW50aWwgdGhlIG5leHQgYmVzdCBmcmFtZSBpcyBhdmFpbGFibGVcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMuZ2V0RWxlbWVudHMoKS5mb3JFYWNoKGVsZW1lbnQgPT4gc3RyaXBFbGVtZW50KGVsZW1lbnQpKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gRm9jdXNhYmxlOyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIG1pc3NpbmcgdGFiaW5kZXggYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHNvIHRoZXkgY2FuIGJlIHJlc2V0IHdoZW4gZHJhZ2dhYmxlIGdldHMgZGVzdHJveWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0IHtIVE1MRWxlbWVudFtdfSBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmNvbnN0IGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleCA9IFtdO1xyXG5cclxuLyoqXHJcbiAqIERlY29yYXRlcyBlbGVtZW50IHdpdGggdGFiaW5kZXggYXR0cmlidXRlc1xyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGRlY29yYXRlRWxlbWVudChlbGVtZW50KSB7XHJcbiAgY29uc3QgaGFzTWlzc2luZ1RhYkluZGV4ID0gQm9vbGVhbighZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgJiYgZWxlbWVudC50YWJJbmRleCA9PT0gLTEpO1xyXG5cclxuICBpZiAoaGFzTWlzc2luZ1RhYkluZGV4KSB7XHJcbiAgICBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXgucHVzaChlbGVtZW50KTtcclxuICAgIGVsZW1lbnQudGFiSW5kZXggPSAwO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgZWxlbWVudHMgdGFiaW5kZXggYXR0cmlidXRlc1xyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpcEVsZW1lbnQoZWxlbWVudCkge1xyXG4gIGNvbnN0IHRhYkluZGV4RWxlbWVudFBvc2l0aW9uID0gZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4LmluZGV4T2YoZWxlbWVudCk7XHJcblxyXG4gIGlmICh0YWJJbmRleEVsZW1lbnRQb3NpdGlvbiAhPT0gLTEpIHtcclxuICAgIGVsZW1lbnQudGFiSW5kZXggPSAtMTtcclxuICAgIGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleC5zcGxpY2UodGFiSW5kZXhFbGVtZW50UG9zaXRpb24sIDEpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Gb2N1c2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcclxuXHJcbnZhciBfRm9jdXNhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZvY3VzYWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0ZvY3VzYWJsZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuLyoqXHJcbiAqIEFsbCBkcmFnZ2FibGUgcGx1Z2lucyBpbmhlcml0IGZyb20gdGhpcyBjbGFzcy5cclxuICogQGFic3RyYWN0XHJcbiAqIEBjbGFzcyBBYnN0cmFjdFBsdWdpblxyXG4gKiBAbW9kdWxlIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBBYnN0cmFjdFBsdWdpbiB7XHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3RQbHVnaW4gY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgQWJzdHJhY3RQbHVnaW5cclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAgICogQHByb3BlcnR5IGRyYWdnYWJsZVxyXG4gICAgICogQHR5cGUge0RyYWdnYWJsZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPdmVycmlkZSB0byBhZGQgbGlzdGVuZXJzXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRlIHRvIHJlbW92ZSBsaXN0ZW5lcnNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdFBsdWdpbjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uSW5pdGlhbGl6ZSA9IFN5bWJvbCgnb25Jbml0aWFsaXplJyk7XHJcbmNvbnN0IG9uRGVzdHJveSA9IFN5bWJvbCgnb25EZXN0cm95Jyk7XHJcbmNvbnN0IGFubm91bmNlRXZlbnQgPSBTeW1ib2woJ2Fubm91bmNlRXZlbnQnKTtcclxuY29uc3QgYW5ub3VuY2VNZXNzYWdlID0gU3ltYm9sKCdhbm5vdW5jZU1lc3NhZ2UnKTtcclxuXHJcbmNvbnN0IEFSSUFfUkVMRVZBTlQgPSAnYXJpYS1yZWxldmFudCc7XHJcbmNvbnN0IEFSSUFfQVRPTUlDID0gJ2FyaWEtYXRvbWljJztcclxuY29uc3QgQVJJQV9MSVZFID0gJ2FyaWEtbGl2ZSc7XHJcbmNvbnN0IFJPTEUgPSAncm9sZSc7XHJcblxyXG4vKipcclxuICogQW5ub3VuY2VtZW50IGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLmV4cGlyZVxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xyXG4gIGV4cGlyZTogNzAwMFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFubm91bmNlbWVudCBwbHVnaW5cclxuICogQGNsYXNzIEFubm91bmNlbWVudFxyXG4gKiBAbW9kdWxlIEFubm91bmNlbWVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgQW5ub3VuY2VtZW50IGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBBbm5vdW5jZW1lbnQgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgQW5ub3VuY2VtZW50XHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBsdWdpbiBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcmlnaW5hbCBkcmFnZ2FibGUgdHJpZ2dlciBtZXRob2QuIEhhY2sgdW50aWwgd2UgaGF2ZSBvbkFsbCBvciBvbignYWxsJylcclxuICAgICAqIEBwcm9wZXJ0eSBvcmlnaW5hbFRyaWdnZXJNZXRob2RcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcmlnaW5hbFRyaWdnZXJNZXRob2QgPSB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyO1xyXG5cclxuICAgIHRoaXNbb25Jbml0aWFsaXplXSA9IHRoaXNbb25Jbml0aWFsaXplXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRlc3Ryb3ldID0gdGhpc1tvbkRlc3Ryb3ldLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBsaXN0ZW5lcnMgdG8gZHJhZ2dhYmxlXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWdnYWJsZTppbml0aWFsaXplJywgdGhpc1tvbkluaXRpYWxpemVdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIGxpc3RlbmVycyBmcm9tIGRyYWdnYWJsZVxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZ2dhYmxlOmRlc3Ryb3knLCB0aGlzW29uRGVzdHJveV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBwYXNzZWQgaW4gb3B0aW9uc1xyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5hbm5vdW5jZW1lbnRzIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW5ub3VuY2VzIGV2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0Fic3RyYWN0RXZlbnR9IGV2ZW50XHJcbiAgICovXHJcbiAgW2Fubm91bmNlRXZlbnRdKGV2ZW50KSB7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5vcHRpb25zW2V2ZW50LnR5cGVdO1xyXG5cclxuICAgIGlmIChtZXNzYWdlICYmIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xyXG4gICAgICB0aGlzW2Fubm91bmNlTWVzc2FnZV0obWVzc2FnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpc1thbm5vdW5jZU1lc3NhZ2VdKG1lc3NhZ2UoZXZlbnQpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFubm91bmNlcyBtZXNzYWdlIHRvIHNjcmVlbiByZWFkZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXHJcbiAgICovXHJcbiAgW2Fubm91bmNlTWVzc2FnZV0obWVzc2FnZSkge1xyXG4gICAgYW5ub3VuY2UobWVzc2FnZSwgeyBleHBpcmU6IHRoaXMub3B0aW9ucy5leHBpcmUgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplIGhhbmRlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uSW5pdGlhbGl6ZV0oKSB7XHJcbiAgICAvLyBIYWNrIHVudGlsIHRoZXJlIGlzIGFuIGFwaSBmb3IgbGlzdGVuaW5nIGZvciBhbGwgZXZlbnRzXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyID0gZXZlbnQgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRoaXNbYW5ub3VuY2VFdmVudF0oZXZlbnQpO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IG9yaWdpbmFsIHRyaWdnZXIgaXMgY2FsbGVkXHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbFRyaWdnZXJNZXRob2QuY2FsbCh0aGlzLmRyYWdnYWJsZSwgZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzdHJveSBoYW5kZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkRlc3Ryb3ldKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlciA9IHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gQW5ub3VuY2VtZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3Qge0hUTUxFbGVtZW50fSBsaXZlUmVnaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5jb25zdCBsaXZlUmVnaW9uID0gY3JlYXRlUmVnaW9uKCk7XHJcblxyXG4vKipcclxuICogQW5ub3VuY2VzIG1lc3NhZ2UgdmlhIGxpdmUgcmVnaW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmV4cGlyZVxyXG4gKi9cclxuZnVuY3Rpb24gYW5ub3VuY2UobWVzc2FnZSwgeyBleHBpcmUgfSkge1xyXG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcbiAgZWxlbWVudC50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XHJcbiAgbGl2ZVJlZ2lvbi5hcHBlbmRDaGlsZChlbGVtZW50KTtcclxuXHJcbiAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgbGl2ZVJlZ2lvbi5yZW1vdmVDaGlsZChlbGVtZW50KTtcclxuICB9LCBleHBpcmUpO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyByZWdpb24gZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlZ2lvbigpIHtcclxuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsICdkcmFnZ2FibGUtbGl2ZS1yZWdpb24nKTtcclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZShBUklBX1JFTEVWQU5ULCAnYWRkaXRpb25zJyk7XHJcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoQVJJQV9BVE9NSUMsICd0cnVlJyk7XHJcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoQVJJQV9MSVZFLCAnYXNzZXJ0aXZlJyk7XHJcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoUk9MRSwgJ2xvZycpO1xyXG5cclxuICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcclxuICBlbGVtZW50LnN0eWxlLndpZHRoID0gJzFweCc7XHJcbiAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMXB4JztcclxuICBlbGVtZW50LnN0eWxlLnRvcCA9ICctMXB4JztcclxuICBlbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcblxyXG4gIHJldHVybiBlbGVtZW50O1xyXG59XHJcblxyXG4vLyBBcHBlbmQgbGl2ZSByZWdpb24gZWxlbWVudCBhcyBlYXJseSBhcyBwb3NzaWJsZVxyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xyXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGl2ZVJlZ2lvbik7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9Bbm5vdW5jZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcclxuXHJcbnZhciBfQW5ub3VuY2VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fubm91bmNlbWVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0Fubm91bmNlbWVudDIuZGVmYXVsdDtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IF9Bbm5vdW5jZW1lbnQuZGVmYXVsdE9wdGlvbnM7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuRHJhZ2dhYmxlRGVzdHJveUV2ZW50ID0gZXhwb3J0cy5EcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50ID0gZXhwb3J0cy5EcmFnZ2FibGVFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgZHJhZ2dhYmxlIGV2ZW50XHJcbiAqIEBjbGFzcyBEcmFnZ2FibGVFdmVudFxyXG4gKiBAbW9kdWxlIERyYWdnYWJsZUV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIERyYWdnYWJsZUV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKiBAcHJvcGVydHkgZHJhZ2dhYmxlXHJcbiAgICogQHR5cGUge0RyYWdnYWJsZX1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ2dhYmxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnZ2FibGU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdnYWJsZUV2ZW50ID0gRHJhZ2dhYmxlRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWdnYWJsZSBpbml0aWFsaXplZCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ2dhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdnYWJsZUV2ZW50LnR5cGUgPSAnZHJhZ2dhYmxlJztcclxuY2xhc3MgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCBleHRlbmRzIERyYWdnYWJsZUV2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQgPSBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZ2dhYmxlIGRlc3RvcnkgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnZ2FibGVEZXN0cm95RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ2dhYmxlRGVzdHJveUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudC50eXBlID0gJ2RyYWdnYWJsZTppbml0aWFsaXplJztcclxuY2xhc3MgRHJhZ2dhYmxlRGVzdHJveUV2ZW50IGV4dGVuZHMgRHJhZ2dhYmxlRXZlbnQge31cclxuZXhwb3J0cy5EcmFnZ2FibGVEZXN0cm95RXZlbnQgPSBEcmFnZ2FibGVEZXN0cm95RXZlbnQ7XHJcbkRyYWdnYWJsZURlc3Ryb3lFdmVudC50eXBlID0gJ2RyYWdnYWJsZTpkZXN0cm95JztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5EcmFnU3RvcHBlZEV2ZW50ID0gZXhwb3J0cy5EcmFnU3RvcEV2ZW50ID0gZXhwb3J0cy5EcmFnUHJlc3N1cmVFdmVudCA9IGV4cG9ydHMuRHJhZ091dENvbnRhaW5lckV2ZW50ID0gZXhwb3J0cy5EcmFnT3ZlckNvbnRhaW5lckV2ZW50ID0gZXhwb3J0cy5EcmFnT3V0RXZlbnQgPSBleHBvcnRzLkRyYWdPdmVyRXZlbnQgPSBleHBvcnRzLkRyYWdNb3ZlRXZlbnQgPSBleHBvcnRzLkRyYWdTdGFydEV2ZW50ID0gZXhwb3J0cy5EcmFnRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIGRyYWcgZXZlbnRcclxuICogQGNsYXNzIERyYWdFdmVudFxyXG4gKiBAbW9kdWxlIERyYWdFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBEcmFnRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgc291cmNlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgc291cmNlXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzb3VyY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgb3JpZ2luYWwgc291cmNlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxTb3VyY2VcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9yaWdpbmFsU291cmNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vcmlnaW5hbFNvdXJjZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgbWlycm9yIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbWlycm9yXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBtaXJyb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgc291cmNlIGNvbnRhaW5lciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IHNvdXJjZUNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc291cmNlQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2VDb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5zb3IgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgc2Vuc29yRXZlbnRcclxuICAgKiBAdHlwZSB7U2Vuc29yRXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNlbnNvckV2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zZW5zb3JFdmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9yaWdpbmFsIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHNlbnNvciBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbEV2ZW50XHJcbiAgICogQHR5cGUge0V2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvcmlnaW5hbEV2ZW50KCkge1xyXG4gICAgaWYgKHRoaXMuc2Vuc29yRXZlbnQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2Vuc29yRXZlbnQub3JpZ2luYWxFdmVudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ0V2ZW50ID0gRHJhZ0V2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgc3RhcnQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RhcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnU3RhcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdFdmVudC50eXBlID0gJ2RyYWcnO1xyXG5jbGFzcyBEcmFnU3RhcnRFdmVudCBleHRlbmRzIERyYWdFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5EcmFnU3RhcnRFdmVudCA9IERyYWdTdGFydEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG1vdmUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ01vdmVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ01vdmVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ1N0YXJ0RXZlbnQudHlwZSA9ICdkcmFnOnN0YXJ0JztcclxuRHJhZ1N0YXJ0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIERyYWdNb3ZlRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ01vdmVFdmVudCA9IERyYWdNb3ZlRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG92ZXIgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdPdmVyRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnT3ZlckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdNb3ZlRXZlbnQudHlwZSA9ICdkcmFnOm1vdmUnO1xyXG5jbGFzcyBEcmFnT3ZlckV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciB5b3UgYXJlIG92ZXJcclxuICAgKiBAcHJvcGVydHkgb3ZlckNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBlbGVtZW50IHlvdSBhcmUgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnT3ZlckV2ZW50ID0gRHJhZ092ZXJFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgb3V0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnT3V0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnT3V0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ092ZXJFdmVudC50eXBlID0gJ2RyYWc6b3Zlcic7XHJcbkRyYWdPdmVyRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIERyYWdPdXRFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBjb250YWluZXIgeW91IGFyZSBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgZWxlbWVudCB5b3UgbGVmdFxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnT3V0RXZlbnQgPSBEcmFnT3V0RXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBvdmVyIGNvbnRhaW5lciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdPdmVyQ29udGFpbmVyRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ092ZXJDb250YWluZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdPdXRFdmVudC50eXBlID0gJ2RyYWc6b3V0JztcclxuY2xhc3MgRHJhZ092ZXJDb250YWluZXJFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBjb250YWluZXIgeW91IGFyZSBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdPdmVyQ29udGFpbmVyRXZlbnQgPSBEcmFnT3ZlckNvbnRhaW5lckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBvdXQgY29udGFpbmVyIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnT3V0Q29udGFpbmVyRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnT3V0Q29udGFpbmVyRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ092ZXJDb250YWluZXJFdmVudC50eXBlID0gJ2RyYWc6b3Zlcjpjb250YWluZXInO1xyXG5jbGFzcyBEcmFnT3V0Q29udGFpbmVyRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIHlvdSBsZWZ0XHJcbiAgICogQHByb3BlcnR5IG92ZXJDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdPdXRDb250YWluZXJFdmVudCA9IERyYWdPdXRDb250YWluZXJFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHByZXNzdXJlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1ByZXNzdXJlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1ByZXNzdXJlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnT3V0Q29udGFpbmVyRXZlbnQudHlwZSA9ICdkcmFnOm91dDpjb250YWluZXInO1xyXG5jbGFzcyBEcmFnUHJlc3N1cmVFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZXNzdXJlIGFwcGxpZWQgb24gZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgcHJlc3N1cmVcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBwcmVzc3VyZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEucHJlc3N1cmU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdQcmVzc3VyZUV2ZW50ID0gRHJhZ1ByZXNzdXJlRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgc3RvcCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RvcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnU3RvcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnUHJlc3N1cmVFdmVudC50eXBlID0gJ2RyYWc6cHJlc3N1cmUnO1xyXG5jbGFzcyBEcmFnU3RvcEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdTdG9wRXZlbnQgPSBEcmFnU3RvcEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdG9wcGVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RvcHBlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1N0b3BwZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnU3RvcEV2ZW50LnR5cGUgPSAnZHJhZzpzdG9wJztcclxuY2xhc3MgRHJhZ1N0b3BwZWRFdmVudCBleHRlbmRzIERyYWdFdmVudCB7fVxyXG5leHBvcnRzLkRyYWdTdG9wcGVkRXZlbnQgPSBEcmFnU3RvcHBlZEV2ZW50O1xyXG5EcmFnU3RvcHBlZEV2ZW50LnR5cGUgPSAnZHJhZzpzdG9wcGVkJztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRHJhZ0V2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHJcbk9iamVjdC5rZXlzKF9EcmFnRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfRHJhZ0V2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9EcmFnZ2FibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcblxyXG5PYmplY3Qua2V5cyhfRHJhZ2dhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfRHJhZ2dhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX1BsdWdpbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cclxuT2JqZWN0LmtleXMoX1BsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfUGx1Z2luc1trZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbnZhciBfU2Vuc29ycyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG5PYmplY3Qua2V5cyhfU2Vuc29ycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9TZW5zb3JzW2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9EcmFnZ2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuXHJcbnZhciBfRHJhZ2dhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RyYWdnYWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0RyYWdnYWJsZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gdG91Y2hDb29yZHM7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCB0b3VjaCBldmVudCBmb3VuZCBpbiB0b3VjaGVzIG9yIGNoYW5nZWRUb3VjaGVzIG9mIGEgdG91Y2ggZXZlbnRzLlxyXG4gKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2ZW50IGEgdG91Y2ggZXZlbnRcclxuICogQHJldHVybiB7VG91Y2h9IGEgdG91Y2ggb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiB0b3VjaENvb3JkcyhldmVudCA9IHt9KSB7XHJcbiAgY29uc3QgeyB0b3VjaGVzLCBjaGFuZ2VkVG91Y2hlcyB9ID0gZXZlbnQ7XHJcbiAgcmV0dXJuIHRvdWNoZXMgJiYgdG91Y2hlc1swXSB8fCBjaGFuZ2VkVG91Y2hlcyAmJiBjaGFuZ2VkVG91Y2hlc1swXTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF90b3VjaENvb3JkcyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xyXG5cclxudmFyIF90b3VjaENvb3JkczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b3VjaENvb3Jkcyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX3RvdWNoQ29vcmRzMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBkaXN0YW5jZTtcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHgxIFRoZSBYIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHkxIFRoZSBZIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHgyIFRoZSBYIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnRcclxuICogQHBhcmFtICB7TnVtYmVyfSB5MiBUaGUgWSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50XHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XHJcbiAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiogMiArICh5MiAtIHkxKSAqKiAyKTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9kaXN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xyXG5cclxudmFyIF9kaXN0YW5jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXN0YW5jZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX2Rpc3RhbmNlMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSByZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lO1xyXG5mdW5jdGlvbiByZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XHJcbiAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcclxuXHJcbnZhciBfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0MyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gY2xvc2VzdDtcclxuY29uc3QgbWF0Y2hGdW5jdGlvbiA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvcjtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGNsb3Nlc3QgcGFyZW50IGVsZW1lbnQgb2YgYSBnaXZlbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW5cclxuICogc2VsZWN0b3Igc3RyaW5nIG9yIG1hdGNoaW5nIGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgY2hpbGQgZWxlbWVudCB0byBmaW5kIGEgcGFyZW50IG9mXHJcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBUaGUgc3RyaW5nIG9yIGZ1bmN0aW9uIHRvIHVzZSB0byBtYXRjaFxyXG4gKiAgICAgdGhlIHBhcmVudCBlbGVtZW50XHJcbiAqIEByZXR1cm4ge0VsZW1lbnR8bnVsbH1cclxuICovXHJcbmZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgdmFsdWUpIHtcclxuICBpZiAoIWVsZW1lbnQpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc2VsZWN0b3IgPSB2YWx1ZTtcclxuICBjb25zdCBjYWxsYmFjayA9IHZhbHVlO1xyXG4gIGNvbnN0IG5vZGVMaXN0ID0gdmFsdWU7XHJcbiAgY29uc3Qgc2luZ2xlRWxlbWVudCA9IHZhbHVlO1xyXG5cclxuICBjb25zdCBpc1NlbGVjdG9yID0gQm9vbGVhbih0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKTtcclxuICBjb25zdCBpc0Z1bmN0aW9uID0gQm9vbGVhbih0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpO1xyXG4gIGNvbnN0IGlzTm9kZUxpc3QgPSBCb29sZWFuKHZhbHVlIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBBcnJheSk7XHJcbiAgY29uc3QgaXNFbGVtZW50ID0gQm9vbGVhbih2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KTtcclxuXHJcbiAgZnVuY3Rpb24gY29uZGl0aW9uRm4oY3VycmVudEVsZW1lbnQpIHtcclxuICAgIGlmICghY3VycmVudEVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtZW50O1xyXG4gICAgfSBlbHNlIGlmIChpc1NlbGVjdG9yKSB7XHJcbiAgICAgIHJldHVybiBtYXRjaEZ1bmN0aW9uLmNhbGwoY3VycmVudEVsZW1lbnQsIHNlbGVjdG9yKTtcclxuICAgIH0gZWxzZSBpZiAoaXNOb2RlTGlzdCkge1xyXG4gICAgICByZXR1cm4gWy4uLm5vZGVMaXN0XS5pbmNsdWRlcyhjdXJyZW50RWxlbWVudCk7XHJcbiAgICB9IGVsc2UgaWYgKGlzRWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gc2luZ2xlRWxlbWVudCA9PT0gY3VycmVudEVsZW1lbnQ7XHJcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24pIHtcclxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGN1cnJlbnRFbGVtZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbGV0IGN1cnJlbnQgPSBlbGVtZW50O1xyXG5cclxuICBkbyB7XHJcbiAgICBjdXJyZW50ID0gY3VycmVudC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCB8fCBjdXJyZW50LmNvcnJlc3BvbmRpbmdFbGVtZW50IHx8IGN1cnJlbnQ7XHJcblxyXG4gICAgaWYgKGNvbmRpdGlvbkZuKGN1cnJlbnQpKSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XHJcbiAgfSB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50KTtcclxuXHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0NCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfY2xvc2VzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xyXG5cclxudmFyIF9jbG9zZXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb3Nlc3QpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9jbG9zZXN0Mi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxudmFyIF9EcmFnZ2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcclxuXHJcbnZhciBfRHJhZ2dhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RyYWdnYWJsZSk7XHJcblxyXG52YXIgX0Ryb3BwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcclxuY29uc3Qgb25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xyXG5jb25zdCBvbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XHJcbmNvbnN0IGRyb3BJbkRyb3B6b25lID0gU3ltYm9sKCdkcm9wSW5Ecm9wWm9uZScpO1xyXG5jb25zdCByZXR1cm5Ub09yaWdpbmFsRHJvcHpvbmUgPSBTeW1ib2woJ3JldHVyblRvT3JpZ2luYWxEcm9wem9uZScpO1xyXG5jb25zdCBjbG9zZXN0RHJvcHpvbmUgPSBTeW1ib2woJ2Nsb3Nlc3REcm9wem9uZScpO1xyXG5jb25zdCBnZXREcm9wem9uZXMgPSBTeW1ib2woJ2dldERyb3B6b25lcycpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYW5ub3VuY2VtZW50IG1lc3NhZ2Ugd2hlbiB0aGUgRHJhZ2dhYmxlIGVsZW1lbnQgaXMgZHJvcHBlZCBpbnRvIGEgZHJvcHpvbmUgZWxlbWVudFxyXG4gKiBAcGFyYW0ge0Ryb3BwYWJsZURyb3BwZWRFdmVudH0gZHJvcHBhYmxlRXZlbnRcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gb25Ecm9wcGFibGVEcm9wcGVkRGVmYXVsdEFubm91bmNlbWVudCh7IGRyYWdFdmVudCwgZHJvcHpvbmUgfSkge1xyXG4gIGNvbnN0IHNvdXJjZVRleHQgPSBkcmFnRXZlbnQuc291cmNlLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcmFnRXZlbnQuc291cmNlLmlkIHx8ICdkcmFnZ2FibGUgZWxlbWVudCc7XHJcbiAgY29uc3QgZHJvcHpvbmVUZXh0ID0gZHJvcHpvbmUudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyb3B6b25lLmlkIHx8ICdkcm9wcGFibGUgZWxlbWVudCc7XHJcblxyXG4gIHJldHVybiBgRHJvcHBlZCAke3NvdXJjZVRleHR9IGludG8gJHtkcm9wem9uZVRleHR9YDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYW5ub3VuY2VtZW50IG1lc3NhZ2Ugd2hlbiB0aGUgRHJhZ2dhYmxlIGVsZW1lbnQgaGFzIHJldHVybmVkIHRvIGl0cyBvcmlnaW5hbCBkcm9wem9uZSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7RHJvcHBhYmxlUmV0dXJuZWRFdmVudH0gZHJvcHBhYmxlRXZlbnRcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gb25Ecm9wcGFibGVSZXR1cm5lZERlZmF1bHRBbm5vdW5jZW1lbnQoeyBkcmFnRXZlbnQsIGRyb3B6b25lIH0pIHtcclxuICBjb25zdCBzb3VyY2VUZXh0ID0gZHJhZ0V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnO1xyXG4gIGNvbnN0IGRyb3B6b25lVGV4dCA9IGRyb3B6b25lLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcm9wem9uZS5pZCB8fCAnZHJvcHBhYmxlIGVsZW1lbnQnO1xyXG5cclxuICByZXR1cm4gYFJldHVybmVkICR7c291cmNlVGV4dH0gZnJvbSAke2Ryb3B6b25lVGV4dH1gO1xyXG59XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtPYmplY3R9IGRlZmF1bHRBbm5vdW5jZW1lbnRzXHJcbiAqIEBjb25zdCB7RnVuY3Rpb259IGRlZmF1bHRBbm5vdW5jZW1lbnRzWydkcm9wcGFibGU6ZHJvcHBlZCddXHJcbiAqIEBjb25zdCB7RnVuY3Rpb259IGRlZmF1bHRBbm5vdW5jZW1lbnRzWydkcm9wcGFibGU6cmV0dXJuZWQnXVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdEFubm91bmNlbWVudHMgPSB7XHJcbiAgJ2Ryb3BwYWJsZTpkcm9wcGVkJzogb25Ecm9wcGFibGVEcm9wcGVkRGVmYXVsdEFubm91bmNlbWVudCxcclxuICAnZHJvcHBhYmxlOnJldHVybmVkJzogb25Ecm9wcGFibGVSZXR1cm5lZERlZmF1bHRBbm5vdW5jZW1lbnRcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRDbGFzc2VzID0ge1xyXG4gICdkcm9wcGFibGU6YWN0aXZlJzogJ2RyYWdnYWJsZS1kcm9wem9uZS0tYWN0aXZlJyxcclxuICAnZHJvcHBhYmxlOm9jY3VwaWVkJzogJ2RyYWdnYWJsZS1kcm9wem9uZS0tb2NjdXBpZWQnXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICBkcm9wem9uZTogJy5kcmFnZ2FibGUtZHJvcHBhYmxlJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERyb3BwYWJsZSBpcyBidWlsdCBvbiB0b3Agb2YgRHJhZ2dhYmxlIGFuZCBhbGxvd3MgZHJvcHBpbmcgZHJhZ2dhYmxlIGVsZW1lbnRzXHJcbiAqIGludG8gZHJvcHpvbmUgZWxlbWVudFxyXG4gKiBAY2xhc3MgRHJvcHBhYmxlXHJcbiAqIEBtb2R1bGUgRHJvcHBhYmxlXHJcbiAqIEBleHRlbmRzIERyYWdnYWJsZVxyXG4gKi9cclxuY2xhc3MgRHJvcHBhYmxlIGV4dGVuZHMgX0RyYWdnYWJsZTIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogRHJvcHBhYmxlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIERyb3BwYWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIERyb3BwYWJsZSBjb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciBEcm9wcGFibGVcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zLCB7XHJcbiAgICAgIGNsYXNzZXM6IF9leHRlbmRzKHt9LCBkZWZhdWx0Q2xhc3Nlcywgb3B0aW9ucy5jbGFzc2VzIHx8IHt9KSxcclxuICAgICAgYW5ub3VuY2VtZW50czogX2V4dGVuZHMoe30sIGRlZmF1bHRBbm5vdW5jZW1lbnRzLCBvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pXHJcbiAgICB9KSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgZHJvcHpvbmUgZWxlbWVudHMgb24gZHJhZyBzdGFydFxyXG4gICAgICogQHByb3BlcnR5IGRyb3B6b25lc1xyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJvcHpvbmVzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExhc3QgZHJvcHpvbmUgZWxlbWVudCB0aGF0IHRoZSBzb3VyY2Ugd2FzIGRyb3BwZWQgaW50b1xyXG4gICAgICogQHByb3BlcnR5IGxhc3REcm9wem9uZVxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxhc3REcm9wem9uZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsIGRyb3B6b25lIGVsZW1lbnQgdGhhdCB0aGUgc291cmNlIHdhcyBkcmFnIGZyb21cclxuICAgICAqIEBwcm9wZXJ0eSBpbml0aWFsRHJvcHpvbmVcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbml0aWFsRHJvcHpvbmUgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnTW92ZV0gPSB0aGlzW29uRHJhZ01vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3lzIERyb3BwYWJsZSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgc3VwZXIuZGVzdHJveSgpO1xyXG5cclxuICAgIHRoaXMub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RhcnRFdmVudH0gZXZlbnQgLSBEcmFnIHN0YXJ0IGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZHJvcHpvbmVzID0gWy4uLnRoaXNbZ2V0RHJvcHpvbmVzXSgpXTtcclxuICAgIGNvbnN0IGRyb3B6b25lID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC5zZW5zb3JFdmVudC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcm9wem9uZSk7XHJcblxyXG4gICAgaWYgKCFkcm9wem9uZSkge1xyXG4gICAgICBldmVudC5jYW5jZWwoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyb3BwYWJsZVN0YXJ0RXZlbnQgPSBuZXcgX0Ryb3BwYWJsZUV2ZW50LkRyb3BwYWJsZVN0YXJ0RXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBkcm9wem9uZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVN0YXJ0RXZlbnQpO1xyXG5cclxuICAgIGlmIChkcm9wcGFibGVTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgZXZlbnQuY2FuY2VsKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmluaXRpYWxEcm9wem9uZSA9IGRyb3B6b25lO1xyXG5cclxuICAgIGZvciAoY29uc3QgZHJvcHpvbmVFbGVtZW50IG9mIHRoaXMuZHJvcHpvbmVzKSB7XHJcbiAgICAgIGlmIChkcm9wem9uZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKSkpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZHJvcHpvbmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6YWN0aXZlJykpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ01vdmVFdmVudH0gZXZlbnQgLSBEcmFnIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnTW92ZV0oZXZlbnQpIHtcclxuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkcm9wem9uZSA9IHRoaXNbY2xvc2VzdERyb3B6b25lXShldmVudC5zZW5zb3JFdmVudC50YXJnZXQpO1xyXG4gICAgY29uc3Qgb3ZlckVtcHR5RHJvcHpvbmUgPSBkcm9wem9uZSAmJiAhZHJvcHpvbmUuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKSk7XHJcblxyXG4gICAgaWYgKG92ZXJFbXB0eURyb3B6b25lICYmIHRoaXNbZHJvcEluRHJvcHpvbmVdKGV2ZW50LCBkcm9wem9uZSkpIHtcclxuICAgICAgdGhpcy5sYXN0RHJvcHpvbmUgPSBkcm9wem9uZTtcclxuICAgIH0gZWxzZSBpZiAoKCFkcm9wem9uZSB8fCBkcm9wem9uZSA9PT0gdGhpcy5pbml0aWFsRHJvcHpvbmUpICYmIHRoaXMubGFzdERyb3B6b25lKSB7XHJcbiAgICAgIHRoaXNbcmV0dXJuVG9PcmlnaW5hbERyb3B6b25lXShldmVudCk7XHJcbiAgICAgIHRoaXMubGFzdERyb3B6b25lID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RvcCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdTdG9wRXZlbnR9IGV2ZW50IC0gRHJhZyBzdG9wIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XHJcbiAgICBjb25zdCBkcm9wcGFibGVTdG9wRXZlbnQgPSBuZXcgX0Ryb3BwYWJsZUV2ZW50LkRyb3BwYWJsZVN0b3BFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGRyb3B6b25lOiB0aGlzLmxhc3REcm9wem9uZSB8fCB0aGlzLmluaXRpYWxEcm9wem9uZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVN0b3BFdmVudCk7XHJcblxyXG4gICAgY29uc3Qgb2NjdXBpZWRDbGFzc2VzID0gdGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGRyb3B6b25lIG9mIHRoaXMuZHJvcHpvbmVzKSB7XHJcbiAgICAgIGRyb3B6b25lLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6YWN0aXZlJykpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmxhc3REcm9wem9uZSAmJiB0aGlzLmxhc3REcm9wem9uZSAhPT0gdGhpcy5pbml0aWFsRHJvcHpvbmUpIHtcclxuICAgICAgdGhpcy5pbml0aWFsRHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZSguLi5vY2N1cGllZENsYXNzZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZHJvcHpvbmVzID0gbnVsbDtcclxuICAgIHRoaXMubGFzdERyb3B6b25lID0gbnVsbDtcclxuICAgIHRoaXMuaW5pdGlhbERyb3B6b25lID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyb3BzIGEgZHJhZ2dhYmxlIGVsZW1lbnQgaW50byBhIGRyb3B6b25lIGVsZW1lbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ01vdmVFdmVudH0gZXZlbnQgLSBEcmFnIG1vdmUgZXZlbnRcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkcm9wem9uZSAtIERyb3B6b25lIGVsZW1lbnQgdG8gZHJvcCBkcmFnZ2FibGUgaW50b1xyXG4gICAqL1xyXG4gIFtkcm9wSW5Ecm9wem9uZV0oZXZlbnQsIGRyb3B6b25lKSB7XHJcbiAgICBjb25zdCBkcm9wcGFibGVEcm9wcGVkRXZlbnQgPSBuZXcgX0Ryb3BwYWJsZUV2ZW50LkRyb3BwYWJsZURyb3BwZWRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGRyb3B6b25lXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJvcHBhYmxlRHJvcHBlZEV2ZW50KTtcclxuXHJcbiAgICBpZiAoZHJvcHBhYmxlRHJvcHBlZEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9jY3VwaWVkQ2xhc3NlcyA9IHRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJvcHBhYmxlOm9jY3VwaWVkJyk7XHJcblxyXG4gICAgaWYgKHRoaXMubGFzdERyb3B6b25lKSB7XHJcbiAgICAgIHRoaXMubGFzdERyb3B6b25lLmNsYXNzTGlzdC5yZW1vdmUoLi4ub2NjdXBpZWRDbGFzc2VzKTtcclxuICAgIH1cclxuXHJcbiAgICBkcm9wem9uZS5hcHBlbmRDaGlsZChldmVudC5zb3VyY2UpO1xyXG4gICAgZHJvcHpvbmUuY2xhc3NMaXN0LmFkZCguLi5vY2N1cGllZENsYXNzZXMpO1xyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW92ZXMgdGhlIHByZXZpb3VzbHkgZHJvcHBlZCBlbGVtZW50IGJhY2sgaW50byBpdHMgb3JpZ2luYWwgZHJvcHpvbmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ01vdmVFdmVudH0gZXZlbnQgLSBEcmFnIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbcmV0dXJuVG9PcmlnaW5hbERyb3B6b25lXShldmVudCkge1xyXG4gICAgY29uc3QgZHJvcHBhYmxlUmV0dXJuZWRFdmVudCA9IG5ldyBfRHJvcHBhYmxlRXZlbnQuRHJvcHBhYmxlUmV0dXJuZWRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGRyb3B6b25lOiB0aGlzLmxhc3REcm9wem9uZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVJldHVybmVkRXZlbnQpO1xyXG5cclxuICAgIGlmIChkcm9wcGFibGVSZXR1cm5lZEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaW5pdGlhbERyb3B6b25lLmFwcGVuZENoaWxkKGV2ZW50LnNvdXJjZSk7XHJcbiAgICB0aGlzLmxhc3REcm9wem9uZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJvcHBhYmxlOm9jY3VwaWVkJykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjbG9zZXN0IGRyb3B6b25lIGVsZW1lbnQgZm9yIGV2ZW4gdGFyZ2V0XHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBFdmVudCB0YXJnZXRcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfVxyXG4gICAqL1xyXG4gIFtjbG9zZXN0RHJvcHpvbmVdKHRhcmdldCkge1xyXG4gICAgaWYgKCF0aGlzLmRyb3B6b25lcykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIHRoaXMuZHJvcHpvbmVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYWxsIGN1cnJlbnQgZHJvcHpvbmUgZWxlbWVudHMgZm9yIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJuIHtOb2RlTGlzdHxIVE1MRWxlbWVudFtdfEFycmF5fVxyXG4gICAqL1xyXG4gIFtnZXREcm9wem9uZXNdKCkge1xyXG4gICAgY29uc3QgZHJvcHpvbmUgPSB0aGlzLm9wdGlvbnMuZHJvcHpvbmU7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkcm9wem9uZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZHJvcHpvbmUpO1xyXG4gICAgfSBlbHNlIGlmIChkcm9wem9uZSBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGRyb3B6b25lIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgcmV0dXJuIGRyb3B6b25lO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHJvcHpvbmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIGRyb3B6b25lKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERyb3BwYWJsZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0NiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG5jb25zdCBjYW5jZWxlZCA9IFN5bWJvbCgnY2FuY2VsZWQnKTtcclxuXHJcbi8qKlxyXG4gKiBBbGwgZXZlbnRzIGZpcmVkIGJ5IGRyYWdnYWJsZSBpbmhlcml0IHRoaXMgY2xhc3MuIFlvdSBjYW4gY2FsbCBgY2FuY2VsKClgIHRvXHJcbiAqIGNhbmNlbCBhIHNwZWNpZmljIGV2ZW50IG9yIHlvdSBjYW4gY2hlY2sgaWYgYW4gZXZlbnQgaGFzIGJlZW4gY2FuY2VsZWQgYnlcclxuICogY2FsbGluZyBgY2FuY2VsZWQoKWAuXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAY2xhc3MgQWJzdHJhY3RFdmVudFxyXG4gKiBAbW9kdWxlIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIEFic3RyYWN0RXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBBYnN0cmFjdEV2ZW50IGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIEFic3RyYWN0RXZlbnRcclxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIEV2ZW50IGRhdGFcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogRXZlbnQgdHlwZVxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcHJvcGVydHkgdHlwZVxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZGF0YSkge1xyXG4gICAgdGhpc1tjYW5jZWxlZF0gPSBmYWxzZTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFkLW9ubHkgdHlwZVxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW50IGNhbmNlbGFibGVcclxuICAgKiBAc3RhdGljXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgdHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnR5cGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFkLW9ubHkgY2FuY2VsYWJsZVxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IGNhbmNlbGFibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jYW5jZWxhYmxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FuY2VscyB0aGUgZXZlbnQgaW5zdGFuY2VcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuICBjYW5jZWwoKSB7XHJcbiAgICB0aGlzW2NhbmNlbGVkXSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBldmVudCBoYXMgYmVlbiBjYW5jZWxlZFxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgY2FuY2VsZWQoKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzW2NhbmNlbGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG5ldyBldmVudCBpbnN0YW5jZSB3aXRoIGV4aXN0aW5nIGV2ZW50IGRhdGEuXHJcbiAgICogVGhpcyBtZXRob2QgYWxsb3dzIGZvciBvdmVycmlkaW5nIG9mIGV2ZW50IGRhdGEuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdEV2ZW50fVxyXG4gICAqL1xyXG4gIGNsb25lKGRhdGEpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihfZXh0ZW5kcyh7fSwgdGhpcy5kYXRhLCBkYXRhKSk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0RXZlbnQ7XHJcbkFic3RyYWN0RXZlbnQudHlwZSA9ICdldmVudCc7XHJcbkFic3RyYWN0RXZlbnQuY2FuY2VsYWJsZSA9IGZhbHNlO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkRyb3BwYWJsZVN0b3BFdmVudCA9IGV4cG9ydHMuRHJvcHBhYmxlUmV0dXJuZWRFdmVudCA9IGV4cG9ydHMuRHJvcHBhYmxlRHJvcHBlZEV2ZW50ID0gZXhwb3J0cy5Ecm9wcGFibGVTdGFydEV2ZW50ID0gZXhwb3J0cy5Ecm9wcGFibGVFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgZHJvcHBhYmxlIGV2ZW50XHJcbiAqIEBjbGFzcyBEcm9wcGFibGVFdmVudFxyXG4gKiBAbW9kdWxlIERyb3BwYWJsZUV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIERyb3BwYWJsZUV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBkcmFnIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZHJvcHBhYmxlIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IGRyYWdFdmVudFxyXG4gICAqIEB0eXBlIHtEcmFnRXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyYWdFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Ecm9wcGFibGVFdmVudCA9IERyb3BwYWJsZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcm9wcGFibGUgc3RhcnQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJvcHBhYmxlU3RhcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJvcHBhYmxlU3RhcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyb3BwYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Ecm9wcGFibGVFdmVudC50eXBlID0gJ2Ryb3BwYWJsZSc7XHJcbmNsYXNzIERyb3BwYWJsZVN0YXJ0RXZlbnQgZXh0ZW5kcyBEcm9wcGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBpbml0aWFsIGRyb3B6b25lIGVsZW1lbnQgb2YgdGhlIGN1cnJlbnRseSBkcmFnZ2luZyBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBkcm9wem9uZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJvcHpvbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyb3B6b25lO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Ecm9wcGFibGVTdGFydEV2ZW50ID0gRHJvcHBhYmxlU3RhcnRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyb3BwYWJsZSBkcm9wcGVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcm9wcGFibGVEcm9wcGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcm9wcGFibGVEcm9wcGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJvcHBhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Ecm9wcGFibGVTdGFydEV2ZW50LnR5cGUgPSAnZHJvcHBhYmxlOnN0YXJ0JztcclxuRHJvcHBhYmxlU3RhcnRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgRHJvcHBhYmxlRHJvcHBlZEV2ZW50IGV4dGVuZHMgRHJvcHBhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZHJvcHpvbmUgZWxlbWVudCB5b3UgZHJvcHBlZCB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaW50b1xyXG4gICAqIEBwcm9wZXJ0eSBkcm9wem9uZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJvcHpvbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyb3B6b25lO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Ecm9wcGFibGVEcm9wcGVkRXZlbnQgPSBEcm9wcGFibGVEcm9wcGVkRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJvcHBhYmxlIHJldHVybmVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJvcHBhYmxlUmV0dXJuZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcm9wcGFibGVSZXR1cm5lZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcm9wcGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Ecm9wcGFibGVEcm9wcGVkRXZlbnQudHlwZSA9ICdkcm9wcGFibGU6ZHJvcHBlZCc7XHJcbkRyb3BwYWJsZURyb3BwZWRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgRHJvcHBhYmxlUmV0dXJuZWRFdmVudCBleHRlbmRzIERyb3BwYWJsZUV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRyb3B6b25lIGVsZW1lbnQgeW91IGRyYWdnZWQgYXdheSBmcm9tXHJcbiAgICogQHByb3BlcnR5IGRyb3B6b25lXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkcm9wem9uZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuZHJvcHpvbmU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyb3BwYWJsZVJldHVybmVkRXZlbnQgPSBEcm9wcGFibGVSZXR1cm5lZEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJvcHBhYmxlIHN0b3AgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyb3BwYWJsZVN0b3BFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyb3BwYWJsZVN0b3BFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcm9wcGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyb3BwYWJsZVJldHVybmVkRXZlbnQudHlwZSA9ICdkcm9wcGFibGU6cmV0dXJuZWQnO1xyXG5Ecm9wcGFibGVSZXR1cm5lZEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBEcm9wcGFibGVTdG9wRXZlbnQgZXh0ZW5kcyBEcm9wcGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBmaW5hbCBkcm9wem9uZSBlbGVtZW50IG9mIHRoZSBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBkcm9wem9uZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJvcHpvbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyb3B6b25lO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLkRyb3BwYWJsZVN0b3BFdmVudCA9IERyb3BwYWJsZVN0b3BFdmVudDtcclxuRHJvcHBhYmxlU3RvcEV2ZW50LnR5cGUgPSAnZHJvcHBhYmxlOnN0b3AnO1xyXG5Ecm9wcGFibGVTdG9wRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Ryb3BwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHJcbk9iamVjdC5rZXlzKF9Ecm9wcGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9Ecm9wcGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbnZhciBfRHJvcHBhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XHJcblxyXG52YXIgX0Ryb3BwYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ecm9wcGFibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Ecm9wcGFibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KVxyXG4vKioqKioqLyBdKTtcclxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@shopify/draggable/lib/droppable.js\n");

/***/ }),

/***/ "./node_modules/@shopify/draggable/lib/plugins.js":
/*!********************************************************!*\
  !*** ./node_modules/@shopify/draggable/lib/plugins.js ***!
  \********************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(true)\r\n\t\tmodule.exports = factory();\r\n\telse {}\r\n})(window, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __nested_webpack_require_565__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId]) {\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_565__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__nested_webpack_require_565__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__nested_webpack_require_565__.c = installedModules;\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__nested_webpack_require_565__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__nested_webpack_require_565__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// define __esModule on exports\r\n/******/ \t__nested_webpack_require_565__.r = function(exports) {\r\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\r\n/******/ \t\t}\r\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\r\n/******/ \t};\r\n/******/\r\n/******/ \t// create a fake namespace object\r\n/******/ \t// mode & 1: value is a module id, require it\r\n/******/ \t// mode & 2: merge all properties of value into the ns\r\n/******/ \t// mode & 4: return value when already ns object\r\n/******/ \t// mode & 8|1: behave like require\r\n/******/ \t__nested_webpack_require_565__.t = function(value, mode) {\r\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_565__(value);\r\n/******/ \t\tif(mode & 8) return value;\r\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\r\n/******/ \t\tvar ns = Object.create(null);\r\n/******/ \t\t__nested_webpack_require_565__.r(ns);\r\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\r\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_565__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\r\n/******/ \t\treturn ns;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__nested_webpack_require_565__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__nested_webpack_require_565__.d(getter, 'a', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__nested_webpack_require_565__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__nested_webpack_require_565__.p = \"\";\r\n/******/\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __nested_webpack_require_565__(__nested_webpack_require_565__.s = 27);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __nested_webpack_require_4113__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_4113__(22);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractPlugin2.default;\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports, __nested_webpack_require_4544__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SnappableEvent = __nested_webpack_require_4544__(10);\r\n\r\nObject.keys(_SnappableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SnappableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports, __nested_webpack_require_5020__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_5020__(21);\r\n\r\nObject.defineProperty(exports, 'closest', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_closest).default;\r\n  }\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_5020__(19);\r\n\r\nObject.defineProperty(exports, 'requestNextAnimationFrame', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_requestNextAnimationFrame).default;\r\n  }\r\n});\r\n\r\nvar _distance = __nested_webpack_require_5020__(17);\r\n\r\nObject.defineProperty(exports, 'distance', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_distance).default;\r\n  }\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_5020__(15);\r\n\r\nObject.defineProperty(exports, 'touchCoords', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_touchCoords).default;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports, __nested_webpack_require_6144__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractEvent = __nested_webpack_require_6144__(24);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractEvent2.default;\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports, __nested_webpack_require_6571__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _CollidableEvent = __nested_webpack_require_6571__(25);\r\n\r\nObject.keys(_CollidableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _CollidableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports, __nested_webpack_require_7050__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_7050__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onSortableSorted = Symbol('onSortableSorted');\r\nconst onSortableSort = Symbol('onSortableSort');\r\n\r\n/**\r\n * SortAnimation default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.duration\r\n * @property {String} defaultOptions.easingFunction\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  duration: 150,\r\n  easingFunction: 'ease-in-out'\r\n};\r\n\r\n/**\r\n * SortAnimation plugin adds sort animation for sortable\r\n * @class SortAnimation\r\n * @module SortAnimation\r\n * @extends AbstractPlugin\r\n */\r\nclass SortAnimation extends _AbstractPlugin2.default {\r\n  /**\r\n   * SortAnimation constructor.\r\n   * @constructs SortAnimation\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * SortAnimation options\r\n     * @property {Object} options\r\n     * @property {Number} defaultOptions.duration\r\n     * @property {String} defaultOptions.easingFunction\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Last animation frame\r\n     * @property {Number} lastAnimationFrame\r\n     * @type {Number}\r\n     */\r\n    this.lastAnimationFrame = null;\r\n    this.lastElements = [];\r\n\r\n    this[onSortableSorted] = this[onSortableSorted].bind(this);\r\n    this[onSortableSort] = this[onSortableSort].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('sortable:sort', this[onSortableSort]);\r\n    this.draggable.on('sortable:sorted', this[onSortableSorted]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('sortable:sort', this[onSortableSort]);\r\n    this.draggable.off('sortable:sorted', this[onSortableSorted]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.sortAnimation || {};\r\n  }\r\n\r\n  /**\r\n   * Sortable sort handler\r\n   * @param {SortableSortEvent} sortableEvent\r\n   * @private\r\n   */\r\n  [onSortableSort]({ dragEvent }) {\r\n    const { sourceContainer } = dragEvent;\r\n    const elements = this.draggable.getDraggableElementsForContainer(sourceContainer);\r\n    this.lastElements = Array.from(elements).map(el => {\r\n      return {\r\n        domEl: el,\r\n        offsetTop: el.offsetTop,\r\n        offsetLeft: el.offsetLeft\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sortable sorted handler\r\n   * @param {SortableSortedEvent} sortableEvent\r\n   * @private\r\n   */\r\n  [onSortableSorted]({ oldIndex, newIndex }) {\r\n    if (oldIndex === newIndex) {\r\n      return;\r\n    }\r\n\r\n    const effectedElements = [];\r\n    let start;\r\n    let end;\r\n    let num;\r\n    if (oldIndex > newIndex) {\r\n      start = newIndex;\r\n      end = oldIndex - 1;\r\n      num = 1;\r\n    } else {\r\n      start = oldIndex + 1;\r\n      end = newIndex;\r\n      num = -1;\r\n    }\r\n\r\n    for (let i = start; i <= end; i++) {\r\n      const from = this.lastElements[i];\r\n      const to = this.lastElements[i + num];\r\n      effectedElements.push({ from, to });\r\n    }\r\n    cancelAnimationFrame(this.lastAnimationFrame);\r\n\r\n    // Can be done in a separate frame\r\n    this.lastAnimationFrame = requestAnimationFrame(() => {\r\n      effectedElements.forEach(element => animate(element, this.options));\r\n    });\r\n  }\r\n}\r\n\r\nexports.default = SortAnimation; /**\r\n                                  * Animates two elements\r\n                                  * @param {Object} element\r\n                                  * @param {Object} element.from\r\n                                  * @param {Object} element.to\r\n                                  * @param {Object} options\r\n                                  * @param {Number} options.duration\r\n                                  * @param {String} options.easingFunction\r\n                                  * @private\r\n                                  */\r\n\r\nfunction animate({ from, to }, { duration, easingFunction }) {\r\n  const domEl = from.domEl;\r\n  const x = from.offsetLeft - to.offsetLeft;\r\n  const y = from.offsetTop - to.offsetTop;\r\n\r\n  domEl.style.pointerEvents = 'none';\r\n  domEl.style.transform = `translate3d(${x}px, ${y}px, 0)`;\r\n\r\n  requestAnimationFrame(() => {\r\n    domEl.addEventListener('transitionend', resetElementOnTransitionEnd);\r\n    domEl.style.transition = `transform ${duration}ms ${easingFunction}`;\r\n    domEl.style.transform = '';\r\n  });\r\n}\r\n\r\n/**\r\n * Resets animation style properties after animation has completed\r\n * @param {Event} event\r\n * @private\r\n */\r\nfunction resetElementOnTransitionEnd(event) {\r\n  event.target.style.transition = '';\r\n  event.target.style.pointerEvents = '';\r\n  event.target.removeEventListener('transitionend', resetElementOnTransitionEnd);\r\n}\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports, __nested_webpack_require_12519__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _SortAnimation = __nested_webpack_require_12519__(5);\r\n\r\nvar _SortAnimation2 = _interopRequireDefault(_SortAnimation);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _SortAnimation2.default;\r\nexports.defaultOptions = _SortAnimation.defaultOptions;\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports, __nested_webpack_require_13039__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_13039__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onSortableSorted = Symbol('onSortableSorted');\r\n\r\n/**\r\n * SwapAnimation default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.duration\r\n * @property {String} defaultOptions.easingFunction\r\n * @property {Boolean} defaultOptions.horizontal\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  duration: 150,\r\n  easingFunction: 'ease-in-out',\r\n  horizontal: false\r\n};\r\n\r\n/**\r\n * SwapAnimation plugin adds swap animations for sortable\r\n * @class SwapAnimation\r\n * @module SwapAnimation\r\n * @extends AbstractPlugin\r\n */\r\nclass SwapAnimation extends _AbstractPlugin2.default {\r\n  /**\r\n   * SwapAnimation constructor.\r\n   * @constructs SwapAnimation\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * SwapAnimation options\r\n     * @property {Object} options\r\n     * @property {Number} defaultOptions.duration\r\n     * @property {String} defaultOptions.easingFunction\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Last animation frame\r\n     * @property {Number} lastAnimationFrame\r\n     * @type {Number}\r\n     */\r\n    this.lastAnimationFrame = null;\r\n\r\n    this[onSortableSorted] = this[onSortableSorted].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('sortable:sorted', this[onSortableSorted]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('sortable:sorted', this[onSortableSorted]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.swapAnimation || {};\r\n  }\r\n\r\n  /**\r\n   * Sortable sorted handler\r\n   * @param {SortableSortedEvent} sortableEvent\r\n   * @private\r\n   */\r\n  [onSortableSorted]({ oldIndex, newIndex, dragEvent }) {\r\n    const { source, over } = dragEvent;\r\n\r\n    cancelAnimationFrame(this.lastAnimationFrame);\r\n\r\n    // Can be done in a separate frame\r\n    this.lastAnimationFrame = requestAnimationFrame(() => {\r\n      if (oldIndex >= newIndex) {\r\n        animate(source, over, this.options);\r\n      } else {\r\n        animate(over, source, this.options);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexports.default = SwapAnimation; /**\r\n                                  * Animates two elements\r\n                                  * @param {HTMLElement} from\r\n                                  * @param {HTMLElement} to\r\n                                  * @param {Object} options\r\n                                  * @param {Number} options.duration\r\n                                  * @param {String} options.easingFunction\r\n                                  * @param {String} options.horizontal\r\n                                  * @private\r\n                                  */\r\n\r\nfunction animate(from, to, { duration, easingFunction, horizontal }) {\r\n  for (const element of [from, to]) {\r\n    element.style.pointerEvents = 'none';\r\n  }\r\n\r\n  if (horizontal) {\r\n    const width = from.offsetWidth;\r\n    from.style.transform = `translate3d(${width}px, 0, 0)`;\r\n    to.style.transform = `translate3d(-${width}px, 0, 0)`;\r\n  } else {\r\n    const height = from.offsetHeight;\r\n    from.style.transform = `translate3d(0, ${height}px, 0)`;\r\n    to.style.transform = `translate3d(0, -${height}px, 0)`;\r\n  }\r\n\r\n  requestAnimationFrame(() => {\r\n    for (const element of [from, to]) {\r\n      element.addEventListener('transitionend', resetElementOnTransitionEnd);\r\n      element.style.transition = `transform ${duration}ms ${easingFunction}`;\r\n      element.style.transform = '';\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Resets animation style properties after animation has completed\r\n * @param {Event} event\r\n * @private\r\n */\r\nfunction resetElementOnTransitionEnd(event) {\r\n  event.target.style.transition = '';\r\n  event.target.style.pointerEvents = '';\r\n  event.target.removeEventListener('transitionend', resetElementOnTransitionEnd);\r\n}\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ (function(module, exports, __nested_webpack_require_17772__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _SwapAnimation = __nested_webpack_require_17772__(7);\r\n\r\nvar _SwapAnimation2 = _interopRequireDefault(_SwapAnimation);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _SwapAnimation2.default;\r\nexports.defaultOptions = _SwapAnimation.defaultOptions;\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ (function(module, exports, __nested_webpack_require_18292__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_18292__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _SnappableEvent = __nested_webpack_require_18292__(1);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragOut = Symbol('onDragOut');\r\nconst onMirrorCreated = Symbol('onMirrorCreated');\r\nconst onMirrorDestroy = Symbol('onMirrorDestroy');\r\n\r\n/**\r\n * Snappable plugin which snaps draggable elements into place\r\n * @class Snappable\r\n * @module Snappable\r\n * @extends AbstractPlugin\r\n */\r\nclass Snappable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Snappable constructor.\r\n   * @constructs Snappable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Keeps track of the first source element\r\n     * @property {HTMLElement|null} firstSource\r\n     */\r\n    this.firstSource = null;\r\n\r\n    /**\r\n     * Keeps track of the mirror element\r\n     * @property {HTMLElement} mirror\r\n     */\r\n    this.mirror = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragOut] = this[onDragOut].bind(this);\r\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\r\n    this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:stop', this[onDragStop]).on('drag:over', this[onDragOver]).on('drag:out', this[onDragOut]).on('droppable:over', this[onDragOver]).on('droppable:out', this[onDragOut]).on('mirror:created', this[onMirrorCreated]).on('mirror:destroy', this[onMirrorDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:stop', this[onDragStop]).off('drag:over', this[onDragOver]).off('drag:out', this[onDragOut]).off('droppable:over', this[onDragOver]).off('droppable:out', this[onDragOut]).off('mirror:created', this[onMirrorCreated]).off('mirror:destroy', this[onMirrorDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {DragStartEvent} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    this.firstSource = event.source;\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop]() {\r\n    this.firstSource = null;\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {DragOverEvent|DroppableOverEvent} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const source = event.source || event.dragEvent.source;\r\n\r\n    if (source === this.firstSource) {\r\n      this.firstSource = null;\r\n      return;\r\n    }\r\n\r\n    const snapInEvent = new _SnappableEvent.SnapInEvent({\r\n      dragEvent: event,\r\n      snappable: event.over || event.droppable\r\n    });\r\n\r\n    this.draggable.trigger(snapInEvent);\r\n\r\n    if (snapInEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    if (this.mirror) {\r\n      this.mirror.style.display = 'none';\r\n    }\r\n\r\n    source.classList.remove(...this.draggable.getClassNamesFor('source:dragging'));\r\n    source.classList.add(...this.draggable.getClassNamesFor('source:placed'));\r\n\r\n    // Need to cancel this in drag out\r\n    setTimeout(() => {\r\n      source.classList.remove(...this.draggable.getClassNamesFor('source:placed'));\r\n    }, this.draggable.options.placedTimeout);\r\n  }\r\n\r\n  /**\r\n   * Drag out handler\r\n   * @private\r\n   * @param {DragOutEvent|DroppableOutEvent} event - Drag out event\r\n   */\r\n  [onDragOut](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const source = event.source || event.dragEvent.source;\r\n\r\n    const snapOutEvent = new _SnappableEvent.SnapOutEvent({\r\n      dragEvent: event,\r\n      snappable: event.over || event.droppable\r\n    });\r\n\r\n    this.draggable.trigger(snapOutEvent);\r\n\r\n    if (snapOutEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    if (this.mirror) {\r\n      this.mirror.style.display = '';\r\n    }\r\n\r\n    source.classList.add(...this.draggable.getClassNamesFor('source:dragging'));\r\n  }\r\n\r\n  /**\r\n   * Mirror created handler\r\n   * @param {MirrorCreatedEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorCreated]({ mirror }) {\r\n    this.mirror = mirror;\r\n  }\r\n\r\n  /**\r\n   * Mirror destroy handler\r\n   * @param {MirrorDestroyEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorDestroy]() {\r\n    this.mirror = null;\r\n  }\r\n}\r\nexports.default = Snappable;\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ (function(module, exports, __nested_webpack_require_23278__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.SnapOutEvent = exports.SnapInEvent = exports.SnapEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_23278__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base snap event\r\n * @class SnapEvent\r\n * @module SnapEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SnapEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Drag event that triggered this snap event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n\r\n  /**\r\n   * Snappable element\r\n   * @property snappable\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get snappable() {\r\n    return this.data.snappable;\r\n  }\r\n}\r\n\r\nexports.SnapEvent = SnapEvent; /**\r\n                                * Snap in event\r\n                                * @class SnapInEvent\r\n                                * @module SnapInEvent\r\n                                * @extends SnapEvent\r\n                                */\r\n\r\nSnapEvent.type = 'snap';\r\nclass SnapInEvent extends SnapEvent {}\r\n\r\nexports.SnapInEvent = SnapInEvent; /**\r\n                                    * Snap out event\r\n                                    * @class SnapOutEvent\r\n                                    * @module SnapOutEvent\r\n                                    * @extends SnapEvent\r\n                                    */\r\n\r\nSnapInEvent.type = 'snap:in';\r\nSnapInEvent.cancelable = true;\r\nclass SnapOutEvent extends SnapEvent {}\r\nexports.SnapOutEvent = SnapOutEvent;\r\nSnapOutEvent.type = 'snap:out';\r\nSnapOutEvent.cancelable = true;\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ (function(module, exports, __nested_webpack_require_25125__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SnappableEvent = __nested_webpack_require_25125__(1);\r\n\r\nObject.keys(_SnappableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SnappableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Snappable = __nested_webpack_require_25125__(9);\r\n\r\nvar _Snappable2 = _interopRequireDefault(_Snappable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Snappable2.default;\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ (function(module, exports, __nested_webpack_require_25843__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_25843__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _utils = __nested_webpack_require_25843__(2);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMirrorCreated = Symbol('onMirrorCreated');\r\nconst onMirrorDestroy = Symbol('onMirrorDestroy');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst resize = Symbol('resize');\r\n\r\n/**\r\n * ResizeMirror default options\r\n * @property {Object} defaultOptions\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {};\r\n\r\n/**\r\n * The ResizeMirror plugin resizes the mirror element to the dimensions of the draggable element that the mirror is hovering over\r\n * @class ResizeMirror\r\n * @module ResizeMirror\r\n * @extends AbstractPlugin\r\n */\r\nclass ResizeMirror extends _AbstractPlugin2.default {\r\n  /**\r\n   * ResizeMirror constructor.\r\n   * @constructs ResizeMirror\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * ResizeMirror options\r\n     * @property {Object} options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * ResizeMirror remembers the last width when resizing the mirror\r\n     * to avoid additional writes to the DOM\r\n     * @property {number} lastWidth\r\n     */\r\n    this.lastWidth = 0;\r\n\r\n    /**\r\n     * ResizeMirror remembers the last height when resizing the mirror\r\n     * to avoid additional writes to the DOM\r\n     * @property {number} lastHeight\r\n     */\r\n    this.lastHeight = 0;\r\n\r\n    /**\r\n     * Keeps track of the mirror element\r\n     * @property {HTMLElement} mirror\r\n     */\r\n    this.mirror = null;\r\n\r\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\r\n    this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('mirror:created', this[onMirrorCreated]).on('drag:over', this[onDragOver]).on('drag:over:container', this[onDragOver]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('mirror:created', this[onMirrorCreated]).off('mirror:destroy', this[onMirrorDestroy]).off('drag:over', this[onDragOver]).off('drag:over:container', this[onDragOver]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.resizeMirror || {};\r\n  }\r\n\r\n  /**\r\n   * Mirror created handler\r\n   * @param {MirrorCreatedEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorCreated]({ mirror }) {\r\n    this.mirror = mirror;\r\n  }\r\n\r\n  /**\r\n   * Mirror destroy handler\r\n   * @param {MirrorDestroyEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorDestroy]() {\r\n    this.mirror = null;\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @param {DragOverEvent | DragOverContainer} dragEvent\r\n   * @private\r\n   */\r\n  [onDragOver](dragEvent) {\r\n    this[resize](dragEvent);\r\n  }\r\n\r\n  /**\r\n   * Resize function for\r\n   * @param {DragOverEvent | DragOverContainer} dragEvent\r\n   * @private\r\n   */\r\n  [resize]({ overContainer, over }) {\r\n    requestAnimationFrame(() => {\r\n      if (!this.mirror.parentNode) {\r\n        return;\r\n      }\r\n\r\n      if (this.mirror.parentNode !== overContainer) {\r\n        overContainer.appendChild(this.mirror);\r\n      }\r\n\r\n      const overElement = over || this.draggable.getDraggableElementsForContainer(overContainer)[0];\r\n\r\n      if (!overElement) {\r\n        return;\r\n      }\r\n\r\n      (0, _utils.requestNextAnimationFrame)(() => {\r\n        const overRect = overElement.getBoundingClientRect();\r\n\r\n        if (this.lastHeight === overRect.height && this.lastWidth === overRect.width) {\r\n          return;\r\n        }\r\n\r\n        this.mirror.style.width = `${overRect.width}px`;\r\n        this.mirror.style.height = `${overRect.height}px`;\r\n\r\n        this.lastWidth = overRect.width;\r\n        this.lastHeight = overRect.height;\r\n      });\r\n    });\r\n  }\r\n}\r\nexports.default = ResizeMirror;\r\n\r\n/***/ }),\r\n/* 13 */\r\n/***/ (function(module, exports, __nested_webpack_require_30444__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _ResizeMirror = __nested_webpack_require_30444__(12);\r\n\r\nvar _ResizeMirror2 = _interopRequireDefault(_ResizeMirror);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _ResizeMirror2.default;\r\nexports.defaultOptions = _ResizeMirror.defaultOptions;\r\n\r\n/***/ }),\r\n/* 14 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = touchCoords;\r\n/**\r\n * Returns the first touch event found in touches or changedTouches of a touch events.\r\n * @param {TouchEvent} event a touch event\r\n * @return {Touch} a touch object\r\n */\r\nfunction touchCoords(event = {}) {\r\n  const { touches, changedTouches } = event;\r\n  return touches && touches[0] || changedTouches && changedTouches[0];\r\n}\r\n\r\n/***/ }),\r\n/* 15 */\r\n/***/ (function(module, exports, __nested_webpack_require_31496__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_31496__(14);\r\n\r\nvar _touchCoords2 = _interopRequireDefault(_touchCoords);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _touchCoords2.default;\r\n\r\n/***/ }),\r\n/* 16 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = distance;\r\n/**\r\n * Returns the distance between two points\r\n * @param  {Number} x1 The X position of the first point\r\n * @param  {Number} y1 The Y position of the first point\r\n * @param  {Number} x2 The X position of the second point\r\n * @param  {Number} y2 The Y position of the second point\r\n * @return {Number}\r\n */\r\nfunction distance(x1, y1, x2, y2) {\r\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\r\n}\r\n\r\n/***/ }),\r\n/* 17 */\r\n/***/ (function(module, exports, __nested_webpack_require_32517__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _distance = __nested_webpack_require_32517__(16);\r\n\r\nvar _distance2 = _interopRequireDefault(_distance);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _distance2.default;\r\n\r\n/***/ }),\r\n/* 18 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = requestNextAnimationFrame;\r\nfunction requestNextAnimationFrame(callback) {\r\n  return requestAnimationFrame(() => {\r\n    requestAnimationFrame(callback);\r\n  });\r\n}\r\n\r\n/***/ }),\r\n/* 19 */\r\n/***/ (function(module, exports, __nested_webpack_require_33276__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_33276__(18);\r\n\r\nvar _requestNextAnimationFrame2 = _interopRequireDefault(_requestNextAnimationFrame);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _requestNextAnimationFrame2.default;\r\n\r\n/***/ }),\r\n/* 20 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = closest;\r\nconst matchFunction = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector;\r\n\r\n/**\r\n * Get the closest parent element of a given element that matches the given\r\n * selector string or matching function\r\n *\r\n * @param {Element} element The child element to find a parent of\r\n * @param {String|Function} selector The string or function to use to match\r\n *     the parent element\r\n * @return {Element|null}\r\n */\r\nfunction closest(element, value) {\r\n  if (!element) {\r\n    return null;\r\n  }\r\n\r\n  const selector = value;\r\n  const callback = value;\r\n  const nodeList = value;\r\n  const singleElement = value;\r\n\r\n  const isSelector = Boolean(typeof value === 'string');\r\n  const isFunction = Boolean(typeof value === 'function');\r\n  const isNodeList = Boolean(value instanceof NodeList || value instanceof Array);\r\n  const isElement = Boolean(value instanceof HTMLElement);\r\n\r\n  function conditionFn(currentElement) {\r\n    if (!currentElement) {\r\n      return currentElement;\r\n    } else if (isSelector) {\r\n      return matchFunction.call(currentElement, selector);\r\n    } else if (isNodeList) {\r\n      return [...nodeList].includes(currentElement);\r\n    } else if (isElement) {\r\n      return singleElement === currentElement;\r\n    } else if (isFunction) {\r\n      return callback(currentElement);\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  let current = element;\r\n\r\n  do {\r\n    current = current.correspondingUseElement || current.correspondingElement || current;\r\n\r\n    if (conditionFn(current)) {\r\n      return current;\r\n    }\r\n\r\n    current = current.parentNode;\r\n  } while (current && current !== document.body && current !== document);\r\n\r\n  return null;\r\n}\r\n\r\n/***/ }),\r\n/* 21 */\r\n/***/ (function(module, exports, __nested_webpack_require_35706__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_35706__(20);\r\n\r\nvar _closest2 = _interopRequireDefault(_closest);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _closest2.default;\r\n\r\n/***/ }),\r\n/* 22 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * All draggable plugins inherit from this class.\r\n * @abstract\r\n * @class AbstractPlugin\r\n * @module AbstractPlugin\r\n */\r\nclass AbstractPlugin {\r\n  /**\r\n   * AbstractPlugin constructor.\r\n   * @constructs AbstractPlugin\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    /**\r\n     * Draggable instance\r\n     * @property draggable\r\n     * @type {Draggable}\r\n     */\r\n    this.draggable = draggable;\r\n  }\r\n\r\n  /**\r\n   * Override to add listeners\r\n   * @abstract\r\n   */\r\n  attach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n\r\n  /**\r\n   * Override to remove listeners\r\n   * @abstract\r\n   */\r\n  detach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n}\r\nexports.default = AbstractPlugin;\r\n\r\n/***/ }),\r\n/* 23 */\r\n/***/ (function(module, exports, __nested_webpack_require_37022__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_37022__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _utils = __nested_webpack_require_37022__(2);\r\n\r\nvar _CollidableEvent = __nested_webpack_require_37022__(4);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragMove = Symbol('onDragMove');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst onRequestAnimationFrame = Symbol('onRequestAnimationFrame');\r\n\r\n/**\r\n * Collidable plugin which detects colliding elements while dragging\r\n * @class Collidable\r\n * @module Collidable\r\n * @extends AbstractPlugin\r\n */\r\nclass Collidable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Collidable constructor.\r\n   * @constructs Collidable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Keeps track of currently colliding elements\r\n     * @property {HTMLElement|null} currentlyCollidingElement\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.currentlyCollidingElement = null;\r\n\r\n    /**\r\n     * Keeps track of currently colliding elements\r\n     * @property {HTMLElement|null} lastCollidingElement\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.lastCollidingElement = null;\r\n\r\n    /**\r\n     * Animation frame for finding colliding elements\r\n     * @property {Number|null} currentAnimationFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.currentAnimationFrame = null;\r\n\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onRequestAnimationFrame] = this[onRequestAnimationFrame].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Returns current collidables based on `collidables` option\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getCollidables() {\r\n    const collidables = this.draggable.options.collidables;\r\n\r\n    if (typeof collidables === 'string') {\r\n      return Array.prototype.slice.call(document.querySelectorAll(collidables));\r\n    } else if (collidables instanceof NodeList || collidables instanceof Array) {\r\n      return Array.prototype.slice.call(collidables);\r\n    } else if (collidables instanceof HTMLElement) {\r\n      return [collidables];\r\n    } else if (typeof collidables === 'function') {\r\n      return collidables();\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag move handler\r\n   * @private\r\n   * @param {DragMoveEvent} event - Drag move event\r\n   */\r\n  [onDragMove](event) {\r\n    const target = event.sensorEvent.target;\r\n\r\n    this.currentAnimationFrame = requestAnimationFrame(this[onRequestAnimationFrame](target));\r\n\r\n    if (this.currentlyCollidingElement) {\r\n      event.cancel();\r\n    }\r\n\r\n    const collidableInEvent = new _CollidableEvent.CollidableInEvent({\r\n      dragEvent: event,\r\n      collidingElement: this.currentlyCollidingElement\r\n    });\r\n\r\n    const collidableOutEvent = new _CollidableEvent.CollidableOutEvent({\r\n      dragEvent: event,\r\n      collidingElement: this.lastCollidingElement\r\n    });\r\n\r\n    const enteringCollidable = Boolean(this.currentlyCollidingElement && this.lastCollidingElement !== this.currentlyCollidingElement);\r\n    const leavingCollidable = Boolean(!this.currentlyCollidingElement && this.lastCollidingElement);\r\n\r\n    if (enteringCollidable) {\r\n      if (this.lastCollidingElement) {\r\n        this.draggable.trigger(collidableOutEvent);\r\n      }\r\n\r\n      this.draggable.trigger(collidableInEvent);\r\n    } else if (leavingCollidable) {\r\n      this.draggable.trigger(collidableOutEvent);\r\n    }\r\n\r\n    this.lastCollidingElement = this.currentlyCollidingElement;\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop](event) {\r\n    const lastCollidingElement = this.currentlyCollidingElement || this.lastCollidingElement;\r\n    const collidableOutEvent = new _CollidableEvent.CollidableOutEvent({\r\n      dragEvent: event,\r\n      collidingElement: lastCollidingElement\r\n    });\r\n\r\n    if (lastCollidingElement) {\r\n      this.draggable.trigger(collidableOutEvent);\r\n    }\r\n\r\n    this.lastCollidingElement = null;\r\n    this.currentlyCollidingElement = null;\r\n  }\r\n\r\n  /**\r\n   * Animation frame function\r\n   * @private\r\n   * @param {HTMLElement} target - Current move target\r\n   * @return {Function}\r\n   */\r\n  [onRequestAnimationFrame](target) {\r\n    return () => {\r\n      const collidables = this.getCollidables();\r\n      this.currentlyCollidingElement = (0, _utils.closest)(target, element => collidables.includes(element));\r\n    };\r\n  }\r\n}\r\nexports.default = Collidable;\r\n\r\n/***/ }),\r\n/* 24 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst canceled = Symbol('canceled');\r\n\r\n/**\r\n * All events fired by draggable inherit this class. You can call `cancel()` to\r\n * cancel a specific event or you can check if an event has been canceled by\r\n * calling `canceled()`.\r\n * @abstract\r\n * @class AbstractEvent\r\n * @module AbstractEvent\r\n */\r\nclass AbstractEvent {\r\n\r\n  /**\r\n   * AbstractEvent constructor.\r\n   * @constructs AbstractEvent\r\n   * @param {object} data - Event data\r\n   */\r\n\r\n  /**\r\n   * Event type\r\n   * @static\r\n   * @abstract\r\n   * @property type\r\n   * @type {String}\r\n   */\r\n  constructor(data) {\r\n    this[canceled] = false;\r\n    this.data = data;\r\n  }\r\n\r\n  /**\r\n   * Read-only type\r\n   * @abstract\r\n   * @return {String}\r\n   */\r\n\r\n\r\n  /**\r\n   * Event cancelable\r\n   * @static\r\n   * @abstract\r\n   * @property cancelable\r\n   * @type {Boolean}\r\n   */\r\n  get type() {\r\n    return this.constructor.type;\r\n  }\r\n\r\n  /**\r\n   * Read-only cancelable\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  get cancelable() {\r\n    return this.constructor.cancelable;\r\n  }\r\n\r\n  /**\r\n   * Cancels the event instance\r\n   * @abstract\r\n   */\r\n  cancel() {\r\n    this[canceled] = true;\r\n  }\r\n\r\n  /**\r\n   * Check if event has been canceled\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  canceled() {\r\n    return Boolean(this[canceled]);\r\n  }\r\n\r\n  /**\r\n   * Returns new event instance with existing event data.\r\n   * This method allows for overriding of event data.\r\n   * @param {Object} data\r\n   * @return {AbstractEvent}\r\n   */\r\n  clone(data) {\r\n    return new this.constructor(_extends({}, this.data, data));\r\n  }\r\n}\r\nexports.default = AbstractEvent;\r\nAbstractEvent.type = 'event';\r\nAbstractEvent.cancelable = false;\r\n\r\n/***/ }),\r\n/* 25 */\r\n/***/ (function(module, exports, __nested_webpack_require_44190__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.CollidableOutEvent = exports.CollidableInEvent = exports.CollidableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_44190__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base collidable event\r\n * @class CollidableEvent\r\n * @module CollidableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass CollidableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Drag event that triggered this colliable event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n}\r\n\r\nexports.CollidableEvent = CollidableEvent; /**\r\n                                            * Collidable in event\r\n                                            * @class CollidableInEvent\r\n                                            * @module CollidableInEvent\r\n                                            * @extends CollidableEvent\r\n                                            */\r\n\r\nCollidableEvent.type = 'collidable';\r\nclass CollidableInEvent extends CollidableEvent {\r\n\r\n  /**\r\n   * Element you are currently colliding with\r\n   * @property collidingElement\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get collidingElement() {\r\n    return this.data.collidingElement;\r\n  }\r\n}\r\n\r\nexports.CollidableInEvent = CollidableInEvent; /**\r\n                                                * Collidable out event\r\n                                                * @class CollidableOutEvent\r\n                                                * @module CollidableOutEvent\r\n                                                * @extends CollidableEvent\r\n                                                */\r\n\r\nCollidableInEvent.type = 'collidable:in';\r\nclass CollidableOutEvent extends CollidableEvent {\r\n\r\n  /**\r\n   * Element you were previously colliding with\r\n   * @property collidingElement\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get collidingElement() {\r\n    return this.data.collidingElement;\r\n  }\r\n}\r\nexports.CollidableOutEvent = CollidableOutEvent;\r\nCollidableOutEvent.type = 'collidable:out';\r\n\r\n/***/ }),\r\n/* 26 */\r\n/***/ (function(module, exports, __nested_webpack_require_46544__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _CollidableEvent = __nested_webpack_require_46544__(4);\r\n\r\nObject.keys(_CollidableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _CollidableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Collidable = __nested_webpack_require_46544__(23);\r\n\r\nvar _Collidable2 = _interopRequireDefault(_Collidable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Collidable2.default;\r\n\r\n/***/ }),\r\n/* 27 */\r\n/***/ (function(module, exports, __nested_webpack_require_47270__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Collidable = __nested_webpack_require_47270__(26);\r\n\r\nObject.defineProperty(exports, 'Collidable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Collidable).default;\r\n  }\r\n});\r\n\r\nvar _ResizeMirror = __nested_webpack_require_47270__(13);\r\n\r\nObject.defineProperty(exports, 'ResizeMirror', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_ResizeMirror).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultResizeMirrorOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _ResizeMirror.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Snappable = __nested_webpack_require_47270__(11);\r\n\r\nObject.defineProperty(exports, 'Snappable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Snappable).default;\r\n  }\r\n});\r\n\r\nvar _SwapAnimation = __nested_webpack_require_47270__(8);\r\n\r\nObject.defineProperty(exports, 'SwapAnimation', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_SwapAnimation).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultSwapAnimationOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _SwapAnimation.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _SortAnimation = __nested_webpack_require_47270__(6);\r\n\r\nObject.defineProperty(exports, 'SortAnimation', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_SortAnimation).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultSortAnimationOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _SortAnimation.defaultOptions;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ })\r\n/******/ ]);\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9wbHVnaW5zLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLd0I7QUFDOUIsQ0FBQztBQUNELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsOEJBQW1CO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixlQUFlLDhCQUFtQjtBQUNsQyxtREFBbUQsK0JBQStCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQSxpRUFBaUUsaUJBQWlCO0FBQ2xGO0FBQ0EsMERBQTBELGFBQWE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixnQ0FBZ0MsOEJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQW1CO0FBQzlCLGtEQUFrRCxnQ0FBZ0M7QUFDbEYsMEVBQTBFLDhCQUFtQiw0QkFBNEIsb0JBQW9CO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFLDBDQUEwQztBQUMxQyxXQUFXLDhCQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhCQUFtQixDQUFDLDhCQUFtQjtB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Q0FBQztBQUNEO0FBQ0EscUJBQXFCLGdDQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHFCQUFxQixnQ0FBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx1Q0FBdUMsdUNBQXVDO0FBQzlFO0FBQ0EsT0FBTztBQUNQO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvbGliL3BsdWdpbnMuanM/MGM1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xyXG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxyXG5cdFx0ZGVmaW5lKFwiUGx1Z2luc1wiLCBbXSwgZmFjdG9yeSk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcblx0XHRleHBvcnRzW1wiUGx1Z2luc1wiXSA9IGZhY3RvcnkoKTtcclxuXHRlbHNlXHJcblx0XHRyb290W1wiUGx1Z2luc1wiXSA9IGZhY3RvcnkoKTtcclxufSkod2luZG93LCBmdW5jdGlvbigpIHtcclxucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcclxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXHJcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxyXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcclxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxyXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xyXG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcclxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXHJcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XHJcbi8qKioqKiovIFx0XHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXHJcbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcclxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XHJcbi8qKioqKiovIFx0fVxyXG4vKioqKioqL1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XHJcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XHJcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcclxuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xyXG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcclxuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XHJcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcclxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcclxuLyoqKioqKi8gXHRcdHJldHVybiBucztcclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cclxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcclxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcclxuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcclxuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xyXG4vKioqKioqL1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xyXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDI3KTtcclxuLyoqKioqKi8gfSlcclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyoqKioqKi8gKFtcclxuLyogMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TbmFwcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cclxuT2JqZWN0LmtleXMoX1NuYXBwYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1NuYXBwYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2Nsb3Nlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY2xvc2VzdCcsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb3Nlc3QpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9kaXN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkaXN0YW5jZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc3RhbmNlKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX3RvdWNoQ29vcmRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3RvdWNoQ29vcmRzJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG91Y2hDb29yZHMpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKioqLyB9KSxcclxuLyogMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0NvbGxpZGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xyXG5cclxuT2JqZWN0LmtleXMoX0NvbGxpZGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9Db2xsaWRhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uU29ydGFibGVTb3J0ZWQgPSBTeW1ib2woJ29uU29ydGFibGVTb3J0ZWQnKTtcclxuY29uc3Qgb25Tb3J0YWJsZVNvcnQgPSBTeW1ib2woJ29uU29ydGFibGVTb3J0Jyk7XHJcblxyXG4vKipcclxuICogU29ydEFuaW1hdGlvbiBkZWZhdWx0IG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWZhdWx0T3B0aW9ucy5kdXJhdGlvblxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGVmYXVsdE9wdGlvbnMuZWFzaW5nRnVuY3Rpb25cclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcclxuICBkdXJhdGlvbjogMTUwLFxyXG4gIGVhc2luZ0Z1bmN0aW9uOiAnZWFzZS1pbi1vdXQnXHJcbn07XHJcblxyXG4vKipcclxuICogU29ydEFuaW1hdGlvbiBwbHVnaW4gYWRkcyBzb3J0IGFuaW1hdGlvbiBmb3Igc29ydGFibGVcclxuICogQGNsYXNzIFNvcnRBbmltYXRpb25cclxuICogQG1vZHVsZSBTb3J0QW5pbWF0aW9uXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBTb3J0QW5pbWF0aW9uIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBTb3J0QW5pbWF0aW9uIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFNvcnRBbmltYXRpb25cclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU29ydEFuaW1hdGlvbiBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLmR1cmF0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZGVmYXVsdE9wdGlvbnMuZWFzaW5nRnVuY3Rpb25cclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGFzdCBhbmltYXRpb24gZnJhbWVcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsYXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcclxuICAgIHRoaXMubGFzdEVsZW1lbnRzID0gW107XHJcblxyXG4gICAgdGhpc1tvblNvcnRhYmxlU29ydGVkXSA9IHRoaXNbb25Tb3J0YWJsZVNvcnRlZF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Tb3J0YWJsZVNvcnRdID0gdGhpc1tvblNvcnRhYmxlU29ydF0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ3NvcnRhYmxlOnNvcnQnLCB0aGlzW29uU29ydGFibGVTb3J0XSk7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignc29ydGFibGU6c29ydGVkJywgdGhpc1tvblNvcnRhYmxlU29ydGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignc29ydGFibGU6c29ydCcsIHRoaXNbb25Tb3J0YWJsZVNvcnRdKTtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignc29ydGFibGU6c29ydGVkJywgdGhpc1tvblNvcnRhYmxlU29ydGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5zb3J0QW5pbWF0aW9uIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU29ydGFibGUgc29ydCBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtTb3J0YWJsZVNvcnRFdmVudH0gc29ydGFibGVFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uU29ydGFibGVTb3J0XSh7IGRyYWdFdmVudCB9KSB7XHJcbiAgICBjb25zdCB7IHNvdXJjZUNvbnRhaW5lciB9ID0gZHJhZ0V2ZW50O1xyXG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmRyYWdnYWJsZS5nZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihzb3VyY2VDb250YWluZXIpO1xyXG4gICAgdGhpcy5sYXN0RWxlbWVudHMgPSBBcnJheS5mcm9tKGVsZW1lbnRzKS5tYXAoZWwgPT4ge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGRvbUVsOiBlbCxcclxuICAgICAgICBvZmZzZXRUb3A6IGVsLm9mZnNldFRvcCxcclxuICAgICAgICBvZmZzZXRMZWZ0OiBlbC5vZmZzZXRMZWZ0XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNvcnRhYmxlIHNvcnRlZCBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtTb3J0YWJsZVNvcnRlZEV2ZW50fSBzb3J0YWJsZUV2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25Tb3J0YWJsZVNvcnRlZF0oeyBvbGRJbmRleCwgbmV3SW5kZXggfSkge1xyXG4gICAgaWYgKG9sZEluZGV4ID09PSBuZXdJbmRleCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZWZmZWN0ZWRFbGVtZW50cyA9IFtdO1xyXG4gICAgbGV0IHN0YXJ0O1xyXG4gICAgbGV0IGVuZDtcclxuICAgIGxldCBudW07XHJcbiAgICBpZiAob2xkSW5kZXggPiBuZXdJbmRleCkge1xyXG4gICAgICBzdGFydCA9IG5ld0luZGV4O1xyXG4gICAgICBlbmQgPSBvbGRJbmRleCAtIDE7XHJcbiAgICAgIG51bSA9IDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGFydCA9IG9sZEluZGV4ICsgMTtcclxuICAgICAgZW5kID0gbmV3SW5kZXg7XHJcbiAgICAgIG51bSA9IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xyXG4gICAgICBjb25zdCBmcm9tID0gdGhpcy5sYXN0RWxlbWVudHNbaV07XHJcbiAgICAgIGNvbnN0IHRvID0gdGhpcy5sYXN0RWxlbWVudHNbaSArIG51bV07XHJcbiAgICAgIGVmZmVjdGVkRWxlbWVudHMucHVzaCh7IGZyb20sIHRvIH0pO1xyXG4gICAgfVxyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUpO1xyXG5cclxuICAgIC8vIENhbiBiZSBkb25lIGluIGEgc2VwYXJhdGUgZnJhbWVcclxuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgZWZmZWN0ZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4gYW5pbWF0ZShlbGVtZW50LCB0aGlzLm9wdGlvbnMpKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gU29ydEFuaW1hdGlvbjsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFuaW1hdGVzIHR3byBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudC5mcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50LnRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmVhc2luZ0Z1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuZnVuY3Rpb24gYW5pbWF0ZSh7IGZyb20sIHRvIH0sIHsgZHVyYXRpb24sIGVhc2luZ0Z1bmN0aW9uIH0pIHtcclxuICBjb25zdCBkb21FbCA9IGZyb20uZG9tRWw7XHJcbiAgY29uc3QgeCA9IGZyb20ub2Zmc2V0TGVmdCAtIHRvLm9mZnNldExlZnQ7XHJcbiAgY29uc3QgeSA9IGZyb20ub2Zmc2V0VG9wIC0gdG8ub2Zmc2V0VG9wO1xyXG5cclxuICBkb21FbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG4gIGRvbUVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7eX1weCwgMClgO1xyXG5cclxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgZG9tRWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZCk7XHJcbiAgICBkb21FbC5zdHlsZS50cmFuc2l0aW9uID0gYHRyYW5zZm9ybSAke2R1cmF0aW9ufW1zICR7ZWFzaW5nRnVuY3Rpb259YDtcclxuICAgIGRvbUVsLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmVzZXRzIGFuaW1hdGlvbiBzdHlsZSBwcm9wZXJ0aWVzIGFmdGVyIGFuaW1hdGlvbiBoYXMgY29tcGxldGVkXHJcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQoZXZlbnQpIHtcclxuICBldmVudC50YXJnZXQuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xyXG4gIGV2ZW50LnRhcmdldC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XHJcbiAgZXZlbnQudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfU29ydEFuaW1hdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG52YXIgX1NvcnRBbmltYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU29ydEFuaW1hdGlvbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX1NvcnRBbmltYXRpb24yLmRlZmF1bHQ7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfU29ydEFuaW1hdGlvbi5kZWZhdWx0T3B0aW9ucztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Tb3J0YWJsZVNvcnRlZCA9IFN5bWJvbCgnb25Tb3J0YWJsZVNvcnRlZCcpO1xyXG5cclxuLyoqXHJcbiAqIFN3YXBBbmltYXRpb24gZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMuZHVyYXRpb25cclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRlZmF1bHRPcHRpb25zLmVhc2luZ0Z1bmN0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVmYXVsdE9wdGlvbnMuaG9yaXpvbnRhbFxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xyXG4gIGR1cmF0aW9uOiAxNTAsXHJcbiAgZWFzaW5nRnVuY3Rpb246ICdlYXNlLWluLW91dCcsXHJcbiAgaG9yaXpvbnRhbDogZmFsc2VcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTd2FwQW5pbWF0aW9uIHBsdWdpbiBhZGRzIHN3YXAgYW5pbWF0aW9ucyBmb3Igc29ydGFibGVcclxuICogQGNsYXNzIFN3YXBBbmltYXRpb25cclxuICogQG1vZHVsZSBTd2FwQW5pbWF0aW9uXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBTd2FwQW5pbWF0aW9uIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBTd2FwQW5pbWF0aW9uIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFN3YXBBbmltYXRpb25cclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3dhcEFuaW1hdGlvbiBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLmR1cmF0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZGVmYXVsdE9wdGlvbnMuZWFzaW5nRnVuY3Rpb25cclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGFzdCBhbmltYXRpb24gZnJhbWVcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsYXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uU29ydGFibGVTb3J0ZWRdID0gdGhpc1tvblNvcnRhYmxlU29ydGVkXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignc29ydGFibGU6c29ydGVkJywgdGhpc1tvblNvcnRhYmxlU29ydGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignc29ydGFibGU6c29ydGVkJywgdGhpc1tvblNvcnRhYmxlU29ydGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5zd2FwQW5pbWF0aW9uIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU29ydGFibGUgc29ydGVkIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge1NvcnRhYmxlU29ydGVkRXZlbnR9IHNvcnRhYmxlRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvblNvcnRhYmxlU29ydGVkXSh7IG9sZEluZGV4LCBuZXdJbmRleCwgZHJhZ0V2ZW50IH0pIHtcclxuICAgIGNvbnN0IHsgc291cmNlLCBvdmVyIH0gPSBkcmFnRXZlbnQ7XHJcblxyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUpO1xyXG5cclxuICAgIC8vIENhbiBiZSBkb25lIGluIGEgc2VwYXJhdGUgZnJhbWVcclxuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgaWYgKG9sZEluZGV4ID49IG5ld0luZGV4KSB7XHJcbiAgICAgICAgYW5pbWF0ZShzb3VyY2UsIG92ZXIsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYW5pbWF0ZShvdmVyLCBzb3VyY2UsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gU3dhcEFuaW1hdGlvbjsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFuaW1hdGVzIHR3byBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmVhc2luZ0Z1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmhvcml6b250YWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5mdW5jdGlvbiBhbmltYXRlKGZyb20sIHRvLCB7IGR1cmF0aW9uLCBlYXNpbmdGdW5jdGlvbiwgaG9yaXpvbnRhbCB9KSB7XHJcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtmcm9tLCB0b10pIHtcclxuICAgIGVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcclxuICB9XHJcblxyXG4gIGlmIChob3Jpem9udGFsKSB7XHJcbiAgICBjb25zdCB3aWR0aCA9IGZyb20ub2Zmc2V0V2lkdGg7XHJcbiAgICBmcm9tLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3dpZHRofXB4LCAwLCAwKWA7XHJcbiAgICB0by5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoLSR7d2lkdGh9cHgsIDAsIDApYDtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gZnJvbS5vZmZzZXRIZWlnaHQ7XHJcbiAgICBmcm9tLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgwLCAke2hlaWdodH1weCwgMClgO1xyXG4gICAgdG8uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDAsIC0ke2hlaWdodH1weCwgMClgO1xyXG4gIH1cclxuXHJcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbZnJvbSwgdG9dKSB7XHJcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZCk7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbiA9IGB0cmFuc2Zvcm0gJHtkdXJhdGlvbn1tcyAke2Vhc2luZ0Z1bmN0aW9ufWA7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJyc7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXNldHMgYW5pbWF0aW9uIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgYW5pbWF0aW9uIGhhcyBjb21wbGV0ZWRcclxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZChldmVudCkge1xyXG4gIGV2ZW50LnRhcmdldC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XHJcbiAgZXZlbnQudGFyZ2V0LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcclxuICBldmVudC50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZCk7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9Td2FwQW5pbWF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuXHJcbnZhciBfU3dhcEFuaW1hdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Td2FwQW5pbWF0aW9uKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfU3dhcEFuaW1hdGlvbjIuZGVmYXVsdDtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IF9Td2FwQW5pbWF0aW9uLmRlZmF1bHRPcHRpb25zO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxudmFyIF9TbmFwcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xyXG5jb25zdCBvbkRyYWdPdXQgPSBTeW1ib2woJ29uRHJhZ091dCcpO1xyXG5jb25zdCBvbk1pcnJvckNyZWF0ZWQgPSBTeW1ib2woJ29uTWlycm9yQ3JlYXRlZCcpO1xyXG5jb25zdCBvbk1pcnJvckRlc3Ryb3kgPSBTeW1ib2woJ29uTWlycm9yRGVzdHJveScpO1xyXG5cclxuLyoqXHJcbiAqIFNuYXBwYWJsZSBwbHVnaW4gd2hpY2ggc25hcHMgZHJhZ2dhYmxlIGVsZW1lbnRzIGludG8gcGxhY2VcclxuICogQGNsYXNzIFNuYXBwYWJsZVxyXG4gKiBAbW9kdWxlIFNuYXBwYWJsZVxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgU25hcHBhYmxlIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBTbmFwcGFibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgU25hcHBhYmxlXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBmaXJzdCBzb3VyY2UgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxudWxsfSBmaXJzdFNvdXJjZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpcnN0U291cmNlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBtaXJyb3IgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gbWlycm9yXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWlycm9yID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnT3V0XSA9IHRoaXNbb25EcmFnT3V0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1pcnJvckNyZWF0ZWRdID0gdGhpc1tvbk1pcnJvckNyZWF0ZWRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTWlycm9yRGVzdHJveV0gPSB0aGlzW29uTWlycm9yRGVzdHJveV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9uKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vbignZHJhZzpvdXQnLCB0aGlzW29uRHJhZ091dF0pLm9uKCdkcm9wcGFibGU6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcm9wcGFibGU6b3V0JywgdGhpc1tvbkRyYWdPdXRdKS5vbignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9uKCdtaXJyb3I6ZGVzdHJveScsIHRoaXNbb25NaXJyb3JEZXN0cm95XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9mZignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub2ZmKCdkcmFnOm91dCcsIHRoaXNbb25EcmFnT3V0XSkub2ZmKCdkcm9wcGFibGU6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9mZignZHJvcHBhYmxlOm91dCcsIHRoaXNbb25EcmFnT3V0XSkub2ZmKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub2ZmKCdtaXJyb3I6ZGVzdHJveScsIHRoaXNbb25NaXJyb3JEZXN0cm95XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0YXJ0RXZlbnR9IGV2ZW50IC0gRHJhZyBzdGFydCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcclxuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmZpcnN0U291cmNlID0gZXZlbnQuc291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdG9wIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0b3BFdmVudH0gZXZlbnQgLSBEcmFnIHN0b3AgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RvcF0oKSB7XHJcbiAgICB0aGlzLmZpcnN0U291cmNlID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgb3ZlciBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyRXZlbnR8RHJvcHBhYmxlT3ZlckV2ZW50fSBldmVudCAtIERyYWcgb3ZlciBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdmVyXShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNvdXJjZSA9IGV2ZW50LnNvdXJjZSB8fCBldmVudC5kcmFnRXZlbnQuc291cmNlO1xyXG5cclxuICAgIGlmIChzb3VyY2UgPT09IHRoaXMuZmlyc3RTb3VyY2UpIHtcclxuICAgICAgdGhpcy5maXJzdFNvdXJjZSA9IG51bGw7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzbmFwSW5FdmVudCA9IG5ldyBfU25hcHBhYmxlRXZlbnQuU25hcEluRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBzbmFwcGFibGU6IGV2ZW50Lm92ZXIgfHwgZXZlbnQuZHJvcHBhYmxlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKHNuYXBJbkV2ZW50KTtcclxuXHJcbiAgICBpZiAoc25hcEluRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubWlycm9yKSB7XHJcbiAgICAgIHRoaXMubWlycm9yLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICB9XHJcblxyXG4gICAgc291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOmRyYWdnaW5nJykpO1xyXG4gICAgc291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcclxuXHJcbiAgICAvLyBOZWVkIHRvIGNhbmNlbCB0aGlzIGluIGRyYWcgb3V0XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgc291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcclxuICAgIH0sIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMucGxhY2VkVGltZW91dCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG91dCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdPdXRFdmVudHxEcm9wcGFibGVPdXRFdmVudH0gZXZlbnQgLSBEcmFnIG91dCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdXRdKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc291cmNlID0gZXZlbnQuc291cmNlIHx8IGV2ZW50LmRyYWdFdmVudC5zb3VyY2U7XHJcblxyXG4gICAgY29uc3Qgc25hcE91dEV2ZW50ID0gbmV3IF9TbmFwcGFibGVFdmVudC5TbmFwT3V0RXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBzbmFwcGFibGU6IGV2ZW50Lm92ZXIgfHwgZXZlbnQuZHJvcHBhYmxlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKHNuYXBPdXRFdmVudCk7XHJcblxyXG4gICAgaWYgKHNuYXBPdXRFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5taXJyb3IpIHtcclxuICAgICAgdGhpcy5taXJyb3Iuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHNvdXJjZS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZHJhZ2dhYmxlLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpkcmFnZ2luZycpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1pcnJvciBjcmVhdGVkIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge01pcnJvckNyZWF0ZWRFdmVudH0gbWlycm9yRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbk1pcnJvckNyZWF0ZWRdKHsgbWlycm9yIH0pIHtcclxuICAgIHRoaXMubWlycm9yID0gbWlycm9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlycm9yIGRlc3Ryb3kgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7TWlycm9yRGVzdHJveUV2ZW50fSBtaXJyb3JFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uTWlycm9yRGVzdHJveV0oKSB7XHJcbiAgICB0aGlzLm1pcnJvciA9IG51bGw7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNuYXBwYWJsZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5TbmFwT3V0RXZlbnQgPSBleHBvcnRzLlNuYXBJbkV2ZW50ID0gZXhwb3J0cy5TbmFwRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIHNuYXAgZXZlbnRcclxuICogQGNsYXNzIFNuYXBFdmVudFxyXG4gKiBAbW9kdWxlIFNuYXBFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBTbmFwRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBzbmFwIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IGRyYWdFdmVudFxyXG4gICAqIEB0eXBlIHtEcmFnRXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyYWdFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU25hcHBhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgc25hcHBhYmxlXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzbmFwcGFibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNuYXBwYWJsZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuU25hcEV2ZW50ID0gU25hcEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNuYXAgaW4gZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTbmFwSW5FdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBTbmFwSW5FdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU25hcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblNuYXBFdmVudC50eXBlID0gJ3NuYXAnO1xyXG5jbGFzcyBTbmFwSW5FdmVudCBleHRlbmRzIFNuYXBFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5TbmFwSW5FdmVudCA9IFNuYXBJbkV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTbmFwIG91dCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTbmFwT3V0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNuYXBPdXRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNuYXBFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuU25hcEluRXZlbnQudHlwZSA9ICdzbmFwOmluJztcclxuU25hcEluRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIFNuYXBPdXRFdmVudCBleHRlbmRzIFNuYXBFdmVudCB7fVxyXG5leHBvcnRzLlNuYXBPdXRFdmVudCA9IFNuYXBPdXRFdmVudDtcclxuU25hcE91dEV2ZW50LnR5cGUgPSAnc25hcDpvdXQnO1xyXG5TbmFwT3V0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NuYXBwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbk9iamVjdC5rZXlzKF9TbmFwcGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9TbmFwcGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbnZhciBfU25hcHBhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHJcbnZhciBfU25hcHBhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NuYXBwYWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX1NuYXBwYWJsZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25NaXJyb3JDcmVhdGVkID0gU3ltYm9sKCdvbk1pcnJvckNyZWF0ZWQnKTtcclxuY29uc3Qgb25NaXJyb3JEZXN0cm95ID0gU3ltYm9sKCdvbk1pcnJvckRlc3Ryb3knKTtcclxuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xyXG5jb25zdCByZXNpemUgPSBTeW1ib2woJ3Jlc2l6ZScpO1xyXG5cclxuLyoqXHJcbiAqIFJlc2l6ZU1pcnJvciBkZWZhdWx0IG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgUmVzaXplTWlycm9yIHBsdWdpbiByZXNpemVzIHRoZSBtaXJyb3IgZWxlbWVudCB0byB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgdGhhdCB0aGUgbWlycm9yIGlzIGhvdmVyaW5nIG92ZXJcclxuICogQGNsYXNzIFJlc2l6ZU1pcnJvclxyXG4gKiBAbW9kdWxlIFJlc2l6ZU1pcnJvclxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgUmVzaXplTWlycm9yIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBSZXNpemVNaXJyb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgUmVzaXplTWlycm9yXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZU1pcnJvciBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVNaXJyb3IgcmVtZW1iZXJzIHRoZSBsYXN0IHdpZHRoIHdoZW4gcmVzaXppbmcgdGhlIG1pcnJvclxyXG4gICAgICogdG8gYXZvaWQgYWRkaXRpb25hbCB3cml0ZXMgdG8gdGhlIERPTVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxhc3RXaWR0aFxyXG4gICAgICovXHJcbiAgICB0aGlzLmxhc3RXaWR0aCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVNaXJyb3IgcmVtZW1iZXJzIHRoZSBsYXN0IGhlaWdodCB3aGVuIHJlc2l6aW5nIHRoZSBtaXJyb3JcclxuICAgICAqIHRvIGF2b2lkIGFkZGl0aW9uYWwgd3JpdGVzIHRvIHRoZSBET01cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXN0SGVpZ2h0XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGFzdEhlaWdodCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgbWlycm9yIGVsZW1lbnRcclxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IG1pcnJvclxyXG4gICAgICovXHJcbiAgICB0aGlzLm1pcnJvciA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvbk1pcnJvckNyZWF0ZWRdID0gdGhpc1tvbk1pcnJvckNyZWF0ZWRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTWlycm9yRGVzdHJveV0gPSB0aGlzW29uTWlycm9yRGVzdHJveV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnT3Zlcl0gPSB0aGlzW29uRHJhZ092ZXJdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub24oJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcmFnOm92ZXI6Y29udGFpbmVyJywgdGhpc1tvbkRyYWdPdmVyXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9mZignbWlycm9yOmRlc3Ryb3knLCB0aGlzW29uTWlycm9yRGVzdHJveV0pLm9mZignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub2ZmKCdkcmFnOm92ZXI6Y29udGFpbmVyJywgdGhpc1tvbkRyYWdPdmVyXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5yZXNpemVNaXJyb3IgfHwge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNaXJyb3IgY3JlYXRlZCBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtNaXJyb3JDcmVhdGVkRXZlbnR9IG1pcnJvckV2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25NaXJyb3JDcmVhdGVkXSh7IG1pcnJvciB9KSB7XHJcbiAgICB0aGlzLm1pcnJvciA9IG1pcnJvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1pcnJvciBkZXN0cm95IGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge01pcnJvckRlc3Ryb3lFdmVudH0gbWlycm9yRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbk1pcnJvckRlc3Ryb3ldKCkge1xyXG4gICAgdGhpcy5taXJyb3IgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBvdmVyIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyRXZlbnQgfCBEcmFnT3ZlckNvbnRhaW5lcn0gZHJhZ0V2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25EcmFnT3Zlcl0oZHJhZ0V2ZW50KSB7XHJcbiAgICB0aGlzW3Jlc2l6ZV0oZHJhZ0V2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2l6ZSBmdW5jdGlvbiBmb3JcclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyRXZlbnQgfCBEcmFnT3ZlckNvbnRhaW5lcn0gZHJhZ0V2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbcmVzaXplXSh7IG92ZXJDb250YWluZXIsIG92ZXIgfSkge1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLm1pcnJvci5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5taXJyb3IucGFyZW50Tm9kZSAhPT0gb3ZlckNvbnRhaW5lcikge1xyXG4gICAgICAgIG92ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5taXJyb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBvdmVyRWxlbWVudCA9IG92ZXIgfHwgdGhpcy5kcmFnZ2FibGUuZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIob3ZlckNvbnRhaW5lcilbMF07XHJcblxyXG4gICAgICBpZiAoIW92ZXJFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAoMCwgX3V0aWxzLnJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUpKCgpID0+IHtcclxuICAgICAgICBjb25zdCBvdmVyUmVjdCA9IG92ZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5sYXN0SGVpZ2h0ID09PSBvdmVyUmVjdC5oZWlnaHQgJiYgdGhpcy5sYXN0V2lkdGggPT09IG92ZXJSZWN0LndpZHRoKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm1pcnJvci5zdHlsZS53aWR0aCA9IGAke292ZXJSZWN0LndpZHRofXB4YDtcclxuICAgICAgICB0aGlzLm1pcnJvci5zdHlsZS5oZWlnaHQgPSBgJHtvdmVyUmVjdC5oZWlnaHR9cHhgO1xyXG5cclxuICAgICAgICB0aGlzLmxhc3RXaWR0aCA9IG92ZXJSZWN0LndpZHRoO1xyXG4gICAgICAgIHRoaXMubGFzdEhlaWdodCA9IG92ZXJSZWN0LmhlaWdodDtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gUmVzaXplTWlycm9yO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9SZXNpemVNaXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuXHJcbnZhciBfUmVzaXplTWlycm9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Jlc2l6ZU1pcnJvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX1Jlc2l6ZU1pcnJvcjIuZGVmYXVsdDtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IF9SZXNpemVNaXJyb3IuZGVmYXVsdE9wdGlvbnM7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHRvdWNoQ29vcmRzO1xyXG4vKipcclxuICogUmV0dXJucyB0aGUgZmlyc3QgdG91Y2ggZXZlbnQgZm91bmQgaW4gdG91Y2hlcyBvciBjaGFuZ2VkVG91Y2hlcyBvZiBhIHRvdWNoIGV2ZW50cy5cclxuICogQHBhcmFtIHtUb3VjaEV2ZW50fSBldmVudCBhIHRvdWNoIGV2ZW50XHJcbiAqIEByZXR1cm4ge1RvdWNofSBhIHRvdWNoIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gdG91Y2hDb29yZHMoZXZlbnQgPSB7fSkge1xyXG4gIGNvbnN0IHsgdG91Y2hlcywgY2hhbmdlZFRvdWNoZXMgfSA9IGV2ZW50O1xyXG4gIHJldHVybiB0b3VjaGVzICYmIHRvdWNoZXNbMF0gfHwgY2hhbmdlZFRvdWNoZXMgJiYgY2hhbmdlZFRvdWNoZXNbMF07XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdG91Y2hDb29yZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxuXHJcbnZhciBfdG91Y2hDb29yZHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG91Y2hDb29yZHMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF90b3VjaENvb3JkczIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gZGlzdGFuY2U7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcclxuICogQHBhcmFtICB7TnVtYmVyfSB4MSBUaGUgWCBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnRcclxuICogQHBhcmFtICB7TnVtYmVyfSB5MSBUaGUgWSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnRcclxuICogQHBhcmFtICB7TnVtYmVyfSB4MiBUaGUgWCBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50XHJcbiAqIEBwYXJhbSAge051bWJlcn0geTIgVGhlIFkgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xyXG4gIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICoqIDIgKyAoeTIgLSB5MSkgKiogMik7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZGlzdGFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxuXHJcbnZhciBfZGlzdGFuY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzdGFuY2UpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9kaXN0YW5jZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZTtcclxuZnVuY3Rpb24gcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xyXG4gIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcblxyXG52YXIgX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb3Nlc3Q7XHJcbmNvbnN0IG1hdGNoRnVuY3Rpb24gPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3I7XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjbG9zZXN0IHBhcmVudCBlbGVtZW50IG9mIGEgZ2l2ZW4gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuXHJcbiAqIHNlbGVjdG9yIHN0cmluZyBvciBtYXRjaGluZyBmdW5jdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGNoaWxkIGVsZW1lbnQgdG8gZmluZCBhIHBhcmVudCBvZlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgVGhlIHN0cmluZyBvciBmdW5jdGlvbiB0byB1c2UgdG8gbWF0Y2hcclxuICogICAgIHRoZSBwYXJlbnQgZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtFbGVtZW50fG51bGx9XHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9zZXN0KGVsZW1lbnQsIHZhbHVlKSB7XHJcbiAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNlbGVjdG9yID0gdmFsdWU7XHJcbiAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZTtcclxuICBjb25zdCBub2RlTGlzdCA9IHZhbHVlO1xyXG4gIGNvbnN0IHNpbmdsZUVsZW1lbnQgPSB2YWx1ZTtcclxuXHJcbiAgY29uc3QgaXNTZWxlY3RvciA9IEJvb2xlYW4odHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyk7XHJcbiAgY29uc3QgaXNGdW5jdGlvbiA9IEJvb2xlYW4odHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKTtcclxuICBjb25zdCBpc05vZGVMaXN0ID0gQm9vbGVhbih2YWx1ZSBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpO1xyXG4gIGNvbnN0IGlzRWxlbWVudCA9IEJvb2xlYW4odmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCk7XHJcblxyXG4gIGZ1bmN0aW9uIGNvbmRpdGlvbkZuKGN1cnJlbnRFbGVtZW50KSB7XHJcbiAgICBpZiAoIWN1cnJlbnRFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcclxuICAgIH0gZWxzZSBpZiAoaXNTZWxlY3Rvcikge1xyXG4gICAgICByZXR1cm4gbWF0Y2hGdW5jdGlvbi5jYWxsKGN1cnJlbnRFbGVtZW50LCBzZWxlY3Rvcik7XHJcbiAgICB9IGVsc2UgaWYgKGlzTm9kZUxpc3QpIHtcclxuICAgICAgcmV0dXJuIFsuLi5ub2RlTGlzdF0uaW5jbHVkZXMoY3VycmVudEVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIGlmIChpc0VsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIHNpbmdsZUVsZW1lbnQgPT09IGN1cnJlbnRFbGVtZW50O1xyXG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKSB7XHJcbiAgICAgIHJldHVybiBjYWxsYmFjayhjdXJyZW50RWxlbWVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxldCBjdXJyZW50ID0gZWxlbWVudDtcclxuXHJcbiAgZG8ge1xyXG4gICAgY3VycmVudCA9IGN1cnJlbnQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQgfHwgY3VycmVudC5jb3JyZXNwb25kaW5nRWxlbWVudCB8fCBjdXJyZW50O1xyXG5cclxuICAgIGlmIChjb25kaXRpb25GbihjdXJyZW50KSkge1xyXG4gICAgICByZXR1cm4gY3VycmVudDtcclxuICAgIH1cclxuXHJcbiAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xyXG4gIH0gd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBjdXJyZW50ICE9PSBkb2N1bWVudCk7XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2Nsb3Nlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxuXHJcbnZhciBfY2xvc2VzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9zZXN0KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfY2xvc2VzdDIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuLyoqXHJcbiAqIEFsbCBkcmFnZ2FibGUgcGx1Z2lucyBpbmhlcml0IGZyb20gdGhpcyBjbGFzcy5cclxuICogQGFic3RyYWN0XHJcbiAqIEBjbGFzcyBBYnN0cmFjdFBsdWdpblxyXG4gKiBAbW9kdWxlIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBBYnN0cmFjdFBsdWdpbiB7XHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3RQbHVnaW4gY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgQWJzdHJhY3RQbHVnaW5cclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAgICogQHByb3BlcnR5IGRyYWdnYWJsZVxyXG4gICAgICogQHR5cGUge0RyYWdnYWJsZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPdmVycmlkZSB0byBhZGQgbGlzdGVuZXJzXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRlIHRvIHJlbW92ZSBsaXN0ZW5lcnNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdFBsdWdpbjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcbnZhciBfQ29sbGlkYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkRyYWdNb3ZlID0gU3ltYm9sKCdvbkRyYWdNb3ZlJyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3Qgb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBTeW1ib2woJ29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyk7XHJcblxyXG4vKipcclxuICogQ29sbGlkYWJsZSBwbHVnaW4gd2hpY2ggZGV0ZWN0cyBjb2xsaWRpbmcgZWxlbWVudHMgd2hpbGUgZHJhZ2dpbmdcclxuICogQGNsYXNzIENvbGxpZGFibGVcclxuICogQG1vZHVsZSBDb2xsaWRhYmxlXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBDb2xsaWRhYmxlIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBDb2xsaWRhYmxlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIENvbGxpZGFibGVcclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2VlcHMgdHJhY2sgb2YgY3VycmVudGx5IGNvbGxpZGluZyBlbGVtZW50c1xyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxudWxsfSBjdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtlZXBzIHRyYWNrIG9mIGN1cnJlbnRseSBjb2xsaWRpbmcgZWxlbWVudHNcclxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8bnVsbH0gbGFzdENvbGxpZGluZ0VsZW1lbnRcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuaW1hdGlvbiBmcmFtZSBmb3IgZmluZGluZyBjb2xsaWRpbmcgZWxlbWVudHNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfG51bGx9IGN1cnJlbnRBbmltYXRpb25GcmFtZVxyXG4gICAgICogQHR5cGUge051bWJlcnxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lXSA9IHRoaXNbb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWVdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY3VycmVudCBjb2xsaWRhYmxlcyBiYXNlZCBvbiBgY29sbGlkYWJsZXNgIG9wdGlvblxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XHJcbiAgICovXHJcbiAgZ2V0Q29sbGlkYWJsZXMoKSB7XHJcbiAgICBjb25zdCBjb2xsaWRhYmxlcyA9IHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuY29sbGlkYWJsZXM7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBjb2xsaWRhYmxlcyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY29sbGlkYWJsZXMpKTtcclxuICAgIH0gZWxzZSBpZiAoY29sbGlkYWJsZXMgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBjb2xsaWRhYmxlcyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb2xsaWRhYmxlcyk7XHJcbiAgICB9IGVsc2UgaWYgKGNvbGxpZGFibGVzIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIFtjb2xsaWRhYmxlc107XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2xsaWRhYmxlcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gY29sbGlkYWJsZXMoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgbW92ZSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdNb3ZlRXZlbnR9IGV2ZW50IC0gRHJhZyBtb3ZlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ01vdmVdKGV2ZW50KSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC5zZW5zb3JFdmVudC50YXJnZXQ7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpc1tvblJlcXVlc3RBbmltYXRpb25GcmFtZV0odGFyZ2V0KSk7XHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCkge1xyXG4gICAgICBldmVudC5jYW5jZWwoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb2xsaWRhYmxlSW5FdmVudCA9IG5ldyBfQ29sbGlkYWJsZUV2ZW50LkNvbGxpZGFibGVJbkV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcclxuICAgICAgY29sbGlkaW5nRWxlbWVudDogdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBjb2xsaWRhYmxlT3V0RXZlbnQgPSBuZXcgX0NvbGxpZGFibGVFdmVudC5Db2xsaWRhYmxlT3V0RXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBjb2xsaWRpbmdFbGVtZW50OiB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBlbnRlcmluZ0NvbGxpZGFibGUgPSBCb29sZWFuKHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCAmJiB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50ICE9PSB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQpO1xyXG4gICAgY29uc3QgbGVhdmluZ0NvbGxpZGFibGUgPSBCb29sZWFuKCF0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgJiYgdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudCk7XHJcblxyXG4gICAgaWYgKGVudGVyaW5nQ29sbGlkYWJsZSkge1xyXG4gICAgICBpZiAodGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIoY29sbGlkYWJsZU91dEV2ZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlSW5FdmVudCk7XHJcbiAgICB9IGVsc2UgaWYgKGxlYXZpbmdDb2xsaWRhYmxlKSB7XHJcbiAgICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIoY29sbGlkYWJsZU91dEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50ID0gdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdG9wIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0b3BFdmVudH0gZXZlbnQgLSBEcmFnIHN0b3AgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RvcF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IGxhc3RDb2xsaWRpbmdFbGVtZW50ID0gdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50IHx8IHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQ7XHJcbiAgICBjb25zdCBjb2xsaWRhYmxlT3V0RXZlbnQgPSBuZXcgX0NvbGxpZGFibGVFdmVudC5Db2xsaWRhYmxlT3V0RXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBjb2xsaWRpbmdFbGVtZW50OiBsYXN0Q29sbGlkaW5nRWxlbWVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGxhc3RDb2xsaWRpbmdFbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIoY29sbGlkYWJsZU91dEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50ID0gbnVsbDtcclxuICAgIHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbmltYXRpb24gZnJhbWUgZnVuY3Rpb25cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIEN1cnJlbnQgbW92ZSB0YXJnZXRcclxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cclxuICAgKi9cclxuICBbb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWVdKHRhcmdldCkge1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgY29uc3QgY29sbGlkYWJsZXMgPSB0aGlzLmdldENvbGxpZGFibGVzKCk7XHJcbiAgICAgIHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCA9ICgwLCBfdXRpbHMuY2xvc2VzdCkodGFyZ2V0LCBlbGVtZW50ID0+IGNvbGxpZGFibGVzLmluY2x1ZGVzKGVsZW1lbnQpKTtcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvbGxpZGFibGU7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxuY29uc3QgY2FuY2VsZWQgPSBTeW1ib2woJ2NhbmNlbGVkJyk7XHJcblxyXG4vKipcclxuICogQWxsIGV2ZW50cyBmaXJlZCBieSBkcmFnZ2FibGUgaW5oZXJpdCB0aGlzIGNsYXNzLiBZb3UgY2FuIGNhbGwgYGNhbmNlbCgpYCB0b1xyXG4gKiBjYW5jZWwgYSBzcGVjaWZpYyBldmVudCBvciB5b3UgY2FuIGNoZWNrIGlmIGFuIGV2ZW50IGhhcyBiZWVuIGNhbmNlbGVkIGJ5XHJcbiAqIGNhbGxpbmcgYGNhbmNlbGVkKClgLlxyXG4gKiBAYWJzdHJhY3RcclxuICogQGNsYXNzIEFic3RyYWN0RXZlbnRcclxuICogQG1vZHVsZSBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBBYnN0cmFjdEV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3RFdmVudCBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBBYnN0cmFjdEV2ZW50XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBFdmVudCBkYXRhXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW50IHR5cGVcclxuICAgKiBAc3RhdGljXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHByb3BlcnR5IHR5cGVcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcclxuICAgIHRoaXNbY2FuY2VsZWRdID0gZmFsc2U7XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZC1vbmx5IHR5cGVcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBFdmVudCBjYW5jZWxhYmxlXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHR5cGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50eXBlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZC1vbmx5IGNhbmNlbGFibGVcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBjYW5jZWxhYmxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY2FuY2VsYWJsZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbmNlbHMgdGhlIGV2ZW50IGluc3RhbmNlXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcbiAgY2FuY2VsKCkge1xyXG4gICAgdGhpc1tjYW5jZWxlZF0gPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgZXZlbnQgaGFzIGJlZW4gY2FuY2VsZWRcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGNhbmNlbGVkKCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4odGhpc1tjYW5jZWxlZF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBuZXcgZXZlbnQgaW5zdGFuY2Ugd2l0aCBleGlzdGluZyBldmVudCBkYXRhLlxyXG4gICAqIFRoaXMgbWV0aG9kIGFsbG93cyBmb3Igb3ZlcnJpZGluZyBvZiBldmVudCBkYXRhLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcbiAgICogQHJldHVybiB7QWJzdHJhY3RFdmVudH1cclxuICAgKi9cclxuICBjbG9uZShkYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoX2V4dGVuZHMoe30sIHRoaXMuZGF0YSwgZGF0YSkpO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdEV2ZW50O1xyXG5BYnN0cmFjdEV2ZW50LnR5cGUgPSAnZXZlbnQnO1xyXG5BYnN0cmFjdEV2ZW50LmNhbmNlbGFibGUgPSBmYWxzZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5Db2xsaWRhYmxlT3V0RXZlbnQgPSBleHBvcnRzLkNvbGxpZGFibGVJbkV2ZW50ID0gZXhwb3J0cy5Db2xsaWRhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNvbGxpZGFibGUgZXZlbnRcclxuICogQGNsYXNzIENvbGxpZGFibGVFdmVudFxyXG4gKiBAbW9kdWxlIENvbGxpZGFibGVFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBDb2xsaWRhYmxlRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjb2xsaWFibGUgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgZHJhZ0V2ZW50XHJcbiAgICogQHR5cGUge0RyYWdFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ0V2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkNvbGxpZGFibGVFdmVudCA9IENvbGxpZGFibGVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb2xsaWRhYmxlIGluIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgQ29sbGlkYWJsZUluRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgQ29sbGlkYWJsZUluRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIENvbGxpZGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Db2xsaWRhYmxlRXZlbnQudHlwZSA9ICdjb2xsaWRhYmxlJztcclxuY2xhc3MgQ29sbGlkYWJsZUluRXZlbnQgZXh0ZW5kcyBDb2xsaWRhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBFbGVtZW50IHlvdSBhcmUgY3VycmVudGx5IGNvbGxpZGluZyB3aXRoXHJcbiAgICogQHByb3BlcnR5IGNvbGxpZGluZ0VsZW1lbnRcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGNvbGxpZGluZ0VsZW1lbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNvbGxpZGluZ0VsZW1lbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkNvbGxpZGFibGVJbkV2ZW50ID0gQ29sbGlkYWJsZUluRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbGxpZGFibGUgb3V0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIENvbGxpZGFibGVPdXRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgQ29sbGlkYWJsZU91dEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgQ29sbGlkYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Db2xsaWRhYmxlSW5FdmVudC50eXBlID0gJ2NvbGxpZGFibGU6aW4nO1xyXG5jbGFzcyBDb2xsaWRhYmxlT3V0RXZlbnQgZXh0ZW5kcyBDb2xsaWRhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBFbGVtZW50IHlvdSB3ZXJlIHByZXZpb3VzbHkgY29sbGlkaW5nIHdpdGhcclxuICAgKiBAcHJvcGVydHkgY29sbGlkaW5nRWxlbWVudFxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgY29sbGlkaW5nRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuY29sbGlkaW5nRWxlbWVudDtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5Db2xsaWRhYmxlT3V0RXZlbnQgPSBDb2xsaWRhYmxlT3V0RXZlbnQ7XHJcbkNvbGxpZGFibGVPdXRFdmVudC50eXBlID0gJ2NvbGxpZGFibGU6b3V0JztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQ29sbGlkYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHJcbk9iamVjdC5rZXlzKF9Db2xsaWRhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfQ29sbGlkYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9Db2xsaWRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcblxyXG52YXIgX0NvbGxpZGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29sbGlkYWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0NvbGxpZGFibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0NvbGxpZGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQ29sbGlkYWJsZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbGxpZGFibGUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfUmVzaXplTWlycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1Jlc2l6ZU1pcnJvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Jlc2l6ZU1pcnJvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRSZXNpemVNaXJyb3JPcHRpb25zJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX1Jlc2l6ZU1pcnJvci5kZWZhdWx0T3B0aW9ucztcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9TbmFwcGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU25hcHBhYmxlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU25hcHBhYmxlKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1N3YXBBbmltYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTd2FwQW5pbWF0aW9uJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3dhcEFuaW1hdGlvbikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRTd2FwQW5pbWF0aW9uT3B0aW9ucycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9Td2FwQW5pbWF0aW9uLmRlZmF1bHRPcHRpb25zO1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1NvcnRBbmltYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTb3J0QW5pbWF0aW9uJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU29ydEFuaW1hdGlvbikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRTb3J0QW5pbWF0aW9uT3B0aW9ucycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9Tb3J0QW5pbWF0aW9uLmRlZmF1bHRPcHRpb25zO1xyXG4gIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqKi8gfSlcclxuLyoqKioqKi8gXSk7XHJcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@shopify/draggable/lib/plugins.js\n");

/***/ }),

/***/ "./node_modules/@shopify/draggable/lib/plugins/collidable.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@shopify/draggable/lib/plugins/collidable.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(true)\r\n\t\tmodule.exports = factory();\r\n\telse {}\r\n})(window, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __nested_webpack_require_574__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId]) {\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_574__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__nested_webpack_require_574__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__nested_webpack_require_574__.c = installedModules;\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__nested_webpack_require_574__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__nested_webpack_require_574__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// define __esModule on exports\r\n/******/ \t__nested_webpack_require_574__.r = function(exports) {\r\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\r\n/******/ \t\t}\r\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\r\n/******/ \t};\r\n/******/\r\n/******/ \t// create a fake namespace object\r\n/******/ \t// mode & 1: value is a module id, require it\r\n/******/ \t// mode & 2: merge all properties of value into the ns\r\n/******/ \t// mode & 4: return value when already ns object\r\n/******/ \t// mode & 8|1: behave like require\r\n/******/ \t__nested_webpack_require_574__.t = function(value, mode) {\r\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_574__(value);\r\n/******/ \t\tif(mode & 8) return value;\r\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\r\n/******/ \t\tvar ns = Object.create(null);\r\n/******/ \t\t__nested_webpack_require_574__.r(ns);\r\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\r\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_574__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\r\n/******/ \t\treturn ns;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__nested_webpack_require_574__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__nested_webpack_require_574__.d(getter, 'a', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__nested_webpack_require_574__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__nested_webpack_require_574__.p = \"\";\r\n/******/\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __nested_webpack_require_574__(__nested_webpack_require_574__.s = 16);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __nested_webpack_require_4122__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _CollidableEvent = __nested_webpack_require_4122__(15);\r\n\r\nObject.keys(_CollidableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _CollidableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = touchCoords;\r\n/**\r\n * Returns the first touch event found in touches or changedTouches of a touch events.\r\n * @param {TouchEvent} event a touch event\r\n * @return {Touch} a touch object\r\n */\r\nfunction touchCoords(event = {}) {\r\n  const { touches, changedTouches } = event;\r\n  return touches && touches[0] || changedTouches && changedTouches[0];\r\n}\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports, __nested_webpack_require_5135__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_5135__(1);\r\n\r\nvar _touchCoords2 = _interopRequireDefault(_touchCoords);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _touchCoords2.default;\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = distance;\r\n/**\r\n * Returns the distance between two points\r\n * @param  {Number} x1 The X position of the first point\r\n * @param  {Number} y1 The Y position of the first point\r\n * @param  {Number} x2 The X position of the second point\r\n * @param  {Number} y2 The Y position of the second point\r\n * @return {Number}\r\n */\r\nfunction distance(x1, y1, x2, y2) {\r\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\r\n}\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports, __nested_webpack_require_6153__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _distance = __nested_webpack_require_6153__(3);\r\n\r\nvar _distance2 = _interopRequireDefault(_distance);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _distance2.default;\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = requestNextAnimationFrame;\r\nfunction requestNextAnimationFrame(callback) {\r\n  return requestAnimationFrame(() => {\r\n    requestAnimationFrame(callback);\r\n  });\r\n}\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports, __nested_webpack_require_6909__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_6909__(5);\r\n\r\nvar _requestNextAnimationFrame2 = _interopRequireDefault(_requestNextAnimationFrame);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _requestNextAnimationFrame2.default;\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = closest;\r\nconst matchFunction = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector;\r\n\r\n/**\r\n * Get the closest parent element of a given element that matches the given\r\n * selector string or matching function\r\n *\r\n * @param {Element} element The child element to find a parent of\r\n * @param {String|Function} selector The string or function to use to match\r\n *     the parent element\r\n * @return {Element|null}\r\n */\r\nfunction closest(element, value) {\r\n  if (!element) {\r\n    return null;\r\n  }\r\n\r\n  const selector = value;\r\n  const callback = value;\r\n  const nodeList = value;\r\n  const singleElement = value;\r\n\r\n  const isSelector = Boolean(typeof value === 'string');\r\n  const isFunction = Boolean(typeof value === 'function');\r\n  const isNodeList = Boolean(value instanceof NodeList || value instanceof Array);\r\n  const isElement = Boolean(value instanceof HTMLElement);\r\n\r\n  function conditionFn(currentElement) {\r\n    if (!currentElement) {\r\n      return currentElement;\r\n    } else if (isSelector) {\r\n      return matchFunction.call(currentElement, selector);\r\n    } else if (isNodeList) {\r\n      return [...nodeList].includes(currentElement);\r\n    } else if (isElement) {\r\n      return singleElement === currentElement;\r\n    } else if (isFunction) {\r\n      return callback(currentElement);\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  let current = element;\r\n\r\n  do {\r\n    current = current.correspondingUseElement || current.correspondingElement || current;\r\n\r\n    if (conditionFn(current)) {\r\n      return current;\r\n    }\r\n\r\n    current = current.parentNode;\r\n  } while (current && current !== document.body && current !== document);\r\n\r\n  return null;\r\n}\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ (function(module, exports, __nested_webpack_require_9336__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_9336__(7);\r\n\r\nvar _closest2 = _interopRequireDefault(_closest);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _closest2.default;\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ (function(module, exports, __nested_webpack_require_9738__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_9738__(8);\r\n\r\nObject.defineProperty(exports, 'closest', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_closest).default;\r\n  }\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_9738__(6);\r\n\r\nObject.defineProperty(exports, 'requestNextAnimationFrame', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_requestNextAnimationFrame).default;\r\n  }\r\n});\r\n\r\nvar _distance = __nested_webpack_require_9738__(4);\r\n\r\nObject.defineProperty(exports, 'distance', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_distance).default;\r\n  }\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_9738__(2);\r\n\r\nObject.defineProperty(exports, 'touchCoords', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_touchCoords).default;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * All draggable plugins inherit from this class.\r\n * @abstract\r\n * @class AbstractPlugin\r\n * @module AbstractPlugin\r\n */\r\nclass AbstractPlugin {\r\n  /**\r\n   * AbstractPlugin constructor.\r\n   * @constructs AbstractPlugin\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    /**\r\n     * Draggable instance\r\n     * @property draggable\r\n     * @type {Draggable}\r\n     */\r\n    this.draggable = draggable;\r\n  }\r\n\r\n  /**\r\n   * Override to add listeners\r\n   * @abstract\r\n   */\r\n  attach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n\r\n  /**\r\n   * Override to remove listeners\r\n   * @abstract\r\n   */\r\n  detach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n}\r\nexports.default = AbstractPlugin;\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ (function(module, exports, __nested_webpack_require_11771__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_11771__(10);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractPlugin2.default;\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ (function(module, exports, __nested_webpack_require_12203__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_12203__(11);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _utils = __nested_webpack_require_12203__(9);\r\n\r\nvar _CollidableEvent = __nested_webpack_require_12203__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragMove = Symbol('onDragMove');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst onRequestAnimationFrame = Symbol('onRequestAnimationFrame');\r\n\r\n/**\r\n * Collidable plugin which detects colliding elements while dragging\r\n * @class Collidable\r\n * @module Collidable\r\n * @extends AbstractPlugin\r\n */\r\nclass Collidable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Collidable constructor.\r\n   * @constructs Collidable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Keeps track of currently colliding elements\r\n     * @property {HTMLElement|null} currentlyCollidingElement\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.currentlyCollidingElement = null;\r\n\r\n    /**\r\n     * Keeps track of currently colliding elements\r\n     * @property {HTMLElement|null} lastCollidingElement\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.lastCollidingElement = null;\r\n\r\n    /**\r\n     * Animation frame for finding colliding elements\r\n     * @property {Number|null} currentAnimationFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.currentAnimationFrame = null;\r\n\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onRequestAnimationFrame] = this[onRequestAnimationFrame].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Returns current collidables based on `collidables` option\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getCollidables() {\r\n    const collidables = this.draggable.options.collidables;\r\n\r\n    if (typeof collidables === 'string') {\r\n      return Array.prototype.slice.call(document.querySelectorAll(collidables));\r\n    } else if (collidables instanceof NodeList || collidables instanceof Array) {\r\n      return Array.prototype.slice.call(collidables);\r\n    } else if (collidables instanceof HTMLElement) {\r\n      return [collidables];\r\n    } else if (typeof collidables === 'function') {\r\n      return collidables();\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag move handler\r\n   * @private\r\n   * @param {DragMoveEvent} event - Drag move event\r\n   */\r\n  [onDragMove](event) {\r\n    const target = event.sensorEvent.target;\r\n\r\n    this.currentAnimationFrame = requestAnimationFrame(this[onRequestAnimationFrame](target));\r\n\r\n    if (this.currentlyCollidingElement) {\r\n      event.cancel();\r\n    }\r\n\r\n    const collidableInEvent = new _CollidableEvent.CollidableInEvent({\r\n      dragEvent: event,\r\n      collidingElement: this.currentlyCollidingElement\r\n    });\r\n\r\n    const collidableOutEvent = new _CollidableEvent.CollidableOutEvent({\r\n      dragEvent: event,\r\n      collidingElement: this.lastCollidingElement\r\n    });\r\n\r\n    const enteringCollidable = Boolean(this.currentlyCollidingElement && this.lastCollidingElement !== this.currentlyCollidingElement);\r\n    const leavingCollidable = Boolean(!this.currentlyCollidingElement && this.lastCollidingElement);\r\n\r\n    if (enteringCollidable) {\r\n      if (this.lastCollidingElement) {\r\n        this.draggable.trigger(collidableOutEvent);\r\n      }\r\n\r\n      this.draggable.trigger(collidableInEvent);\r\n    } else if (leavingCollidable) {\r\n      this.draggable.trigger(collidableOutEvent);\r\n    }\r\n\r\n    this.lastCollidingElement = this.currentlyCollidingElement;\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop](event) {\r\n    const lastCollidingElement = this.currentlyCollidingElement || this.lastCollidingElement;\r\n    const collidableOutEvent = new _CollidableEvent.CollidableOutEvent({\r\n      dragEvent: event,\r\n      collidingElement: lastCollidingElement\r\n    });\r\n\r\n    if (lastCollidingElement) {\r\n      this.draggable.trigger(collidableOutEvent);\r\n    }\r\n\r\n    this.lastCollidingElement = null;\r\n    this.currentlyCollidingElement = null;\r\n  }\r\n\r\n  /**\r\n   * Animation frame function\r\n   * @private\r\n   * @param {HTMLElement} target - Current move target\r\n   * @return {Function}\r\n   */\r\n  [onRequestAnimationFrame](target) {\r\n    return () => {\r\n      const collidables = this.getCollidables();\r\n      this.currentlyCollidingElement = (0, _utils.closest)(target, element => collidables.includes(element));\r\n    };\r\n  }\r\n}\r\nexports.default = Collidable;\r\n\r\n/***/ }),\r\n/* 13 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst canceled = Symbol('canceled');\r\n\r\n/**\r\n * All events fired by draggable inherit this class. You can call `cancel()` to\r\n * cancel a specific event or you can check if an event has been canceled by\r\n * calling `canceled()`.\r\n * @abstract\r\n * @class AbstractEvent\r\n * @module AbstractEvent\r\n */\r\nclass AbstractEvent {\r\n\r\n  /**\r\n   * AbstractEvent constructor.\r\n   * @constructs AbstractEvent\r\n   * @param {object} data - Event data\r\n   */\r\n\r\n  /**\r\n   * Event type\r\n   * @static\r\n   * @abstract\r\n   * @property type\r\n   * @type {String}\r\n   */\r\n  constructor(data) {\r\n    this[canceled] = false;\r\n    this.data = data;\r\n  }\r\n\r\n  /**\r\n   * Read-only type\r\n   * @abstract\r\n   * @return {String}\r\n   */\r\n\r\n\r\n  /**\r\n   * Event cancelable\r\n   * @static\r\n   * @abstract\r\n   * @property cancelable\r\n   * @type {Boolean}\r\n   */\r\n  get type() {\r\n    return this.constructor.type;\r\n  }\r\n\r\n  /**\r\n   * Read-only cancelable\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  get cancelable() {\r\n    return this.constructor.cancelable;\r\n  }\r\n\r\n  /**\r\n   * Cancels the event instance\r\n   * @abstract\r\n   */\r\n  cancel() {\r\n    this[canceled] = true;\r\n  }\r\n\r\n  /**\r\n   * Check if event has been canceled\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  canceled() {\r\n    return Boolean(this[canceled]);\r\n  }\r\n\r\n  /**\r\n   * Returns new event instance with existing event data.\r\n   * This method allows for overriding of event data.\r\n   * @param {Object} data\r\n   * @return {AbstractEvent}\r\n   */\r\n  clone(data) {\r\n    return new this.constructor(_extends({}, this.data, data));\r\n  }\r\n}\r\nexports.default = AbstractEvent;\r\nAbstractEvent.type = 'event';\r\nAbstractEvent.cancelable = false;\r\n\r\n/***/ }),\r\n/* 14 */\r\n/***/ (function(module, exports, __nested_webpack_require_19372__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractEvent = __nested_webpack_require_19372__(13);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractEvent2.default;\r\n\r\n/***/ }),\r\n/* 15 */\r\n/***/ (function(module, exports, __nested_webpack_require_19800__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.CollidableOutEvent = exports.CollidableInEvent = exports.CollidableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_19800__(14);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base collidable event\r\n * @class CollidableEvent\r\n * @module CollidableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass CollidableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Drag event that triggered this colliable event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n}\r\n\r\nexports.CollidableEvent = CollidableEvent; /**\r\n                                            * Collidable in event\r\n                                            * @class CollidableInEvent\r\n                                            * @module CollidableInEvent\r\n                                            * @extends CollidableEvent\r\n                                            */\r\n\r\nCollidableEvent.type = 'collidable';\r\nclass CollidableInEvent extends CollidableEvent {\r\n\r\n  /**\r\n   * Element you are currently colliding with\r\n   * @property collidingElement\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get collidingElement() {\r\n    return this.data.collidingElement;\r\n  }\r\n}\r\n\r\nexports.CollidableInEvent = CollidableInEvent; /**\r\n                                                * Collidable out event\r\n                                                * @class CollidableOutEvent\r\n                                                * @module CollidableOutEvent\r\n                                                * @extends CollidableEvent\r\n                                                */\r\n\r\nCollidableInEvent.type = 'collidable:in';\r\nclass CollidableOutEvent extends CollidableEvent {\r\n\r\n  /**\r\n   * Element you were previously colliding with\r\n   * @property collidingElement\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get collidingElement() {\r\n    return this.data.collidingElement;\r\n  }\r\n}\r\nexports.CollidableOutEvent = CollidableOutEvent;\r\nCollidableOutEvent.type = 'collidable:out';\r\n\r\n/***/ }),\r\n/* 16 */\r\n/***/ (function(module, exports, __nested_webpack_require_22155__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _CollidableEvent = __nested_webpack_require_22155__(0);\r\n\r\nObject.keys(_CollidableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _CollidableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Collidable = __nested_webpack_require_22155__(12);\r\n\r\nvar _Collidable2 = _interopRequireDefault(_Collidable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Collidable2.default;\r\n\r\n/***/ })\r\n/******/ ]);\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9wbHVnaW5zL2NvbGxpZGFibGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUsyQjtBQUNqQyxDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw4QkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGVBQWUsOEJBQW1CO0FBQ2xDLG1EQUFtRCwrQkFBK0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLGlFQUFpRSxpQkFBaUI7QUFDbEY7QUFDQSwwREFBMEQsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGdDQUFnQyw4QkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBbUI7QUFDOUIsa0RBQWtELGdDQUFnQztBQUNsRiwwRUFBMEUsOEJBQW1CLDRCQUE0QixvQkFBb0I7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsMENBQTBDO0FBQzFDLFdBQVcsOEJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQW1CLENB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QUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsdUJBQXVCLGdDQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLGtCQUFrQixnQ0FBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9saWIvcGx1Z2lucy9jb2xsaWRhYmxlLmpzPzJlNTYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuXHRcdGRlZmluZShcIkNvbGxpZGFibGVcIiwgW10sIGZhY3RvcnkpO1xyXG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxyXG5cdFx0ZXhwb3J0c1tcIkNvbGxpZGFibGVcIl0gPSBmYWN0b3J5KCk7XHJcblx0ZWxzZVxyXG5cdFx0cm9vdFtcIkNvbGxpZGFibGVcIl0gPSBmYWN0b3J5KCk7XHJcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XHJcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXHJcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcclxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XHJcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcclxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcclxuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXHJcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxyXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxyXG4vKioqKioqLyBcdFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXHJcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxyXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG4vKioqKioqLyBcdH1cclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xyXG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XHJcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcclxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XHJcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xyXG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XHJcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcclxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNik7XHJcbi8qKioqKiovIH0pXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKioqKiovIChbXHJcbi8qIDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0NvbGxpZGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG5cclxuT2JqZWN0LmtleXMoX0NvbGxpZGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9Db2xsaWRhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gdG91Y2hDb29yZHM7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCB0b3VjaCBldmVudCBmb3VuZCBpbiB0b3VjaGVzIG9yIGNoYW5nZWRUb3VjaGVzIG9mIGEgdG91Y2ggZXZlbnRzLlxyXG4gKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2ZW50IGEgdG91Y2ggZXZlbnRcclxuICogQHJldHVybiB7VG91Y2h9IGEgdG91Y2ggb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiB0b3VjaENvb3JkcyhldmVudCA9IHt9KSB7XHJcbiAgY29uc3QgeyB0b3VjaGVzLCBjaGFuZ2VkVG91Y2hlcyB9ID0gZXZlbnQ7XHJcbiAgcmV0dXJuIHRvdWNoZXMgJiYgdG91Y2hlc1swXSB8fCBjaGFuZ2VkVG91Y2hlcyAmJiBjaGFuZ2VkVG91Y2hlc1swXTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3RvdWNoQ29vcmRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbnZhciBfdG91Y2hDb29yZHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG91Y2hDb29yZHMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF90b3VjaENvb3JkczIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBkaXN0YW5jZTtcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHgxIFRoZSBYIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHkxIFRoZSBZIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHgyIFRoZSBYIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnRcclxuICogQHBhcmFtICB7TnVtYmVyfSB5MiBUaGUgWSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50XHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XHJcbiAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiogMiArICh5MiAtIHkxKSAqKiAyKTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2Rpc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHJcbnZhciBfZGlzdGFuY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzdGFuY2UpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9kaXN0YW5jZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSByZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lO1xyXG5mdW5jdGlvbiByZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XHJcbiAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG52YXIgX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gY2xvc2VzdDtcclxuY29uc3QgbWF0Y2hGdW5jdGlvbiA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvcjtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGNsb3Nlc3QgcGFyZW50IGVsZW1lbnQgb2YgYSBnaXZlbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW5cclxuICogc2VsZWN0b3Igc3RyaW5nIG9yIG1hdGNoaW5nIGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgY2hpbGQgZWxlbWVudCB0byBmaW5kIGEgcGFyZW50IG9mXHJcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBUaGUgc3RyaW5nIG9yIGZ1bmN0aW9uIHRvIHVzZSB0byBtYXRjaFxyXG4gKiAgICAgdGhlIHBhcmVudCBlbGVtZW50XHJcbiAqIEByZXR1cm4ge0VsZW1lbnR8bnVsbH1cclxuICovXHJcbmZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgdmFsdWUpIHtcclxuICBpZiAoIWVsZW1lbnQpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc2VsZWN0b3IgPSB2YWx1ZTtcclxuICBjb25zdCBjYWxsYmFjayA9IHZhbHVlO1xyXG4gIGNvbnN0IG5vZGVMaXN0ID0gdmFsdWU7XHJcbiAgY29uc3Qgc2luZ2xlRWxlbWVudCA9IHZhbHVlO1xyXG5cclxuICBjb25zdCBpc1NlbGVjdG9yID0gQm9vbGVhbih0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKTtcclxuICBjb25zdCBpc0Z1bmN0aW9uID0gQm9vbGVhbih0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpO1xyXG4gIGNvbnN0IGlzTm9kZUxpc3QgPSBCb29sZWFuKHZhbHVlIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBBcnJheSk7XHJcbiAgY29uc3QgaXNFbGVtZW50ID0gQm9vbGVhbih2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KTtcclxuXHJcbiAgZnVuY3Rpb24gY29uZGl0aW9uRm4oY3VycmVudEVsZW1lbnQpIHtcclxuICAgIGlmICghY3VycmVudEVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtZW50O1xyXG4gICAgfSBlbHNlIGlmIChpc1NlbGVjdG9yKSB7XHJcbiAgICAgIHJldHVybiBtYXRjaEZ1bmN0aW9uLmNhbGwoY3VycmVudEVsZW1lbnQsIHNlbGVjdG9yKTtcclxuICAgIH0gZWxzZSBpZiAoaXNOb2RlTGlzdCkge1xyXG4gICAgICByZXR1cm4gWy4uLm5vZGVMaXN0XS5pbmNsdWRlcyhjdXJyZW50RWxlbWVudCk7XHJcbiAgICB9IGVsc2UgaWYgKGlzRWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gc2luZ2xlRWxlbWVudCA9PT0gY3VycmVudEVsZW1lbnQ7XHJcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24pIHtcclxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGN1cnJlbnRFbGVtZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbGV0IGN1cnJlbnQgPSBlbGVtZW50O1xyXG5cclxuICBkbyB7XHJcbiAgICBjdXJyZW50ID0gY3VycmVudC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCB8fCBjdXJyZW50LmNvcnJlc3BvbmRpbmdFbGVtZW50IHx8IGN1cnJlbnQ7XHJcblxyXG4gICAgaWYgKGNvbmRpdGlvbkZuKGN1cnJlbnQpKSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XHJcbiAgfSB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50KTtcclxuXHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9jbG9zZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuXHJcbnZhciBfY2xvc2VzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9zZXN0KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfY2xvc2VzdDIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9jbG9zZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY2xvc2VzdCcsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb3Nlc3QpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX2Rpc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGlzdGFuY2UnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXN0YW5jZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF90b3VjaENvb3JkcyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3RvdWNoQ29vcmRzJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG91Y2hDb29yZHMpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbi8qKlxyXG4gKiBBbGwgZHJhZ2dhYmxlIHBsdWdpbnMgaW5oZXJpdCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAY2xhc3MgQWJzdHJhY3RQbHVnaW5cclxuICogQG1vZHVsZSBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgQWJzdHJhY3RQbHVnaW4ge1xyXG4gIC8qKlxyXG4gICAqIEFic3RyYWN0UGx1Z2luIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIEFic3RyYWN0UGx1Z2luXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgICAqIEBwcm9wZXJ0eSBkcmFnZ2FibGVcclxuICAgICAqIEB0eXBlIHtEcmFnZ2FibGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3ZlcnJpZGUgdG8gYWRkIGxpc3RlbmVyc1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPdmVycmlkZSB0byByZW1vdmUgbGlzdGVuZXJzXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gQWJzdHJhY3RQbHVnaW47XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cclxudmFyIF9Db2xsaWRhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcclxuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xyXG5jb25zdCBvblJlcXVlc3RBbmltYXRpb25GcmFtZSA9IFN5bWJvbCgnb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcclxuXHJcbi8qKlxyXG4gKiBDb2xsaWRhYmxlIHBsdWdpbiB3aGljaCBkZXRlY3RzIGNvbGxpZGluZyBlbGVtZW50cyB3aGlsZSBkcmFnZ2luZ1xyXG4gKiBAY2xhc3MgQ29sbGlkYWJsZVxyXG4gKiBAbW9kdWxlIENvbGxpZGFibGVcclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIENvbGxpZGFibGUgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIENvbGxpZGFibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgQ29sbGlkYWJsZVxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZWVwcyB0cmFjayBvZiBjdXJyZW50bHkgY29sbGlkaW5nIGVsZW1lbnRzXHJcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fG51bGx9IGN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnRcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2VlcHMgdHJhY2sgb2YgY3VycmVudGx5IGNvbGxpZGluZyBlbGVtZW50c1xyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxudWxsfSBsYXN0Q29sbGlkaW5nRWxlbWVudFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW5pbWF0aW9uIGZyYW1lIGZvciBmaW5kaW5nIGNvbGxpZGluZyBlbGVtZW50c1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8bnVsbH0gY3VycmVudEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWVdID0gdGhpc1tvblJlcXVlc3RBbmltYXRpb25GcmFtZV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjdXJyZW50IGNvbGxpZGFibGVzIGJhc2VkIG9uIGBjb2xsaWRhYmxlc2Agb3B0aW9uXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnRbXX1cclxuICAgKi9cclxuICBnZXRDb2xsaWRhYmxlcygpIHtcclxuICAgIGNvbnN0IGNvbGxpZGFibGVzID0gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5jb2xsaWRhYmxlcztcclxuXHJcbiAgICBpZiAodHlwZW9mIGNvbGxpZGFibGVzID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChjb2xsaWRhYmxlcykpO1xyXG4gICAgfSBlbHNlIGlmIChjb2xsaWRhYmxlcyBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGNvbGxpZGFibGVzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbGxpZGFibGVzKTtcclxuICAgIH0gZWxzZSBpZiAoY29sbGlkYWJsZXMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gW2NvbGxpZGFibGVzXTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbGxpZGFibGVzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHJldHVybiBjb2xsaWRhYmxlcygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ01vdmVFdmVudH0gZXZlbnQgLSBEcmFnIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnTW92ZV0oZXZlbnQpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnNlbnNvckV2ZW50LnRhcmdldDtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzW29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lXSh0YXJnZXQpKTtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50KSB7XHJcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbGxpZGFibGVJbkV2ZW50ID0gbmV3IF9Db2xsaWRhYmxlRXZlbnQuQ29sbGlkYWJsZUluRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBjb2xsaWRpbmdFbGVtZW50OiB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnRcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGNvbGxpZGFibGVPdXRFdmVudCA9IG5ldyBfQ29sbGlkYWJsZUV2ZW50LkNvbGxpZGFibGVPdXRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGNvbGxpZGluZ0VsZW1lbnQ6IHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnRcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGVudGVyaW5nQ29sbGlkYWJsZSA9IEJvb2xlYW4odGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ICYmIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgIT09IHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCk7XHJcbiAgICBjb25zdCBsZWF2aW5nQ29sbGlkYWJsZSA9IEJvb2xlYW4oIXRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCAmJiB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50KTtcclxuXHJcbiAgICBpZiAoZW50ZXJpbmdDb2xsaWRhYmxlKSB7XHJcbiAgICAgIGlmICh0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKGNvbGxpZGFibGVJbkV2ZW50KTtcclxuICAgIH0gZWxzZSBpZiAobGVhdmluZ0NvbGxpZGFibGUpIHtcclxuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgPSB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0b3AgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RvcEV2ZW50fSBldmVudCAtIERyYWcgc3RvcCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdG9wXShldmVudCkge1xyXG4gICAgY29uc3QgbGFzdENvbGxpZGluZ0VsZW1lbnQgPSB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgfHwgdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudDtcclxuICAgIGNvbnN0IGNvbGxpZGFibGVPdXRFdmVudCA9IG5ldyBfQ29sbGlkYWJsZUV2ZW50LkNvbGxpZGFibGVPdXRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGNvbGxpZGluZ0VsZW1lbnQ6IGxhc3RDb2xsaWRpbmdFbGVtZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAobGFzdENvbGxpZGluZ0VsZW1lbnQpIHtcclxuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xyXG4gICAgdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuaW1hdGlvbiBmcmFtZSBmdW5jdGlvblxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gQ3VycmVudCBtb3ZlIHRhcmdldFxyXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxyXG4gICAqL1xyXG4gIFtvblJlcXVlc3RBbmltYXRpb25GcmFtZV0odGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCBjb2xsaWRhYmxlcyA9IHRoaXMuZ2V0Q29sbGlkYWJsZXMoKTtcclxuICAgICAgdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ID0gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIGVsZW1lbnQgPT4gY29sbGlkYWJsZXMuaW5jbHVkZXMoZWxlbWVudCkpO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29sbGlkYWJsZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG5jb25zdCBjYW5jZWxlZCA9IFN5bWJvbCgnY2FuY2VsZWQnKTtcclxuXHJcbi8qKlxyXG4gKiBBbGwgZXZlbnRzIGZpcmVkIGJ5IGRyYWdnYWJsZSBpbmhlcml0IHRoaXMgY2xhc3MuIFlvdSBjYW4gY2FsbCBgY2FuY2VsKClgIHRvXHJcbiAqIGNhbmNlbCBhIHNwZWNpZmljIGV2ZW50IG9yIHlvdSBjYW4gY2hlY2sgaWYgYW4gZXZlbnQgaGFzIGJlZW4gY2FuY2VsZWQgYnlcclxuICogY2FsbGluZyBgY2FuY2VsZWQoKWAuXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAY2xhc3MgQWJzdHJhY3RFdmVudFxyXG4gKiBAbW9kdWxlIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIEFic3RyYWN0RXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBBYnN0cmFjdEV2ZW50IGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIEFic3RyYWN0RXZlbnRcclxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIEV2ZW50IGRhdGFcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogRXZlbnQgdHlwZVxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcHJvcGVydHkgdHlwZVxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZGF0YSkge1xyXG4gICAgdGhpc1tjYW5jZWxlZF0gPSBmYWxzZTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFkLW9ubHkgdHlwZVxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW50IGNhbmNlbGFibGVcclxuICAgKiBAc3RhdGljXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgdHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnR5cGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFkLW9ubHkgY2FuY2VsYWJsZVxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IGNhbmNlbGFibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jYW5jZWxhYmxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FuY2VscyB0aGUgZXZlbnQgaW5zdGFuY2VcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuICBjYW5jZWwoKSB7XHJcbiAgICB0aGlzW2NhbmNlbGVkXSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBldmVudCBoYXMgYmVlbiBjYW5jZWxlZFxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgY2FuY2VsZWQoKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzW2NhbmNlbGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG5ldyBldmVudCBpbnN0YW5jZSB3aXRoIGV4aXN0aW5nIGV2ZW50IGRhdGEuXHJcbiAgICogVGhpcyBtZXRob2QgYWxsb3dzIGZvciBvdmVycmlkaW5nIG9mIGV2ZW50IGRhdGEuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdEV2ZW50fVxyXG4gICAqL1xyXG4gIGNsb25lKGRhdGEpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihfZXh0ZW5kcyh7fSwgdGhpcy5kYXRhLCBkYXRhKSk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0RXZlbnQ7XHJcbkFic3RyYWN0RXZlbnQudHlwZSA9ICdldmVudCc7XHJcbkFic3RyYWN0RXZlbnQuY2FuY2VsYWJsZSA9IGZhbHNlO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuQ29sbGlkYWJsZU91dEV2ZW50ID0gZXhwb3J0cy5Db2xsaWRhYmxlSW5FdmVudCA9IGV4cG9ydHMuQ29sbGlkYWJsZUV2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgY29sbGlkYWJsZSBldmVudFxyXG4gKiBAY2xhc3MgQ29sbGlkYWJsZUV2ZW50XHJcbiAqIEBtb2R1bGUgQ29sbGlkYWJsZUV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIENvbGxpZGFibGVFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGNvbGxpYWJsZSBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBkcmFnRXZlbnRcclxuICAgKiBAdHlwZSB7RHJhZ0V2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkcmFnRXZlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuQ29sbGlkYWJsZUV2ZW50ID0gQ29sbGlkYWJsZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbGxpZGFibGUgaW4gZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBDb2xsaWRhYmxlSW5FdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBDb2xsaWRhYmxlSW5FdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgQ29sbGlkYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkNvbGxpZGFibGVFdmVudC50eXBlID0gJ2NvbGxpZGFibGUnO1xyXG5jbGFzcyBDb2xsaWRhYmxlSW5FdmVudCBleHRlbmRzIENvbGxpZGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEVsZW1lbnQgeW91IGFyZSBjdXJyZW50bHkgY29sbGlkaW5nIHdpdGhcclxuICAgKiBAcHJvcGVydHkgY29sbGlkaW5nRWxlbWVudFxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgY29sbGlkaW5nRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuY29sbGlkaW5nRWxlbWVudDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuQ29sbGlkYWJsZUluRXZlbnQgPSBDb2xsaWRhYmxlSW5FdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29sbGlkYWJsZSBvdXQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgQ29sbGlkYWJsZU91dEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBDb2xsaWRhYmxlT3V0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBDb2xsaWRhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkNvbGxpZGFibGVJbkV2ZW50LnR5cGUgPSAnY29sbGlkYWJsZTppbic7XHJcbmNsYXNzIENvbGxpZGFibGVPdXRFdmVudCBleHRlbmRzIENvbGxpZGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEVsZW1lbnQgeW91IHdlcmUgcHJldmlvdXNseSBjb2xsaWRpbmcgd2l0aFxyXG4gICAqIEBwcm9wZXJ0eSBjb2xsaWRpbmdFbGVtZW50XHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjb2xsaWRpbmdFbGVtZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jb2xsaWRpbmdFbGVtZW50O1xyXG4gIH1cclxufVxyXG5leHBvcnRzLkNvbGxpZGFibGVPdXRFdmVudCA9IENvbGxpZGFibGVPdXRFdmVudDtcclxuQ29sbGlkYWJsZU91dEV2ZW50LnR5cGUgPSAnY29sbGlkYWJsZTpvdXQnO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Db2xsaWRhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxuT2JqZWN0LmtleXMoX0NvbGxpZGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9Db2xsaWRhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX0NvbGxpZGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuXHJcbnZhciBfQ29sbGlkYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db2xsaWRhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfQ29sbGlkYWJsZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pXHJcbi8qKioqKiovIF0pO1xyXG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@shopify/draggable/lib/plugins/collidable.js\n");

/***/ }),

/***/ "./node_modules/@shopify/draggable/lib/plugins/resize-mirror.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@shopify/draggable/lib/plugins/resize-mirror.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(true)\r\n\t\tmodule.exports = factory();\r\n\telse {}\r\n})(window, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __nested_webpack_require_580__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId]) {\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_580__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__nested_webpack_require_580__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__nested_webpack_require_580__.c = installedModules;\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__nested_webpack_require_580__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__nested_webpack_require_580__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// define __esModule on exports\r\n/******/ \t__nested_webpack_require_580__.r = function(exports) {\r\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\r\n/******/ \t\t}\r\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\r\n/******/ \t};\r\n/******/\r\n/******/ \t// create a fake namespace object\r\n/******/ \t// mode & 1: value is a module id, require it\r\n/******/ \t// mode & 2: merge all properties of value into the ns\r\n/******/ \t// mode & 4: return value when already ns object\r\n/******/ \t// mode & 8|1: behave like require\r\n/******/ \t__nested_webpack_require_580__.t = function(value, mode) {\r\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_580__(value);\r\n/******/ \t\tif(mode & 8) return value;\r\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\r\n/******/ \t\tvar ns = Object.create(null);\r\n/******/ \t\t__nested_webpack_require_580__.r(ns);\r\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\r\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_580__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\r\n/******/ \t\treturn ns;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__nested_webpack_require_580__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__nested_webpack_require_580__.d(getter, 'a', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__nested_webpack_require_580__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__nested_webpack_require_580__.p = \"\";\r\n/******/\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __nested_webpack_require_580__(__nested_webpack_require_580__.s = 12);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = touchCoords;\r\n/**\r\n * Returns the first touch event found in touches or changedTouches of a touch events.\r\n * @param {TouchEvent} event a touch event\r\n * @return {Touch} a touch object\r\n */\r\nfunction touchCoords(event = {}) {\r\n  const { touches, changedTouches } = event;\r\n  return touches && touches[0] || changedTouches && changedTouches[0];\r\n}\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports, __nested_webpack_require_4662__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_4662__(0);\r\n\r\nvar _touchCoords2 = _interopRequireDefault(_touchCoords);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _touchCoords2.default;\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = distance;\r\n/**\r\n * Returns the distance between two points\r\n * @param  {Number} x1 The X position of the first point\r\n * @param  {Number} y1 The Y position of the first point\r\n * @param  {Number} x2 The X position of the second point\r\n * @param  {Number} y2 The Y position of the second point\r\n * @return {Number}\r\n */\r\nfunction distance(x1, y1, x2, y2) {\r\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\r\n}\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports, __nested_webpack_require_5680__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _distance = __nested_webpack_require_5680__(2);\r\n\r\nvar _distance2 = _interopRequireDefault(_distance);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _distance2.default;\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = requestNextAnimationFrame;\r\nfunction requestNextAnimationFrame(callback) {\r\n  return requestAnimationFrame(() => {\r\n    requestAnimationFrame(callback);\r\n  });\r\n}\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports, __nested_webpack_require_6436__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_6436__(4);\r\n\r\nvar _requestNextAnimationFrame2 = _interopRequireDefault(_requestNextAnimationFrame);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _requestNextAnimationFrame2.default;\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = closest;\r\nconst matchFunction = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector;\r\n\r\n/**\r\n * Get the closest parent element of a given element that matches the given\r\n * selector string or matching function\r\n *\r\n * @param {Element} element The child element to find a parent of\r\n * @param {String|Function} selector The string or function to use to match\r\n *     the parent element\r\n * @return {Element|null}\r\n */\r\nfunction closest(element, value) {\r\n  if (!element) {\r\n    return null;\r\n  }\r\n\r\n  const selector = value;\r\n  const callback = value;\r\n  const nodeList = value;\r\n  const singleElement = value;\r\n\r\n  const isSelector = Boolean(typeof value === 'string');\r\n  const isFunction = Boolean(typeof value === 'function');\r\n  const isNodeList = Boolean(value instanceof NodeList || value instanceof Array);\r\n  const isElement = Boolean(value instanceof HTMLElement);\r\n\r\n  function conditionFn(currentElement) {\r\n    if (!currentElement) {\r\n      return currentElement;\r\n    } else if (isSelector) {\r\n      return matchFunction.call(currentElement, selector);\r\n    } else if (isNodeList) {\r\n      return [...nodeList].includes(currentElement);\r\n    } else if (isElement) {\r\n      return singleElement === currentElement;\r\n    } else if (isFunction) {\r\n      return callback(currentElement);\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  let current = element;\r\n\r\n  do {\r\n    current = current.correspondingUseElement || current.correspondingElement || current;\r\n\r\n    if (conditionFn(current)) {\r\n      return current;\r\n    }\r\n\r\n    current = current.parentNode;\r\n  } while (current && current !== document.body && current !== document);\r\n\r\n  return null;\r\n}\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports, __nested_webpack_require_8863__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_8863__(6);\r\n\r\nvar _closest2 = _interopRequireDefault(_closest);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _closest2.default;\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ (function(module, exports, __nested_webpack_require_9265__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_9265__(7);\r\n\r\nObject.defineProperty(exports, 'closest', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_closest).default;\r\n  }\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_9265__(5);\r\n\r\nObject.defineProperty(exports, 'requestNextAnimationFrame', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_requestNextAnimationFrame).default;\r\n  }\r\n});\r\n\r\nvar _distance = __nested_webpack_require_9265__(3);\r\n\r\nObject.defineProperty(exports, 'distance', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_distance).default;\r\n  }\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_9265__(1);\r\n\r\nObject.defineProperty(exports, 'touchCoords', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_touchCoords).default;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * All draggable plugins inherit from this class.\r\n * @abstract\r\n * @class AbstractPlugin\r\n * @module AbstractPlugin\r\n */\r\nclass AbstractPlugin {\r\n  /**\r\n   * AbstractPlugin constructor.\r\n   * @constructs AbstractPlugin\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    /**\r\n     * Draggable instance\r\n     * @property draggable\r\n     * @type {Draggable}\r\n     */\r\n    this.draggable = draggable;\r\n  }\r\n\r\n  /**\r\n   * Override to add listeners\r\n   * @abstract\r\n   */\r\n  attach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n\r\n  /**\r\n   * Override to remove listeners\r\n   * @abstract\r\n   */\r\n  detach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n}\r\nexports.default = AbstractPlugin;\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ (function(module, exports, __nested_webpack_require_11297__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_11297__(9);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractPlugin2.default;\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ (function(module, exports, __nested_webpack_require_11728__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_11728__(10);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _utils = __nested_webpack_require_11728__(8);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMirrorCreated = Symbol('onMirrorCreated');\r\nconst onMirrorDestroy = Symbol('onMirrorDestroy');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst resize = Symbol('resize');\r\n\r\n/**\r\n * ResizeMirror default options\r\n * @property {Object} defaultOptions\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {};\r\n\r\n/**\r\n * The ResizeMirror plugin resizes the mirror element to the dimensions of the draggable element that the mirror is hovering over\r\n * @class ResizeMirror\r\n * @module ResizeMirror\r\n * @extends AbstractPlugin\r\n */\r\nclass ResizeMirror extends _AbstractPlugin2.default {\r\n  /**\r\n   * ResizeMirror constructor.\r\n   * @constructs ResizeMirror\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * ResizeMirror options\r\n     * @property {Object} options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * ResizeMirror remembers the last width when resizing the mirror\r\n     * to avoid additional writes to the DOM\r\n     * @property {number} lastWidth\r\n     */\r\n    this.lastWidth = 0;\r\n\r\n    /**\r\n     * ResizeMirror remembers the last height when resizing the mirror\r\n     * to avoid additional writes to the DOM\r\n     * @property {number} lastHeight\r\n     */\r\n    this.lastHeight = 0;\r\n\r\n    /**\r\n     * Keeps track of the mirror element\r\n     * @property {HTMLElement} mirror\r\n     */\r\n    this.mirror = null;\r\n\r\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\r\n    this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('mirror:created', this[onMirrorCreated]).on('drag:over', this[onDragOver]).on('drag:over:container', this[onDragOver]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('mirror:created', this[onMirrorCreated]).off('mirror:destroy', this[onMirrorDestroy]).off('drag:over', this[onDragOver]).off('drag:over:container', this[onDragOver]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.resizeMirror || {};\r\n  }\r\n\r\n  /**\r\n   * Mirror created handler\r\n   * @param {MirrorCreatedEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorCreated]({ mirror }) {\r\n    this.mirror = mirror;\r\n  }\r\n\r\n  /**\r\n   * Mirror destroy handler\r\n   * @param {MirrorDestroyEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorDestroy]() {\r\n    this.mirror = null;\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @param {DragOverEvent | DragOverContainer} dragEvent\r\n   * @private\r\n   */\r\n  [onDragOver](dragEvent) {\r\n    this[resize](dragEvent);\r\n  }\r\n\r\n  /**\r\n   * Resize function for\r\n   * @param {DragOverEvent | DragOverContainer} dragEvent\r\n   * @private\r\n   */\r\n  [resize]({ overContainer, over }) {\r\n    requestAnimationFrame(() => {\r\n      if (!this.mirror.parentNode) {\r\n        return;\r\n      }\r\n\r\n      if (this.mirror.parentNode !== overContainer) {\r\n        overContainer.appendChild(this.mirror);\r\n      }\r\n\r\n      const overElement = over || this.draggable.getDraggableElementsForContainer(overContainer)[0];\r\n\r\n      if (!overElement) {\r\n        return;\r\n      }\r\n\r\n      (0, _utils.requestNextAnimationFrame)(() => {\r\n        const overRect = overElement.getBoundingClientRect();\r\n\r\n        if (this.lastHeight === overRect.height && this.lastWidth === overRect.width) {\r\n          return;\r\n        }\r\n\r\n        this.mirror.style.width = `${overRect.width}px`;\r\n        this.mirror.style.height = `${overRect.height}px`;\r\n\r\n        this.lastWidth = overRect.width;\r\n        this.lastHeight = overRect.height;\r\n      });\r\n    });\r\n  }\r\n}\r\nexports.default = ResizeMirror;\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ (function(module, exports, __nested_webpack_require_16330__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _ResizeMirror = __nested_webpack_require_16330__(11);\r\n\r\nvar _ResizeMirror2 = _interopRequireDefault(_ResizeMirror);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _ResizeMirror2.default;\r\nexports.defaultOptions = _ResizeMirror.defaultOptions;\r\n\r\n/***/ })\r\n/******/ ]);\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9wbHVnaW5zL3Jlc2l6ZS1taXJyb3IuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUs2QjtBQUNuQyxDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw4QkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGVBQWUsOEJBQW1CO0FBQ2xDLG1EQUFtRCwrQkFBK0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLGlFQUFpRSxpQkFBaUI7QUFDbEY7QUFDQSwwREFBMEQsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGdDQUFnQyw4QkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBbUI7QUFDOUIsa0RBQWtELGdDQUFnQztBQUNsRiwwRUFBMEUsOEJBQW1CLDRCQUE0QixvQkFBb0I7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsMENBQTBDO0FBQzFDLFdBQVcsOEJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQW1C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Q1A7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9saWIvcGx1Z2lucy9yZXNpemUtbWlycm9yLmpzP2U3OGQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuXHRcdGRlZmluZShcIlJlc2l6ZU1pcnJvclwiLCBbXSwgZmFjdG9yeSk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcblx0XHRleHBvcnRzW1wiUmVzaXplTWlycm9yXCJdID0gZmFjdG9yeSgpO1xyXG5cdGVsc2VcclxuXHRcdHJvb3RbXCJSZXNpemVNaXJyb3JcIl0gPSBmYWN0b3J5KCk7XHJcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XHJcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXHJcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcclxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XHJcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcclxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcclxuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXHJcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxyXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxyXG4vKioqKioqLyBcdFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXHJcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxyXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG4vKioqKioqLyBcdH1cclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xyXG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XHJcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcclxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XHJcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xyXG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XHJcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcclxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxMik7XHJcbi8qKioqKiovIH0pXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKioqKiovIChbXHJcbi8qIDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHRvdWNoQ29vcmRzO1xyXG4vKipcclxuICogUmV0dXJucyB0aGUgZmlyc3QgdG91Y2ggZXZlbnQgZm91bmQgaW4gdG91Y2hlcyBvciBjaGFuZ2VkVG91Y2hlcyBvZiBhIHRvdWNoIGV2ZW50cy5cclxuICogQHBhcmFtIHtUb3VjaEV2ZW50fSBldmVudCBhIHRvdWNoIGV2ZW50XHJcbiAqIEByZXR1cm4ge1RvdWNofSBhIHRvdWNoIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gdG91Y2hDb29yZHMoZXZlbnQgPSB7fSkge1xyXG4gIGNvbnN0IHsgdG91Y2hlcywgY2hhbmdlZFRvdWNoZXMgfSA9IGV2ZW50O1xyXG4gIHJldHVybiB0b3VjaGVzICYmIHRvdWNoZXNbMF0gfHwgY2hhbmdlZFRvdWNoZXMgJiYgY2hhbmdlZFRvdWNoZXNbMF07XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF90b3VjaENvb3JkcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG52YXIgX3RvdWNoQ29vcmRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvdWNoQ29vcmRzKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfdG91Y2hDb29yZHMyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gZGlzdGFuY2U7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcclxuICogQHBhcmFtICB7TnVtYmVyfSB4MSBUaGUgWCBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnRcclxuICogQHBhcmFtICB7TnVtYmVyfSB5MSBUaGUgWSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnRcclxuICogQHBhcmFtICB7TnVtYmVyfSB4MiBUaGUgWCBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50XHJcbiAqIEBwYXJhbSAge051bWJlcn0geTIgVGhlIFkgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xyXG4gIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICoqIDIgKyAoeTIgLSB5MSkgKiogMik7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9kaXN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG52YXIgX2Rpc3RhbmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc3RhbmNlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfZGlzdGFuY2UyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZTtcclxuZnVuY3Rpb24gcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xyXG4gIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxudmFyIF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb3Nlc3Q7XHJcbmNvbnN0IG1hdGNoRnVuY3Rpb24gPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3I7XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjbG9zZXN0IHBhcmVudCBlbGVtZW50IG9mIGEgZ2l2ZW4gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuXHJcbiAqIHNlbGVjdG9yIHN0cmluZyBvciBtYXRjaGluZyBmdW5jdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGNoaWxkIGVsZW1lbnQgdG8gZmluZCBhIHBhcmVudCBvZlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgVGhlIHN0cmluZyBvciBmdW5jdGlvbiB0byB1c2UgdG8gbWF0Y2hcclxuICogICAgIHRoZSBwYXJlbnQgZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtFbGVtZW50fG51bGx9XHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9zZXN0KGVsZW1lbnQsIHZhbHVlKSB7XHJcbiAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNlbGVjdG9yID0gdmFsdWU7XHJcbiAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZTtcclxuICBjb25zdCBub2RlTGlzdCA9IHZhbHVlO1xyXG4gIGNvbnN0IHNpbmdsZUVsZW1lbnQgPSB2YWx1ZTtcclxuXHJcbiAgY29uc3QgaXNTZWxlY3RvciA9IEJvb2xlYW4odHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyk7XHJcbiAgY29uc3QgaXNGdW5jdGlvbiA9IEJvb2xlYW4odHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKTtcclxuICBjb25zdCBpc05vZGVMaXN0ID0gQm9vbGVhbih2YWx1ZSBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpO1xyXG4gIGNvbnN0IGlzRWxlbWVudCA9IEJvb2xlYW4odmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCk7XHJcblxyXG4gIGZ1bmN0aW9uIGNvbmRpdGlvbkZuKGN1cnJlbnRFbGVtZW50KSB7XHJcbiAgICBpZiAoIWN1cnJlbnRFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcclxuICAgIH0gZWxzZSBpZiAoaXNTZWxlY3Rvcikge1xyXG4gICAgICByZXR1cm4gbWF0Y2hGdW5jdGlvbi5jYWxsKGN1cnJlbnRFbGVtZW50LCBzZWxlY3Rvcik7XHJcbiAgICB9IGVsc2UgaWYgKGlzTm9kZUxpc3QpIHtcclxuICAgICAgcmV0dXJuIFsuLi5ub2RlTGlzdF0uaW5jbHVkZXMoY3VycmVudEVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIGlmIChpc0VsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIHNpbmdsZUVsZW1lbnQgPT09IGN1cnJlbnRFbGVtZW50O1xyXG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKSB7XHJcbiAgICAgIHJldHVybiBjYWxsYmFjayhjdXJyZW50RWxlbWVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxldCBjdXJyZW50ID0gZWxlbWVudDtcclxuXHJcbiAgZG8ge1xyXG4gICAgY3VycmVudCA9IGN1cnJlbnQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQgfHwgY3VycmVudC5jb3JyZXNwb25kaW5nRWxlbWVudCB8fCBjdXJyZW50O1xyXG5cclxuICAgIGlmIChjb25kaXRpb25GbihjdXJyZW50KSkge1xyXG4gICAgICByZXR1cm4gY3VycmVudDtcclxuICAgIH1cclxuXHJcbiAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xyXG4gIH0gd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBjdXJyZW50ICE9PSBkb2N1bWVudCk7XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfY2xvc2VzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG52YXIgX2Nsb3Nlc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xvc2VzdCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX2Nsb3Nlc3QyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfY2xvc2VzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2Nsb3Nlc3QnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9zZXN0KS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9kaXN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2Rpc3RhbmNlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzdGFuY2UpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfdG91Y2hDb29yZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd0b3VjaENvb3JkcycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvdWNoQ29vcmRzKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbi8qKlxyXG4gKiBBbGwgZHJhZ2dhYmxlIHBsdWdpbnMgaW5oZXJpdCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAY2xhc3MgQWJzdHJhY3RQbHVnaW5cclxuICogQG1vZHVsZSBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgQWJzdHJhY3RQbHVnaW4ge1xyXG4gIC8qKlxyXG4gICAqIEFic3RyYWN0UGx1Z2luIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIEFic3RyYWN0UGx1Z2luXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgICAqIEBwcm9wZXJ0eSBkcmFnZ2FibGVcclxuICAgICAqIEB0eXBlIHtEcmFnZ2FibGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3ZlcnJpZGUgdG8gYWRkIGxpc3RlbmVyc1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPdmVycmlkZSB0byByZW1vdmUgbGlzdGVuZXJzXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gQWJzdHJhY3RQbHVnaW47XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uTWlycm9yQ3JlYXRlZCA9IFN5bWJvbCgnb25NaXJyb3JDcmVhdGVkJyk7XHJcbmNvbnN0IG9uTWlycm9yRGVzdHJveSA9IFN5bWJvbCgnb25NaXJyb3JEZXN0cm95Jyk7XHJcbmNvbnN0IG9uRHJhZ092ZXIgPSBTeW1ib2woJ29uRHJhZ092ZXInKTtcclxuY29uc3QgcmVzaXplID0gU3ltYm9sKCdyZXNpemUnKTtcclxuXHJcbi8qKlxyXG4gKiBSZXNpemVNaXJyb3IgZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge307XHJcblxyXG4vKipcclxuICogVGhlIFJlc2l6ZU1pcnJvciBwbHVnaW4gcmVzaXplcyB0aGUgbWlycm9yIGVsZW1lbnQgdG8gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGRyYWdnYWJsZSBlbGVtZW50IHRoYXQgdGhlIG1pcnJvciBpcyBob3ZlcmluZyBvdmVyXHJcbiAqIEBjbGFzcyBSZXNpemVNaXJyb3JcclxuICogQG1vZHVsZSBSZXNpemVNaXJyb3JcclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIFJlc2l6ZU1pcnJvciBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogUmVzaXplTWlycm9yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFJlc2l6ZU1pcnJvclxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVNaXJyb3Igb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplTWlycm9yIHJlbWVtYmVycyB0aGUgbGFzdCB3aWR0aCB3aGVuIHJlc2l6aW5nIHRoZSBtaXJyb3JcclxuICAgICAqIHRvIGF2b2lkIGFkZGl0aW9uYWwgd3JpdGVzIHRvIHRoZSBET01cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXN0V2lkdGhcclxuICAgICAqL1xyXG4gICAgdGhpcy5sYXN0V2lkdGggPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplTWlycm9yIHJlbWVtYmVycyB0aGUgbGFzdCBoZWlnaHQgd2hlbiByZXNpemluZyB0aGUgbWlycm9yXHJcbiAgICAgKiB0byBhdm9pZCBhZGRpdGlvbmFsIHdyaXRlcyB0byB0aGUgRE9NXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbGFzdEhlaWdodFxyXG4gICAgICovXHJcbiAgICB0aGlzLmxhc3RIZWlnaHQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIG1pcnJvciBlbGVtZW50XHJcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBtaXJyb3JcclxuICAgICAqL1xyXG4gICAgdGhpcy5taXJyb3IgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25NaXJyb3JDcmVhdGVkXSA9IHRoaXNbb25NaXJyb3JDcmVhdGVkXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1pcnJvckRlc3Ryb3ldID0gdGhpc1tvbk1pcnJvckRlc3Ryb3ldLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ092ZXJdID0gdGhpc1tvbkRyYWdPdmVyXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9uKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vbignZHJhZzpvdmVyOmNvbnRhaW5lcicsIHRoaXNbb25EcmFnT3Zlcl0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ21pcnJvcjpjcmVhdGVkJywgdGhpc1tvbk1pcnJvckNyZWF0ZWRdKS5vZmYoJ21pcnJvcjpkZXN0cm95JywgdGhpc1tvbk1pcnJvckRlc3Ryb3ldKS5vZmYoJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9mZignZHJhZzpvdmVyOmNvbnRhaW5lcicsIHRoaXNbb25EcmFnT3Zlcl0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBvcHRpb25zIHBhc3NlZCB0aHJvdWdoIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMucmVzaXplTWlycm9yIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlycm9yIGNyZWF0ZWQgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7TWlycm9yQ3JlYXRlZEV2ZW50fSBtaXJyb3JFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uTWlycm9yQ3JlYXRlZF0oeyBtaXJyb3IgfSkge1xyXG4gICAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNaXJyb3IgZGVzdHJveSBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtNaXJyb3JEZXN0cm95RXZlbnR9IG1pcnJvckV2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25NaXJyb3JEZXN0cm95XSgpIHtcclxuICAgIHRoaXMubWlycm9yID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgb3ZlciBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtEcmFnT3ZlckV2ZW50IHwgRHJhZ092ZXJDb250YWluZXJ9IGRyYWdFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRHJhZ092ZXJdKGRyYWdFdmVudCkge1xyXG4gICAgdGhpc1tyZXNpemVdKGRyYWdFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNpemUgZnVuY3Rpb24gZm9yXHJcbiAgICogQHBhcmFtIHtEcmFnT3ZlckV2ZW50IHwgRHJhZ092ZXJDb250YWluZXJ9IGRyYWdFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW3Jlc2l6ZV0oeyBvdmVyQ29udGFpbmVyLCBvdmVyIH0pIHtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5taXJyb3IucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMubWlycm9yLnBhcmVudE5vZGUgIT09IG92ZXJDb250YWluZXIpIHtcclxuICAgICAgICBvdmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubWlycm9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgb3ZlckVsZW1lbnQgPSBvdmVyIHx8IHRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG92ZXJDb250YWluZXIpWzBdO1xyXG5cclxuICAgICAgaWYgKCFvdmVyRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgKDAsIF91dGlscy5yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKSgoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb3ZlclJlY3QgPSBvdmVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGFzdEhlaWdodCA9PT0gb3ZlclJlY3QuaGVpZ2h0ICYmIHRoaXMubGFzdFdpZHRoID09PSBvdmVyUmVjdC53aWR0aCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5taXJyb3Iuc3R5bGUud2lkdGggPSBgJHtvdmVyUmVjdC53aWR0aH1weGA7XHJcbiAgICAgICAgdGhpcy5taXJyb3Iuc3R5bGUuaGVpZ2h0ID0gYCR7b3ZlclJlY3QuaGVpZ2h0fXB4YDtcclxuXHJcbiAgICAgICAgdGhpcy5sYXN0V2lkdGggPSBvdmVyUmVjdC53aWR0aDtcclxuICAgICAgICB0aGlzLmxhc3RIZWlnaHQgPSBvdmVyUmVjdC5oZWlnaHQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJlc2l6ZU1pcnJvcjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfUmVzaXplTWlycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblxyXG52YXIgX1Jlc2l6ZU1pcnJvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZXNpemVNaXJyb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9SZXNpemVNaXJyb3IyLmRlZmF1bHQ7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfUmVzaXplTWlycm9yLmRlZmF1bHRPcHRpb25zO1xyXG5cclxuLyoqKi8gfSlcclxuLyoqKioqKi8gXSk7XHJcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@shopify/draggable/lib/plugins/resize-mirror.js\n");

/***/ }),

/***/ "./node_modules/@shopify/draggable/lib/plugins/snappable.js":
/*!******************************************************************!*\
  !*** ./node_modules/@shopify/draggable/lib/plugins/snappable.js ***!
  \******************************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(true)\r\n\t\tmodule.exports = factory();\r\n\telse {}\r\n})(window, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __nested_webpack_require_571__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId]) {\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_571__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__nested_webpack_require_571__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__nested_webpack_require_571__.c = installedModules;\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__nested_webpack_require_571__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__nested_webpack_require_571__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// define __esModule on exports\r\n/******/ \t__nested_webpack_require_571__.r = function(exports) {\r\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\r\n/******/ \t\t}\r\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\r\n/******/ \t};\r\n/******/\r\n/******/ \t// create a fake namespace object\r\n/******/ \t// mode & 1: value is a module id, require it\r\n/******/ \t// mode & 2: merge all properties of value into the ns\r\n/******/ \t// mode & 4: return value when already ns object\r\n/******/ \t// mode & 8|1: behave like require\r\n/******/ \t__nested_webpack_require_571__.t = function(value, mode) {\r\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_571__(value);\r\n/******/ \t\tif(mode & 8) return value;\r\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\r\n/******/ \t\tvar ns = Object.create(null);\r\n/******/ \t\t__nested_webpack_require_571__.r(ns);\r\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\r\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_571__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\r\n/******/ \t\treturn ns;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__nested_webpack_require_571__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__nested_webpack_require_571__.d(getter, 'a', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__nested_webpack_require_571__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__nested_webpack_require_571__.p = \"\";\r\n/******/\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __nested_webpack_require_571__(__nested_webpack_require_571__.s = 7);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __nested_webpack_require_4118__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SnappableEvent = __nested_webpack_require_4118__(6);\r\n\r\nObject.keys(_SnappableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SnappableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * All draggable plugins inherit from this class.\r\n * @abstract\r\n * @class AbstractPlugin\r\n * @module AbstractPlugin\r\n */\r\nclass AbstractPlugin {\r\n  /**\r\n   * AbstractPlugin constructor.\r\n   * @constructs AbstractPlugin\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    /**\r\n     * Draggable instance\r\n     * @property draggable\r\n     * @type {Draggable}\r\n     */\r\n    this.draggable = draggable;\r\n  }\r\n\r\n  /**\r\n   * Override to add listeners\r\n   * @abstract\r\n   */\r\n  attach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n\r\n  /**\r\n   * Override to remove listeners\r\n   * @abstract\r\n   */\r\n  detach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n}\r\nexports.default = AbstractPlugin;\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports, __nested_webpack_require_5504__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_5504__(1);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractPlugin2.default;\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports, __nested_webpack_require_5934__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_5934__(2);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _SnappableEvent = __nested_webpack_require_5934__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragOut = Symbol('onDragOut');\r\nconst onMirrorCreated = Symbol('onMirrorCreated');\r\nconst onMirrorDestroy = Symbol('onMirrorDestroy');\r\n\r\n/**\r\n * Snappable plugin which snaps draggable elements into place\r\n * @class Snappable\r\n * @module Snappable\r\n * @extends AbstractPlugin\r\n */\r\nclass Snappable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Snappable constructor.\r\n   * @constructs Snappable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Keeps track of the first source element\r\n     * @property {HTMLElement|null} firstSource\r\n     */\r\n    this.firstSource = null;\r\n\r\n    /**\r\n     * Keeps track of the mirror element\r\n     * @property {HTMLElement} mirror\r\n     */\r\n    this.mirror = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragOut] = this[onDragOut].bind(this);\r\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\r\n    this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:stop', this[onDragStop]).on('drag:over', this[onDragOver]).on('drag:out', this[onDragOut]).on('droppable:over', this[onDragOver]).on('droppable:out', this[onDragOut]).on('mirror:created', this[onMirrorCreated]).on('mirror:destroy', this[onMirrorDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:stop', this[onDragStop]).off('drag:over', this[onDragOver]).off('drag:out', this[onDragOut]).off('droppable:over', this[onDragOver]).off('droppable:out', this[onDragOut]).off('mirror:created', this[onMirrorCreated]).off('mirror:destroy', this[onMirrorDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {DragStartEvent} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    this.firstSource = event.source;\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop]() {\r\n    this.firstSource = null;\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {DragOverEvent|DroppableOverEvent} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const source = event.source || event.dragEvent.source;\r\n\r\n    if (source === this.firstSource) {\r\n      this.firstSource = null;\r\n      return;\r\n    }\r\n\r\n    const snapInEvent = new _SnappableEvent.SnapInEvent({\r\n      dragEvent: event,\r\n      snappable: event.over || event.droppable\r\n    });\r\n\r\n    this.draggable.trigger(snapInEvent);\r\n\r\n    if (snapInEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    if (this.mirror) {\r\n      this.mirror.style.display = 'none';\r\n    }\r\n\r\n    source.classList.remove(...this.draggable.getClassNamesFor('source:dragging'));\r\n    source.classList.add(...this.draggable.getClassNamesFor('source:placed'));\r\n\r\n    // Need to cancel this in drag out\r\n    setTimeout(() => {\r\n      source.classList.remove(...this.draggable.getClassNamesFor('source:placed'));\r\n    }, this.draggable.options.placedTimeout);\r\n  }\r\n\r\n  /**\r\n   * Drag out handler\r\n   * @private\r\n   * @param {DragOutEvent|DroppableOutEvent} event - Drag out event\r\n   */\r\n  [onDragOut](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const source = event.source || event.dragEvent.source;\r\n\r\n    const snapOutEvent = new _SnappableEvent.SnapOutEvent({\r\n      dragEvent: event,\r\n      snappable: event.over || event.droppable\r\n    });\r\n\r\n    this.draggable.trigger(snapOutEvent);\r\n\r\n    if (snapOutEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    if (this.mirror) {\r\n      this.mirror.style.display = '';\r\n    }\r\n\r\n    source.classList.add(...this.draggable.getClassNamesFor('source:dragging'));\r\n  }\r\n\r\n  /**\r\n   * Mirror created handler\r\n   * @param {MirrorCreatedEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorCreated]({ mirror }) {\r\n    this.mirror = mirror;\r\n  }\r\n\r\n  /**\r\n   * Mirror destroy handler\r\n   * @param {MirrorDestroyEvent} mirrorEvent\r\n   * @private\r\n   */\r\n  [onMirrorDestroy]() {\r\n    this.mirror = null;\r\n  }\r\n}\r\nexports.default = Snappable;\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst canceled = Symbol('canceled');\r\n\r\n/**\r\n * All events fired by draggable inherit this class. You can call `cancel()` to\r\n * cancel a specific event or you can check if an event has been canceled by\r\n * calling `canceled()`.\r\n * @abstract\r\n * @class AbstractEvent\r\n * @module AbstractEvent\r\n */\r\nclass AbstractEvent {\r\n\r\n  /**\r\n   * AbstractEvent constructor.\r\n   * @constructs AbstractEvent\r\n   * @param {object} data - Event data\r\n   */\r\n\r\n  /**\r\n   * Event type\r\n   * @static\r\n   * @abstract\r\n   * @property type\r\n   * @type {String}\r\n   */\r\n  constructor(data) {\r\n    this[canceled] = false;\r\n    this.data = data;\r\n  }\r\n\r\n  /**\r\n   * Read-only type\r\n   * @abstract\r\n   * @return {String}\r\n   */\r\n\r\n\r\n  /**\r\n   * Event cancelable\r\n   * @static\r\n   * @abstract\r\n   * @property cancelable\r\n   * @type {Boolean}\r\n   */\r\n  get type() {\r\n    return this.constructor.type;\r\n  }\r\n\r\n  /**\r\n   * Read-only cancelable\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  get cancelable() {\r\n    return this.constructor.cancelable;\r\n  }\r\n\r\n  /**\r\n   * Cancels the event instance\r\n   * @abstract\r\n   */\r\n  cancel() {\r\n    this[canceled] = true;\r\n  }\r\n\r\n  /**\r\n   * Check if event has been canceled\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  canceled() {\r\n    return Boolean(this[canceled]);\r\n  }\r\n\r\n  /**\r\n   * Returns new event instance with existing event data.\r\n   * This method allows for overriding of event data.\r\n   * @param {Object} data\r\n   * @return {AbstractEvent}\r\n   */\r\n  clone(data) {\r\n    return new this.constructor(_extends({}, this.data, data));\r\n  }\r\n}\r\nexports.default = AbstractEvent;\r\nAbstractEvent.type = 'event';\r\nAbstractEvent.cancelable = false;\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports, __nested_webpack_require_13024__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractEvent = __nested_webpack_require_13024__(4);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractEvent2.default;\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports, __nested_webpack_require_13450__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.SnapOutEvent = exports.SnapInEvent = exports.SnapEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_13450__(5);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base snap event\r\n * @class SnapEvent\r\n * @module SnapEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SnapEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Drag event that triggered this snap event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n\r\n  /**\r\n   * Snappable element\r\n   * @property snappable\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get snappable() {\r\n    return this.data.snappable;\r\n  }\r\n}\r\n\r\nexports.SnapEvent = SnapEvent; /**\r\n                                * Snap in event\r\n                                * @class SnapInEvent\r\n                                * @module SnapInEvent\r\n                                * @extends SnapEvent\r\n                                */\r\n\r\nSnapEvent.type = 'snap';\r\nclass SnapInEvent extends SnapEvent {}\r\n\r\nexports.SnapInEvent = SnapInEvent; /**\r\n                                    * Snap out event\r\n                                    * @class SnapOutEvent\r\n                                    * @module SnapOutEvent\r\n                                    * @extends SnapEvent\r\n                                    */\r\n\r\nSnapInEvent.type = 'snap:in';\r\nSnapInEvent.cancelable = true;\r\nclass SnapOutEvent extends SnapEvent {}\r\nexports.SnapOutEvent = SnapOutEvent;\r\nSnapOutEvent.type = 'snap:out';\r\nSnapOutEvent.cancelable = true;\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports, __nested_webpack_require_15296__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SnappableEvent = __nested_webpack_require_15296__(0);\r\n\r\nObject.keys(_SnappableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SnappableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Snappable = __nested_webpack_require_15296__(3);\r\n\r\nvar _Snappable2 = _interopRequireDefault(_Snappable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Snappable2.default;\r\n\r\n/***/ })\r\n/******/ ]);\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9wbHVnaW5zL3NuYXBwYWJsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNLEVBSzBCO0FBQ2hDLENBQUM7QUFDRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDhCQUFtQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZUFBZSw4QkFBbUI7QUFDbEMsbURBQW1ELCtCQUErQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0EsaUVBQWlFLGlCQUFpQjtBQUNsRjtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZ0NBQWdDLDhCQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUFtQjtBQUM5QixrREFBa0QsZ0NBQWdDO0FBQ2xGLDBFQUEwRSw4QkFBbUIsNEJBQTRCLG9CQUFvQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRSwwQ0FBMEM7QUFDMUMsV0FBVyw4QkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBbUIsQ0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCLGdDQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLGlCQUFpQixnQ0FBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9saWIvcGx1Z2lucy9zbmFwcGFibGUuanM/ZWUyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xyXG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxyXG5cdFx0ZGVmaW5lKFwiU25hcHBhYmxlXCIsIFtdLCBmYWN0b3J5KTtcclxuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcclxuXHRcdGV4cG9ydHNbXCJTbmFwcGFibGVcIl0gPSBmYWN0b3J5KCk7XHJcblx0ZWxzZVxyXG5cdFx0cm9vdFtcIlNuYXBwYWJsZVwiXSA9IGZhY3RvcnkoKTtcclxufSkod2luZG93LCBmdW5jdGlvbigpIHtcclxucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcclxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXHJcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxyXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcclxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxyXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xyXG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcclxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXHJcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XHJcbi8qKioqKiovIFx0XHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXHJcbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcclxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XHJcbi8qKioqKiovIFx0fVxyXG4vKioqKioqL1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XHJcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XHJcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcclxuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xyXG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcclxuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XHJcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcclxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcclxuLyoqKioqKi8gXHRcdHJldHVybiBucztcclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cclxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcclxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcclxuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcclxuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xyXG4vKioqKioqL1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xyXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDcpO1xyXG4vKioqKioqLyB9KVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKioqKioqLyAoW1xyXG4vKiAwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TbmFwcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG5PYmplY3Qua2V5cyhfU25hcHBhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfU25hcHBhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuLyoqXHJcbiAqIEFsbCBkcmFnZ2FibGUgcGx1Z2lucyBpbmhlcml0IGZyb20gdGhpcyBjbGFzcy5cclxuICogQGFic3RyYWN0XHJcbiAqIEBjbGFzcyBBYnN0cmFjdFBsdWdpblxyXG4gKiBAbW9kdWxlIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBBYnN0cmFjdFBsdWdpbiB7XHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3RQbHVnaW4gY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgQWJzdHJhY3RQbHVnaW5cclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAgICogQHByb3BlcnR5IGRyYWdnYWJsZVxyXG4gICAgICogQHR5cGUge0RyYWdnYWJsZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPdmVycmlkZSB0byBhZGQgbGlzdGVuZXJzXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRlIHRvIHJlbW92ZSBsaXN0ZW5lcnNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdFBsdWdpbjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG52YXIgX1NuYXBwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcclxuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xyXG5jb25zdCBvbkRyYWdPdmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyJyk7XHJcbmNvbnN0IG9uRHJhZ091dCA9IFN5bWJvbCgnb25EcmFnT3V0Jyk7XHJcbmNvbnN0IG9uTWlycm9yQ3JlYXRlZCA9IFN5bWJvbCgnb25NaXJyb3JDcmVhdGVkJyk7XHJcbmNvbnN0IG9uTWlycm9yRGVzdHJveSA9IFN5bWJvbCgnb25NaXJyb3JEZXN0cm95Jyk7XHJcblxyXG4vKipcclxuICogU25hcHBhYmxlIHBsdWdpbiB3aGljaCBzbmFwcyBkcmFnZ2FibGUgZWxlbWVudHMgaW50byBwbGFjZVxyXG4gKiBAY2xhc3MgU25hcHBhYmxlXHJcbiAqIEBtb2R1bGUgU25hcHBhYmxlXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBTbmFwcGFibGUgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIFNuYXBwYWJsZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBTbmFwcGFibGVcclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGZpcnN0IHNvdXJjZSBlbGVtZW50XHJcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fG51bGx9IGZpcnN0U291cmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZmlyc3RTb3VyY2UgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIG1pcnJvciBlbGVtZW50XHJcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBtaXJyb3JcclxuICAgICAqL1xyXG4gICAgdGhpcy5taXJyb3IgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ092ZXJdID0gdGhpc1tvbkRyYWdPdmVyXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdPdXRdID0gdGhpc1tvbkRyYWdPdXRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTWlycm9yQ3JlYXRlZF0gPSB0aGlzW29uTWlycm9yQ3JlYXRlZF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25NaXJyb3JEZXN0cm95XSA9IHRoaXNbb25NaXJyb3JEZXN0cm95XS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSkub24oJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcmFnOm91dCcsIHRoaXNbb25EcmFnT3V0XSkub24oJ2Ryb3BwYWJsZTpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub24oJ2Ryb3BwYWJsZTpvdXQnLCB0aGlzW29uRHJhZ091dF0pLm9uKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub24oJ21pcnJvcjpkZXN0cm95JywgdGhpc1tvbk1pcnJvckRlc3Ryb3ldKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSkub2ZmKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vZmYoJ2RyYWc6b3V0JywgdGhpc1tvbkRyYWdPdXRdKS5vZmYoJ2Ryb3BwYWJsZTpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub2ZmKCdkcm9wcGFibGU6b3V0JywgdGhpc1tvbkRyYWdPdXRdKS5vZmYoJ21pcnJvcjpjcmVhdGVkJywgdGhpc1tvbk1pcnJvckNyZWF0ZWRdKS5vZmYoJ21pcnJvcjpkZXN0cm95JywgdGhpc1tvbk1pcnJvckRlc3Ryb3ldKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RhcnRFdmVudH0gZXZlbnQgLSBEcmFnIHN0YXJ0IGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZmlyc3RTb3VyY2UgPSBldmVudC5zb3VyY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0b3AgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RvcEV2ZW50fSBldmVudCAtIERyYWcgc3RvcCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdG9wXSgpIHtcclxuICAgIHRoaXMuZmlyc3RTb3VyY2UgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBvdmVyIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ092ZXJFdmVudHxEcm9wcGFibGVPdmVyRXZlbnR9IGV2ZW50IC0gRHJhZyBvdmVyIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ092ZXJdKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc291cmNlID0gZXZlbnQuc291cmNlIHx8IGV2ZW50LmRyYWdFdmVudC5zb3VyY2U7XHJcblxyXG4gICAgaWYgKHNvdXJjZSA9PT0gdGhpcy5maXJzdFNvdXJjZSkge1xyXG4gICAgICB0aGlzLmZpcnN0U291cmNlID0gbnVsbDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNuYXBJbkV2ZW50ID0gbmV3IF9TbmFwcGFibGVFdmVudC5TbmFwSW5FdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIHNuYXBwYWJsZTogZXZlbnQub3ZlciB8fCBldmVudC5kcm9wcGFibGVcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIoc25hcEluRXZlbnQpO1xyXG5cclxuICAgIGlmIChzbmFwSW5FdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5taXJyb3IpIHtcclxuICAgICAgdGhpcy5taXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIH1cclxuXHJcbiAgICBzb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmRyYWdnYWJsZS5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6ZHJhZ2dpbmcnKSk7XHJcbiAgICBzb3VyY2UuY2xhc3NMaXN0LmFkZCguLi50aGlzLmRyYWdnYWJsZS5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xyXG5cclxuICAgIC8vIE5lZWQgdG8gY2FuY2VsIHRoaXMgaW4gZHJhZyBvdXRcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBzb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmRyYWdnYWJsZS5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xyXG4gICAgfSwgdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5wbGFjZWRUaW1lb3V0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgb3V0IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ091dEV2ZW50fERyb3BwYWJsZU91dEV2ZW50fSBldmVudCAtIERyYWcgb3V0IGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ091dF0oZXZlbnQpIHtcclxuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzb3VyY2UgPSBldmVudC5zb3VyY2UgfHwgZXZlbnQuZHJhZ0V2ZW50LnNvdXJjZTtcclxuXHJcbiAgICBjb25zdCBzbmFwT3V0RXZlbnQgPSBuZXcgX1NuYXBwYWJsZUV2ZW50LlNuYXBPdXRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIHNuYXBwYWJsZTogZXZlbnQub3ZlciB8fCBldmVudC5kcm9wcGFibGVcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIoc25hcE91dEV2ZW50KTtcclxuXHJcbiAgICBpZiAoc25hcE91dEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm1pcnJvcikge1xyXG4gICAgICB0aGlzLm1pcnJvci5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgc291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOmRyYWdnaW5nJykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlycm9yIGNyZWF0ZWQgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7TWlycm9yQ3JlYXRlZEV2ZW50fSBtaXJyb3JFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uTWlycm9yQ3JlYXRlZF0oeyBtaXJyb3IgfSkge1xyXG4gICAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNaXJyb3IgZGVzdHJveSBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtNaXJyb3JEZXN0cm95RXZlbnR9IG1pcnJvckV2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25NaXJyb3JEZXN0cm95XSgpIHtcclxuICAgIHRoaXMubWlycm9yID0gbnVsbDtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gU25hcHBhYmxlO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxuY29uc3QgY2FuY2VsZWQgPSBTeW1ib2woJ2NhbmNlbGVkJyk7XHJcblxyXG4vKipcclxuICogQWxsIGV2ZW50cyBmaXJlZCBieSBkcmFnZ2FibGUgaW5oZXJpdCB0aGlzIGNsYXNzLiBZb3UgY2FuIGNhbGwgYGNhbmNlbCgpYCB0b1xyXG4gKiBjYW5jZWwgYSBzcGVjaWZpYyBldmVudCBvciB5b3UgY2FuIGNoZWNrIGlmIGFuIGV2ZW50IGhhcyBiZWVuIGNhbmNlbGVkIGJ5XHJcbiAqIGNhbGxpbmcgYGNhbmNlbGVkKClgLlxyXG4gKiBAYWJzdHJhY3RcclxuICogQGNsYXNzIEFic3RyYWN0RXZlbnRcclxuICogQG1vZHVsZSBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBBYnN0cmFjdEV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3RFdmVudCBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBBYnN0cmFjdEV2ZW50XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBFdmVudCBkYXRhXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW50IHR5cGVcclxuICAgKiBAc3RhdGljXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHByb3BlcnR5IHR5cGVcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcclxuICAgIHRoaXNbY2FuY2VsZWRdID0gZmFsc2U7XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZC1vbmx5IHR5cGVcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBFdmVudCBjYW5jZWxhYmxlXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHR5cGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50eXBlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZC1vbmx5IGNhbmNlbGFibGVcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBjYW5jZWxhYmxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY2FuY2VsYWJsZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbmNlbHMgdGhlIGV2ZW50IGluc3RhbmNlXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcbiAgY2FuY2VsKCkge1xyXG4gICAgdGhpc1tjYW5jZWxlZF0gPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgZXZlbnQgaGFzIGJlZW4gY2FuY2VsZWRcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGNhbmNlbGVkKCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4odGhpc1tjYW5jZWxlZF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBuZXcgZXZlbnQgaW5zdGFuY2Ugd2l0aCBleGlzdGluZyBldmVudCBkYXRhLlxyXG4gICAqIFRoaXMgbWV0aG9kIGFsbG93cyBmb3Igb3ZlcnJpZGluZyBvZiBldmVudCBkYXRhLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcbiAgICogQHJldHVybiB7QWJzdHJhY3RFdmVudH1cclxuICAgKi9cclxuICBjbG9uZShkYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoX2V4dGVuZHMoe30sIHRoaXMuZGF0YSwgZGF0YSkpO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdEV2ZW50O1xyXG5BYnN0cmFjdEV2ZW50LnR5cGUgPSAnZXZlbnQnO1xyXG5BYnN0cmFjdEV2ZW50LmNhbmNlbGFibGUgPSBmYWxzZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLlNuYXBPdXRFdmVudCA9IGV4cG9ydHMuU25hcEluRXZlbnQgPSBleHBvcnRzLlNuYXBFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2Ugc25hcCBldmVudFxyXG4gKiBAY2xhc3MgU25hcEV2ZW50XHJcbiAqIEBtb2R1bGUgU25hcEV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIFNuYXBFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIHNuYXAgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgZHJhZ0V2ZW50XHJcbiAgICogQHR5cGUge0RyYWdFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ0V2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTbmFwcGFibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBzbmFwcGFibGVcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNuYXBwYWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc25hcHBhYmxlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5TbmFwRXZlbnQgPSBTbmFwRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU25hcCBpbiBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFNuYXBJbkV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNuYXBJbkV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTbmFwRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuU25hcEV2ZW50LnR5cGUgPSAnc25hcCc7XHJcbmNsYXNzIFNuYXBJbkV2ZW50IGV4dGVuZHMgU25hcEV2ZW50IHt9XHJcblxyXG5leHBvcnRzLlNuYXBJbkV2ZW50ID0gU25hcEluRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNuYXAgb3V0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFNuYXBPdXRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU25hcE91dEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU25hcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5TbmFwSW5FdmVudC50eXBlID0gJ3NuYXA6aW4nO1xyXG5TbmFwSW5FdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgU25hcE91dEV2ZW50IGV4dGVuZHMgU25hcEV2ZW50IHt9XHJcbmV4cG9ydHMuU25hcE91dEV2ZW50ID0gU25hcE91dEV2ZW50O1xyXG5TbmFwT3V0RXZlbnQudHlwZSA9ICdzbmFwOm91dCc7XHJcblNuYXBPdXRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TbmFwcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG5PYmplY3Qua2V5cyhfU25hcHBhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfU25hcHBhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX1NuYXBwYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG52YXIgX1NuYXBwYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TbmFwcGFibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9TbmFwcGFibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KVxyXG4vKioqKioqLyBdKTtcclxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@shopify/draggable/lib/plugins/snappable.js\n");

/***/ }),

/***/ "./node_modules/@shopify/draggable/lib/plugins/swap-animation.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@shopify/draggable/lib/plugins/swap-animation.js ***!
  \***********************************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(true)\r\n\t\tmodule.exports = factory();\r\n\telse {}\r\n})(window, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __nested_webpack_require_583__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId]) {\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_583__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__nested_webpack_require_583__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__nested_webpack_require_583__.c = installedModules;\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__nested_webpack_require_583__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__nested_webpack_require_583__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// define __esModule on exports\r\n/******/ \t__nested_webpack_require_583__.r = function(exports) {\r\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\r\n/******/ \t\t}\r\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\r\n/******/ \t};\r\n/******/\r\n/******/ \t// create a fake namespace object\r\n/******/ \t// mode & 1: value is a module id, require it\r\n/******/ \t// mode & 2: merge all properties of value into the ns\r\n/******/ \t// mode & 4: return value when already ns object\r\n/******/ \t// mode & 8|1: behave like require\r\n/******/ \t__nested_webpack_require_583__.t = function(value, mode) {\r\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_583__(value);\r\n/******/ \t\tif(mode & 8) return value;\r\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\r\n/******/ \t\tvar ns = Object.create(null);\r\n/******/ \t\t__nested_webpack_require_583__.r(ns);\r\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\r\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_583__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\r\n/******/ \t\treturn ns;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__nested_webpack_require_583__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__nested_webpack_require_583__.d(getter, 'a', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__nested_webpack_require_583__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__nested_webpack_require_583__.p = \"\";\r\n/******/\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __nested_webpack_require_583__(__nested_webpack_require_583__.s = 3);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * All draggable plugins inherit from this class.\r\n * @abstract\r\n * @class AbstractPlugin\r\n * @module AbstractPlugin\r\n */\r\nclass AbstractPlugin {\r\n  /**\r\n   * AbstractPlugin constructor.\r\n   * @constructs AbstractPlugin\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    /**\r\n     * Draggable instance\r\n     * @property draggable\r\n     * @type {Draggable}\r\n     */\r\n    this.draggable = draggable;\r\n  }\r\n\r\n  /**\r\n   * Override to add listeners\r\n   * @abstract\r\n   */\r\n  attach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n\r\n  /**\r\n   * Override to remove listeners\r\n   * @abstract\r\n   */\r\n  detach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n}\r\nexports.default = AbstractPlugin;\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports, __nested_webpack_require_5041__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_5041__(0);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractPlugin2.default;\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports, __nested_webpack_require_5471__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_5471__(1);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onSortableSorted = Symbol('onSortableSorted');\r\n\r\n/**\r\n * SwapAnimation default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.duration\r\n * @property {String} defaultOptions.easingFunction\r\n * @property {Boolean} defaultOptions.horizontal\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  duration: 150,\r\n  easingFunction: 'ease-in-out',\r\n  horizontal: false\r\n};\r\n\r\n/**\r\n * SwapAnimation plugin adds swap animations for sortable\r\n * @class SwapAnimation\r\n * @module SwapAnimation\r\n * @extends AbstractPlugin\r\n */\r\nclass SwapAnimation extends _AbstractPlugin2.default {\r\n  /**\r\n   * SwapAnimation constructor.\r\n   * @constructs SwapAnimation\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * SwapAnimation options\r\n     * @property {Object} options\r\n     * @property {Number} defaultOptions.duration\r\n     * @property {String} defaultOptions.easingFunction\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Last animation frame\r\n     * @property {Number} lastAnimationFrame\r\n     * @type {Number}\r\n     */\r\n    this.lastAnimationFrame = null;\r\n\r\n    this[onSortableSorted] = this[onSortableSorted].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('sortable:sorted', this[onSortableSorted]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('sortable:sorted', this[onSortableSorted]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.swapAnimation || {};\r\n  }\r\n\r\n  /**\r\n   * Sortable sorted handler\r\n   * @param {SortableSortedEvent} sortableEvent\r\n   * @private\r\n   */\r\n  [onSortableSorted]({ oldIndex, newIndex, dragEvent }) {\r\n    const { source, over } = dragEvent;\r\n\r\n    cancelAnimationFrame(this.lastAnimationFrame);\r\n\r\n    // Can be done in a separate frame\r\n    this.lastAnimationFrame = requestAnimationFrame(() => {\r\n      if (oldIndex >= newIndex) {\r\n        animate(source, over, this.options);\r\n      } else {\r\n        animate(over, source, this.options);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexports.default = SwapAnimation; /**\r\n                                  * Animates two elements\r\n                                  * @param {HTMLElement} from\r\n                                  * @param {HTMLElement} to\r\n                                  * @param {Object} options\r\n                                  * @param {Number} options.duration\r\n                                  * @param {String} options.easingFunction\r\n                                  * @param {String} options.horizontal\r\n                                  * @private\r\n                                  */\r\n\r\nfunction animate(from, to, { duration, easingFunction, horizontal }) {\r\n  for (const element of [from, to]) {\r\n    element.style.pointerEvents = 'none';\r\n  }\r\n\r\n  if (horizontal) {\r\n    const width = from.offsetWidth;\r\n    from.style.transform = `translate3d(${width}px, 0, 0)`;\r\n    to.style.transform = `translate3d(-${width}px, 0, 0)`;\r\n  } else {\r\n    const height = from.offsetHeight;\r\n    from.style.transform = `translate3d(0, ${height}px, 0)`;\r\n    to.style.transform = `translate3d(0, -${height}px, 0)`;\r\n  }\r\n\r\n  requestAnimationFrame(() => {\r\n    for (const element of [from, to]) {\r\n      element.addEventListener('transitionend', resetElementOnTransitionEnd);\r\n      element.style.transition = `transform ${duration}ms ${easingFunction}`;\r\n      element.style.transform = '';\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Resets animation style properties after animation has completed\r\n * @param {Event} event\r\n * @private\r\n */\r\nfunction resetElementOnTransitionEnd(event) {\r\n  event.target.style.transition = '';\r\n  event.target.style.pointerEvents = '';\r\n  event.target.removeEventListener('transitionend', resetElementOnTransitionEnd);\r\n}\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports, __nested_webpack_require_10204__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _SwapAnimation = __nested_webpack_require_10204__(2);\r\n\r\nvar _SwapAnimation2 = _interopRequireDefault(_SwapAnimation);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _SwapAnimation2.default;\r\nexports.defaultOptions = _SwapAnimation.defaultOptions;\r\n\r\n/***/ })\r\n/******/ ]);\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9wbHVnaW5zL3N3YXAtYW5pbWF0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLOEI7QUFDcEMsQ0FBQztBQUNELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsOEJBQW1CO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixlQUFlLDhCQUFtQjtBQUNsQyxtREFBbUQsK0JBQStCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQSxpRUFBaUUsaUJBQWlCO0FBQ2xGO0FBQ0EsMERBQTBELGFBQWE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixnQ0FBZ0MsOEJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQW1CO0FBQzlCLGtEQUFrRCxnQ0FBZ0M7QUFDbEYsMEVBQTBFLDhCQUFtQiw0QkFBNEIsb0JBQW9CO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFLDBDQUEwQztBQUMxQyxXQUFXLDhCQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhCQUFt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QSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHFCQUFxQixnQ0FBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9wbHVnaW5zL3N3YXAtYW5pbWF0aW9uLmpzPzAzNzYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuXHRcdGRlZmluZShcIlN3YXBBbmltYXRpb25cIiwgW10sIGZhY3RvcnkpO1xyXG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxyXG5cdFx0ZXhwb3J0c1tcIlN3YXBBbmltYXRpb25cIl0gPSBmYWN0b3J5KCk7XHJcblx0ZWxzZVxyXG5cdFx0cm9vdFtcIlN3YXBBbmltYXRpb25cIl0gPSBmYWN0b3J5KCk7XHJcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XHJcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXHJcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcclxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XHJcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcclxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcclxuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXHJcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxyXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxyXG4vKioqKioqLyBcdFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXHJcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxyXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG4vKioqKioqLyBcdH1cclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xyXG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XHJcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcclxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XHJcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xyXG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XHJcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcclxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAzKTtcclxuLyoqKioqKi8gfSlcclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyoqKioqKi8gKFtcclxuLyogMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuLyoqXHJcbiAqIEFsbCBkcmFnZ2FibGUgcGx1Z2lucyBpbmhlcml0IGZyb20gdGhpcyBjbGFzcy5cclxuICogQGFic3RyYWN0XHJcbiAqIEBjbGFzcyBBYnN0cmFjdFBsdWdpblxyXG4gKiBAbW9kdWxlIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBBYnN0cmFjdFBsdWdpbiB7XHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3RQbHVnaW4gY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgQWJzdHJhY3RQbHVnaW5cclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAgICogQHByb3BlcnR5IGRyYWdnYWJsZVxyXG4gICAgICogQHR5cGUge0RyYWdnYWJsZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPdmVycmlkZSB0byBhZGQgbGlzdGVuZXJzXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRlIHRvIHJlbW92ZSBsaXN0ZW5lcnNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdFBsdWdpbjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uU29ydGFibGVTb3J0ZWQgPSBTeW1ib2woJ29uU29ydGFibGVTb3J0ZWQnKTtcclxuXHJcbi8qKlxyXG4gKiBTd2FwQW5pbWF0aW9uIGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLmR1cmF0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZWZhdWx0T3B0aW9ucy5lYXNpbmdGdW5jdGlvblxyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRlZmF1bHRPcHRpb25zLmhvcml6b250YWxcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcclxuICBkdXJhdGlvbjogMTUwLFxyXG4gIGVhc2luZ0Z1bmN0aW9uOiAnZWFzZS1pbi1vdXQnLFxyXG4gIGhvcml6b250YWw6IGZhbHNlXHJcbn07XHJcblxyXG4vKipcclxuICogU3dhcEFuaW1hdGlvbiBwbHVnaW4gYWRkcyBzd2FwIGFuaW1hdGlvbnMgZm9yIHNvcnRhYmxlXHJcbiAqIEBjbGFzcyBTd2FwQW5pbWF0aW9uXHJcbiAqIEBtb2R1bGUgU3dhcEFuaW1hdGlvblxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgU3dhcEFuaW1hdGlvbiBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogU3dhcEFuaW1hdGlvbiBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBTd2FwQW5pbWF0aW9uXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN3YXBBbmltYXRpb24gb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWZhdWx0T3B0aW9ucy5kdXJhdGlvblxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGRlZmF1bHRPcHRpb25zLmVhc2luZ0Z1bmN0aW9uXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIHRoaXMuZ2V0T3B0aW9ucygpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExhc3QgYW5pbWF0aW9uIGZyYW1lXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbGFzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxhc3RBbmltYXRpb25GcmFtZSA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvblNvcnRhYmxlU29ydGVkXSA9IHRoaXNbb25Tb3J0YWJsZVNvcnRlZF0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ3NvcnRhYmxlOnNvcnRlZCcsIHRoaXNbb25Tb3J0YWJsZVNvcnRlZF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ3NvcnRhYmxlOnNvcnRlZCcsIHRoaXNbb25Tb3J0YWJsZVNvcnRlZF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBvcHRpb25zIHBhc3NlZCB0aHJvdWdoIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuc3dhcEFuaW1hdGlvbiB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNvcnRhYmxlIHNvcnRlZCBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtTb3J0YWJsZVNvcnRlZEV2ZW50fSBzb3J0YWJsZUV2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25Tb3J0YWJsZVNvcnRlZF0oeyBvbGRJbmRleCwgbmV3SW5kZXgsIGRyYWdFdmVudCB9KSB7XHJcbiAgICBjb25zdCB7IHNvdXJjZSwgb3ZlciB9ID0gZHJhZ0V2ZW50O1xyXG5cclxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lKTtcclxuXHJcbiAgICAvLyBDYW4gYmUgZG9uZSBpbiBhIHNlcGFyYXRlIGZyYW1lXHJcbiAgICB0aGlzLmxhc3RBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIGlmIChvbGRJbmRleCA+PSBuZXdJbmRleCkge1xyXG4gICAgICAgIGFuaW1hdGUoc291cmNlLCBvdmVyLCB0aGlzLm9wdGlvbnMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFuaW1hdGUob3Zlciwgc291cmNlLCB0aGlzLm9wdGlvbnMpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IFN3YXBBbmltYXRpb247IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBBbmltYXRlcyB0d28gZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZnJvbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kdXJhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5lYXNpbmdGdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5ob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuZnVuY3Rpb24gYW5pbWF0ZShmcm9tLCB0bywgeyBkdXJhdGlvbiwgZWFzaW5nRnVuY3Rpb24sIGhvcml6b250YWwgfSkge1xyXG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBbZnJvbSwgdG9dKSB7XHJcbiAgICBlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcbiAgfVxyXG5cclxuICBpZiAoaG9yaXpvbnRhbCkge1xyXG4gICAgY29uc3Qgd2lkdGggPSBmcm9tLm9mZnNldFdpZHRoO1xyXG4gICAgZnJvbS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt3aWR0aH1weCwgMCwgMClgO1xyXG4gICAgdG8uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKC0ke3dpZHRofXB4LCAwLCAwKWA7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IGhlaWdodCA9IGZyb20ub2Zmc2V0SGVpZ2h0O1xyXG4gICAgZnJvbS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoMCwgJHtoZWlnaHR9cHgsIDApYDtcclxuICAgIHRvLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgwLCAtJHtoZWlnaHR9cHgsIDApYDtcclxuICB9XHJcblxyXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgW2Zyb20sIHRvXSkge1xyXG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQpO1xyXG4gICAgICBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb24gPSBgdHJhbnNmb3JtICR7ZHVyYXRpb259bXMgJHtlYXNpbmdGdW5jdGlvbn1gO1xyXG4gICAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmVzZXRzIGFuaW1hdGlvbiBzdHlsZSBwcm9wZXJ0aWVzIGFmdGVyIGFuaW1hdGlvbiBoYXMgY29tcGxldGVkXHJcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQoZXZlbnQpIHtcclxuICBldmVudC50YXJnZXQuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xyXG4gIGV2ZW50LnRhcmdldC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XHJcbiAgZXZlbnQudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfU3dhcEFuaW1hdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG52YXIgX1N3YXBBbmltYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3dhcEFuaW1hdGlvbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX1N3YXBBbmltYXRpb24yLmRlZmF1bHQ7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfU3dhcEFuaW1hdGlvbi5kZWZhdWx0T3B0aW9ucztcclxuXHJcbi8qKiovIH0pXHJcbi8qKioqKiovIF0pO1xyXG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@shopify/draggable/lib/plugins/swap-animation.js\n");

/***/ }),

/***/ "./node_modules/@shopify/draggable/lib/sortable.js":
/*!*********************************************************!*\
  !*** ./node_modules/@shopify/draggable/lib/sortable.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(true)\r\n\t\tmodule.exports = factory();\r\n\telse {}\r\n})(window, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __nested_webpack_require_568__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId]) {\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_568__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__nested_webpack_require_568__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__nested_webpack_require_568__.c = installedModules;\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__nested_webpack_require_568__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__nested_webpack_require_568__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// define __esModule on exports\r\n/******/ \t__nested_webpack_require_568__.r = function(exports) {\r\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\r\n/******/ \t\t}\r\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\r\n/******/ \t};\r\n/******/\r\n/******/ \t// create a fake namespace object\r\n/******/ \t// mode & 1: value is a module id, require it\r\n/******/ \t// mode & 2: merge all properties of value into the ns\r\n/******/ \t// mode & 4: return value when already ns object\r\n/******/ \t// mode & 8|1: behave like require\r\n/******/ \t__nested_webpack_require_568__.t = function(value, mode) {\r\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_568__(value);\r\n/******/ \t\tif(mode & 8) return value;\r\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\r\n/******/ \t\tvar ns = Object.create(null);\r\n/******/ \t\t__nested_webpack_require_568__.r(ns);\r\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\r\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_568__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\r\n/******/ \t\treturn ns;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__nested_webpack_require_568__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__nested_webpack_require_568__.d(getter, 'a', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__nested_webpack_require_568__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__nested_webpack_require_568__.p = \"\";\r\n/******/\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __nested_webpack_require_568__(__nested_webpack_require_568__.s = 48);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __nested_webpack_require_4116__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SensorEvent = __nested_webpack_require_4116__(19);\r\n\r\nObject.keys(_SensorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SensorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports, __nested_webpack_require_4583__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_4583__(22);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Sensor2.default;\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports, __nested_webpack_require_4982__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_4982__(30);\r\n\r\nObject.defineProperty(exports, 'closest', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_closest).default;\r\n  }\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_4982__(28);\r\n\r\nObject.defineProperty(exports, 'requestNextAnimationFrame', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_requestNextAnimationFrame).default;\r\n  }\r\n});\r\n\r\nvar _distance = __nested_webpack_require_4982__(26);\r\n\r\nObject.defineProperty(exports, 'distance', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_distance).default;\r\n  }\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_4982__(24);\r\n\r\nObject.defineProperty(exports, 'touchCoords', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_touchCoords).default;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports, __nested_webpack_require_6106__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractEvent = __nested_webpack_require_6106__(46);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractEvent2.default;\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports, __nested_webpack_require_6533__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_6533__(39);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractPlugin2.default;\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports, __nested_webpack_require_6964__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_6964__(1);\r\n\r\nObject.defineProperty(exports, 'Sensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Sensor).default;\r\n  }\r\n});\r\n\r\nvar _MouseSensor = __nested_webpack_require_6964__(21);\r\n\r\nObject.defineProperty(exports, 'MouseSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_MouseSensor).default;\r\n  }\r\n});\r\n\r\nvar _TouchSensor = __nested_webpack_require_6964__(18);\r\n\r\nObject.defineProperty(exports, 'TouchSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_TouchSensor).default;\r\n  }\r\n});\r\n\r\nvar _DragSensor = __nested_webpack_require_6964__(16);\r\n\r\nObject.defineProperty(exports, 'DragSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_DragSensor).default;\r\n  }\r\n});\r\n\r\nvar _ForceTouchSensor = __nested_webpack_require_6964__(14);\r\n\r\nObject.defineProperty(exports, 'ForceTouchSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_ForceTouchSensor).default;\r\n  }\r\n});\r\n\r\nvar _SensorEvent = __nested_webpack_require_6964__(0);\r\n\r\nObject.keys(_SensorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SensorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports, __nested_webpack_require_8570__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Announcement = __nested_webpack_require_8570__(41);\r\n\r\nObject.defineProperty(exports, 'Announcement', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Announcement).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultAnnouncementOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Announcement.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Focusable = __nested_webpack_require_8570__(38);\r\n\r\nObject.defineProperty(exports, 'Focusable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Focusable).default;\r\n  }\r\n});\r\n\r\nvar _Mirror = __nested_webpack_require_8570__(36);\r\n\r\nObject.defineProperty(exports, 'Mirror', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Mirror).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultMirrorOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Mirror.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Scrollable = __nested_webpack_require_8570__(32);\r\n\r\nObject.defineProperty(exports, 'Scrollable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Scrollable).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultScrollableOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Scrollable.defaultOptions;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports, __nested_webpack_require_10113__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DraggableEvent = __nested_webpack_require_10113__(42);\r\n\r\nObject.keys(_DraggableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DraggableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ (function(module, exports, __nested_webpack_require_10589__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragEvent = __nested_webpack_require_10589__(43);\r\n\r\nObject.keys(_DragEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DragEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ (function(module, exports, __nested_webpack_require_11050__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SortableEvent = __nested_webpack_require_11050__(47);\r\n\r\nObject.keys(_SortableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SortableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * The Emitter is a simple emitter class that provides you with `on()`, `off()` and `trigger()` methods\r\n * @class Emitter\r\n * @module Emitter\r\n */\r\nclass Emitter {\r\n  constructor() {\r\n    this.callbacks = {};\r\n  }\r\n\r\n  /**\r\n   * Registers callbacks by event name\r\n   * @param {String} type\r\n   * @param {...Function} callbacks\r\n   */\r\n  on(type, ...callbacks) {\r\n    if (!this.callbacks[type]) {\r\n      this.callbacks[type] = [];\r\n    }\r\n\r\n    this.callbacks[type].push(...callbacks);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Unregisters callbacks by event name\r\n   * @param {String} type\r\n   * @param {Function} callback\r\n   */\r\n  off(type, callback) {\r\n    if (!this.callbacks[type]) {\r\n      return null;\r\n    }\r\n\r\n    const copy = this.callbacks[type].slice(0);\r\n\r\n    for (let i = 0; i < copy.length; i++) {\r\n      if (callback === copy[i]) {\r\n        this.callbacks[type].splice(i, 1);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Triggers event callbacks by event object\r\n   * @param {AbstractEvent} event\r\n   */\r\n  trigger(event) {\r\n    if (!this.callbacks[event.type]) {\r\n      return null;\r\n    }\r\n\r\n    const callbacks = [...this.callbacks[event.type]];\r\n    const caughtErrors = [];\r\n\r\n    for (let i = callbacks.length - 1; i >= 0; i--) {\r\n      const callback = callbacks[i];\r\n\r\n      try {\r\n        callback(event);\r\n      } catch (error) {\r\n        caughtErrors.push(error);\r\n      }\r\n    }\r\n\r\n    if (caughtErrors.length) {\r\n      /* eslint-disable no-console */\r\n      console.error(`Draggable caught errors while triggering '${event.type}'`, caughtErrors);\r\n      /* eslint-disable no-console */\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\nexports.default = Emitter;\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ (function(module, exports, __nested_webpack_require_13388__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Emitter = __nested_webpack_require_13388__(10);\r\n\r\nvar _Emitter2 = _interopRequireDefault(_Emitter);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Emitter2.default;\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ (function(module, exports, __nested_webpack_require_13792__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _utils = __nested_webpack_require_13792__(2);\r\n\r\nvar _Plugins = __nested_webpack_require_13792__(6);\r\n\r\nvar _Emitter = __nested_webpack_require_13792__(11);\r\n\r\nvar _Emitter2 = _interopRequireDefault(_Emitter);\r\n\r\nvar _Sensors = __nested_webpack_require_13792__(5);\r\n\r\nvar _DraggableEvent = __nested_webpack_require_13792__(7);\r\n\r\nvar _DragEvent = __nested_webpack_require_13792__(8);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragMove = Symbol('onDragMove');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst onDragPressure = Symbol('onDragPressure');\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['drag:start']\r\n * @const {Function} defaultAnnouncements['drag:stop']\r\n */\r\nconst defaultAnnouncements = {\r\n  'drag:start': event => `Picked up ${event.source.textContent.trim() || event.source.id || 'draggable element'}`,\r\n  'drag:stop': event => `Released ${event.source.textContent.trim() || event.source.id || 'draggable element'}`\r\n};\r\n\r\nconst defaultClasses = {\r\n  'container:dragging': 'draggable-container--is-dragging',\r\n  'source:dragging': 'draggable-source--is-dragging',\r\n  'source:placed': 'draggable-source--placed',\r\n  'container:placed': 'draggable-container--placed',\r\n  'body:dragging': 'draggable--is-dragging',\r\n  'draggable:over': 'draggable--over',\r\n  'container:over': 'draggable-container--over',\r\n  'source:original': 'draggable--original',\r\n  mirror: 'draggable-mirror'\r\n};\r\n\r\nconst defaultOptions = exports.defaultOptions = {\r\n  draggable: '.draggable-source',\r\n  handle: null,\r\n  delay: {},\r\n  distance: 0,\r\n  placedTimeout: 800,\r\n  plugins: [],\r\n  sensors: [],\r\n  exclude: {\r\n    plugins: [],\r\n    sensors: []\r\n  }\r\n};\r\n\r\n/**\r\n * This is the core draggable library that does the heavy lifting\r\n * @class Draggable\r\n * @module Draggable\r\n */\r\nclass Draggable {\r\n\r\n  /**\r\n   * Draggable constructor.\r\n   * @constructs Draggable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Draggable containers\r\n   * @param {Object} options - Options for draggable\r\n   */\r\n\r\n  /**\r\n   * Default plugins draggable uses\r\n   * @static\r\n   * @property {Object} Plugins\r\n   * @property {Announcement} Plugins.Announcement\r\n   * @property {Focusable} Plugins.Focusable\r\n   * @property {Mirror} Plugins.Mirror\r\n   * @property {Scrollable} Plugins.Scrollable\r\n   * @type {Object}\r\n   */\r\n  constructor(containers = [document.body], options = {}) {\r\n    /**\r\n     * Draggable containers\r\n     * @property containers\r\n     * @type {HTMLElement[]}\r\n     */\r\n    if (containers instanceof NodeList || containers instanceof Array) {\r\n      this.containers = [...containers];\r\n    } else if (containers instanceof HTMLElement) {\r\n      this.containers = [containers];\r\n    } else {\r\n      throw new Error('Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`');\r\n    }\r\n\r\n    this.options = _extends({}, defaultOptions, options, {\r\n      classes: _extends({}, defaultClasses, options.classes || {}),\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {}),\r\n      exclude: {\r\n        plugins: options.exclude && options.exclude.plugins || [],\r\n        sensors: options.exclude && options.exclude.sensors || []\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Draggables event emitter\r\n     * @property emitter\r\n     * @type {Emitter}\r\n     */\r\n    this.emitter = new _Emitter2.default();\r\n\r\n    /**\r\n     * Current drag state\r\n     * @property dragging\r\n     * @type {Boolean}\r\n     */\r\n    this.dragging = false;\r\n\r\n    /**\r\n     * Active plugins\r\n     * @property plugins\r\n     * @type {Plugin[]}\r\n     */\r\n    this.plugins = [];\r\n\r\n    /**\r\n     * Active sensors\r\n     * @property sensors\r\n     * @type {Sensor[]}\r\n     */\r\n    this.sensors = [];\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onDragPressure] = this[onDragPressure].bind(this);\r\n\r\n    document.addEventListener('drag:start', this[onDragStart], true);\r\n    document.addEventListener('drag:move', this[onDragMove], true);\r\n    document.addEventListener('drag:stop', this[onDragStop], true);\r\n    document.addEventListener('drag:pressure', this[onDragPressure], true);\r\n\r\n    const defaultPlugins = Object.values(Draggable.Plugins).filter(Plugin => !this.options.exclude.plugins.includes(Plugin));\r\n    const defaultSensors = Object.values(Draggable.Sensors).filter(sensor => !this.options.exclude.sensors.includes(sensor));\r\n\r\n    this.addPlugin(...[...defaultPlugins, ...this.options.plugins]);\r\n    this.addSensor(...[...defaultSensors, ...this.options.sensors]);\r\n\r\n    const draggableInitializedEvent = new _DraggableEvent.DraggableInitializedEvent({\r\n      draggable: this\r\n    });\r\n\r\n    this.on('mirror:created', ({ mirror }) => this.mirror = mirror);\r\n    this.on('mirror:destroy', () => this.mirror = null);\r\n\r\n    this.trigger(draggableInitializedEvent);\r\n  }\r\n\r\n  /**\r\n   * Destroys Draggable instance. This removes all internal event listeners and\r\n   * deactivates sensors and plugins\r\n   */\r\n\r\n\r\n  /**\r\n   * Default sensors draggable uses\r\n   * @static\r\n   * @property {Object} Sensors\r\n   * @property {MouseSensor} Sensors.MouseSensor\r\n   * @property {TouchSensor} Sensors.TouchSensor\r\n   * @type {Object}\r\n   */\r\n  destroy() {\r\n    document.removeEventListener('drag:start', this[onDragStart], true);\r\n    document.removeEventListener('drag:move', this[onDragMove], true);\r\n    document.removeEventListener('drag:stop', this[onDragStop], true);\r\n    document.removeEventListener('drag:pressure', this[onDragPressure], true);\r\n\r\n    const draggableDestroyEvent = new _DraggableEvent.DraggableDestroyEvent({\r\n      draggable: this\r\n    });\r\n\r\n    this.trigger(draggableDestroyEvent);\r\n\r\n    this.removePlugin(...this.plugins.map(plugin => plugin.constructor));\r\n    this.removeSensor(...this.sensors.map(sensor => sensor.constructor));\r\n  }\r\n\r\n  /**\r\n   * Adds plugin to this draggable instance. This will end up calling the attach method of the plugin\r\n   * @param {...typeof Plugin} plugins - Plugins that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addPlugin(CustomA11yPlugin, CustomMirrorPlugin)\r\n   */\r\n  addPlugin(...plugins) {\r\n    const activePlugins = plugins.map(Plugin => new Plugin(this));\r\n\r\n    activePlugins.forEach(plugin => plugin.attach());\r\n    this.plugins = [...this.plugins, ...activePlugins];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes plugins that are already attached to this draggable instance. This will end up calling\r\n   * the detach method of the plugin\r\n   * @param {...typeof Plugin} plugins - Plugins that you want detached from draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removePlugin(MirrorPlugin, CustomMirrorPlugin)\r\n   */\r\n  removePlugin(...plugins) {\r\n    const removedPlugins = this.plugins.filter(plugin => plugins.includes(plugin.constructor));\r\n\r\n    removedPlugins.forEach(plugin => plugin.detach());\r\n    this.plugins = this.plugins.filter(plugin => !plugins.includes(plugin.constructor));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds sensors to this draggable instance. This will end up calling the attach method of the sensor\r\n   * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addSensor(ForceTouchSensor, CustomSensor)\r\n   */\r\n  addSensor(...sensors) {\r\n    const activeSensors = sensors.map(Sensor => new Sensor(this.containers, this.options));\r\n\r\n    activeSensors.forEach(sensor => sensor.attach());\r\n    this.sensors = [...this.sensors, ...activeSensors];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes sensors that are already attached to this draggable instance. This will end up calling\r\n   * the detach method of the sensor\r\n   * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removeSensor(TouchSensor, DragSensor)\r\n   */\r\n  removeSensor(...sensors) {\r\n    const removedSensors = this.sensors.filter(sensor => sensors.includes(sensor.constructor));\r\n\r\n    removedSensors.forEach(sensor => sensor.detach());\r\n    this.sensors = this.sensors.filter(sensor => !sensors.includes(sensor.constructor));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds container to this draggable instance\r\n   * @param {...HTMLElement} containers - Containers you want to add to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addContainer(document.body)\r\n   */\r\n  addContainer(...containers) {\r\n    this.containers = [...this.containers, ...containers];\r\n    this.sensors.forEach(sensor => sensor.addContainer(...containers));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes container from this draggable instance\r\n   * @param {...HTMLElement} containers - Containers you want to remove from draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removeContainer(document.body)\r\n   */\r\n  removeContainer(...containers) {\r\n    this.containers = this.containers.filter(container => !containers.includes(container));\r\n    this.sensors.forEach(sensor => sensor.removeContainer(...containers));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds listener for draggable events\r\n   * @param {String} type - Event name\r\n   * @param {...Function} callbacks - Event callbacks\r\n   * @return {Draggable}\r\n   * @example draggable.on('drag:start', (dragEvent) => dragEvent.cancel());\r\n   */\r\n  on(type, ...callbacks) {\r\n    this.emitter.on(type, ...callbacks);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes listener from draggable\r\n   * @param {String} type - Event name\r\n   * @param {Function} callback - Event callback\r\n   * @return {Draggable}\r\n   * @example draggable.off('drag:start', handlerFunction);\r\n   */\r\n  off(type, callback) {\r\n    this.emitter.off(type, callback);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Triggers draggable event\r\n   * @param {AbstractEvent} event - Event instance\r\n   * @return {Draggable}\r\n   * @example draggable.trigger(event);\r\n   */\r\n  trigger(event) {\r\n    this.emitter.trigger(event);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns class name for class identifier\r\n   * @param {String} name - Name of class identifier\r\n   * @return {String|null}\r\n   */\r\n  getClassNameFor(name) {\r\n    return this.getClassNamesFor(name)[0];\r\n  }\r\n\r\n  /**\r\n   * Returns class names for class identifier\r\n   * @return {String[]}\r\n   */\r\n  getClassNamesFor(name) {\r\n    const classNames = this.options.classes[name];\r\n\r\n    if (classNames instanceof Array) {\r\n      return classNames;\r\n    } else if (typeof classNames === 'string' || classNames instanceof String) {\r\n      return [classNames];\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if this draggable instance is currently dragging\r\n   * @return {Boolean}\r\n   */\r\n  isDragging() {\r\n    return Boolean(this.dragging);\r\n  }\r\n\r\n  /**\r\n   * Returns all draggable elements\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getDraggableElements() {\r\n    return this.containers.reduce((current, container) => {\r\n      return [...current, ...this.getDraggableElementsForContainer(container)];\r\n    }, []);\r\n  }\r\n\r\n  /**\r\n   * Returns draggable elements for a given container, excluding the mirror and\r\n   * original source element if present\r\n   * @param {HTMLElement} container\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getDraggableElementsForContainer(container) {\r\n    const allDraggableElements = container.querySelectorAll(this.options.draggable);\r\n\r\n    return [...allDraggableElements].filter(childElement => {\r\n      return childElement !== this.originalSource && childElement !== this.mirror;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragStart](event) {\r\n    const sensorEvent = getSensorEvent(event);\r\n    const { target, container } = sensorEvent;\r\n\r\n    if (!this.containers.includes(container)) {\r\n      return;\r\n    }\r\n\r\n    if (this.options.handle && target && !(0, _utils.closest)(target, this.options.handle)) {\r\n      sensorEvent.cancel();\r\n      return;\r\n    }\r\n\r\n    // Find draggable source element\r\n    this.originalSource = (0, _utils.closest)(target, this.options.draggable);\r\n    this.sourceContainer = container;\r\n\r\n    if (!this.originalSource) {\r\n      sensorEvent.cancel();\r\n      return;\r\n    }\r\n\r\n    if (this.lastPlacedSource && this.lastPlacedContainer) {\r\n      clearTimeout(this.placedTimeoutID);\r\n      this.lastPlacedSource.classList.remove(...this.getClassNamesFor('source:placed'));\r\n      this.lastPlacedContainer.classList.remove(...this.getClassNamesFor('container:placed'));\r\n    }\r\n\r\n    this.source = this.originalSource.cloneNode(true);\r\n    this.originalSource.parentNode.insertBefore(this.source, this.originalSource);\r\n    this.originalSource.style.display = 'none';\r\n\r\n    const dragEvent = new _DragEvent.DragStartEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sourceContainer: container,\r\n      sensorEvent\r\n    });\r\n\r\n    this.trigger(dragEvent);\r\n\r\n    this.dragging = !dragEvent.canceled();\r\n\r\n    if (dragEvent.canceled()) {\r\n      this.source.parentNode.removeChild(this.source);\r\n      this.originalSource.style.display = null;\r\n      return;\r\n    }\r\n\r\n    this.originalSource.classList.add(...this.getClassNamesFor('source:original'));\r\n    this.source.classList.add(...this.getClassNamesFor('source:dragging'));\r\n    this.sourceContainer.classList.add(...this.getClassNamesFor('container:dragging'));\r\n    document.body.classList.add(...this.getClassNamesFor('body:dragging'));\r\n    applyUserSelect(document.body, 'none');\r\n\r\n    requestAnimationFrame(() => {\r\n      const oldSensorEvent = getSensorEvent(event);\r\n      const newSensorEvent = oldSensorEvent.clone({ target: this.source });\r\n\r\n      this[onDragMove](_extends({}, event, {\r\n        detail: newSensorEvent\r\n      }));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag move handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = getSensorEvent(event);\r\n    const { container } = sensorEvent;\r\n    let target = sensorEvent.target;\r\n\r\n    const dragMoveEvent = new _DragEvent.DragMoveEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sourceContainer: container,\r\n      sensorEvent\r\n    });\r\n\r\n    this.trigger(dragMoveEvent);\r\n\r\n    if (dragMoveEvent.canceled()) {\r\n      sensorEvent.cancel();\r\n    }\r\n\r\n    target = (0, _utils.closest)(target, this.options.draggable);\r\n    const withinCorrectContainer = (0, _utils.closest)(sensorEvent.target, this.containers);\r\n    const overContainer = sensorEvent.overContainer || withinCorrectContainer;\r\n    const isLeavingContainer = this.currentOverContainer && overContainer !== this.currentOverContainer;\r\n    const isLeavingDraggable = this.currentOver && target !== this.currentOver;\r\n    const isOverContainer = overContainer && this.currentOverContainer !== overContainer;\r\n    const isOverDraggable = withinCorrectContainer && target && this.currentOver !== target;\r\n\r\n    if (isLeavingDraggable) {\r\n      const dragOutEvent = new _DragEvent.DragOutEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        over: this.currentOver,\r\n        overContainer: this.currentOverContainer\r\n      });\r\n\r\n      this.currentOver.classList.remove(...this.getClassNamesFor('draggable:over'));\r\n      this.currentOver = null;\r\n\r\n      this.trigger(dragOutEvent);\r\n    }\r\n\r\n    if (isLeavingContainer) {\r\n      const dragOutContainerEvent = new _DragEvent.DragOutContainerEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer: this.currentOverContainer\r\n      });\r\n\r\n      this.currentOverContainer.classList.remove(...this.getClassNamesFor('container:over'));\r\n      this.currentOverContainer = null;\r\n\r\n      this.trigger(dragOutContainerEvent);\r\n    }\r\n\r\n    if (isOverContainer) {\r\n      overContainer.classList.add(...this.getClassNamesFor('container:over'));\r\n\r\n      const dragOverContainerEvent = new _DragEvent.DragOverContainerEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer\r\n      });\r\n\r\n      this.currentOverContainer = overContainer;\r\n\r\n      this.trigger(dragOverContainerEvent);\r\n    }\r\n\r\n    if (isOverDraggable) {\r\n      target.classList.add(...this.getClassNamesFor('draggable:over'));\r\n\r\n      const dragOverEvent = new _DragEvent.DragOverEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer,\r\n        over: target\r\n      });\r\n\r\n      this.currentOver = target;\r\n\r\n      this.trigger(dragOverEvent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragStop](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    this.dragging = false;\r\n\r\n    const dragStopEvent = new _DragEvent.DragStopEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sensorEvent: event.sensorEvent,\r\n      sourceContainer: this.sourceContainer\r\n    });\r\n\r\n    this.trigger(dragStopEvent);\r\n\r\n    this.source.parentNode.insertBefore(this.originalSource, this.source);\r\n    this.source.parentNode.removeChild(this.source);\r\n    this.originalSource.style.display = '';\r\n\r\n    this.source.classList.remove(...this.getClassNamesFor('source:dragging'));\r\n    this.originalSource.classList.remove(...this.getClassNamesFor('source:original'));\r\n    this.originalSource.classList.add(...this.getClassNamesFor('source:placed'));\r\n    this.sourceContainer.classList.add(...this.getClassNamesFor('container:placed'));\r\n    this.sourceContainer.classList.remove(...this.getClassNamesFor('container:dragging'));\r\n    document.body.classList.remove(...this.getClassNamesFor('body:dragging'));\r\n    applyUserSelect(document.body, '');\r\n\r\n    if (this.currentOver) {\r\n      this.currentOver.classList.remove(...this.getClassNamesFor('draggable:over'));\r\n    }\r\n\r\n    if (this.currentOverContainer) {\r\n      this.currentOverContainer.classList.remove(...this.getClassNamesFor('container:over'));\r\n    }\r\n\r\n    this.lastPlacedSource = this.originalSource;\r\n    this.lastPlacedContainer = this.sourceContainer;\r\n\r\n    this.placedTimeoutID = setTimeout(() => {\r\n      if (this.lastPlacedSource) {\r\n        this.lastPlacedSource.classList.remove(...this.getClassNamesFor('source:placed'));\r\n      }\r\n\r\n      if (this.lastPlacedContainer) {\r\n        this.lastPlacedContainer.classList.remove(...this.getClassNamesFor('container:placed'));\r\n      }\r\n\r\n      this.lastPlacedSource = null;\r\n      this.lastPlacedContainer = null;\r\n    }, this.options.placedTimeout);\r\n\r\n    const dragStoppedEvent = new _DragEvent.DragStoppedEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sensorEvent: event.sensorEvent,\r\n      sourceContainer: this.sourceContainer\r\n    });\r\n\r\n    this.trigger(dragStoppedEvent);\r\n\r\n    this.source = null;\r\n    this.originalSource = null;\r\n    this.currentOverContainer = null;\r\n    this.currentOver = null;\r\n    this.sourceContainer = null;\r\n  }\r\n\r\n  /**\r\n   * Drag pressure handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragPressure](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = getSensorEvent(event);\r\n    const source = this.source || (0, _utils.closest)(sensorEvent.originalEvent.target, this.options.draggable);\r\n\r\n    const dragPressureEvent = new _DragEvent.DragPressureEvent({\r\n      sensorEvent,\r\n      source,\r\n      pressure: sensorEvent.pressure\r\n    });\r\n\r\n    this.trigger(dragPressureEvent);\r\n  }\r\n}\r\n\r\nexports.default = Draggable;\r\nDraggable.Plugins = { Announcement: _Plugins.Announcement, Focusable: _Plugins.Focusable, Mirror: _Plugins.Mirror, Scrollable: _Plugins.Scrollable };\r\nDraggable.Sensors = { MouseSensor: _Sensors.MouseSensor, TouchSensor: _Sensors.TouchSensor };\r\nfunction getSensorEvent(event) {\r\n  return event.detail;\r\n}\r\n\r\nfunction applyUserSelect(element, value) {\r\n  element.style.webkitUserSelect = value;\r\n  element.style.mozUserSelect = value;\r\n  element.style.msUserSelect = value;\r\n  element.style.oUserSelect = value;\r\n  element.style.userSelect = value;\r\n}\r\n\r\n/***/ }),\r\n/* 13 */\r\n/***/ (function(module, exports, __nested_webpack_require_34925__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_34925__(1);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_34925__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMouseForceWillBegin = Symbol('onMouseForceWillBegin');\r\nconst onMouseForceDown = Symbol('onMouseForceDown');\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseForceChange = Symbol('onMouseForceChange');\r\nconst onMouseMove = Symbol('onMouseMove');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst onMouseForceGlobalChange = Symbol('onMouseForceGlobalChange');\r\n\r\n/**\r\n * This sensor picks up native force touch events and dictates drag operations\r\n * @class ForceTouchSensor\r\n * @module ForceTouchSensor\r\n * @extends Sensor\r\n */\r\nclass ForceTouchSensor extends _Sensor2.default {\r\n  /**\r\n   * ForceTouchSensor constructor.\r\n   * @constructs ForceTouchSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed\r\n     * @property mightDrag\r\n     * @type {Boolean}\r\n     */\r\n    this.mightDrag = false;\r\n\r\n    this[onMouseForceWillBegin] = this[onMouseForceWillBegin].bind(this);\r\n    this[onMouseForceDown] = this[onMouseForceDown].bind(this);\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseForceChange] = this[onMouseForceChange].bind(this);\r\n    this[onMouseMove] = this[onMouseMove].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    for (const container of this.containers) {\r\n      container.addEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\r\n      container.addEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\r\n      container.addEventListener('mousedown', this[onMouseDown], true);\r\n      container.addEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\r\n    }\r\n\r\n    document.addEventListener('mousemove', this[onMouseMove]);\r\n    document.addEventListener('mouseup', this[onMouseUp]);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    for (const container of this.containers) {\r\n      container.removeEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\r\n      container.removeEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\r\n      container.removeEventListener('mousedown', this[onMouseDown], true);\r\n      container.removeEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\r\n    }\r\n\r\n    document.removeEventListener('mousemove', this[onMouseMove]);\r\n    document.removeEventListener('mouseup', this[onMouseUp]);\r\n  }\r\n\r\n  /**\r\n   * Mouse force will begin handler\r\n   * @private\r\n   * @param {Event} event - Mouse force will begin event\r\n   */\r\n  [onMouseForceWillBegin](event) {\r\n    event.preventDefault();\r\n    this.mightDrag = true;\r\n  }\r\n\r\n  /**\r\n   * Mouse force down handler\r\n   * @private\r\n   * @param {Event} event - Mouse force down event\r\n   */\r\n  [onMouseForceDown](event) {\r\n    if (this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = event.currentTarget;\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragStartEvent);\r\n\r\n    this.currentContainer = container;\r\n    this.dragging = !dragStartEvent.canceled();\r\n    this.mightDrag = false;\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target: null,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.mightDrag = false;\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    if (!this.mightDrag) {\r\n      return;\r\n    }\r\n\r\n    // Need workaround for real click\r\n    // Cancel potential drag events\r\n    event.stopPropagation();\r\n    event.stopImmediatePropagation();\r\n    event.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler\r\n   * @private\r\n   * @param {Event} event - Mouse force will begin event\r\n   */\r\n  [onMouseMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse force change handler\r\n   * @private\r\n   * @param {Event} event - Mouse force change event\r\n   */\r\n  [onMouseForceChange](event) {\r\n    if (this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = event.target;\r\n    const container = event.currentTarget;\r\n\r\n    const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({\r\n      pressure: event.webkitForce,\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragPressureEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse force global change handler\r\n   * @private\r\n   * @param {Event} event - Mouse force global change event\r\n   */\r\n  [onMouseForceGlobalChange](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = event.target;\r\n\r\n    const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({\r\n      pressure: event.webkitForce,\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragPressureEvent);\r\n  }\r\n}\r\nexports.default = ForceTouchSensor;\r\n\r\n/***/ }),\r\n/* 14 */\r\n/***/ (function(module, exports, __nested_webpack_require_41665__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _ForceTouchSensor = __nested_webpack_require_41665__(13);\r\n\r\nvar _ForceTouchSensor2 = _interopRequireDefault(_ForceTouchSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _ForceTouchSensor2.default;\r\n\r\n/***/ }),\r\n/* 15 */\r\n/***/ (function(module, exports, __nested_webpack_require_42105__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_42105__(2);\r\n\r\nvar _Sensor = __nested_webpack_require_42105__(1);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_42105__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragEnd = Symbol('onDragEnd');\r\nconst onDrop = Symbol('onDrop');\r\nconst reset = Symbol('reset');\r\n\r\n/**\r\n * This sensor picks up native browser drag events and dictates drag operations\r\n * @class DragSensor\r\n * @module DragSensor\r\n * @extends Sensor\r\n */\r\nclass DragSensor extends _Sensor2.default {\r\n  /**\r\n   * DragSensor constructor.\r\n   * @constructs DragSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Mouse down timer which will end up setting the draggable attribute, unless canceled\r\n     * @property mouseDownTimeout\r\n     * @type {Number}\r\n     */\r\n    this.mouseDownTimeout = null;\r\n\r\n    /**\r\n     * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed\r\n     * @property draggableElement\r\n     * @type {HTMLElement}\r\n     */\r\n    this.draggableElement = null;\r\n\r\n    /**\r\n     * Native draggable element could be links or images, their draggable state will be disabled during drag operation\r\n     * @property nativeDraggableElement\r\n     * @type {HTMLElement}\r\n     */\r\n    this.nativeDraggableElement = null;\r\n\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragEnd] = this[onDragEnd].bind(this);\r\n    this[onDrop] = this[onDrop].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {Event} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    // Need for firefox. \"text\" key is needed for IE\r\n    event.dataTransfer.setData('text', '');\r\n    event.dataTransfer.effectAllowed = this.options.type;\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    this.currentContainer = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!this.currentContainer) {\r\n      return;\r\n    }\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    // Workaround\r\n    setTimeout(() => {\r\n      this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n      if (dragStartEvent.canceled()) {\r\n        this.dragging = false;\r\n      } else {\r\n        this.dragging = true;\r\n      }\r\n    }, 0);\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {Event} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = this.currentContainer;\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragMoveEvent);\r\n\r\n    if (!dragMoveEvent.canceled()) {\r\n      event.preventDefault();\r\n      event.dataTransfer.dropEffect = this.options.type;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag end handler\r\n   * @private\r\n   * @param {Event} event - Drag end event\r\n   */\r\n  [onDragEnd](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp], true);\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = this.currentContainer;\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragStopEvent);\r\n\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n\r\n    this[reset]();\r\n  }\r\n\r\n  /**\r\n   * Drop handler\r\n   * @private\r\n   * @param {Event} event - Drop event\r\n   */\r\n  [onDrop](event) {\r\n    // eslint-disable-line class-methods-use-this\r\n    event.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    // Firefox bug for inputs within draggables https://bugzilla.mozilla.org/show_bug.cgi?id=739071\r\n    if (event.target && (event.target.form || event.target.contenteditable)) {\r\n      return;\r\n    }\r\n\r\n    const nativeDraggableElement = (0, _utils.closest)(event.target, element => element.draggable);\r\n\r\n    if (nativeDraggableElement) {\r\n      nativeDraggableElement.draggable = false;\r\n      this.nativeDraggableElement = nativeDraggableElement;\r\n    }\r\n\r\n    document.addEventListener('mouseup', this[onMouseUp], true);\r\n    document.addEventListener('dragstart', this[onDragStart], false);\r\n    document.addEventListener('dragover', this[onDragOver], false);\r\n    document.addEventListener('dragend', this[onDragEnd], false);\r\n    document.addEventListener('drop', this[onDrop], false);\r\n\r\n    const target = (0, _utils.closest)(event.target, this.options.draggable);\r\n\r\n    if (!target) {\r\n      return;\r\n    }\r\n\r\n    this.startEvent = event;\r\n\r\n    this.mouseDownTimeout = setTimeout(() => {\r\n      target.draggable = true;\r\n      this.draggableElement = target;\r\n    }, this.delay.drag);\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp]() {\r\n    this[reset]();\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [reset]() {\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp], true);\r\n    document.removeEventListener('dragstart', this[onDragStart], false);\r\n    document.removeEventListener('dragover', this[onDragOver], false);\r\n    document.removeEventListener('dragend', this[onDragEnd], false);\r\n    document.removeEventListener('drop', this[onDrop], false);\r\n\r\n    if (this.nativeDraggableElement) {\r\n      this.nativeDraggableElement.draggable = true;\r\n      this.nativeDraggableElement = null;\r\n    }\r\n\r\n    if (this.draggableElement) {\r\n      this.draggableElement.draggable = false;\r\n      this.draggableElement = null;\r\n    }\r\n  }\r\n}\r\nexports.default = DragSensor;\r\n\r\n/***/ }),\r\n/* 16 */\r\n/***/ (function(module, exports, __nested_webpack_require_49378__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragSensor = __nested_webpack_require_49378__(15);\r\n\r\nvar _DragSensor2 = _interopRequireDefault(_DragSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _DragSensor2.default;\r\n\r\n/***/ }),\r\n/* 17 */\r\n/***/ (function(module, exports, __nested_webpack_require_49794__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_49794__(2);\r\n\r\nvar _Sensor = __nested_webpack_require_49794__(1);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_49794__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onTouchStart = Symbol('onTouchStart');\r\nconst onTouchEnd = Symbol('onTouchEnd');\r\nconst onTouchMove = Symbol('onTouchMove');\r\nconst startDrag = Symbol('startDrag');\r\nconst onDistanceChange = Symbol('onDistanceChange');\r\n\r\n/**\r\n * Prevents scrolling when set to true\r\n * @var {Boolean} preventScrolling\r\n */\r\nlet preventScrolling = false;\r\n\r\n// WebKit requires cancelable `touchmove` events to be added as early as possible\r\nwindow.addEventListener('touchmove', event => {\r\n  if (!preventScrolling) {\r\n    return;\r\n  }\r\n\r\n  // Prevent scrolling\r\n  event.preventDefault();\r\n}, { passive: false });\r\n\r\n/**\r\n * This sensor picks up native browser touch events and dictates drag operations\r\n * @class TouchSensor\r\n * @module TouchSensor\r\n * @extends Sensor\r\n */\r\nclass TouchSensor extends _Sensor2.default {\r\n  /**\r\n   * TouchSensor constructor.\r\n   * @constructs TouchSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Closest scrollable container so accidental scroll can cancel long touch\r\n     * @property currentScrollableParent\r\n     * @type {HTMLElement}\r\n     */\r\n    this.currentScrollableParent = null;\r\n\r\n    /**\r\n     * TimeoutID for managing delay\r\n     * @property tapTimeout\r\n     * @type {Number}\r\n     */\r\n    this.tapTimeout = null;\r\n\r\n    /**\r\n     * touchMoved indicates if touch has moved during tapTimeout\r\n     * @property touchMoved\r\n     * @type {Boolean}\r\n     */\r\n    this.touchMoved = false;\r\n\r\n    /**\r\n     * Save pageX coordinates for delay drag\r\n     * @property {Numbre} pageX\r\n     * @private\r\n     */\r\n    this.pageX = null;\r\n\r\n    /**\r\n     * Save pageY coordinates for delay drag\r\n     * @property {Numbre} pageY\r\n     * @private\r\n     */\r\n    this.pageY = null;\r\n\r\n    this[onTouchStart] = this[onTouchStart].bind(this);\r\n    this[onTouchEnd] = this[onTouchEnd].bind(this);\r\n    this[onTouchMove] = this[onTouchMove].bind(this);\r\n    this[startDrag] = this[startDrag].bind(this);\r\n    this[onDistanceChange] = this[onDistanceChange].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('touchstart', this[onTouchStart]);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('touchstart', this[onTouchStart]);\r\n  }\r\n\r\n  /**\r\n   * Touch start handler\r\n   * @private\r\n   * @param {Event} event - Touch start event\r\n   */\r\n  [onTouchStart](event) {\r\n    const container = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!container) {\r\n      return;\r\n    }\r\n    const { distance = 0 } = this.options;\r\n    const { delay } = this;\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n    this.onTouchStartAt = Date.now();\r\n    this.startEvent = event;\r\n    this.currentContainer = container;\r\n\r\n    document.addEventListener('touchend', this[onTouchEnd]);\r\n    document.addEventListener('touchcancel', this[onTouchEnd]);\r\n    document.addEventListener('touchmove', this[onDistanceChange]);\r\n    container.addEventListener('contextmenu', onContextMenu);\r\n\r\n    if (distance) {\r\n      preventScrolling = true;\r\n    }\r\n\r\n    this.tapTimeout = window.setTimeout(() => {\r\n      this[onDistanceChange]({ touches: [{ pageX: this.pageX, pageY: this.pageY }] });\r\n    }, delay.touch);\r\n  }\r\n\r\n  /**\r\n   * Start the drag\r\n   * @private\r\n   */\r\n  [startDrag]() {\r\n    const startEvent = this.startEvent;\r\n    const container = this.currentContainer;\r\n    const touch = (0, _utils.touchCoords)(startEvent);\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: touch.pageX,\r\n      clientY: touch.pageY,\r\n      target: startEvent.target,\r\n      container,\r\n      originalEvent: startEvent\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n    this.dragging = !dragStartEvent.canceled();\r\n\r\n    if (this.dragging) {\r\n      document.addEventListener('touchmove', this[onTouchMove]);\r\n    }\r\n    preventScrolling = this.dragging;\r\n  }\r\n\r\n  /**\r\n   * Touch move handler prior to drag start.\r\n   * @private\r\n   * @param {Event} event - Touch move event\r\n   */\r\n  [onDistanceChange](event) {\r\n    const { distance } = this.options;\r\n    const { startEvent, delay } = this;\r\n    const start = (0, _utils.touchCoords)(startEvent);\r\n    const current = (0, _utils.touchCoords)(event);\r\n    const timeElapsed = Date.now() - this.onTouchStartAt;\r\n    const distanceTravelled = (0, _utils.distance)(start.pageX, start.pageY, current.pageX, current.pageY);\r\n\r\n    Object.assign(this, current);\r\n\r\n    clearTimeout(this.tapTimeout);\r\n\r\n    if (timeElapsed < delay.touch) {\r\n      // moved during delay\r\n      document.removeEventListener('touchmove', this[onDistanceChange]);\r\n    } else if (distanceTravelled >= distance) {\r\n      document.removeEventListener('touchmove', this[onDistanceChange]);\r\n      this[startDrag]();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler while dragging\r\n   * @private\r\n   * @param {Event} event - Touch move event\r\n   */\r\n  [onTouchMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n    const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: pageX,\r\n      clientY: pageY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Touch end handler\r\n   * @private\r\n   * @param {Event} event - Touch end event\r\n   */\r\n  [onTouchEnd](event) {\r\n    clearTimeout(this.tapTimeout);\r\n    preventScrolling = false;\r\n\r\n    document.removeEventListener('touchend', this[onTouchEnd]);\r\n    document.removeEventListener('touchcancel', this[onTouchEnd]);\r\n    document.removeEventListener('touchmove', this[onDistanceChange]);\r\n\r\n    if (this.currentContainer) {\r\n      this.currentContainer.removeEventListener('contextmenu', onContextMenu);\r\n    }\r\n\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('touchmove', this[onTouchMove]);\r\n\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n    const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);\r\n\r\n    event.preventDefault();\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: pageX,\r\n      clientY: pageY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n  }\r\n}\r\n\r\nexports.default = TouchSensor;\r\nfunction onContextMenu(event) {\r\n  event.preventDefault();\r\n  event.stopPropagation();\r\n}\r\n\r\n/***/ }),\r\n/* 18 */\r\n/***/ (function(module, exports, __nested_webpack_require_57274__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _TouchSensor = __nested_webpack_require_57274__(17);\r\n\r\nvar _TouchSensor2 = _interopRequireDefault(_TouchSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _TouchSensor2.default;\r\n\r\n/***/ }),\r\n/* 19 */\r\n/***/ (function(module, exports, __nested_webpack_require_57694__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DragPressureSensorEvent = exports.DragStopSensorEvent = exports.DragMoveSensorEvent = exports.DragStartSensorEvent = exports.SensorEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_57694__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base sensor event\r\n * @class SensorEvent\r\n * @module SensorEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SensorEvent extends _AbstractEvent2.default {\r\n  /**\r\n   * Original browser event that triggered a sensor\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    return this.data.originalEvent;\r\n  }\r\n\r\n  /**\r\n   * Normalized clientX for both touch and mouse events\r\n   * @property clientX\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get clientX() {\r\n    return this.data.clientX;\r\n  }\r\n\r\n  /**\r\n   * Normalized clientY for both touch and mouse events\r\n   * @property clientY\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get clientY() {\r\n    return this.data.clientY;\r\n  }\r\n\r\n  /**\r\n   * Normalized target for both touch and mouse events\r\n   * Returns the element that is behind cursor or touch pointer\r\n   * @property target\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get target() {\r\n    return this.data.target;\r\n  }\r\n\r\n  /**\r\n   * Container that initiated the sensor\r\n   * @property container\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get container() {\r\n    return this.data.container;\r\n  }\r\n\r\n  /**\r\n   * Trackpad pressure\r\n   * @property pressure\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get pressure() {\r\n    return this.data.pressure;\r\n  }\r\n}\r\n\r\nexports.SensorEvent = SensorEvent; /**\r\n                                    * Drag start sensor event\r\n                                    * @class DragStartSensorEvent\r\n                                    * @module DragStartSensorEvent\r\n                                    * @extends SensorEvent\r\n                                    */\r\n\r\nclass DragStartSensorEvent extends SensorEvent {}\r\n\r\nexports.DragStartSensorEvent = DragStartSensorEvent; /**\r\n                                                      * Drag move sensor event\r\n                                                      * @class DragMoveSensorEvent\r\n                                                      * @module DragMoveSensorEvent\r\n                                                      * @extends SensorEvent\r\n                                                      */\r\n\r\nDragStartSensorEvent.type = 'drag:start';\r\nclass DragMoveSensorEvent extends SensorEvent {}\r\n\r\nexports.DragMoveSensorEvent = DragMoveSensorEvent; /**\r\n                                                    * Drag stop sensor event\r\n                                                    * @class DragStopSensorEvent\r\n                                                    * @module DragStopSensorEvent\r\n                                                    * @extends SensorEvent\r\n                                                    */\r\n\r\nDragMoveSensorEvent.type = 'drag:move';\r\nclass DragStopSensorEvent extends SensorEvent {}\r\n\r\nexports.DragStopSensorEvent = DragStopSensorEvent; /**\r\n                                                    * Drag pressure sensor event\r\n                                                    * @class DragPressureSensorEvent\r\n                                                    * @module DragPressureSensorEvent\r\n                                                    * @extends SensorEvent\r\n                                                    */\r\n\r\nDragStopSensorEvent.type = 'drag:stop';\r\nclass DragPressureSensorEvent extends SensorEvent {}\r\nexports.DragPressureSensorEvent = DragPressureSensorEvent;\r\nDragPressureSensorEvent.type = 'drag:pressure';\r\n\r\n/***/ }),\r\n/* 20 */\r\n/***/ (function(module, exports, __nested_webpack_require_61685__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_61685__(2);\r\n\r\nvar _Sensor = __nested_webpack_require_61685__(1);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_61685__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onContextMenuWhileDragging = Symbol('onContextMenuWhileDragging');\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseMove = Symbol('onMouseMove');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst startDrag = Symbol('startDrag');\r\nconst onDistanceChange = Symbol('onDistanceChange');\r\n\r\n/**\r\n * This sensor picks up native browser mouse events and dictates drag operations\r\n * @class MouseSensor\r\n * @module MouseSensor\r\n * @extends Sensor\r\n */\r\nclass MouseSensor extends _Sensor2.default {\r\n  /**\r\n   * MouseSensor constructor.\r\n   * @constructs MouseSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Mouse down timer which will end up triggering the drag start operation\r\n     * @property mouseDownTimeout\r\n     * @type {Number}\r\n     */\r\n    this.mouseDownTimeout = null;\r\n\r\n    /**\r\n     * Save pageX coordinates for delay drag\r\n     * @property {Numbre} pageX\r\n     * @private\r\n     */\r\n    this.pageX = null;\r\n\r\n    /**\r\n     * Save pageY coordinates for delay drag\r\n     * @property {Numbre} pageY\r\n     * @private\r\n     */\r\n    this.pageY = null;\r\n\r\n    this[onContextMenuWhileDragging] = this[onContextMenuWhileDragging].bind(this);\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseMove] = this[onMouseMove].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n    this[startDrag] = this[startDrag].bind(this);\r\n    this[onDistanceChange] = this[onDistanceChange].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    if (event.button !== 0 || event.ctrlKey || event.metaKey) {\r\n      return;\r\n    }\r\n    const container = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!container) {\r\n      return;\r\n    }\r\n\r\n    const { delay } = this;\r\n    const { pageX, pageY } = event;\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n    this.onMouseDownAt = Date.now();\r\n    this.startEvent = event;\r\n\r\n    this.currentContainer = container;\r\n    document.addEventListener('mouseup', this[onMouseUp]);\r\n    document.addEventListener('dragstart', preventNativeDragStart);\r\n    document.addEventListener('mousemove', this[onDistanceChange]);\r\n\r\n    this.mouseDownTimeout = window.setTimeout(() => {\r\n      this[onDistanceChange]({ pageX: this.pageX, pageY: this.pageY });\r\n    }, delay.mouse);\r\n  }\r\n\r\n  /**\r\n   * Start the drag\r\n   * @private\r\n   */\r\n  [startDrag]() {\r\n    const startEvent = this.startEvent;\r\n    const container = this.currentContainer;\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: startEvent.clientX,\r\n      clientY: startEvent.clientY,\r\n      target: startEvent.target,\r\n      container,\r\n      originalEvent: startEvent\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n    this.dragging = !dragStartEvent.canceled();\r\n\r\n    if (this.dragging) {\r\n      document.addEventListener('contextmenu', this[onContextMenuWhileDragging], true);\r\n      document.addEventListener('mousemove', this[onMouseMove]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect change in distance, starting drag when both\r\n   * delay and distance requirements are met\r\n   * @private\r\n   * @param {Event} event - Mouse move event\r\n   */\r\n  [onDistanceChange](event) {\r\n    const { pageX, pageY } = event;\r\n    const { distance } = this.options;\r\n    const { startEvent, delay } = this;\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n\r\n    if (!this.currentContainer) {\r\n      return;\r\n    }\r\n\r\n    const timeElapsed = Date.now() - this.onMouseDownAt;\r\n    const distanceTravelled = (0, _utils.distance)(startEvent.pageX, startEvent.pageY, pageX, pageY) || 0;\r\n\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    if (timeElapsed < delay.mouse) {\r\n      // moved during delay\r\n      document.removeEventListener('mousemove', this[onDistanceChange]);\r\n    } else if (distanceTravelled >= distance) {\r\n      document.removeEventListener('mousemove', this[onDistanceChange]);\r\n      this[startDrag]();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler\r\n   * @private\r\n   * @param {Event} event - Mouse move event\r\n   */\r\n  [onMouseMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp](event) {\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    if (event.button !== 0) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp]);\r\n    document.removeEventListener('dragstart', preventNativeDragStart);\r\n    document.removeEventListener('mousemove', this[onDistanceChange]);\r\n\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    document.removeEventListener('contextmenu', this[onContextMenuWhileDragging], true);\r\n    document.removeEventListener('mousemove', this[onMouseMove]);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n  }\r\n\r\n  /**\r\n   * Context menu handler\r\n   * @private\r\n   * @param {Event} event - Context menu event\r\n   */\r\n  [onContextMenuWhileDragging](event) {\r\n    event.preventDefault();\r\n  }\r\n}\r\n\r\nexports.default = MouseSensor;\r\nfunction preventNativeDragStart(event) {\r\n  event.preventDefault();\r\n}\r\n\r\n/***/ }),\r\n/* 21 */\r\n/***/ (function(module, exports, __nested_webpack_require_68557__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _MouseSensor = __nested_webpack_require_68557__(20);\r\n\r\nvar _MouseSensor2 = _interopRequireDefault(_MouseSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _MouseSensor2.default;\r\n\r\n/***/ }),\r\n/* 22 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst defaultDealy = {\r\n  mouse: 0,\r\n  drag: 0,\r\n  touch: 100\r\n};\r\n\r\n/**\r\n * Base sensor class. Extend from this class to create a new or custom sensor\r\n * @class Sensor\r\n * @module Sensor\r\n */\r\nclass Sensor {\r\n  /**\r\n   * Sensor constructor.\r\n   * @constructs Sensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    /**\r\n     * Current containers\r\n     * @property containers\r\n     * @type {HTMLElement[]}\r\n     */\r\n    this.containers = [...containers];\r\n\r\n    /**\r\n     * Current options\r\n     * @property options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, options);\r\n\r\n    /**\r\n     * Current drag state\r\n     * @property dragging\r\n     * @type {Boolean}\r\n     */\r\n    this.dragging = false;\r\n\r\n    /**\r\n     * Current container\r\n     * @property currentContainer\r\n     * @type {HTMLElement}\r\n     */\r\n    this.currentContainer = null;\r\n\r\n    /**\r\n     * The event of the initial sensor down\r\n     * @property startEvent\r\n     * @type {Event}\r\n     */\r\n    this.startEvent = null;\r\n\r\n    /**\r\n     * The delay of each sensor\r\n     * @property delay\r\n     * @type {Object}\r\n     */\r\n    this.delay = calcDelay(options.delay);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   * @return {Sensor}\r\n   */\r\n  attach() {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   * @return {Sensor}\r\n   */\r\n  detach() {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds container to this sensor instance\r\n   * @param {...HTMLElement} containers - Containers you want to add to this sensor\r\n   * @example draggable.addContainer(document.body)\r\n   */\r\n  addContainer(...containers) {\r\n    this.containers = [...this.containers, ...containers];\r\n  }\r\n\r\n  /**\r\n   * Removes container from this sensor instance\r\n   * @param {...HTMLElement} containers - Containers you want to remove from this sensor\r\n   * @example draggable.removeContainer(document.body)\r\n   */\r\n  removeContainer(...containers) {\r\n    this.containers = this.containers.filter(container => !containers.includes(container));\r\n  }\r\n\r\n  /**\r\n   * Triggers event on target element\r\n   * @param {HTMLElement} element - Element to trigger event on\r\n   * @param {SensorEvent} sensorEvent - Sensor event to trigger\r\n   */\r\n  trigger(element, sensorEvent) {\r\n    const event = document.createEvent('Event');\r\n    event.detail = sensorEvent;\r\n    event.initEvent(sensorEvent.type, true, true);\r\n    element.dispatchEvent(event);\r\n    this.lastEvent = sensorEvent;\r\n\r\n    return sensorEvent;\r\n  }\r\n}\r\n\r\nexports.default = Sensor; /**\r\n                           * Calculate the delay of each sensor through the delay in the options\r\n                           * @param {undefined|Number|Object} optionsDelay - the delay in the options\r\n                           * @return {Object}\r\n                           */\r\n\r\nfunction calcDelay(optionsDelay) {\r\n  const delay = {};\r\n\r\n  if (optionsDelay === undefined) {\r\n    return _extends({}, defaultDealy);\r\n  }\r\n\r\n  if (typeof optionsDelay === 'number') {\r\n    for (const key in defaultDealy) {\r\n      if (defaultDealy.hasOwnProperty(key)) {\r\n        delay[key] = optionsDelay;\r\n      }\r\n    }\r\n    return delay;\r\n  }\r\n\r\n  for (const key in defaultDealy) {\r\n    if (defaultDealy.hasOwnProperty(key)) {\r\n      if (optionsDelay[key] === undefined) {\r\n        delay[key] = defaultDealy[key];\r\n      } else {\r\n        delay[key] = optionsDelay[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  return delay;\r\n}\r\n\r\n/***/ }),\r\n/* 23 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = touchCoords;\r\n/**\r\n * Returns the first touch event found in touches or changedTouches of a touch events.\r\n * @param {TouchEvent} event a touch event\r\n * @return {Touch} a touch object\r\n */\r\nfunction touchCoords(event = {}) {\r\n  const { touches, changedTouches } = event;\r\n  return touches && touches[0] || changedTouches && changedTouches[0];\r\n}\r\n\r\n/***/ }),\r\n/* 24 */\r\n/***/ (function(module, exports, __nested_webpack_require_73514__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_73514__(23);\r\n\r\nvar _touchCoords2 = _interopRequireDefault(_touchCoords);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _touchCoords2.default;\r\n\r\n/***/ }),\r\n/* 25 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = distance;\r\n/**\r\n * Returns the distance between two points\r\n * @param  {Number} x1 The X position of the first point\r\n * @param  {Number} y1 The Y position of the first point\r\n * @param  {Number} x2 The X position of the second point\r\n * @param  {Number} y2 The Y position of the second point\r\n * @return {Number}\r\n */\r\nfunction distance(x1, y1, x2, y2) {\r\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\r\n}\r\n\r\n/***/ }),\r\n/* 26 */\r\n/***/ (function(module, exports, __nested_webpack_require_74535__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _distance = __nested_webpack_require_74535__(25);\r\n\r\nvar _distance2 = _interopRequireDefault(_distance);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _distance2.default;\r\n\r\n/***/ }),\r\n/* 27 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = requestNextAnimationFrame;\r\nfunction requestNextAnimationFrame(callback) {\r\n  return requestAnimationFrame(() => {\r\n    requestAnimationFrame(callback);\r\n  });\r\n}\r\n\r\n/***/ }),\r\n/* 28 */\r\n/***/ (function(module, exports, __nested_webpack_require_75294__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_75294__(27);\r\n\r\nvar _requestNextAnimationFrame2 = _interopRequireDefault(_requestNextAnimationFrame);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _requestNextAnimationFrame2.default;\r\n\r\n/***/ }),\r\n/* 29 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = closest;\r\nconst matchFunction = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector;\r\n\r\n/**\r\n * Get the closest parent element of a given element that matches the given\r\n * selector string or matching function\r\n *\r\n * @param {Element} element The child element to find a parent of\r\n * @param {String|Function} selector The string or function to use to match\r\n *     the parent element\r\n * @return {Element|null}\r\n */\r\nfunction closest(element, value) {\r\n  if (!element) {\r\n    return null;\r\n  }\r\n\r\n  const selector = value;\r\n  const callback = value;\r\n  const nodeList = value;\r\n  const singleElement = value;\r\n\r\n  const isSelector = Boolean(typeof value === 'string');\r\n  const isFunction = Boolean(typeof value === 'function');\r\n  const isNodeList = Boolean(value instanceof NodeList || value instanceof Array);\r\n  const isElement = Boolean(value instanceof HTMLElement);\r\n\r\n  function conditionFn(currentElement) {\r\n    if (!currentElement) {\r\n      return currentElement;\r\n    } else if (isSelector) {\r\n      return matchFunction.call(currentElement, selector);\r\n    } else if (isNodeList) {\r\n      return [...nodeList].includes(currentElement);\r\n    } else if (isElement) {\r\n      return singleElement === currentElement;\r\n    } else if (isFunction) {\r\n      return callback(currentElement);\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  let current = element;\r\n\r\n  do {\r\n    current = current.correspondingUseElement || current.correspondingElement || current;\r\n\r\n    if (conditionFn(current)) {\r\n      return current;\r\n    }\r\n\r\n    current = current.parentNode;\r\n  } while (current && current !== document.body && current !== document);\r\n\r\n  return null;\r\n}\r\n\r\n/***/ }),\r\n/* 30 */\r\n/***/ (function(module, exports, __nested_webpack_require_77724__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_77724__(29);\r\n\r\nvar _closest2 = _interopRequireDefault(_closest);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _closest2.default;\r\n\r\n/***/ }),\r\n/* 31 */\r\n/***/ (function(module, exports, __nested_webpack_require_78128__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = exports.scroll = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_78128__(4);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _utils = __nested_webpack_require_78128__(2);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = exports.onDragStart = Symbol('onDragStart');\r\nconst onDragMove = exports.onDragMove = Symbol('onDragMove');\r\nconst onDragStop = exports.onDragStop = Symbol('onDragStop');\r\nconst scroll = exports.scroll = Symbol('scroll');\r\n\r\n/**\r\n * Scrollable default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.speed\r\n * @property {Number} defaultOptions.sensitivity\r\n * @property {HTMLElement[]} defaultOptions.scrollableElements\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  speed: 6,\r\n  sensitivity: 50,\r\n  scrollableElements: []\r\n};\r\n\r\n/**\r\n * Scrollable plugin which scrolls the closest scrollable parent\r\n * @class Scrollable\r\n * @module Scrollable\r\n * @extends AbstractPlugin\r\n */\r\nclass Scrollable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Scrollable constructor.\r\n   * @constructs Scrollable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Scrollable options\r\n     * @property {Object} options\r\n     * @property {Number} options.speed\r\n     * @property {Number} options.sensitivity\r\n     * @property {HTMLElement[]} options.scrollableElements\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Keeps current mouse position\r\n     * @property {Object} currentMousePosition\r\n     * @property {Number} currentMousePosition.clientX\r\n     * @property {Number} currentMousePosition.clientY\r\n     * @type {Object|null}\r\n     */\r\n    this.currentMousePosition = null;\r\n\r\n    /**\r\n     * Scroll animation frame\r\n     * @property scrollAnimationFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.scrollAnimationFrame = null;\r\n\r\n    /**\r\n     * Closest scrollable element\r\n     * @property scrollableElement\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.scrollableElement = null;\r\n\r\n    /**\r\n     * Animation frame looking for the closest scrollable element\r\n     * @property findScrollableElementFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.findScrollableElementFrame = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[scroll] = this[scroll].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.scrollable || {};\r\n  }\r\n\r\n  /**\r\n   * Returns closest scrollable elements by element\r\n   * @param {HTMLElement} target\r\n   * @return {HTMLElement}\r\n   */\r\n  getScrollableElement(target) {\r\n    if (this.hasDefinedScrollableElements()) {\r\n      return (0, _utils.closest)(target, this.options.scrollableElements) || document.documentElement;\r\n    } else {\r\n      return closestScrollableElement(target);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if at least one scrollable element have been defined via options\r\n   * @param {HTMLElement} target\r\n   * @return {Boolean}\r\n   */\r\n  hasDefinedScrollableElements() {\r\n    return Boolean(this.options.scrollableElements.length !== 0);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler. Finds closest scrollable parent in separate frame\r\n   * @param {DragStartEvent} dragEvent\r\n   * @private\r\n   */\r\n  [onDragStart](dragEvent) {\r\n    this.findScrollableElementFrame = requestAnimationFrame(() => {\r\n      this.scrollableElement = this.getScrollableElement(dragEvent.source);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag move handler. Remembers mouse position and initiates scrolling\r\n   * @param {DragMoveEvent} dragEvent\r\n   * @private\r\n   */\r\n  [onDragMove](dragEvent) {\r\n    this.findScrollableElementFrame = requestAnimationFrame(() => {\r\n      this.scrollableElement = this.getScrollableElement(dragEvent.sensorEvent.target);\r\n    });\r\n\r\n    if (!this.scrollableElement) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = dragEvent.sensorEvent;\r\n    const scrollOffset = { x: 0, y: 0 };\r\n\r\n    if ('ontouchstart' in window) {\r\n      scrollOffset.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\r\n      scrollOffset.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;\r\n    }\r\n\r\n    this.currentMousePosition = {\r\n      clientX: sensorEvent.clientX - scrollOffset.x,\r\n      clientY: sensorEvent.clientY - scrollOffset.y\r\n    };\r\n\r\n    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler. Cancels scroll animations and resets state\r\n   * @private\r\n   */\r\n  [onDragStop]() {\r\n    cancelAnimationFrame(this.scrollAnimationFrame);\r\n    cancelAnimationFrame(this.findScrollableElementFrame);\r\n\r\n    this.scrollableElement = null;\r\n    this.scrollAnimationFrame = null;\r\n    this.findScrollableElementFrame = null;\r\n    this.currentMousePosition = null;\r\n  }\r\n\r\n  /**\r\n   * Scroll function that does the heavylifting\r\n   * @private\r\n   */\r\n  [scroll]() {\r\n    if (!this.scrollableElement || !this.currentMousePosition) {\r\n      return;\r\n    }\r\n\r\n    cancelAnimationFrame(this.scrollAnimationFrame);\r\n\r\n    const { speed, sensitivity } = this.options;\r\n\r\n    const rect = this.scrollableElement.getBoundingClientRect();\r\n    const bottomCutOff = rect.bottom > window.innerHeight;\r\n    const topCutOff = rect.top < 0;\r\n    const cutOff = topCutOff || bottomCutOff;\r\n\r\n    const documentScrollingElement = getDocumentScrollingElement();\r\n    const scrollableElement = this.scrollableElement;\r\n    const clientX = this.currentMousePosition.clientX;\r\n    const clientY = this.currentMousePosition.clientY;\r\n\r\n    if (scrollableElement !== document.body && scrollableElement !== document.documentElement && !cutOff) {\r\n      const { offsetHeight, offsetWidth } = scrollableElement;\r\n\r\n      if (rect.top + offsetHeight - clientY < sensitivity) {\r\n        scrollableElement.scrollTop += speed;\r\n      } else if (clientY - rect.top < sensitivity) {\r\n        scrollableElement.scrollTop -= speed;\r\n      }\r\n\r\n      if (rect.left + offsetWidth - clientX < sensitivity) {\r\n        scrollableElement.scrollLeft += speed;\r\n      } else if (clientX - rect.left < sensitivity) {\r\n        scrollableElement.scrollLeft -= speed;\r\n      }\r\n    } else {\r\n      const { innerHeight, innerWidth } = window;\r\n\r\n      if (clientY < sensitivity) {\r\n        documentScrollingElement.scrollTop -= speed;\r\n      } else if (innerHeight - clientY < sensitivity) {\r\n        documentScrollingElement.scrollTop += speed;\r\n      }\r\n\r\n      if (clientX < sensitivity) {\r\n        documentScrollingElement.scrollLeft -= speed;\r\n      } else if (innerWidth - clientX < sensitivity) {\r\n        documentScrollingElement.scrollLeft += speed;\r\n      }\r\n    }\r\n\r\n    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\r\n  }\r\n}\r\n\r\nexports.default = Scrollable; /**\r\n                               * Returns true if the passed element has overflow\r\n                               * @param {HTMLElement} element\r\n                               * @return {Boolean}\r\n                               * @private\r\n                               */\r\n\r\nfunction hasOverflow(element) {\r\n  const overflowRegex = /(auto|scroll)/;\r\n  const computedStyles = getComputedStyle(element, null);\r\n\r\n  const overflow = computedStyles.getPropertyValue('overflow') + computedStyles.getPropertyValue('overflow-y') + computedStyles.getPropertyValue('overflow-x');\r\n\r\n  return overflowRegex.test(overflow);\r\n}\r\n\r\n/**\r\n * Returns true if the passed element is statically positioned\r\n * @param {HTMLElement} element\r\n * @return {Boolean}\r\n * @private\r\n */\r\nfunction isStaticallyPositioned(element) {\r\n  const position = getComputedStyle(element).getPropertyValue('position');\r\n  return position === 'static';\r\n}\r\n\r\n/**\r\n * Finds closest scrollable element\r\n * @param {HTMLElement} element\r\n * @return {HTMLElement}\r\n * @private\r\n */\r\nfunction closestScrollableElement(element) {\r\n  if (!element) {\r\n    return getDocumentScrollingElement();\r\n  }\r\n\r\n  const position = getComputedStyle(element).getPropertyValue('position');\r\n  const excludeStaticParents = position === 'absolute';\r\n\r\n  const scrollableElement = (0, _utils.closest)(element, parent => {\r\n    if (excludeStaticParents && isStaticallyPositioned(parent)) {\r\n      return false;\r\n    }\r\n    return hasOverflow(parent);\r\n  });\r\n\r\n  if (position === 'fixed' || !scrollableElement) {\r\n    return getDocumentScrollingElement();\r\n  } else {\r\n    return scrollableElement;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns element that scrolls document\r\n * @return {HTMLElement}\r\n * @private\r\n */\r\nfunction getDocumentScrollingElement() {\r\n  return document.scrollingElement || document.documentElement;\r\n}\r\n\r\n/***/ }),\r\n/* 32 */\r\n/***/ (function(module, exports, __nested_webpack_require_88050__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Scrollable = __nested_webpack_require_88050__(31);\r\n\r\nvar _Scrollable2 = _interopRequireDefault(_Scrollable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Scrollable2.default;\r\nexports.defaultOptions = _Scrollable.defaultOptions;\r\n\r\n/***/ }),\r\n/* 33 */\r\n/***/ (function(module, exports, __nested_webpack_require_88557__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.MirrorDestroyEvent = exports.MirrorMoveEvent = exports.MirrorAttachedEvent = exports.MirrorCreatedEvent = exports.MirrorCreateEvent = exports.MirrorEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_88557__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base mirror event\r\n * @class MirrorEvent\r\n * @module MirrorEvent\r\n * @extends AbstractEvent\r\n */\r\nclass MirrorEvent extends _AbstractEvent2.default {\r\n  /**\r\n   * Draggables source element\r\n   * @property source\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get source() {\r\n    return this.data.source;\r\n  }\r\n\r\n  /**\r\n   * Draggables original source element\r\n   * @property originalSource\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get originalSource() {\r\n    return this.data.originalSource;\r\n  }\r\n\r\n  /**\r\n   * Draggables source container element\r\n   * @property sourceContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get sourceContainer() {\r\n    return this.data.sourceContainer;\r\n  }\r\n\r\n  /**\r\n   * Sensor event\r\n   * @property sensorEvent\r\n   * @type {SensorEvent}\r\n   * @readonly\r\n   */\r\n  get sensorEvent() {\r\n    return this.data.sensorEvent;\r\n  }\r\n\r\n  /**\r\n   * Drag event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n\r\n  /**\r\n   * Original event that triggered sensor event\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    if (this.sensorEvent) {\r\n      return this.sensorEvent.originalEvent;\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexports.MirrorEvent = MirrorEvent; /**\r\n                                    * Mirror create event\r\n                                    * @class MirrorCreateEvent\r\n                                    * @module MirrorCreateEvent\r\n                                    * @extends MirrorEvent\r\n                                    */\r\n\r\nclass MirrorCreateEvent extends MirrorEvent {}\r\n\r\nexports.MirrorCreateEvent = MirrorCreateEvent; /**\r\n                                                * Mirror created event\r\n                                                * @class MirrorCreatedEvent\r\n                                                * @module MirrorCreatedEvent\r\n                                                * @extends MirrorEvent\r\n                                                */\r\n\r\nMirrorCreateEvent.type = 'mirror:create';\r\nclass MirrorCreatedEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\n\r\nexports.MirrorCreatedEvent = MirrorCreatedEvent; /**\r\n                                                  * Mirror attached event\r\n                                                  * @class MirrorAttachedEvent\r\n                                                  * @module MirrorAttachedEvent\r\n                                                  * @extends MirrorEvent\r\n                                                  */\r\n\r\nMirrorCreatedEvent.type = 'mirror:created';\r\nclass MirrorAttachedEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\n\r\nexports.MirrorAttachedEvent = MirrorAttachedEvent; /**\r\n                                                    * Mirror move event\r\n                                                    * @class MirrorMoveEvent\r\n                                                    * @module MirrorMoveEvent\r\n                                                    * @extends MirrorEvent\r\n                                                    */\r\n\r\nMirrorAttachedEvent.type = 'mirror:attached';\r\nclass MirrorMoveEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n\r\n  /**\r\n   * Sensor has exceeded mirror's threshold on x axis\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  get passedThreshX() {\r\n    return this.data.passedThreshX;\r\n  }\r\n\r\n  /**\r\n   * Sensor has exceeded mirror's threshold on y axis\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  get passedThreshY() {\r\n    return this.data.passedThreshY;\r\n  }\r\n}\r\n\r\nexports.MirrorMoveEvent = MirrorMoveEvent; /**\r\n                                            * Mirror destroy event\r\n                                            * @class MirrorDestroyEvent\r\n                                            * @module MirrorDestroyEvent\r\n                                            * @extends MirrorEvent\r\n                                            */\r\n\r\nMirrorMoveEvent.type = 'mirror:move';\r\nMirrorMoveEvent.cancelable = true;\r\nclass MirrorDestroyEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\nexports.MirrorDestroyEvent = MirrorDestroyEvent;\r\nMirrorDestroyEvent.type = 'mirror:destroy';\r\nMirrorDestroyEvent.cancelable = true;\r\n\r\n/***/ }),\r\n/* 34 */\r\n/***/ (function(module, exports, __nested_webpack_require_94009__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _MirrorEvent = __nested_webpack_require_94009__(33);\r\n\r\nObject.keys(_MirrorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _MirrorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 35 */\r\n/***/ (function(module, exports, __nested_webpack_require_94477__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = exports.getAppendableContainer = exports.onScroll = exports.onMirrorMove = exports.onMirrorCreated = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_94477__(4);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _MirrorEvent = __nested_webpack_require_94477__(34);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\r\n\r\nconst onDragStart = exports.onDragStart = Symbol('onDragStart');\r\nconst onDragMove = exports.onDragMove = Symbol('onDragMove');\r\nconst onDragStop = exports.onDragStop = Symbol('onDragStop');\r\nconst onMirrorCreated = exports.onMirrorCreated = Symbol('onMirrorCreated');\r\nconst onMirrorMove = exports.onMirrorMove = Symbol('onMirrorMove');\r\nconst onScroll = exports.onScroll = Symbol('onScroll');\r\nconst getAppendableContainer = exports.getAppendableContainer = Symbol('getAppendableContainer');\r\n\r\n/**\r\n * Mirror default options\r\n * @property {Object} defaultOptions\r\n * @property {Boolean} defaultOptions.constrainDimensions\r\n * @property {Boolean} defaultOptions.xAxis\r\n * @property {Boolean} defaultOptions.yAxis\r\n * @property {null} defaultOptions.cursorOffsetX\r\n * @property {null} defaultOptions.cursorOffsetY\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  constrainDimensions: false,\r\n  xAxis: true,\r\n  yAxis: true,\r\n  cursorOffsetX: null,\r\n  cursorOffsetY: null,\r\n  thresholdX: null,\r\n  thresholdY: null\r\n};\r\n\r\n/**\r\n * Mirror plugin which controls the mirror positioning while dragging\r\n * @class Mirror\r\n * @module Mirror\r\n * @extends AbstractPlugin\r\n */\r\nclass Mirror extends _AbstractPlugin2.default {\r\n  /**\r\n   * Mirror constructor.\r\n   * @constructs Mirror\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Mirror options\r\n     * @property {Object} options\r\n     * @property {Boolean} options.constrainDimensions\r\n     * @property {Boolean} options.xAxis\r\n     * @property {Boolean} options.yAxis\r\n     * @property {Number|null} options.cursorOffsetX\r\n     * @property {Number|null} options.cursorOffsetY\r\n     * @property {String|HTMLElement|Function} options.appendTo\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Scroll offset for touch devices because the mirror is positioned fixed\r\n     * @property {Object} scrollOffset\r\n     * @property {Number} scrollOffset.x\r\n     * @property {Number} scrollOffset.y\r\n     */\r\n    this.scrollOffset = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Initial scroll offset for touch devices because the mirror is positioned fixed\r\n     * @property {Object} scrollOffset\r\n     * @property {Number} scrollOffset.x\r\n     * @property {Number} scrollOffset.y\r\n     */\r\n    this.initialScrollOffset = {\r\n      x: window.scrollX,\r\n      y: window.scrollY\r\n    };\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\r\n    this[onMirrorMove] = this[onMirrorMove].bind(this);\r\n    this[onScroll] = this[onScroll].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]).on('mirror:created', this[onMirrorCreated]).on('mirror:move', this[onMirrorMove]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]).off('mirror:created', this[onMirrorCreated]).off('mirror:move', this[onMirrorMove]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.mirror || {};\r\n  }\r\n\r\n  [onDragStart](dragEvent) {\r\n    if (dragEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    if ('ontouchstart' in window) {\r\n      document.addEventListener('scroll', this[onScroll], true);\r\n    }\r\n\r\n    this.initialScrollOffset = {\r\n      x: window.scrollX,\r\n      y: window.scrollY\r\n    };\r\n\r\n    const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    // Last sensor position of mirror move\r\n    this.lastMirrorMovedClient = {\r\n      x: sensorEvent.clientX,\r\n      y: sensorEvent.clientY\r\n    };\r\n\r\n    const mirrorCreateEvent = new _MirrorEvent.MirrorCreateEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent\r\n    });\r\n\r\n    this.draggable.trigger(mirrorCreateEvent);\r\n\r\n    if (isNativeDragEvent(sensorEvent) || mirrorCreateEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const appendableContainer = this[getAppendableContainer](source) || sourceContainer;\r\n    this.mirror = source.cloneNode(true);\r\n\r\n    const mirrorCreatedEvent = new _MirrorEvent.MirrorCreatedEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror\r\n    });\r\n\r\n    const mirrorAttachedEvent = new _MirrorEvent.MirrorAttachedEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror\r\n    });\r\n\r\n    this.draggable.trigger(mirrorCreatedEvent);\r\n    appendableContainer.appendChild(this.mirror);\r\n    this.draggable.trigger(mirrorAttachedEvent);\r\n  }\r\n\r\n  [onDragMove](dragEvent) {\r\n    if (!this.mirror || dragEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    let passedThreshX = true;\r\n    let passedThreshY = true;\r\n\r\n    if (this.options.thresholdX || this.options.thresholdY) {\r\n      const { x: lastX, y: lastY } = this.lastMirrorMovedClient;\r\n\r\n      if (Math.abs(lastX - sensorEvent.clientX) < this.options.thresholdX) {\r\n        passedThreshX = false;\r\n      } else {\r\n        this.lastMirrorMovedClient.x = sensorEvent.clientX;\r\n      }\r\n\r\n      if (Math.abs(lastY - sensorEvent.clientY) < this.options.thresholdY) {\r\n        passedThreshY = false;\r\n      } else {\r\n        this.lastMirrorMovedClient.y = sensorEvent.clientY;\r\n      }\r\n\r\n      if (!passedThreshX && !passedThreshY) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const mirrorMoveEvent = new _MirrorEvent.MirrorMoveEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror,\r\n      passedThreshX,\r\n      passedThreshY\r\n    });\r\n\r\n    this.draggable.trigger(mirrorMoveEvent);\r\n  }\r\n\r\n  [onDragStop](dragEvent) {\r\n    if ('ontouchstart' in window) {\r\n      document.removeEventListener('scroll', this[onScroll], true);\r\n    }\r\n\r\n    this.initialScrollOffset = { x: 0, y: 0 };\r\n    this.scrollOffset = { x: 0, y: 0 };\r\n\r\n    if (!this.mirror) {\r\n      return;\r\n    }\r\n\r\n    const { source, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    const mirrorDestroyEvent = new _MirrorEvent.MirrorDestroyEvent({\r\n      source,\r\n      mirror: this.mirror,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent\r\n    });\r\n\r\n    this.draggable.trigger(mirrorDestroyEvent);\r\n\r\n    if (!mirrorDestroyEvent.canceled()) {\r\n      this.mirror.parentNode.removeChild(this.mirror);\r\n    }\r\n  }\r\n\r\n  [onScroll]() {\r\n    this.scrollOffset = {\r\n      x: window.scrollX - this.initialScrollOffset.x,\r\n      y: window.scrollY - this.initialScrollOffset.y\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Mirror created handler\r\n   * @param {MirrorCreatedEvent} mirrorEvent\r\n   * @return {Promise}\r\n   * @private\r\n   */\r\n  [onMirrorCreated]({ mirror, source, sensorEvent }) {\r\n    const mirrorClasses = this.draggable.getClassNamesFor('mirror');\r\n\r\n    const setState = (_ref) => {\r\n      let { mirrorOffset, initialX, initialY } = _ref,\r\n          args = _objectWithoutProperties(_ref, ['mirrorOffset', 'initialX', 'initialY']);\r\n\r\n      this.mirrorOffset = mirrorOffset;\r\n      this.initialX = initialX;\r\n      this.initialY = initialY;\r\n      this.lastMovedX = initialX;\r\n      this.lastMovedY = initialY;\r\n      return _extends({ mirrorOffset, initialX, initialY }, args);\r\n    };\r\n\r\n    mirror.style.display = 'none';\r\n\r\n    const initialState = {\r\n      mirror,\r\n      source,\r\n      sensorEvent,\r\n      mirrorClasses,\r\n      scrollOffset: this.scrollOffset,\r\n      options: this.options,\r\n      passedThreshX: true,\r\n      passedThreshY: true\r\n    };\r\n\r\n    return Promise.resolve(initialState)\r\n    // Fix reflow here\r\n    .then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({ initial: true })).then(removeMirrorID).then(setState);\r\n  }\r\n\r\n  /**\r\n   * Mirror move handler\r\n   * @param {MirrorMoveEvent} mirrorEvent\r\n   * @return {Promise|null}\r\n   * @private\r\n   */\r\n  [onMirrorMove](mirrorEvent) {\r\n    if (mirrorEvent.canceled()) {\r\n      return null;\r\n    }\r\n\r\n    const setState = (_ref2) => {\r\n      let { lastMovedX, lastMovedY } = _ref2,\r\n          args = _objectWithoutProperties(_ref2, ['lastMovedX', 'lastMovedY']);\r\n\r\n      this.lastMovedX = lastMovedX;\r\n      this.lastMovedY = lastMovedY;\r\n\r\n      return _extends({ lastMovedX, lastMovedY }, args);\r\n    };\r\n\r\n    const initialState = {\r\n      mirror: mirrorEvent.mirror,\r\n      sensorEvent: mirrorEvent.sensorEvent,\r\n      mirrorOffset: this.mirrorOffset,\r\n      options: this.options,\r\n      initialX: this.initialX,\r\n      initialY: this.initialY,\r\n      scrollOffset: this.scrollOffset,\r\n      passedThreshX: mirrorEvent.passedThreshX,\r\n      passedThreshY: mirrorEvent.passedThreshY,\r\n      lastMovedX: this.lastMovedX,\r\n      lastMovedY: this.lastMovedY\r\n    };\r\n\r\n    return Promise.resolve(initialState).then(positionMirror({ raf: true })).then(setState);\r\n  }\r\n\r\n  /**\r\n   * Returns appendable container for mirror based on the appendTo option\r\n   * @private\r\n   * @param {Object} options\r\n   * @param {HTMLElement} options.source - Current source\r\n   * @return {HTMLElement}\r\n   */\r\n  [getAppendableContainer](source) {\r\n    const appendTo = this.options.appendTo;\r\n\r\n    if (typeof appendTo === 'string') {\r\n      return document.querySelector(appendTo);\r\n    } else if (appendTo instanceof HTMLElement) {\r\n      return appendTo;\r\n    } else if (typeof appendTo === 'function') {\r\n      return appendTo(source);\r\n    } else {\r\n      return source.parentNode;\r\n    }\r\n  }\r\n}\r\n\r\nexports.default = Mirror; /**\r\n                           * Computes mirror dimensions based on the source element\r\n                           * Adds sourceRect to state\r\n                           * @param {Object} state\r\n                           * @param {HTMLElement} state.source\r\n                           * @return {Promise}\r\n                           * @private\r\n                           */\r\n\r\nfunction computeMirrorDimensions(_ref3) {\r\n  let { source } = _ref3,\r\n      args = _objectWithoutProperties(_ref3, ['source']);\r\n\r\n  return withPromise(resolve => {\r\n    const sourceRect = source.getBoundingClientRect();\r\n    resolve(_extends({ source, sourceRect }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Calculates mirror offset\r\n * Adds mirrorOffset to state\r\n * @param {Object} state\r\n * @param {SensorEvent} state.sensorEvent\r\n * @param {DOMRect} state.sourceRect\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction calculateMirrorOffset(_ref4) {\r\n  let { sensorEvent, sourceRect, options } = _ref4,\r\n      args = _objectWithoutProperties(_ref4, ['sensorEvent', 'sourceRect', 'options']);\r\n\r\n  return withPromise(resolve => {\r\n    const top = options.cursorOffsetY === null ? sensorEvent.clientY - sourceRect.top : options.cursorOffsetY;\r\n    const left = options.cursorOffsetX === null ? sensorEvent.clientX - sourceRect.left : options.cursorOffsetX;\r\n\r\n    const mirrorOffset = { top, left };\r\n\r\n    resolve(_extends({ sensorEvent, sourceRect, mirrorOffset, options }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Applys mirror styles\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {HTMLElement} state.source\r\n * @param {Object} state.options\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction resetMirror(_ref5) {\r\n  let { mirror, source, options } = _ref5,\r\n      args = _objectWithoutProperties(_ref5, ['mirror', 'source', 'options']);\r\n\r\n  return withPromise(resolve => {\r\n    let offsetHeight;\r\n    let offsetWidth;\r\n\r\n    if (options.constrainDimensions) {\r\n      const computedSourceStyles = getComputedStyle(source);\r\n      offsetHeight = computedSourceStyles.getPropertyValue('height');\r\n      offsetWidth = computedSourceStyles.getPropertyValue('width');\r\n    }\r\n\r\n    mirror.style.display = null;\r\n    mirror.style.position = 'fixed';\r\n    mirror.style.pointerEvents = 'none';\r\n    mirror.style.top = 0;\r\n    mirror.style.left = 0;\r\n    mirror.style.margin = 0;\r\n\r\n    if (options.constrainDimensions) {\r\n      mirror.style.height = offsetHeight;\r\n      mirror.style.width = offsetWidth;\r\n    }\r\n\r\n    resolve(_extends({ mirror, source, options }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Applys mirror class on mirror element\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {String[]} state.mirrorClasses\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction addMirrorClasses(_ref6) {\r\n  let { mirror, mirrorClasses } = _ref6,\r\n      args = _objectWithoutProperties(_ref6, ['mirror', 'mirrorClasses']);\r\n\r\n  return withPromise(resolve => {\r\n    mirror.classList.add(...mirrorClasses);\r\n    resolve(_extends({ mirror, mirrorClasses }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Removes source ID from cloned mirror element\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction removeMirrorID(_ref7) {\r\n  let { mirror } = _ref7,\r\n      args = _objectWithoutProperties(_ref7, ['mirror']);\r\n\r\n  return withPromise(resolve => {\r\n    mirror.removeAttribute('id');\r\n    delete mirror.id;\r\n    resolve(_extends({ mirror }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Positions mirror with translate3d\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {SensorEvent} state.sensorEvent\r\n * @param {Object} state.mirrorOffset\r\n * @param {Number} state.initialY\r\n * @param {Number} state.initialX\r\n * @param {Object} state.options\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction positionMirror({ withFrame = false, initial = false } = {}) {\r\n  return (_ref8) => {\r\n    let {\r\n      mirror,\r\n      sensorEvent,\r\n      mirrorOffset,\r\n      initialY,\r\n      initialX,\r\n      scrollOffset,\r\n      options,\r\n      passedThreshX,\r\n      passedThreshY,\r\n      lastMovedX,\r\n      lastMovedY\r\n    } = _ref8,\r\n        args = _objectWithoutProperties(_ref8, ['mirror', 'sensorEvent', 'mirrorOffset', 'initialY', 'initialX', 'scrollOffset', 'options', 'passedThreshX', 'passedThreshY', 'lastMovedX', 'lastMovedY']);\r\n\r\n    return withPromise(resolve => {\r\n      const result = _extends({\r\n        mirror,\r\n        sensorEvent,\r\n        mirrorOffset,\r\n        options\r\n      }, args);\r\n\r\n      if (mirrorOffset) {\r\n        const x = passedThreshX ? Math.round((sensorEvent.clientX - mirrorOffset.left - scrollOffset.x) / (options.thresholdX || 1)) * (options.thresholdX || 1) : Math.round(lastMovedX);\r\n        const y = passedThreshY ? Math.round((sensorEvent.clientY - mirrorOffset.top - scrollOffset.y) / (options.thresholdY || 1)) * (options.thresholdY || 1) : Math.round(lastMovedY);\r\n\r\n        if (options.xAxis && options.yAxis || initial) {\r\n          mirror.style.transform = `translate3d(${x}px, ${y}px, 0)`;\r\n        } else if (options.xAxis && !options.yAxis) {\r\n          mirror.style.transform = `translate3d(${x}px, ${initialY}px, 0)`;\r\n        } else if (options.yAxis && !options.xAxis) {\r\n          mirror.style.transform = `translate3d(${initialX}px, ${y}px, 0)`;\r\n        }\r\n\r\n        if (initial) {\r\n          result.initialX = x;\r\n          result.initialY = y;\r\n        }\r\n\r\n        result.lastMovedX = x;\r\n        result.lastMovedY = y;\r\n      }\r\n\r\n      resolve(result);\r\n    }, { frame: withFrame });\r\n  };\r\n}\r\n\r\n/**\r\n * Wraps functions in promise with potential animation frame option\r\n * @param {Function} callback\r\n * @param {Object} options\r\n * @param {Boolean} options.raf\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction withPromise(callback, { raf = false } = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    if (raf) {\r\n      requestAnimationFrame(() => {\r\n        callback(resolve, reject);\r\n      });\r\n    } else {\r\n      callback(resolve, reject);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Returns true if the sensor event was triggered by a native browser drag event\r\n * @param {SensorEvent} sensorEvent\r\n */\r\nfunction isNativeDragEvent(sensorEvent) {\r\n  return (/^drag/.test(sensorEvent.originalEvent.type)\r\n  );\r\n}\r\n\r\n/***/ }),\r\n/* 36 */\r\n/***/ (function(module, exports, __nested_webpack_require_111991__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Mirror = __nested_webpack_require_111991__(35);\r\n\r\nvar _Mirror2 = _interopRequireDefault(_Mirror);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Mirror2.default;\r\nexports.defaultOptions = _Mirror.defaultOptions;\r\n\r\n/***/ }),\r\n/* 37 */\r\n/***/ (function(module, exports, __nested_webpack_require_112478__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_112478__(4);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onInitialize = Symbol('onInitialize');\r\nconst onDestroy = Symbol('onDestroy');\r\n\r\n/**\r\n * Focusable default options\r\n * @property {Object} defaultOptions\r\n * @type {Object}\r\n */\r\nconst defaultOptions = {};\r\n\r\n/**\r\n * Focusable plugin\r\n * @class Focusable\r\n * @module Focusable\r\n * @extends AbstractPlugin\r\n */\r\nclass Focusable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Focusable constructor.\r\n   * @constructs Focusable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Focusable options\r\n     * @property {Object} options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    this[onInitialize] = this[onInitialize].bind(this);\r\n    this[onDestroy] = this[onDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches listeners to draggable\r\n   */\r\n  attach() {\r\n    this.draggable.on('draggable:initialize', this[onInitialize]).on('draggable:destroy', this[onDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Detaches listeners from draggable\r\n   */\r\n  detach() {\r\n    this.draggable.off('draggable:initialize', this[onInitialize]).off('draggable:destroy', this[onDestroy]);\r\n\r\n    // Remove modified elements when detach\r\n    this[onDestroy]();\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.focusable || {};\r\n  }\r\n\r\n  /**\r\n   * Returns draggable containers and elements\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getElements() {\r\n    return [...this.draggable.containers, ...this.draggable.getDraggableElements()];\r\n  }\r\n\r\n  /**\r\n   * Intialize handler\r\n   * @private\r\n   */\r\n  [onInitialize]() {\r\n    // Can wait until the next best frame is available\r\n    requestAnimationFrame(() => {\r\n      this.getElements().forEach(element => decorateElement(element));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Destroy handler\r\n   * @private\r\n   */\r\n  [onDestroy]() {\r\n    // Can wait until the next best frame is available\r\n    requestAnimationFrame(() => {\r\n      this.getElements().forEach(element => stripElement(element));\r\n    });\r\n  }\r\n}\r\n\r\nexports.default = Focusable; /**\r\n                              * Keeps track of all the elements that are missing tabindex attributes\r\n                              * so they can be reset when draggable gets destroyed\r\n                              * @const {HTMLElement[]} elementsWithMissingTabIndex\r\n                              */\r\n\r\nconst elementsWithMissingTabIndex = [];\r\n\r\n/**\r\n * Decorates element with tabindex attributes\r\n * @param {HTMLElement} element\r\n * @return {Object}\r\n * @private\r\n */\r\nfunction decorateElement(element) {\r\n  const hasMissingTabIndex = Boolean(!element.getAttribute('tabindex') && element.tabIndex === -1);\r\n\r\n  if (hasMissingTabIndex) {\r\n    elementsWithMissingTabIndex.push(element);\r\n    element.tabIndex = 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Removes elements tabindex attributes\r\n * @param {HTMLElement} element\r\n * @private\r\n */\r\nfunction stripElement(element) {\r\n  const tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);\r\n\r\n  if (tabIndexElementPosition !== -1) {\r\n    element.tabIndex = -1;\r\n    elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);\r\n  }\r\n}\r\n\r\n/***/ }),\r\n/* 38 */\r\n/***/ (function(module, exports, __nested_webpack_require_116390__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Focusable = __nested_webpack_require_116390__(37);\r\n\r\nvar _Focusable2 = _interopRequireDefault(_Focusable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Focusable2.default;\r\n\r\n/***/ }),\r\n/* 39 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * All draggable plugins inherit from this class.\r\n * @abstract\r\n * @class AbstractPlugin\r\n * @module AbstractPlugin\r\n */\r\nclass AbstractPlugin {\r\n  /**\r\n   * AbstractPlugin constructor.\r\n   * @constructs AbstractPlugin\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    /**\r\n     * Draggable instance\r\n     * @property draggable\r\n     * @type {Draggable}\r\n     */\r\n    this.draggable = draggable;\r\n  }\r\n\r\n  /**\r\n   * Override to add listeners\r\n   * @abstract\r\n   */\r\n  attach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n\r\n  /**\r\n   * Override to remove listeners\r\n   * @abstract\r\n   */\r\n  detach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n}\r\nexports.default = AbstractPlugin;\r\n\r\n/***/ }),\r\n/* 40 */\r\n/***/ (function(module, exports, __nested_webpack_require_117714__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_117714__(4);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onInitialize = Symbol('onInitialize');\r\nconst onDestroy = Symbol('onDestroy');\r\nconst announceEvent = Symbol('announceEvent');\r\nconst announceMessage = Symbol('announceMessage');\r\n\r\nconst ARIA_RELEVANT = 'aria-relevant';\r\nconst ARIA_ATOMIC = 'aria-atomic';\r\nconst ARIA_LIVE = 'aria-live';\r\nconst ROLE = 'role';\r\n\r\n/**\r\n * Announcement default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.expire\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  expire: 7000\r\n};\r\n\r\n/**\r\n * Announcement plugin\r\n * @class Announcement\r\n * @module Announcement\r\n * @extends AbstractPlugin\r\n */\r\nclass Announcement extends _AbstractPlugin2.default {\r\n  /**\r\n   * Announcement constructor.\r\n   * @constructs Announcement\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Plugin options\r\n     * @property options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Original draggable trigger method. Hack until we have onAll or on('all')\r\n     * @property originalTriggerMethod\r\n     * @type {Function}\r\n     */\r\n    this.originalTriggerMethod = this.draggable.trigger;\r\n\r\n    this[onInitialize] = this[onInitialize].bind(this);\r\n    this[onDestroy] = this[onDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches listeners to draggable\r\n   */\r\n  attach() {\r\n    this.draggable.on('draggable:initialize', this[onInitialize]);\r\n  }\r\n\r\n  /**\r\n   * Detaches listeners from draggable\r\n   */\r\n  detach() {\r\n    this.draggable.off('draggable:destroy', this[onDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Returns passed in options\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.announcements || {};\r\n  }\r\n\r\n  /**\r\n   * Announces event\r\n   * @private\r\n   * @param {AbstractEvent} event\r\n   */\r\n  [announceEvent](event) {\r\n    const message = this.options[event.type];\r\n\r\n    if (message && typeof message === 'string') {\r\n      this[announceMessage](message);\r\n    }\r\n\r\n    if (message && typeof message === 'function') {\r\n      this[announceMessage](message(event));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Announces message to screen reader\r\n   * @private\r\n   * @param {String} message\r\n   */\r\n  [announceMessage](message) {\r\n    announce(message, { expire: this.options.expire });\r\n  }\r\n\r\n  /**\r\n   * Initialize hander\r\n   * @private\r\n   */\r\n  [onInitialize]() {\r\n    // Hack until there is an api for listening for all events\r\n    this.draggable.trigger = event => {\r\n      try {\r\n        this[announceEvent](event);\r\n      } finally {\r\n        // Ensure that original trigger is called\r\n        this.originalTriggerMethod.call(this.draggable, event);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Destroy hander\r\n   * @private\r\n   */\r\n  [onDestroy]() {\r\n    this.draggable.trigger = this.originalTriggerMethod;\r\n  }\r\n}\r\n\r\nexports.default = Announcement; /**\r\n                                 * @const {HTMLElement} liveRegion\r\n                                 */\r\n\r\nconst liveRegion = createRegion();\r\n\r\n/**\r\n * Announces message via live region\r\n * @param {String} message\r\n * @param {Object} options\r\n * @param {Number} options.expire\r\n */\r\nfunction announce(message, { expire }) {\r\n  const element = document.createElement('div');\r\n\r\n  element.textContent = message;\r\n  liveRegion.appendChild(element);\r\n\r\n  return setTimeout(() => {\r\n    liveRegion.removeChild(element);\r\n  }, expire);\r\n}\r\n\r\n/**\r\n * Creates region element\r\n * @return {HTMLElement}\r\n */\r\nfunction createRegion() {\r\n  const element = document.createElement('div');\r\n\r\n  element.setAttribute('id', 'draggable-live-region');\r\n  element.setAttribute(ARIA_RELEVANT, 'additions');\r\n  element.setAttribute(ARIA_ATOMIC, 'true');\r\n  element.setAttribute(ARIA_LIVE, 'assertive');\r\n  element.setAttribute(ROLE, 'log');\r\n\r\n  element.style.position = 'fixed';\r\n  element.style.width = '1px';\r\n  element.style.height = '1px';\r\n  element.style.top = '-1px';\r\n  element.style.overflow = 'hidden';\r\n\r\n  return element;\r\n}\r\n\r\n// Append live region element as early as possible\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  document.body.appendChild(liveRegion);\r\n});\r\n\r\n/***/ }),\r\n/* 41 */\r\n/***/ (function(module, exports, __nested_webpack_require_122602__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Announcement = __nested_webpack_require_122602__(40);\r\n\r\nvar _Announcement2 = _interopRequireDefault(_Announcement);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Announcement2.default;\r\nexports.defaultOptions = _Announcement.defaultOptions;\r\n\r\n/***/ }),\r\n/* 42 */\r\n/***/ (function(module, exports, __nested_webpack_require_123119__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DraggableDestroyEvent = exports.DraggableInitializedEvent = exports.DraggableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_123119__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base draggable event\r\n * @class DraggableEvent\r\n * @module DraggableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DraggableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Draggable instance\r\n   * @property draggable\r\n   * @type {Draggable}\r\n   * @readonly\r\n   */\r\n  get draggable() {\r\n    return this.data.draggable;\r\n  }\r\n}\r\n\r\nexports.DraggableEvent = DraggableEvent; /**\r\n                                          * Draggable initialized event\r\n                                          * @class DraggableInitializedEvent\r\n                                          * @module DraggableInitializedEvent\r\n                                          * @extends DraggableEvent\r\n                                          */\r\n\r\nDraggableEvent.type = 'draggable';\r\nclass DraggableInitializedEvent extends DraggableEvent {}\r\n\r\nexports.DraggableInitializedEvent = DraggableInitializedEvent; /**\r\n                                                                * Draggable destory event\r\n                                                                * @class DraggableInitializedEvent\r\n                                                                * @module DraggableDestroyEvent\r\n                                                                * @extends DraggableDestroyEvent\r\n                                                                */\r\n\r\nDraggableInitializedEvent.type = 'draggable:initialize';\r\nclass DraggableDestroyEvent extends DraggableEvent {}\r\nexports.DraggableDestroyEvent = DraggableDestroyEvent;\r\nDraggableDestroyEvent.type = 'draggable:destroy';\r\n\r\n/***/ }),\r\n/* 43 */\r\n/***/ (function(module, exports, __nested_webpack_require_125183__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DragStoppedEvent = exports.DragStopEvent = exports.DragPressureEvent = exports.DragOutContainerEvent = exports.DragOverContainerEvent = exports.DragOutEvent = exports.DragOverEvent = exports.DragMoveEvent = exports.DragStartEvent = exports.DragEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_125183__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base drag event\r\n * @class DragEvent\r\n * @module DragEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DragEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Draggables source element\r\n   * @property source\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get source() {\r\n    return this.data.source;\r\n  }\r\n\r\n  /**\r\n   * Draggables original source element\r\n   * @property originalSource\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get originalSource() {\r\n    return this.data.originalSource;\r\n  }\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n\r\n  /**\r\n   * Draggables source container element\r\n   * @property sourceContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get sourceContainer() {\r\n    return this.data.sourceContainer;\r\n  }\r\n\r\n  /**\r\n   * Sensor event\r\n   * @property sensorEvent\r\n   * @type {SensorEvent}\r\n   * @readonly\r\n   */\r\n  get sensorEvent() {\r\n    return this.data.sensorEvent;\r\n  }\r\n\r\n  /**\r\n   * Original event that triggered sensor event\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    if (this.sensorEvent) {\r\n      return this.sensorEvent.originalEvent;\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexports.DragEvent = DragEvent; /**\r\n                                * Drag start event\r\n                                * @class DragStartEvent\r\n                                * @module DragStartEvent\r\n                                * @extends DragEvent\r\n                                */\r\n\r\nDragEvent.type = 'drag';\r\nclass DragStartEvent extends DragEvent {}\r\n\r\nexports.DragStartEvent = DragStartEvent; /**\r\n                                          * Drag move event\r\n                                          * @class DragMoveEvent\r\n                                          * @module DragMoveEvent\r\n                                          * @extends DragEvent\r\n                                          */\r\n\r\nDragStartEvent.type = 'drag:start';\r\nDragStartEvent.cancelable = true;\r\nclass DragMoveEvent extends DragEvent {}\r\n\r\nexports.DragMoveEvent = DragMoveEvent; /**\r\n                                        * Drag over event\r\n                                        * @class DragOverEvent\r\n                                        * @module DragOverEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragMoveEvent.type = 'drag:move';\r\nclass DragOverEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you are over\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n}\r\n\r\nexports.DragOverEvent = DragOverEvent; /**\r\n                                        * Drag out event\r\n                                        * @class DragOutEvent\r\n                                        * @module DragOutEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragOverEvent.type = 'drag:over';\r\nDragOverEvent.cancelable = true;\r\nclass DragOutEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you left\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n}\r\n\r\nexports.DragOutEvent = DragOutEvent; /**\r\n                                      * Drag over container event\r\n                                      * @class DragOverContainerEvent\r\n                                      * @module DragOverContainerEvent\r\n                                      * @extends DragEvent\r\n                                      */\r\n\r\nDragOutEvent.type = 'drag:out';\r\nclass DragOverContainerEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.DragOverContainerEvent = DragOverContainerEvent; /**\r\n                                                          * Drag out container event\r\n                                                          * @class DragOutContainerEvent\r\n                                                          * @module DragOutContainerEvent\r\n                                                          * @extends DragEvent\r\n                                                          */\r\n\r\nDragOverContainerEvent.type = 'drag:over:container';\r\nclass DragOutContainerEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you left\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.DragOutContainerEvent = DragOutContainerEvent; /**\r\n                                                        * Drag pressure event\r\n                                                        * @class DragPressureEvent\r\n                                                        * @module DragPressureEvent\r\n                                                        * @extends DragEvent\r\n                                                        */\r\n\r\nDragOutContainerEvent.type = 'drag:out:container';\r\nclass DragPressureEvent extends DragEvent {\r\n\r\n  /**\r\n   * Pressure applied on draggable element\r\n   * @property pressure\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get pressure() {\r\n    return this.data.pressure;\r\n  }\r\n}\r\n\r\nexports.DragPressureEvent = DragPressureEvent; /**\r\n                                                * Drag stop event\r\n                                                * @class DragStopEvent\r\n                                                * @module DragStopEvent\r\n                                                * @extends DragEvent\r\n                                                */\r\n\r\nDragPressureEvent.type = 'drag:pressure';\r\nclass DragStopEvent extends DragEvent {}\r\n\r\nexports.DragStopEvent = DragStopEvent; /**\r\n                                        * Drag stopped event\r\n                                        * @class DragStoppedEvent\r\n                                        * @module DragStoppedEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragStopEvent.type = 'drag:stop';\r\nclass DragStoppedEvent extends DragEvent {}\r\nexports.DragStoppedEvent = DragStoppedEvent;\r\nDragStoppedEvent.type = 'drag:stopped';\r\n\r\n/***/ }),\r\n/* 44 */\r\n/***/ (function(module, exports, __nested_webpack_require_132708__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragEvent = __nested_webpack_require_132708__(8);\r\n\r\nObject.keys(_DragEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DragEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _DraggableEvent = __nested_webpack_require_132708__(7);\r\n\r\nObject.keys(_DraggableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DraggableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Plugins = __nested_webpack_require_132708__(6);\r\n\r\nObject.keys(_Plugins).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _Plugins[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Sensors = __nested_webpack_require_132708__(5);\r\n\r\nObject.keys(_Sensors).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _Sensors[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Draggable = __nested_webpack_require_132708__(12);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Draggable2.default;\r\n\r\n/***/ }),\r\n/* 45 */\r\n/***/ (function(module, exports, __nested_webpack_require_134291__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _Draggable = __nested_webpack_require_134291__(44);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nvar _SortableEvent = __nested_webpack_require_134291__(9);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragOverContainer = Symbol('onDragOverContainer');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragStop = Symbol('onDragStop');\r\n\r\n/**\r\n * Returns announcement message when a Draggable element has been sorted with another Draggable element\r\n * or moved into a new container\r\n * @param {SortableSortedEvent} sortableEvent\r\n * @return {String}\r\n */\r\nfunction onSortableSortedDefaultAnnouncement({ dragEvent }) {\r\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'sortable element';\r\n\r\n  if (dragEvent.over) {\r\n    const overText = dragEvent.over.textContent.trim() || dragEvent.over.id || 'sortable element';\r\n    const isFollowing = dragEvent.source.compareDocumentPosition(dragEvent.over) & Node.DOCUMENT_POSITION_FOLLOWING;\r\n\r\n    if (isFollowing) {\r\n      return `Placed ${sourceText} after ${overText}`;\r\n    } else {\r\n      return `Placed ${sourceText} before ${overText}`;\r\n    }\r\n  } else {\r\n    // need to figure out how to compute container name\r\n    return `Placed ${sourceText} into a different container`;\r\n  }\r\n}\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['sortable:sorted']\r\n */\r\nconst defaultAnnouncements = {\r\n  'sortable:sorted': onSortableSortedDefaultAnnouncement\r\n};\r\n\r\n/**\r\n * Sortable is built on top of Draggable and allows sorting of draggable elements. Sortable will keep\r\n * track of the original index and emits the new index as you drag over draggable elements.\r\n * @class Sortable\r\n * @module Sortable\r\n * @extends Draggable\r\n */\r\nclass Sortable extends _Draggable2.default {\r\n  /**\r\n   * Sortable constructor.\r\n   * @constructs Sortable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Sortable containers\r\n   * @param {Object} options - Options for Sortable\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, _extends({}, options, {\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {})\r\n    }));\r\n\r\n    /**\r\n     * start index of source on drag start\r\n     * @property startIndex\r\n     * @type {Number}\r\n     */\r\n    this.startIndex = null;\r\n\r\n    /**\r\n     * start container on drag start\r\n     * @property startContainer\r\n     * @type {HTMLElement}\r\n     * @default null\r\n     */\r\n    this.startContainer = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragOverContainer] = this[onDragOverContainer].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n\r\n    this.on('drag:start', this[onDragStart]).on('drag:over:container', this[onDragOverContainer]).on('drag:over', this[onDragOver]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Destroys Sortable instance.\r\n   */\r\n  destroy() {\r\n    super.destroy();\r\n\r\n    this.off('drag:start', this[onDragStart]).off('drag:over:container', this[onDragOverContainer]).off('drag:over', this[onDragOver]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Returns true index of element within its container during drag operation, i.e. excluding mirror and original source\r\n   * @param {HTMLElement} element - An element\r\n   * @return {Number}\r\n   */\r\n  index(element) {\r\n    return this.getSortableElementsForContainer(element.parentNode).indexOf(element);\r\n  }\r\n\r\n  /**\r\n   * Returns sortable elements for a given container, excluding the mirror and\r\n   * original source element if present\r\n   * @param {HTMLElement} container\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getSortableElementsForContainer(container) {\r\n    const allSortableElements = container.querySelectorAll(this.options.draggable);\r\n\r\n    return [...allSortableElements].filter(childElement => {\r\n      return childElement !== this.originalSource && childElement !== this.mirror && childElement.parentNode === container;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {DragStartEvent} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    this.startContainer = event.source.parentNode;\r\n    this.startIndex = this.index(event.source);\r\n\r\n    const sortableStartEvent = new _SortableEvent.SortableStartEvent({\r\n      dragEvent: event,\r\n      startIndex: this.startIndex,\r\n      startContainer: this.startContainer\r\n    });\r\n\r\n    this.trigger(sortableStartEvent);\r\n\r\n    if (sortableStartEvent.canceled()) {\r\n      event.cancel();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag over container handler\r\n   * @private\r\n   * @param {DragOverContainerEvent} event - Drag over container event\r\n   */\r\n  [onDragOverContainer](event) {\r\n    if (event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const { source, over, overContainer } = event;\r\n    const oldIndex = this.index(source);\r\n\r\n    const sortableSortEvent = new _SortableEvent.SortableSortEvent({\r\n      dragEvent: event,\r\n      currentIndex: oldIndex,\r\n      source,\r\n      over\r\n    });\r\n\r\n    this.trigger(sortableSortEvent);\r\n\r\n    if (sortableSortEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const children = this.getSortableElementsForContainer(overContainer);\r\n    const moves = move({ source, over, overContainer, children });\r\n\r\n    if (!moves) {\r\n      return;\r\n    }\r\n\r\n    const { oldContainer, newContainer } = moves;\r\n    const newIndex = this.index(event.source);\r\n\r\n    const sortableSortedEvent = new _SortableEvent.SortableSortedEvent({\r\n      dragEvent: event,\r\n      oldIndex,\r\n      newIndex,\r\n      oldContainer,\r\n      newContainer\r\n    });\r\n\r\n    this.trigger(sortableSortedEvent);\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {DragOverEvent} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (event.over === event.originalSource || event.over === event.source) {\r\n      return;\r\n    }\r\n\r\n    const { source, over, overContainer } = event;\r\n    const oldIndex = this.index(source);\r\n\r\n    const sortableSortEvent = new _SortableEvent.SortableSortEvent({\r\n      dragEvent: event,\r\n      currentIndex: oldIndex,\r\n      source,\r\n      over\r\n    });\r\n\r\n    this.trigger(sortableSortEvent);\r\n\r\n    if (sortableSortEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const children = this.getDraggableElementsForContainer(overContainer);\r\n    const moves = move({ source, over, overContainer, children });\r\n\r\n    if (!moves) {\r\n      return;\r\n    }\r\n\r\n    const { oldContainer, newContainer } = moves;\r\n    const newIndex = this.index(source);\r\n\r\n    const sortableSortedEvent = new _SortableEvent.SortableSortedEvent({\r\n      dragEvent: event,\r\n      oldIndex,\r\n      newIndex,\r\n      oldContainer,\r\n      newContainer\r\n    });\r\n\r\n    this.trigger(sortableSortedEvent);\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop](event) {\r\n    const sortableStopEvent = new _SortableEvent.SortableStopEvent({\r\n      dragEvent: event,\r\n      oldIndex: this.startIndex,\r\n      newIndex: this.index(event.source),\r\n      oldContainer: this.startContainer,\r\n      newContainer: event.source.parentNode\r\n    });\r\n\r\n    this.trigger(sortableStopEvent);\r\n\r\n    this.startIndex = null;\r\n    this.startContainer = null;\r\n  }\r\n}\r\n\r\nexports.default = Sortable;\r\nfunction index(element) {\r\n  return Array.prototype.indexOf.call(element.parentNode.children, element);\r\n}\r\n\r\nfunction move({ source, over, overContainer, children }) {\r\n  const emptyOverContainer = !children.length;\r\n  const differentContainer = source.parentNode !== overContainer;\r\n  const sameContainer = over && source.parentNode === over.parentNode;\r\n\r\n  if (emptyOverContainer) {\r\n    return moveInsideEmptyContainer(source, overContainer);\r\n  } else if (sameContainer) {\r\n    return moveWithinContainer(source, over);\r\n  } else if (differentContainer) {\r\n    return moveOutsideContainer(source, over, overContainer);\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\nfunction moveInsideEmptyContainer(source, overContainer) {\r\n  const oldContainer = source.parentNode;\r\n\r\n  overContainer.appendChild(source);\r\n\r\n  return { oldContainer, newContainer: overContainer };\r\n}\r\n\r\nfunction moveWithinContainer(source, over) {\r\n  const oldIndex = index(source);\r\n  const newIndex = index(over);\r\n\r\n  if (oldIndex < newIndex) {\r\n    source.parentNode.insertBefore(source, over.nextElementSibling);\r\n  } else {\r\n    source.parentNode.insertBefore(source, over);\r\n  }\r\n\r\n  return { oldContainer: source.parentNode, newContainer: source.parentNode };\r\n}\r\n\r\nfunction moveOutsideContainer(source, over, overContainer) {\r\n  const oldContainer = source.parentNode;\r\n\r\n  if (over) {\r\n    over.parentNode.insertBefore(source, over);\r\n  } else {\r\n    // need to figure out proper position\r\n    overContainer.appendChild(source);\r\n  }\r\n\r\n  return { oldContainer, newContainer: source.parentNode };\r\n}\r\n\r\n/***/ }),\r\n/* 46 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst canceled = Symbol('canceled');\r\n\r\n/**\r\n * All events fired by draggable inherit this class. You can call `cancel()` to\r\n * cancel a specific event or you can check if an event has been canceled by\r\n * calling `canceled()`.\r\n * @abstract\r\n * @class AbstractEvent\r\n * @module AbstractEvent\r\n */\r\nclass AbstractEvent {\r\n\r\n  /**\r\n   * AbstractEvent constructor.\r\n   * @constructs AbstractEvent\r\n   * @param {object} data - Event data\r\n   */\r\n\r\n  /**\r\n   * Event type\r\n   * @static\r\n   * @abstract\r\n   * @property type\r\n   * @type {String}\r\n   */\r\n  constructor(data) {\r\n    this[canceled] = false;\r\n    this.data = data;\r\n  }\r\n\r\n  /**\r\n   * Read-only type\r\n   * @abstract\r\n   * @return {String}\r\n   */\r\n\r\n\r\n  /**\r\n   * Event cancelable\r\n   * @static\r\n   * @abstract\r\n   * @property cancelable\r\n   * @type {Boolean}\r\n   */\r\n  get type() {\r\n    return this.constructor.type;\r\n  }\r\n\r\n  /**\r\n   * Read-only cancelable\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  get cancelable() {\r\n    return this.constructor.cancelable;\r\n  }\r\n\r\n  /**\r\n   * Cancels the event instance\r\n   * @abstract\r\n   */\r\n  cancel() {\r\n    this[canceled] = true;\r\n  }\r\n\r\n  /**\r\n   * Check if event has been canceled\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  canceled() {\r\n    return Boolean(this[canceled]);\r\n  }\r\n\r\n  /**\r\n   * Returns new event instance with existing event data.\r\n   * This method allows for overriding of event data.\r\n   * @param {Object} data\r\n   * @return {AbstractEvent}\r\n   */\r\n  clone(data) {\r\n    return new this.constructor(_extends({}, this.data, data));\r\n  }\r\n}\r\nexports.default = AbstractEvent;\r\nAbstractEvent.type = 'event';\r\nAbstractEvent.cancelable = false;\r\n\r\n/***/ }),\r\n/* 47 */\r\n/***/ (function(module, exports, __nested_webpack_require_145868__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.SortableStopEvent = exports.SortableSortedEvent = exports.SortableSortEvent = exports.SortableStartEvent = exports.SortableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_145868__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base sortable event\r\n * @class SortableEvent\r\n * @module SortableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SortableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Original drag event that triggered this sortable event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n}\r\n\r\nexports.SortableEvent = SortableEvent; /**\r\n                                        * Sortable start event\r\n                                        * @class SortableStartEvent\r\n                                        * @module SortableStartEvent\r\n                                        * @extends SortableEvent\r\n                                        */\r\n\r\nSortableEvent.type = 'sortable';\r\nclass SortableStartEvent extends SortableEvent {\r\n\r\n  /**\r\n   * Start index of source on sortable start\r\n   * @property startIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get startIndex() {\r\n    return this.data.startIndex;\r\n  }\r\n\r\n  /**\r\n   * Start container on sortable start\r\n   * @property startContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get startContainer() {\r\n    return this.data.startContainer;\r\n  }\r\n}\r\n\r\nexports.SortableStartEvent = SortableStartEvent; /**\r\n                                                  * Sortable sort event\r\n                                                  * @class SortableSortEvent\r\n                                                  * @module SortableSortEvent\r\n                                                  * @extends SortableEvent\r\n                                                  */\r\n\r\nSortableStartEvent.type = 'sortable:start';\r\nSortableStartEvent.cancelable = true;\r\nclass SortableSortEvent extends SortableEvent {\r\n\r\n  /**\r\n   * Index of current draggable element\r\n   * @property currentIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get currentIndex() {\r\n    return this.data.currentIndex;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you are hovering over\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n\r\n  /**\r\n   * Draggable container element you are hovering over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.dragEvent.overContainer;\r\n  }\r\n}\r\n\r\nexports.SortableSortEvent = SortableSortEvent; /**\r\n                                                * Sortable sorted event\r\n                                                * @class SortableSortedEvent\r\n                                                * @module SortableSortedEvent\r\n                                                * @extends SortableEvent\r\n                                                */\r\n\r\nSortableSortEvent.type = 'sortable:sort';\r\nSortableSortEvent.cancelable = true;\r\nclass SortableSortedEvent extends SortableEvent {\r\n\r\n  /**\r\n   * Index of last sorted event\r\n   * @property oldIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get oldIndex() {\r\n    return this.data.oldIndex;\r\n  }\r\n\r\n  /**\r\n   * New index of this sorted event\r\n   * @property newIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get newIndex() {\r\n    return this.data.newIndex;\r\n  }\r\n\r\n  /**\r\n   * Old container of draggable element\r\n   * @property oldContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get oldContainer() {\r\n    return this.data.oldContainer;\r\n  }\r\n\r\n  /**\r\n   * New container of draggable element\r\n   * @property newContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get newContainer() {\r\n    return this.data.newContainer;\r\n  }\r\n}\r\n\r\nexports.SortableSortedEvent = SortableSortedEvent; /**\r\n                                                    * Sortable stop event\r\n                                                    * @class SortableStopEvent\r\n                                                    * @module SortableStopEvent\r\n                                                    * @extends SortableEvent\r\n                                                    */\r\n\r\nSortableSortedEvent.type = 'sortable:sorted';\r\nclass SortableStopEvent extends SortableEvent {\r\n\r\n  /**\r\n   * Original index on sortable start\r\n   * @property oldIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get oldIndex() {\r\n    return this.data.oldIndex;\r\n  }\r\n\r\n  /**\r\n   * New index of draggable element\r\n   * @property newIndex\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get newIndex() {\r\n    return this.data.newIndex;\r\n  }\r\n\r\n  /**\r\n   * Original container of draggable element\r\n   * @property oldContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get oldContainer() {\r\n    return this.data.oldContainer;\r\n  }\r\n\r\n  /**\r\n   * New container of draggable element\r\n   * @property newContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get newContainer() {\r\n    return this.data.newContainer;\r\n  }\r\n}\r\nexports.SortableStopEvent = SortableStopEvent;\r\nSortableStopEvent.type = 'sortable:stop';\r\n\r\n/***/ }),\r\n/* 48 */\r\n/***/ (function(module, exports, __nested_webpack_require_151374__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SortableEvent = __nested_webpack_require_151374__(9);\r\n\r\nObject.keys(_SortableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SortableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Sortable = __nested_webpack_require_151374__(45);\r\n\r\nvar _Sortable2 = _interopRequireDefault(_Sortable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Sortable2.default;\r\n\r\n/***/ })\r\n/******/ ]);\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9zb3J0YWJsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNLEVBS3lCO0FBQy9CLENBQUM7QUFDRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDhCQUFtQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZUFBZSw4QkFBbUI7QUFDbEMsbURBQW1ELCtCQUErQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0EsaUVBQWlFLGlCQUFpQjtBQUNsRjtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZ0NBQWdDLDhCQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUFtQjtBQUM5QixrREFBa0QsZ0NBQWdDO0FBQ2xGLDBFQUEwRSw4QkFBbUIsNEJBQTRCLG9CQUFvQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRSwwQ0FBMEM7QUFDMUMsV0FBVyw4QkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBbUIsQ0FBQyw4QkFBbUI7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eEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsZUFBZTtBQUNqQyxjQUFjO0FBQ2Q7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9saWIvc29ydGFibGUuanM/MzgzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xyXG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxyXG5cdFx0ZGVmaW5lKFwiU29ydGFibGVcIiwgW10sIGZhY3RvcnkpO1xyXG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxyXG5cdFx0ZXhwb3J0c1tcIlNvcnRhYmxlXCJdID0gZmFjdG9yeSgpO1xyXG5cdGVsc2VcclxuXHRcdHJvb3RbXCJTb3J0YWJsZVwiXSA9IGZhY3RvcnkoKTtcclxufSkod2luZG93LCBmdW5jdGlvbigpIHtcclxucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcclxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXHJcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxyXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcclxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxyXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xyXG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcclxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXHJcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XHJcbi8qKioqKiovIFx0XHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXHJcbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcclxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XHJcbi8qKioqKiovIFx0fVxyXG4vKioqKioqL1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XHJcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XHJcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcclxuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcclxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xyXG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcclxuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XHJcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcclxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcclxuLyoqKioqKi8gXHRcdHJldHVybiBucztcclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cclxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcclxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcclxuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcclxuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xyXG4vKioqKioqL1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xyXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDQ4KTtcclxuLyoqKioqKi8gfSlcclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyoqKioqKi8gKFtcclxuLyogMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuXHJcbk9iamVjdC5rZXlzKF9TZW5zb3JFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9TZW5zb3JFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxuXHJcbnZhciBfU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX1NlbnNvcjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9jbG9zZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2Nsb3Nlc3QnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9zZXN0KS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncmVxdWVzdE5leHRBbmltYXRpb25GcmFtZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfZGlzdGFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGlzdGFuY2UnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXN0YW5jZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF90b3VjaENvb3JkcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd0b3VjaENvb3JkcycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvdWNoQ29vcmRzKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1NlbnNvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Nb3VzZVNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdNb3VzZVNlbnNvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vdXNlU2Vuc29yKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1RvdWNoU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1RvdWNoU2Vuc29yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVG91Y2hTZW5zb3IpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfRHJhZ1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdEcmFnU2Vuc29yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ1NlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Gb3JjZVRvdWNoU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0ZvcmNlVG91Y2hTZW5zb3InLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Gb3JjZVRvdWNoU2Vuc29yKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbk9iamVjdC5rZXlzKF9TZW5zb3JFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9TZW5zb3JFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKioqLyB9KSxcclxuLyogNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQW5ub3VuY2VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Fubm91bmNlbWVudCcsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fubm91bmNlbWVudCkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRBbm5vdW5jZW1lbnRPcHRpb25zJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX0Fubm91bmNlbWVudC5kZWZhdWx0T3B0aW9ucztcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Gb2N1c2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRm9jdXNhYmxlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRm9jdXNhYmxlKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX01pcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdNaXJyb3InLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NaXJyb3IpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0TWlycm9yT3B0aW9ucycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9NaXJyb3IuZGVmYXVsdE9wdGlvbnM7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfU2Nyb2xsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTY3JvbGxhYmxlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Nyb2xsYWJsZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRTY3JvbGxhYmxlT3B0aW9ucycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9TY3JvbGxhYmxlLmRlZmF1bHRPcHRpb25zO1xyXG4gIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0RyYWdnYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XHJcblxyXG5PYmplY3Qua2V5cyhfRHJhZ2dhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfRHJhZ2dhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRHJhZ0V2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XHJcblxyXG5PYmplY3Qua2V5cyhfRHJhZ0V2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX0RyYWdFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Tb3J0YWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XHJcblxyXG5PYmplY3Qua2V5cyhfU29ydGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9Tb3J0YWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG4vKipcclxuICogVGhlIEVtaXR0ZXIgaXMgYSBzaW1wbGUgZW1pdHRlciBjbGFzcyB0aGF0IHByb3ZpZGVzIHlvdSB3aXRoIGBvbigpYCwgYG9mZigpYCBhbmQgYHRyaWdnZXIoKWAgbWV0aG9kc1xyXG4gKiBAY2xhc3MgRW1pdHRlclxyXG4gKiBAbW9kdWxlIEVtaXR0ZXJcclxuICovXHJcbmNsYXNzIEVtaXR0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgYnkgZXZlbnQgbmFtZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXHJcbiAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gY2FsbGJhY2tzXHJcbiAgICovXHJcbiAgb24odHlwZSwgLi4uY2FsbGJhY2tzKSB7XHJcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW3R5cGVdKSB7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jYWxsYmFja3NbdHlwZV0ucHVzaCguLi5jYWxsYmFja3MpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVW5yZWdpc3RlcnMgY2FsbGJhY2tzIGJ5IGV2ZW50IG5hbWVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgb2ZmKHR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW3R5cGVdKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvcHkgPSB0aGlzLmNhbGxiYWNrc1t0eXBlXS5zbGljZSgwKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvcHkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGNhbGxiYWNrID09PSBjb3B5W2ldKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3NbdHlwZV0uc3BsaWNlKGksIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmlnZ2VycyBldmVudCBjYWxsYmFja3MgYnkgZXZlbnQgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtBYnN0cmFjdEV2ZW50fSBldmVudFxyXG4gICAqL1xyXG4gIHRyaWdnZXIoZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5jYWxsYmFja3NbZXZlbnQudHlwZV0pIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2FsbGJhY2tzID0gWy4uLnRoaXMuY2FsbGJhY2tzW2V2ZW50LnR5cGVdXTtcclxuICAgIGNvbnN0IGNhdWdodEVycm9ycyA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSBjYWxsYmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgY29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjYXVnaHRFcnJvcnMucHVzaChlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2F1Z2h0RXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYERyYWdnYWJsZSBjYXVnaHQgZXJyb3JzIHdoaWxlIHRyaWdnZXJpbmcgJyR7ZXZlbnQudHlwZX0nYCwgY2F1Z2h0RXJyb3JzKTtcclxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBFbWl0dGVyO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDExICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9FbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblxyXG52YXIgX0VtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRW1pdHRlcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0VtaXR0ZXIyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG52YXIgX1BsdWdpbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cclxudmFyIF9FbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblxyXG52YXIgX0VtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRW1pdHRlcik7XHJcblxyXG52YXIgX1NlbnNvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxudmFyIF9EcmFnZ2FibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcblxyXG52YXIgX0RyYWdFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XHJcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcclxuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xyXG5jb25zdCBvbkRyYWdQcmVzc3VyZSA9IFN5bWJvbCgnb25EcmFnUHJlc3N1cmUnKTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3Qge09iamVjdH0gZGVmYXVsdEFubm91bmNlbWVudHNcclxuICogQGNvbnN0IHtGdW5jdGlvbn0gZGVmYXVsdEFubm91bmNlbWVudHNbJ2RyYWc6c3RhcnQnXVxyXG4gKiBAY29uc3Qge0Z1bmN0aW9ufSBkZWZhdWx0QW5ub3VuY2VtZW50c1snZHJhZzpzdG9wJ11cclxuICovXHJcbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xyXG4gICdkcmFnOnN0YXJ0JzogZXZlbnQgPT4gYFBpY2tlZCB1cCAke2V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZXZlbnQuc291cmNlLmlkIHx8ICdkcmFnZ2FibGUgZWxlbWVudCd9YCxcclxuICAnZHJhZzpzdG9wJzogZXZlbnQgPT4gYFJlbGVhc2VkICR7ZXZlbnQuc291cmNlLnRleHRDb250ZW50LnRyaW0oKSB8fCBldmVudC5zb3VyY2UuaWQgfHwgJ2RyYWdnYWJsZSBlbGVtZW50J31gXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0Q2xhc3NlcyA9IHtcclxuICAnY29udGFpbmVyOmRyYWdnaW5nJzogJ2RyYWdnYWJsZS1jb250YWluZXItLWlzLWRyYWdnaW5nJyxcclxuICAnc291cmNlOmRyYWdnaW5nJzogJ2RyYWdnYWJsZS1zb3VyY2UtLWlzLWRyYWdnaW5nJyxcclxuICAnc291cmNlOnBsYWNlZCc6ICdkcmFnZ2FibGUtc291cmNlLS1wbGFjZWQnLFxyXG4gICdjb250YWluZXI6cGxhY2VkJzogJ2RyYWdnYWJsZS1jb250YWluZXItLXBsYWNlZCcsXHJcbiAgJ2JvZHk6ZHJhZ2dpbmcnOiAnZHJhZ2dhYmxlLS1pcy1kcmFnZ2luZycsXHJcbiAgJ2RyYWdnYWJsZTpvdmVyJzogJ2RyYWdnYWJsZS0tb3ZlcicsXHJcbiAgJ2NvbnRhaW5lcjpvdmVyJzogJ2RyYWdnYWJsZS1jb250YWluZXItLW92ZXInLFxyXG4gICdzb3VyY2U6b3JpZ2luYWwnOiAnZHJhZ2dhYmxlLS1vcmlnaW5hbCcsXHJcbiAgbWlycm9yOiAnZHJhZ2dhYmxlLW1pcnJvcidcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcclxuICBkcmFnZ2FibGU6ICcuZHJhZ2dhYmxlLXNvdXJjZScsXHJcbiAgaGFuZGxlOiBudWxsLFxyXG4gIGRlbGF5OiB7fSxcclxuICBkaXN0YW5jZTogMCxcclxuICBwbGFjZWRUaW1lb3V0OiA4MDAsXHJcbiAgcGx1Z2luczogW10sXHJcbiAgc2Vuc29yczogW10sXHJcbiAgZXhjbHVkZToge1xyXG4gICAgcGx1Z2luczogW10sXHJcbiAgICBzZW5zb3JzOiBbXVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBjb3JlIGRyYWdnYWJsZSBsaWJyYXJ5IHRoYXQgZG9lcyB0aGUgaGVhdnkgbGlmdGluZ1xyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlXHJcbiAqIEBtb2R1bGUgRHJhZ2dhYmxlXHJcbiAqL1xyXG5jbGFzcyBEcmFnZ2FibGUge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgRHJhZ2dhYmxlXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gRHJhZ2dhYmxlIGNvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGRyYWdnYWJsZVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBEZWZhdWx0IHBsdWdpbnMgZHJhZ2dhYmxlIHVzZXNcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IFBsdWdpbnNcclxuICAgKiBAcHJvcGVydHkge0Fubm91bmNlbWVudH0gUGx1Z2lucy5Bbm5vdW5jZW1lbnRcclxuICAgKiBAcHJvcGVydHkge0ZvY3VzYWJsZX0gUGx1Z2lucy5Gb2N1c2FibGVcclxuICAgKiBAcHJvcGVydHkge01pcnJvcn0gUGx1Z2lucy5NaXJyb3JcclxuICAgKiBAcHJvcGVydHkge1Njcm9sbGFibGV9IFBsdWdpbnMuU2Nyb2xsYWJsZVxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtkb2N1bWVudC5ib2R5XSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZSBjb250YWluZXJzXHJcbiAgICAgKiBAcHJvcGVydHkgY29udGFpbmVyc1xyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XHJcbiAgICAgKi9cclxuICAgIGlmIChjb250YWluZXJzIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgY29udGFpbmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi5jb250YWluZXJzXTtcclxuICAgIH0gZWxzZSBpZiAoY29udGFpbmVycyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuY29udGFpbmVycyA9IFtjb250YWluZXJzXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRHJhZ2dhYmxlIGNvbnRhaW5lcnMgYXJlIGV4cGVjdGVkIHRvIGJlIG9mIHR5cGUgYE5vZGVMaXN0YCwgYEhUTUxFbGVtZW50W11gIG9yIGBIVE1MRWxlbWVudGAnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMsIHtcclxuICAgICAgY2xhc3NlczogX2V4dGVuZHMoe30sIGRlZmF1bHRDbGFzc2VzLCBvcHRpb25zLmNsYXNzZXMgfHwge30pLFxyXG4gICAgICBhbm5vdW5jZW1lbnRzOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdEFubm91bmNlbWVudHMsIG9wdGlvbnMuYW5ub3VuY2VtZW50cyB8fCB7fSksXHJcbiAgICAgIGV4Y2x1ZGU6IHtcclxuICAgICAgICBwbHVnaW5zOiBvcHRpb25zLmV4Y2x1ZGUgJiYgb3B0aW9ucy5leGNsdWRlLnBsdWdpbnMgfHwgW10sXHJcbiAgICAgICAgc2Vuc29yczogb3B0aW9ucy5leGNsdWRlICYmIG9wdGlvbnMuZXhjbHVkZS5zZW5zb3JzIHx8IFtdXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhZ2dhYmxlcyBldmVudCBlbWl0dGVyXHJcbiAgICAgKiBAcHJvcGVydHkgZW1pdHRlclxyXG4gICAgICogQHR5cGUge0VtaXR0ZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZW1pdHRlciA9IG5ldyBfRW1pdHRlcjIuZGVmYXVsdCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBkcmFnIHN0YXRlXHJcbiAgICAgKiBAcHJvcGVydHkgZHJhZ2dpbmdcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmUgcGx1Z2luc1xyXG4gICAgICogQHByb3BlcnR5IHBsdWdpbnNcclxuICAgICAqIEB0eXBlIHtQbHVnaW5bXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5wbHVnaW5zID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmUgc2Vuc29yc1xyXG4gICAgICogQHByb3BlcnR5IHNlbnNvcnNcclxuICAgICAqIEB0eXBlIHtTZW5zb3JbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZW5zb3JzID0gW107XHJcblxyXG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1ByZXNzdXJlXSA9IHRoaXNbb25EcmFnUHJlc3N1cmVdLmJpbmQodGhpcyk7XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOnByZXNzdXJlJywgdGhpc1tvbkRyYWdQcmVzc3VyZV0sIHRydWUpO1xyXG5cclxuICAgIGNvbnN0IGRlZmF1bHRQbHVnaW5zID0gT2JqZWN0LnZhbHVlcyhEcmFnZ2FibGUuUGx1Z2lucykuZmlsdGVyKFBsdWdpbiA9PiAhdGhpcy5vcHRpb25zLmV4Y2x1ZGUucGx1Z2lucy5pbmNsdWRlcyhQbHVnaW4pKTtcclxuICAgIGNvbnN0IGRlZmF1bHRTZW5zb3JzID0gT2JqZWN0LnZhbHVlcyhEcmFnZ2FibGUuU2Vuc29ycykuZmlsdGVyKHNlbnNvciA9PiAhdGhpcy5vcHRpb25zLmV4Y2x1ZGUuc2Vuc29ycy5pbmNsdWRlcyhzZW5zb3IpKTtcclxuXHJcbiAgICB0aGlzLmFkZFBsdWdpbiguLi5bLi4uZGVmYXVsdFBsdWdpbnMsIC4uLnRoaXMub3B0aW9ucy5wbHVnaW5zXSk7XHJcbiAgICB0aGlzLmFkZFNlbnNvciguLi5bLi4uZGVmYXVsdFNlbnNvcnMsIC4uLnRoaXMub3B0aW9ucy5zZW5zb3JzXSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCA9IG5ldyBfRHJhZ2dhYmxlRXZlbnQuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCh7XHJcbiAgICAgIGRyYWdnYWJsZTogdGhpc1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5vbignbWlycm9yOmNyZWF0ZWQnLCAoeyBtaXJyb3IgfSkgPT4gdGhpcy5taXJyb3IgPSBtaXJyb3IpO1xyXG4gICAgdGhpcy5vbignbWlycm9yOmRlc3Ryb3knLCAoKSA9PiB0aGlzLm1pcnJvciA9IG51bGwpO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3lzIERyYWdnYWJsZSBpbnN0YW5jZS4gVGhpcyByZW1vdmVzIGFsbCBpbnRlcm5hbCBldmVudCBsaXN0ZW5lcnMgYW5kXHJcbiAgICogZGVhY3RpdmF0ZXMgc2Vuc29ycyBhbmQgcGx1Z2luc1xyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRGVmYXVsdCBzZW5zb3JzIGRyYWdnYWJsZSB1c2VzXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBTZW5zb3JzXHJcbiAgICogQHByb3BlcnR5IHtNb3VzZVNlbnNvcn0gU2Vuc29ycy5Nb3VzZVNlbnNvclxyXG4gICAqIEBwcm9wZXJ0eSB7VG91Y2hTZW5zb3J9IFNlbnNvcnMuVG91Y2hTZW5zb3JcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6cHJlc3N1cmUnLCB0aGlzW29uRHJhZ1ByZXNzdXJlXSwgdHJ1ZSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ2dhYmxlRGVzdHJveUV2ZW50ID0gbmV3IF9EcmFnZ2FibGVFdmVudC5EcmFnZ2FibGVEZXN0cm95RXZlbnQoe1xyXG4gICAgICBkcmFnZ2FibGU6IHRoaXNcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnZ2FibGVEZXN0cm95RXZlbnQpO1xyXG5cclxuICAgIHRoaXMucmVtb3ZlUGx1Z2luKC4uLnRoaXMucGx1Z2lucy5tYXAocGx1Z2luID0+IHBsdWdpbi5jb25zdHJ1Y3RvcikpO1xyXG4gICAgdGhpcy5yZW1vdmVTZW5zb3IoLi4udGhpcy5zZW5zb3JzLm1hcChzZW5zb3IgPT4gc2Vuc29yLmNvbnN0cnVjdG9yKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIHBsdWdpbiB0byB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZS4gVGhpcyB3aWxsIGVuZCB1cCBjYWxsaW5nIHRoZSBhdHRhY2ggbWV0aG9kIG9mIHRoZSBwbHVnaW5cclxuICAgKiBAcGFyYW0gey4uLnR5cGVvZiBQbHVnaW59IHBsdWdpbnMgLSBQbHVnaW5zIHRoYXQgeW91IHdhbnQgYXR0YWNoZWQgdG8gZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5hZGRQbHVnaW4oQ3VzdG9tQTExeVBsdWdpbiwgQ3VzdG9tTWlycm9yUGx1Z2luKVxyXG4gICAqL1xyXG4gIGFkZFBsdWdpbiguLi5wbHVnaW5zKSB7XHJcbiAgICBjb25zdCBhY3RpdmVQbHVnaW5zID0gcGx1Z2lucy5tYXAoUGx1Z2luID0+IG5ldyBQbHVnaW4odGhpcykpO1xyXG5cclxuICAgIGFjdGl2ZVBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4gcGx1Z2luLmF0dGFjaCgpKTtcclxuICAgIHRoaXMucGx1Z2lucyA9IFsuLi50aGlzLnBsdWdpbnMsIC4uLmFjdGl2ZVBsdWdpbnNdO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBwbHVnaW5zIHRoYXQgYXJlIGFscmVhZHkgYXR0YWNoZWQgdG8gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2UuIFRoaXMgd2lsbCBlbmQgdXAgY2FsbGluZ1xyXG4gICAqIHRoZSBkZXRhY2ggbWV0aG9kIG9mIHRoZSBwbHVnaW5cclxuICAgKiBAcGFyYW0gey4uLnR5cGVvZiBQbHVnaW59IHBsdWdpbnMgLSBQbHVnaW5zIHRoYXQgeW91IHdhbnQgZGV0YWNoZWQgZnJvbSBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLnJlbW92ZVBsdWdpbihNaXJyb3JQbHVnaW4sIEN1c3RvbU1pcnJvclBsdWdpbilcclxuICAgKi9cclxuICByZW1vdmVQbHVnaW4oLi4ucGx1Z2lucykge1xyXG4gICAgY29uc3QgcmVtb3ZlZFBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiBwbHVnaW5zLmluY2x1ZGVzKHBsdWdpbi5jb25zdHJ1Y3RvcikpO1xyXG5cclxuICAgIHJlbW92ZWRQbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHBsdWdpbi5kZXRhY2goKSk7XHJcbiAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiAhcGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4uY29uc3RydWN0b3IpKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgc2Vuc29ycyB0byB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZS4gVGhpcyB3aWxsIGVuZCB1cCBjYWxsaW5nIHRoZSBhdHRhY2ggbWV0aG9kIG9mIHRoZSBzZW5zb3JcclxuICAgKiBAcGFyYW0gey4uLnR5cGVvZiBTZW5zb3J9IHNlbnNvcnMgLSBTZW5zb3JzIHRoYXQgeW91IHdhbnQgYXR0YWNoZWQgdG8gZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5hZGRTZW5zb3IoRm9yY2VUb3VjaFNlbnNvciwgQ3VzdG9tU2Vuc29yKVxyXG4gICAqL1xyXG4gIGFkZFNlbnNvciguLi5zZW5zb3JzKSB7XHJcbiAgICBjb25zdCBhY3RpdmVTZW5zb3JzID0gc2Vuc29ycy5tYXAoU2Vuc29yID0+IG5ldyBTZW5zb3IodGhpcy5jb250YWluZXJzLCB0aGlzLm9wdGlvbnMpKTtcclxuXHJcbiAgICBhY3RpdmVTZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5hdHRhY2goKSk7XHJcbiAgICB0aGlzLnNlbnNvcnMgPSBbLi4udGhpcy5zZW5zb3JzLCAuLi5hY3RpdmVTZW5zb3JzXTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgc2Vuc29ycyB0aGF0IGFyZSBhbHJlYWR5IGF0dGFjaGVkIHRvIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlLiBUaGlzIHdpbGwgZW5kIHVwIGNhbGxpbmdcclxuICAgKiB0aGUgZGV0YWNoIG1ldGhvZCBvZiB0aGUgc2Vuc29yXHJcbiAgICogQHBhcmFtIHsuLi50eXBlb2YgU2Vuc29yfSBzZW5zb3JzIC0gU2Vuc29ycyB0aGF0IHlvdSB3YW50IGF0dGFjaGVkIHRvIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUucmVtb3ZlU2Vuc29yKFRvdWNoU2Vuc29yLCBEcmFnU2Vuc29yKVxyXG4gICAqL1xyXG4gIHJlbW92ZVNlbnNvciguLi5zZW5zb3JzKSB7XHJcbiAgICBjb25zdCByZW1vdmVkU2Vuc29ycyA9IHRoaXMuc2Vuc29ycy5maWx0ZXIoc2Vuc29yID0+IHNlbnNvcnMuaW5jbHVkZXMoc2Vuc29yLmNvbnN0cnVjdG9yKSk7XHJcblxyXG4gICAgcmVtb3ZlZFNlbnNvcnMuZm9yRWFjaChzZW5zb3IgPT4gc2Vuc29yLmRldGFjaCgpKTtcclxuICAgIHRoaXMuc2Vuc29ycyA9IHRoaXMuc2Vuc29ycy5maWx0ZXIoc2Vuc29yID0+ICFzZW5zb3JzLmluY2x1ZGVzKHNlbnNvci5jb25zdHJ1Y3RvcikpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBjb250YWluZXIgdG8gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0gey4uLkhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVycyB5b3Ugd2FudCB0byBhZGQgdG8gZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5hZGRDb250YWluZXIoZG9jdW1lbnQuYm9keSlcclxuICAgKi9cclxuICBhZGRDb250YWluZXIoLi4uY29udGFpbmVycykge1xyXG4gICAgdGhpcy5jb250YWluZXJzID0gWy4uLnRoaXMuY29udGFpbmVycywgLi4uY29udGFpbmVyc107XHJcbiAgICB0aGlzLnNlbnNvcnMuZm9yRWFjaChzZW5zb3IgPT4gc2Vuc29yLmFkZENvbnRhaW5lciguLi5jb250YWluZXJzKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgY29udGFpbmVyIGZyb20gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0gey4uLkhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVycyB5b3Ugd2FudCB0byByZW1vdmUgZnJvbSBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLnJlbW92ZUNvbnRhaW5lcihkb2N1bWVudC5ib2R5KVxyXG4gICAqL1xyXG4gIHJlbW92ZUNvbnRhaW5lciguLi5jb250YWluZXJzKSB7XHJcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSB0aGlzLmNvbnRhaW5lcnMuZmlsdGVyKGNvbnRhaW5lciA9PiAhY29udGFpbmVycy5pbmNsdWRlcyhjb250YWluZXIpKTtcclxuICAgIHRoaXMuc2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IucmVtb3ZlQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBsaXN0ZW5lciBmb3IgZHJhZ2dhYmxlIGV2ZW50c1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gRXZlbnQgbmFtZVxyXG4gICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGNhbGxiYWNrcyAtIEV2ZW50IGNhbGxiYWNrc1xyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCAoZHJhZ0V2ZW50KSA9PiBkcmFnRXZlbnQuY2FuY2VsKCkpO1xyXG4gICAqL1xyXG4gIG9uKHR5cGUsIC4uLmNhbGxiYWNrcykge1xyXG4gICAgdGhpcy5lbWl0dGVyLm9uKHR5cGUsIC4uLmNhbGxiYWNrcyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgbGlzdGVuZXIgZnJvbSBkcmFnZ2FibGVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIEV2ZW50IG5hbWVcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEV2ZW50IGNhbGxiYWNrXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCBoYW5kbGVyRnVuY3Rpb24pO1xyXG4gICAqL1xyXG4gIG9mZih0eXBlLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5lbWl0dGVyLm9mZih0eXBlLCBjYWxsYmFjayk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXJzIGRyYWdnYWJsZSBldmVudFxyXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RFdmVudH0gZXZlbnQgLSBFdmVudCBpbnN0YW5jZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUudHJpZ2dlcihldmVudCk7XHJcbiAgICovXHJcbiAgdHJpZ2dlcihldmVudCkge1xyXG4gICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoZXZlbnQpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGNsYXNzIG5hbWUgZm9yIGNsYXNzIGlkZW50aWZpZXJcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgY2xhc3MgaWRlbnRpZmllclxyXG4gICAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxyXG4gICAqL1xyXG4gIGdldENsYXNzTmFtZUZvcihuYW1lKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRDbGFzc05hbWVzRm9yKG5hbWUpWzBdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjbGFzcyBuYW1lcyBmb3IgY2xhc3MgaWRlbnRpZmllclxyXG4gICAqIEByZXR1cm4ge1N0cmluZ1tdfVxyXG4gICAqL1xyXG4gIGdldENsYXNzTmFtZXNGb3IobmFtZSkge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IHRoaXMub3B0aW9ucy5jbGFzc2VzW25hbWVdO1xyXG5cclxuICAgIGlmIChjbGFzc05hbWVzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjbGFzc05hbWVzID09PSAnc3RyaW5nJyB8fCBjbGFzc05hbWVzIGluc3RhbmNlb2YgU3RyaW5nKSB7XHJcbiAgICAgIHJldHVybiBbY2xhc3NOYW1lc107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2UgaXMgY3VycmVudGx5IGRyYWdnaW5nXHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBpc0RyYWdnaW5nKCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5kcmFnZ2luZyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFsbCBkcmFnZ2FibGUgZWxlbWVudHNcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudFtdfVxyXG4gICAqL1xyXG4gIGdldERyYWdnYWJsZUVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVycy5yZWR1Y2UoKGN1cnJlbnQsIGNvbnRhaW5lcikgPT4ge1xyXG4gICAgICByZXR1cm4gWy4uLmN1cnJlbnQsIC4uLnRoaXMuZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIoY29udGFpbmVyKV07XHJcbiAgICB9LCBbXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGRyYWdnYWJsZSBlbGVtZW50cyBmb3IgYSBnaXZlbiBjb250YWluZXIsIGV4Y2x1ZGluZyB0aGUgbWlycm9yIGFuZFxyXG4gICAqIG9yaWdpbmFsIHNvdXJjZSBlbGVtZW50IGlmIHByZXNlbnRcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudFtdfVxyXG4gICAqL1xyXG4gIGdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gICAgY29uc3QgYWxsRHJhZ2dhYmxlRWxlbWVudHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcclxuXHJcbiAgICByZXR1cm4gWy4uLmFsbERyYWdnYWJsZUVsZW1lbnRzXS5maWx0ZXIoY2hpbGRFbGVtZW50ID0+IHtcclxuICAgICAgcmV0dXJuIGNoaWxkRWxlbWVudCAhPT0gdGhpcy5vcmlnaW5hbFNvdXJjZSAmJiBjaGlsZEVsZW1lbnQgIT09IHRoaXMubWlycm9yO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRE9NIERyYWcgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RhcnRdKGV2ZW50KSB7XHJcbiAgICBjb25zdCBzZW5zb3JFdmVudCA9IGdldFNlbnNvckV2ZW50KGV2ZW50KTtcclxuICAgIGNvbnN0IHsgdGFyZ2V0LCBjb250YWluZXIgfSA9IHNlbnNvckV2ZW50O1xyXG5cclxuICAgIGlmICghdGhpcy5jb250YWluZXJzLmluY2x1ZGVzKGNvbnRhaW5lcikpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlICYmIHRhcmdldCAmJiAhKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIHRoaXMub3B0aW9ucy5oYW5kbGUpKSB7XHJcbiAgICAgIHNlbnNvckV2ZW50LmNhbmNlbCgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmluZCBkcmFnZ2FibGUgc291cmNlIGVsZW1lbnRcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XHJcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuXHJcbiAgICBpZiAoIXRoaXMub3JpZ2luYWxTb3VyY2UpIHtcclxuICAgICAgc2Vuc29yRXZlbnQuY2FuY2VsKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5sYXN0UGxhY2VkU291cmNlICYmIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lcikge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5wbGFjZWRUaW1lb3V0SUQpO1xyXG4gICAgICB0aGlzLmxhc3RQbGFjZWRTb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XHJcbiAgICAgIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOnBsYWNlZCcpKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNvdXJjZSA9IHRoaXMub3JpZ2luYWxTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnNvdXJjZSwgdGhpcy5vcmlnaW5hbFNvdXJjZSk7XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgY29uc3QgZHJhZ0V2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ1N0YXJ0RXZlbnQoe1xyXG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ0V2ZW50KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdFdmVudC5jYW5jZWxlZCgpO1xyXG5cclxuICAgIGlmIChkcmFnRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICB0aGlzLnNvdXJjZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc291cmNlKTtcclxuICAgICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpvcmlnaW5hbCcpKTtcclxuICAgIHRoaXMuc291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6ZHJhZ2dpbmcnKSk7XHJcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOmRyYWdnaW5nJykpO1xyXG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignYm9keTpkcmFnZ2luZycpKTtcclxuICAgIGFwcGx5VXNlclNlbGVjdChkb2N1bWVudC5ib2R5LCAnbm9uZScpO1xyXG5cclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG9sZFNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xyXG4gICAgICBjb25zdCBuZXdTZW5zb3JFdmVudCA9IG9sZFNlbnNvckV2ZW50LmNsb25lKHsgdGFyZ2V0OiB0aGlzLnNvdXJjZSB9KTtcclxuXHJcbiAgICAgIHRoaXNbb25EcmFnTW92ZV0oX2V4dGVuZHMoe30sIGV2ZW50LCB7XHJcbiAgICAgICAgZGV0YWlsOiBuZXdTZW5zb3JFdmVudFxyXG4gICAgICB9KSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgbW92ZSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERPTSBEcmFnIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ01vdmVdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xyXG4gICAgY29uc3QgeyBjb250YWluZXIgfSA9IHNlbnNvckV2ZW50O1xyXG4gICAgbGV0IHRhcmdldCA9IHNlbnNvckV2ZW50LnRhcmdldDtcclxuXHJcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ01vdmVFdmVudCh7XHJcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnTW92ZUV2ZW50KTtcclxuXHJcbiAgICBpZiAoZHJhZ01vdmVFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHNlbnNvckV2ZW50LmNhbmNlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRhcmdldCA9ICgwLCBfdXRpbHMuY2xvc2VzdCkodGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcclxuICAgIGNvbnN0IHdpdGhpbkNvcnJlY3RDb250YWluZXIgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKHNlbnNvckV2ZW50LnRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcclxuICAgIGNvbnN0IG92ZXJDb250YWluZXIgPSBzZW5zb3JFdmVudC5vdmVyQ29udGFpbmVyIHx8IHdpdGhpbkNvcnJlY3RDb250YWluZXI7XHJcbiAgICBjb25zdCBpc0xlYXZpbmdDb250YWluZXIgPSB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyICYmIG92ZXJDb250YWluZXIgIT09IHRoaXMuY3VycmVudE92ZXJDb250YWluZXI7XHJcbiAgICBjb25zdCBpc0xlYXZpbmdEcmFnZ2FibGUgPSB0aGlzLmN1cnJlbnRPdmVyICYmIHRhcmdldCAhPT0gdGhpcy5jdXJyZW50T3ZlcjtcclxuICAgIGNvbnN0IGlzT3ZlckNvbnRhaW5lciA9IG92ZXJDb250YWluZXIgJiYgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciAhPT0gb3ZlckNvbnRhaW5lcjtcclxuICAgIGNvbnN0IGlzT3ZlckRyYWdnYWJsZSA9IHdpdGhpbkNvcnJlY3RDb250YWluZXIgJiYgdGFyZ2V0ICYmIHRoaXMuY3VycmVudE92ZXIgIT09IHRhcmdldDtcclxuXHJcbiAgICBpZiAoaXNMZWF2aW5nRHJhZ2dhYmxlKSB7XHJcbiAgICAgIGNvbnN0IGRyYWdPdXRFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdPdXRFdmVudCh7XHJcbiAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcclxuICAgICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgICBvdmVyOiB0aGlzLmN1cnJlbnRPdmVyLFxyXG4gICAgICAgIG92ZXJDb250YWluZXI6IHRoaXMuY3VycmVudE92ZXJDb250YWluZXJcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcmFnZ2FibGU6b3ZlcicpKTtcclxuICAgICAgdGhpcy5jdXJyZW50T3ZlciA9IG51bGw7XHJcblxyXG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ091dEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNMZWF2aW5nQ29udGFpbmVyKSB7XHJcbiAgICAgIGNvbnN0IGRyYWdPdXRDb250YWluZXJFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdPdXRDb250YWluZXJFdmVudCh7XHJcbiAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcclxuICAgICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgICBvdmVyQ29udGFpbmVyOiB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOm92ZXInKSk7XHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgPSBudWxsO1xyXG5cclxuICAgICAgdGhpcy50cmlnZ2VyKGRyYWdPdXRDb250YWluZXJFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzT3ZlckNvbnRhaW5lcikge1xyXG4gICAgICBvdmVyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6b3ZlcicpKTtcclxuXHJcbiAgICAgIGNvbnN0IGRyYWdPdmVyQ29udGFpbmVyRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnT3ZlckNvbnRhaW5lckV2ZW50KHtcclxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG92ZXJDb250YWluZXJcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyID0gb3ZlckNvbnRhaW5lcjtcclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3ZlckNvbnRhaW5lckV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNPdmVyRHJhZ2dhYmxlKSB7XHJcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJhZ2dhYmxlOm92ZXInKSk7XHJcblxyXG4gICAgICBjb25zdCBkcmFnT3ZlckV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ092ZXJFdmVudCh7XHJcbiAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcclxuICAgICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgICBvdmVyQ29udGFpbmVyLFxyXG4gICAgICAgIG92ZXI6IHRhcmdldFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXIgPSB0YXJnZXQ7XHJcblxyXG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ092ZXJFdmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0b3AgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBET00gRHJhZyBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdG9wXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdTdG9wRXZlbnQoe1xyXG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc2Vuc29yRXZlbnQ6IGV2ZW50LnNlbnNvckV2ZW50LFxyXG4gICAgICBzb3VyY2VDb250YWluZXI6IHRoaXMuc291cmNlQ29udGFpbmVyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ1N0b3BFdmVudCk7XHJcblxyXG4gICAgdGhpcy5zb3VyY2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5vcmlnaW5hbFNvdXJjZSwgdGhpcy5zb3VyY2UpO1xyXG4gICAgdGhpcy5zb3VyY2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNvdXJjZSk7XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuXHJcbiAgICB0aGlzLnNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOmRyYWdnaW5nJykpO1xyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOm9yaWdpbmFsJykpO1xyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcclxuICAgIHRoaXMuc291cmNlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6cGxhY2VkJykpO1xyXG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpkcmFnZ2luZycpKTtcclxuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2JvZHk6ZHJhZ2dpbmcnKSk7XHJcbiAgICBhcHBseVVzZXJTZWxlY3QoZG9jdW1lbnQuYm9keSwgJycpO1xyXG5cclxuICAgIGlmICh0aGlzLmN1cnJlbnRPdmVyKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2RyYWdnYWJsZTpvdmVyJykpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpvdmVyJykpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZSA9IHRoaXMub3JpZ2luYWxTb3VyY2U7XHJcbiAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIgPSB0aGlzLnNvdXJjZUNvbnRhaW5lcjtcclxuXHJcbiAgICB0aGlzLnBsYWNlZFRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy5sYXN0UGxhY2VkU291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0UGxhY2VkU291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6cGxhY2VkJykpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmxhc3RQbGFjZWRTb3VyY2UgPSBudWxsO1xyXG4gICAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIgPSBudWxsO1xyXG4gICAgfSwgdGhpcy5vcHRpb25zLnBsYWNlZFRpbWVvdXQpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdG9wcGVkRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnU3RvcHBlZEV2ZW50KHtcclxuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNlbnNvckV2ZW50OiBldmVudC5zZW5zb3JFdmVudCxcclxuICAgICAgc291cmNlQ29udGFpbmVyOiB0aGlzLnNvdXJjZUNvbnRhaW5lclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdTdG9wcGVkRXZlbnQpO1xyXG5cclxuICAgIHRoaXMuc291cmNlID0gbnVsbDtcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UgPSBudWxsO1xyXG4gICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciA9IG51bGw7XHJcbiAgICB0aGlzLmN1cnJlbnRPdmVyID0gbnVsbDtcclxuICAgIHRoaXMuc291cmNlQ29udGFpbmVyID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgcHJlc3N1cmUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBET00gRHJhZyBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdQcmVzc3VyZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XHJcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZSB8fCAoMCwgX3V0aWxzLmNsb3Nlc3QpKHNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcclxuXHJcbiAgICBjb25zdCBkcmFnUHJlc3N1cmVFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdQcmVzc3VyZUV2ZW50KHtcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgcHJlc3N1cmU6IHNlbnNvckV2ZW50LnByZXNzdXJlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ1ByZXNzdXJlRXZlbnQpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ2dhYmxlO1xyXG5EcmFnZ2FibGUuUGx1Z2lucyA9IHsgQW5ub3VuY2VtZW50OiBfUGx1Z2lucy5Bbm5vdW5jZW1lbnQsIEZvY3VzYWJsZTogX1BsdWdpbnMuRm9jdXNhYmxlLCBNaXJyb3I6IF9QbHVnaW5zLk1pcnJvciwgU2Nyb2xsYWJsZTogX1BsdWdpbnMuU2Nyb2xsYWJsZSB9O1xyXG5EcmFnZ2FibGUuU2Vuc29ycyA9IHsgTW91c2VTZW5zb3I6IF9TZW5zb3JzLk1vdXNlU2Vuc29yLCBUb3VjaFNlbnNvcjogX1NlbnNvcnMuVG91Y2hTZW5zb3IgfTtcclxuZnVuY3Rpb24gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpIHtcclxuICByZXR1cm4gZXZlbnQuZGV0YWlsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVVzZXJTZWxlY3QoZWxlbWVudCwgdmFsdWUpIHtcclxuICBlbGVtZW50LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSB2YWx1ZTtcclxuICBlbGVtZW50LnN0eWxlLm1velVzZXJTZWxlY3QgPSB2YWx1ZTtcclxuICBlbGVtZW50LnN0eWxlLm1zVXNlclNlbGVjdCA9IHZhbHVlO1xyXG4gIGVsZW1lbnQuc3R5bGUub1VzZXJTZWxlY3QgPSB2YWx1ZTtcclxuICBlbGVtZW50LnN0eWxlLnVzZXJTZWxlY3QgPSB2YWx1ZTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uTW91c2VGb3JjZVdpbGxCZWdpbiA9IFN5bWJvbCgnb25Nb3VzZUZvcmNlV2lsbEJlZ2luJyk7XHJcbmNvbnN0IG9uTW91c2VGb3JjZURvd24gPSBTeW1ib2woJ29uTW91c2VGb3JjZURvd24nKTtcclxuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XHJcbmNvbnN0IG9uTW91c2VGb3JjZUNoYW5nZSA9IFN5bWJvbCgnb25Nb3VzZUZvcmNlQ2hhbmdlJyk7XHJcbmNvbnN0IG9uTW91c2VNb3ZlID0gU3ltYm9sKCdvbk1vdXNlTW92ZScpO1xyXG5jb25zdCBvbk1vdXNlVXAgPSBTeW1ib2woJ29uTW91c2VVcCcpO1xyXG5jb25zdCBvbk1vdXNlRm9yY2VHbG9iYWxDaGFuZ2UgPSBTeW1ib2woJ29uTW91c2VGb3JjZUdsb2JhbENoYW5nZScpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgc2Vuc29yIHBpY2tzIHVwIG5hdGl2ZSBmb3JjZSB0b3VjaCBldmVudHMgYW5kIGRpY3RhdGVzIGRyYWcgb3BlcmF0aW9uc1xyXG4gKiBAY2xhc3MgRm9yY2VUb3VjaFNlbnNvclxyXG4gKiBAbW9kdWxlIEZvcmNlVG91Y2hTZW5zb3JcclxuICogQGV4dGVuZHMgU2Vuc29yXHJcbiAqL1xyXG5jbGFzcyBGb3JjZVRvdWNoU2Vuc29yIGV4dGVuZHMgX1NlbnNvcjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogRm9yY2VUb3VjaFNlbnNvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBGb3JjZVRvdWNoU2Vuc29yXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZSBlbGVtZW50IG5lZWRzIHRvIGJlIHJlbWVtYmVyZWQgdG8gdW5zZXQgdGhlIGRyYWdnYWJsZSBhdHRyaWJ1dGUgYWZ0ZXIgZHJhZyBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZFxyXG4gICAgICogQHByb3BlcnR5IG1pZ2h0RHJhZ1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWlnaHREcmFnID0gZmFsc2U7XHJcblxyXG4gICAgdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dID0gdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VGb3JjZURvd25dID0gdGhpc1tvbk1vdXNlRm9yY2VEb3duXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlRG93bl0gPSB0aGlzW29uTW91c2VEb3duXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdID0gdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VNb3ZlXSA9IHRoaXNbb25Nb3VzZU1vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VVcF0gPSB0aGlzW29uTW91c2VVcF0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICBmb3IgKGNvbnN0IGNvbnRhaW5lciBvZiB0aGlzLmNvbnRhaW5lcnMpIHtcclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2V3aWxsYmVnaW4nLCB0aGlzW29uTW91c2VGb3JjZVdpbGxCZWdpbl0sIGZhbHNlKTtcclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2Vkb3duJywgdGhpc1tvbk1vdXNlRm9yY2VEb3duXSwgZmFsc2UpO1xyXG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZWNoYW5nZWQnLCB0aGlzW29uTW91c2VGb3JjZUNoYW5nZV0sIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uTW91c2VNb3ZlXSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICBmb3IgKGNvbnN0IGNvbnRhaW5lciBvZiB0aGlzLmNvbnRhaW5lcnMpIHtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2V3aWxsYmVnaW4nLCB0aGlzW29uTW91c2VGb3JjZVdpbGxCZWdpbl0sIGZhbHNlKTtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2Vkb3duJywgdGhpc1tvbk1vdXNlRm9yY2VEb3duXSwgZmFsc2UpO1xyXG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZWNoYW5nZWQnLCB0aGlzW29uTW91c2VGb3JjZUNoYW5nZV0sIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uTW91c2VNb3ZlXSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGZvcmNlIHdpbGwgYmVnaW4gaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBmb3JjZSB3aWxsIGJlZ2luIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VGb3JjZVdpbGxCZWdpbl0oZXZlbnQpIHtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBmb3JjZSBkb3duIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2UgZG93biBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRm9yY2VEb3duXShldmVudCkge1xyXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RhcnRTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGNvbnRhaW5lciwgZHJhZ1N0YXJ0RXZlbnQpO1xyXG5cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIHRoaXMuZHJhZ2dpbmcgPSAhZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKTtcclxuICAgIHRoaXMubWlnaHREcmFnID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSB1cCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIHVwIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VVcF0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0b3BTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldDogbnVsbCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RvcEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBudWxsO1xyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5taWdodERyYWcgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGRvd24gaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBkb3duIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VEb3duXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLm1pZ2h0RHJhZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTmVlZCB3b3JrYXJvdW5kIGZvciByZWFsIGNsaWNrXHJcbiAgICAvLyBDYW5jZWwgcG90ZW50aWFsIGRyYWcgZXZlbnRzXHJcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIG1vdmUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBmb3JjZSB3aWxsIGJlZ2luIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VNb3ZlXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdNb3ZlU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ01vdmVFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBmb3JjZSBjaGFuZ2UgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBmb3JjZSBjaGFuZ2UgZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZUZvcmNlQ2hhbmdlXShldmVudCkge1xyXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XHJcblxyXG4gICAgY29uc3QgZHJhZ1ByZXNzdXJlRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdQcmVzc3VyZVNlbnNvckV2ZW50KHtcclxuICAgICAgcHJlc3N1cmU6IGV2ZW50LndlYmtpdEZvcmNlLFxyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdQcmVzc3VyZUV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGZvcmNlIGdsb2JhbCBjaGFuZ2UgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBmb3JjZSBnbG9iYWwgY2hhbmdlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VGb3JjZUdsb2JhbENoYW5nZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuICAgIGNvbnN0IGRyYWdQcmVzc3VyZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnUHJlc3N1cmVTZW5zb3JFdmVudCh7XHJcbiAgICAgIHByZXNzdXJlOiBldmVudC53ZWJraXRGb3JjZSxcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdQcmVzc3VyZUV2ZW50KTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gRm9yY2VUb3VjaFNlbnNvcjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRm9yY2VUb3VjaFNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cclxudmFyIF9Gb3JjZVRvdWNoU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZvcmNlVG91Y2hTZW5zb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Gb3JjZVRvdWNoU2Vuc29yMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG52YXIgX1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpO1xyXG5cclxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XHJcbmNvbnN0IG9uTW91c2VVcCA9IFN5bWJvbCgnb25Nb3VzZVVwJyk7XHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdPdmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyJyk7XHJcbmNvbnN0IG9uRHJhZ0VuZCA9IFN5bWJvbCgnb25EcmFnRW5kJyk7XHJcbmNvbnN0IG9uRHJvcCA9IFN5bWJvbCgnb25Ecm9wJyk7XHJcbmNvbnN0IHJlc2V0ID0gU3ltYm9sKCdyZXNldCcpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgc2Vuc29yIHBpY2tzIHVwIG5hdGl2ZSBicm93c2VyIGRyYWcgZXZlbnRzIGFuZCBkaWN0YXRlcyBkcmFnIG9wZXJhdGlvbnNcclxuICogQGNsYXNzIERyYWdTZW5zb3JcclxuICogQG1vZHVsZSBEcmFnU2Vuc29yXHJcbiAqIEBleHRlbmRzIFNlbnNvclxyXG4gKi9cclxuY2xhc3MgRHJhZ1NlbnNvciBleHRlbmRzIF9TZW5zb3IyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIERyYWdTZW5zb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgRHJhZ1NlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBkb3duIHRpbWVyIHdoaWNoIHdpbGwgZW5kIHVwIHNldHRpbmcgdGhlIGRyYWdnYWJsZSBhdHRyaWJ1dGUsIHVubGVzcyBjYW5jZWxlZFxyXG4gICAgICogQHByb3BlcnR5IG1vdXNlRG93blRpbWVvdXRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubW91c2VEb3duVGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmFnZ2FibGUgZWxlbWVudCBuZWVkcyB0byBiZSByZW1lbWJlcmVkIHRvIHVuc2V0IHRoZSBkcmFnZ2FibGUgYXR0cmlidXRlIGFmdGVyIGRyYWcgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWRcclxuICAgICAqIEBwcm9wZXJ0eSBkcmFnZ2FibGVFbGVtZW50XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJhZ2dhYmxlRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOYXRpdmUgZHJhZ2dhYmxlIGVsZW1lbnQgY291bGQgYmUgbGlua3Mgb3IgaW1hZ2VzLCB0aGVpciBkcmFnZ2FibGUgc3RhdGUgd2lsbCBiZSBkaXNhYmxlZCBkdXJpbmcgZHJhZyBvcGVyYXRpb25cclxuICAgICAqIEBwcm9wZXJ0eSBuYXRpdmVEcmFnZ2FibGVFbGVtZW50XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvbk1vdXNlRG93bl0gPSB0aGlzW29uTW91c2VEb3duXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlVXBdID0gdGhpc1tvbk1vdXNlVXBdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ092ZXJdID0gdGhpc1tvbkRyYWdPdmVyXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdFbmRdID0gdGhpc1tvbkRyYWdFbmRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJvcF0gPSB0aGlzW29uRHJvcF0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdGFydCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERyYWcgc3RhcnQgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RhcnRdKGV2ZW50KSB7XHJcbiAgICAvLyBOZWVkIGZvciBmaXJlZm94LiBcInRleHRcIiBrZXkgaXMgbmVlZGVkIGZvciBJRVxyXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoJ3RleHQnLCAnJyk7XHJcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IHRoaXMub3B0aW9ucy50eXBlO1xyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGV2ZW50LnRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuY3VycmVudENvbnRhaW5lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdGFydFNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFdvcmthcm91bmRcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XHJcblxyXG4gICAgICBpZiAoZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSwgMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG92ZXIgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBEcmFnIG92ZXIgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnT3Zlcl0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbnRhaW5lcjtcclxuXHJcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnTW92ZVNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcclxuXHJcbiAgICBpZiAoIWRyYWdNb3ZlRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IHRoaXMub3B0aW9ucy50eXBlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBlbmQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBEcmFnIGVuZCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdFbmRdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0sIHRydWUpO1xyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0b3BTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGNvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5zdGFydEV2ZW50ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW3Jlc2V0XSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJvcCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERyb3AgZXZlbnRcclxuICAgKi9cclxuICBbb25Ecm9wXShldmVudCkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZG93biBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGRvd24gZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZURvd25dKGV2ZW50KSB7XHJcbiAgICAvLyBGaXJlZm94IGJ1ZyBmb3IgaW5wdXRzIHdpdGhpbiBkcmFnZ2FibGVzIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTczOTA3MVxyXG4gICAgaWYgKGV2ZW50LnRhcmdldCAmJiAoZXZlbnQudGFyZ2V0LmZvcm0gfHwgZXZlbnQudGFyZ2V0LmNvbnRlbnRlZGl0YWJsZSkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5hdGl2ZURyYWdnYWJsZUVsZW1lbnQgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGV2ZW50LnRhcmdldCwgZWxlbWVudCA9PiBlbGVtZW50LmRyYWdnYWJsZSk7XHJcblxyXG4gICAgaWYgKG5hdGl2ZURyYWdnYWJsZUVsZW1lbnQpIHtcclxuICAgICAgbmF0aXZlRHJhZ2dhYmxlRWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcclxuICAgICAgdGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gbmF0aXZlRHJhZ2dhYmxlRWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0sIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCB0aGlzW29uRHJhZ0VuZF0sIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzW29uRHJvcF0sIGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGV2ZW50LnRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XHJcblxyXG4gICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IGV2ZW50O1xyXG5cclxuICAgIHRoaXMubW91c2VEb3duVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0YXJnZXQuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuICAgICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50ID0gdGFyZ2V0O1xyXG4gICAgfSwgdGhpcy5kZWxheS5kcmFnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIHVwIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgdXAgZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZVVwXSgpIHtcclxuICAgIHRoaXNbcmVzZXRdKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSB1cCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIHVwIGV2ZW50XHJcbiAgICovXHJcbiAgW3Jlc2V0XSgpIHtcclxuICAgIGNsZWFyVGltZW91dCh0aGlzLm1vdXNlRG93blRpbWVvdXQpO1xyXG5cclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0sIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIHRoaXNbb25EcmFnRW5kXSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXNbb25Ecm9wXSwgZmFsc2UpO1xyXG5cclxuICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7XHJcbiAgICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZHJhZ2dhYmxlRWxlbWVudCkge1xyXG4gICAgICB0aGlzLmRyYWdnYWJsZUVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuZHJhZ2dhYmxlRWxlbWVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERyYWdTZW5zb3I7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0RyYWdTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxuXHJcbnZhciBfRHJhZ1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnU2Vuc29yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfRHJhZ1NlbnNvcjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uVG91Y2hTdGFydCA9IFN5bWJvbCgnb25Ub3VjaFN0YXJ0Jyk7XHJcbmNvbnN0IG9uVG91Y2hFbmQgPSBTeW1ib2woJ29uVG91Y2hFbmQnKTtcclxuY29uc3Qgb25Ub3VjaE1vdmUgPSBTeW1ib2woJ29uVG91Y2hNb3ZlJyk7XHJcbmNvbnN0IHN0YXJ0RHJhZyA9IFN5bWJvbCgnc3RhcnREcmFnJyk7XHJcbmNvbnN0IG9uRGlzdGFuY2VDaGFuZ2UgPSBTeW1ib2woJ29uRGlzdGFuY2VDaGFuZ2UnKTtcclxuXHJcbi8qKlxyXG4gKiBQcmV2ZW50cyBzY3JvbGxpbmcgd2hlbiBzZXQgdG8gdHJ1ZVxyXG4gKiBAdmFyIHtCb29sZWFufSBwcmV2ZW50U2Nyb2xsaW5nXHJcbiAqL1xyXG5sZXQgcHJldmVudFNjcm9sbGluZyA9IGZhbHNlO1xyXG5cclxuLy8gV2ViS2l0IHJlcXVpcmVzIGNhbmNlbGFibGUgYHRvdWNobW92ZWAgZXZlbnRzIHRvIGJlIGFkZGVkIGFzIGVhcmx5IGFzIHBvc3NpYmxlXHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBldmVudCA9PiB7XHJcbiAgaWYgKCFwcmV2ZW50U2Nyb2xsaW5nKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBQcmV2ZW50IHNjcm9sbGluZ1xyXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbn0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XHJcblxyXG4vKipcclxuICogVGhpcyBzZW5zb3IgcGlja3MgdXAgbmF0aXZlIGJyb3dzZXIgdG91Y2ggZXZlbnRzIGFuZCBkaWN0YXRlcyBkcmFnIG9wZXJhdGlvbnNcclxuICogQGNsYXNzIFRvdWNoU2Vuc29yXHJcbiAqIEBtb2R1bGUgVG91Y2hTZW5zb3JcclxuICogQGV4dGVuZHMgU2Vuc29yXHJcbiAqL1xyXG5jbGFzcyBUb3VjaFNlbnNvciBleHRlbmRzIF9TZW5zb3IyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIFRvdWNoU2Vuc29yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFRvdWNoU2Vuc29yXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb3Nlc3Qgc2Nyb2xsYWJsZSBjb250YWluZXIgc28gYWNjaWRlbnRhbCBzY3JvbGwgY2FuIGNhbmNlbCBsb25nIHRvdWNoXHJcbiAgICAgKiBAcHJvcGVydHkgY3VycmVudFNjcm9sbGFibGVQYXJlbnRcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXJyZW50U2Nyb2xsYWJsZVBhcmVudCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaW1lb3V0SUQgZm9yIG1hbmFnaW5nIGRlbGF5XHJcbiAgICAgKiBAcHJvcGVydHkgdGFwVGltZW91dFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy50YXBUaW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHRvdWNoTW92ZWQgaW5kaWNhdGVzIGlmIHRvdWNoIGhhcyBtb3ZlZCBkdXJpbmcgdGFwVGltZW91dFxyXG4gICAgICogQHByb3BlcnR5IHRvdWNoTW92ZWRcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRvdWNoTW92ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNhdmUgcGFnZVggY29vcmRpbmF0ZXMgZm9yIGRlbGF5IGRyYWdcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYnJlfSBwYWdlWFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5wYWdlWCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTYXZlIHBhZ2VZIGNvb3JkaW5hdGVzIGZvciBkZWxheSBkcmFnXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJyZX0gcGFnZVlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFnZVkgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25Ub3VjaFN0YXJ0XSA9IHRoaXNbb25Ub3VjaFN0YXJ0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvblRvdWNoRW5kXSA9IHRoaXNbb25Ub3VjaEVuZF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Ub3VjaE1vdmVdID0gdGhpc1tvblRvdWNoTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbc3RhcnREcmFnXSA9IHRoaXNbc3RhcnREcmFnXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSA9IHRoaXNbb25EaXN0YW5jZUNoYW5nZV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpc1tvblRvdWNoU3RhcnRdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpc1tvblRvdWNoU3RhcnRdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRvdWNoIHN0YXJ0IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVG91Y2ggc3RhcnQgZXZlbnRcclxuICAgKi9cclxuICBbb25Ub3VjaFN0YXJ0XShldmVudCkge1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC50YXJnZXQsIHRoaXMuY29udGFpbmVycyk7XHJcblxyXG4gICAgaWYgKCFjb250YWluZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBkaXN0YW5jZSA9IDAgfSA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IHsgZGVsYXkgfSA9IHRoaXM7XHJcbiAgICBjb25zdCB7IHBhZ2VYLCBwYWdlWSB9ID0gKDAsIF91dGlscy50b3VjaENvb3JkcykoZXZlbnQpO1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBwYWdlWCwgcGFnZVkgfSk7XHJcbiAgICB0aGlzLm9uVG91Y2hTdGFydEF0ID0gRGF0ZS5ub3coKTtcclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IGV2ZW50O1xyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gY29udGFpbmVyO1xyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpc1tvblRvdWNoRW5kXSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51KTtcclxuXHJcbiAgICBpZiAoZGlzdGFuY2UpIHtcclxuICAgICAgcHJldmVudFNjcm9sbGluZyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy50YXBUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKHsgdG91Y2hlczogW3sgcGFnZVg6IHRoaXMucGFnZVgsIHBhZ2VZOiB0aGlzLnBhZ2VZIH1dIH0pO1xyXG4gICAgfSwgZGVsYXkudG91Y2gpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdGhlIGRyYWdcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtzdGFydERyYWddKCkge1xyXG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IHRoaXMuc3RhcnRFdmVudDtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbnRhaW5lcjtcclxuICAgIGNvbnN0IHRvdWNoID0gKDAsIF91dGlscy50b3VjaENvb3Jkcykoc3RhcnRFdmVudCk7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdGFydFNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogdG91Y2gucGFnZVgsXHJcbiAgICAgIGNsaWVudFk6IHRvdWNoLnBhZ2VZLFxyXG4gICAgICB0YXJnZXQ6IHN0YXJ0RXZlbnQudGFyZ2V0LFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IHN0YXJ0RXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCk7XHJcblxyXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvblRvdWNoTW92ZV0pO1xyXG4gICAgfVxyXG4gICAgcHJldmVudFNjcm9sbGluZyA9IHRoaXMuZHJhZ2dpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUb3VjaCBtb3ZlIGhhbmRsZXIgcHJpb3IgdG8gZHJhZyBzdGFydC5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVG91Y2ggbW92ZSBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRpc3RhbmNlQ2hhbmdlXShldmVudCkge1xyXG4gICAgY29uc3QgeyBkaXN0YW5jZSB9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgY29uc3QgeyBzdGFydEV2ZW50LCBkZWxheSB9ID0gdGhpcztcclxuICAgIGNvbnN0IHN0YXJ0ID0gKDAsIF91dGlscy50b3VjaENvb3Jkcykoc3RhcnRFdmVudCk7XHJcbiAgICBjb25zdCBjdXJyZW50ID0gKDAsIF91dGlscy50b3VjaENvb3JkcykoZXZlbnQpO1xyXG4gICAgY29uc3QgdGltZUVsYXBzZWQgPSBEYXRlLm5vdygpIC0gdGhpcy5vblRvdWNoU3RhcnRBdDtcclxuICAgIGNvbnN0IGRpc3RhbmNlVHJhdmVsbGVkID0gKDAsIF91dGlscy5kaXN0YW5jZSkoc3RhcnQucGFnZVgsIHN0YXJ0LnBhZ2VZLCBjdXJyZW50LnBhZ2VYLCBjdXJyZW50LnBhZ2VZKTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGN1cnJlbnQpO1xyXG5cclxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRhcFRpbWVvdXQpO1xyXG5cclxuICAgIGlmICh0aW1lRWxhcHNlZCA8IGRlbGF5LnRvdWNoKSB7XHJcbiAgICAgIC8vIG1vdmVkIGR1cmluZyBkZWxheVxyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2VUcmF2ZWxsZWQgPj0gZGlzdGFuY2UpIHtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcbiAgICAgIHRoaXNbc3RhcnREcmFnXSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgbW92ZSBoYW5kbGVyIHdoaWxlIGRyYWdnaW5nXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRvdWNoIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25Ub3VjaE1vdmVdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBwYWdlWCwgcGFnZVkgfSA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKGV2ZW50KTtcclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQocGFnZVggLSB3aW5kb3cuc2Nyb2xsWCwgcGFnZVkgLSB3aW5kb3cuc2Nyb2xsWSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ01vdmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ01vdmVTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IHBhZ2VYLFxyXG4gICAgICBjbGllbnRZOiBwYWdlWSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVG91Y2ggZW5kIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVG91Y2ggZW5kIGV2ZW50XHJcbiAgICovXHJcbiAgW29uVG91Y2hFbmRdKGV2ZW50KSB7XHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy50YXBUaW1lb3V0KTtcclxuICAgIHByZXZlbnRTY3JvbGxpbmcgPSBmYWxzZTtcclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzW29uVG91Y2hFbmRdKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG5cclxuICAgIGlmICh0aGlzLmN1cnJlbnRDb250YWluZXIpIHtcclxuICAgICAgdGhpcy5jdXJyZW50Q29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uVG91Y2hNb3ZlXSk7XHJcblxyXG4gICAgY29uc3QgeyBwYWdlWCwgcGFnZVkgfSA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKGV2ZW50KTtcclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQocGFnZVggLSB3aW5kb3cuc2Nyb2xsWCwgcGFnZVkgLSB3aW5kb3cuc2Nyb2xsWSk7XHJcblxyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RvcFNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogcGFnZVgsXHJcbiAgICAgIGNsaWVudFk6IHBhZ2VZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBUb3VjaFNlbnNvcjtcclxuZnVuY3Rpb24gb25Db250ZXh0TWVudShldmVudCkge1xyXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfVG91Y2hTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcclxuXHJcbnZhciBfVG91Y2hTZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVG91Y2hTZW5zb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Ub3VjaFNlbnNvcjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5EcmFnUHJlc3N1cmVTZW5zb3JFdmVudCA9IGV4cG9ydHMuRHJhZ1N0b3BTZW5zb3JFdmVudCA9IGV4cG9ydHMuRHJhZ01vdmVTZW5zb3JFdmVudCA9IGV4cG9ydHMuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQgPSBleHBvcnRzLlNlbnNvckV2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKipcclxuICogQmFzZSBzZW5zb3IgZXZlbnRcclxuICogQGNsYXNzIFNlbnNvckV2ZW50XHJcbiAqIEBtb2R1bGUgU2Vuc29yRXZlbnRcclxuICogQGV4dGVuZHMgQWJzdHJhY3RFdmVudFxyXG4gKi9cclxuY2xhc3MgU2Vuc29yRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgYnJvd3NlciBldmVudCB0aGF0IHRyaWdnZXJlZCBhIHNlbnNvclxyXG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbEV2ZW50XHJcbiAgICogQHR5cGUge0V2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvcmlnaW5hbEV2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vcmlnaW5hbEV2ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplZCBjbGllbnRYIGZvciBib3RoIHRvdWNoIGFuZCBtb3VzZSBldmVudHNcclxuICAgKiBAcHJvcGVydHkgY2xpZW50WFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGNsaWVudFgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNsaWVudFg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOb3JtYWxpemVkIGNsaWVudFkgZm9yIGJvdGggdG91Y2ggYW5kIG1vdXNlIGV2ZW50c1xyXG4gICAqIEBwcm9wZXJ0eSBjbGllbnRZXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgY2xpZW50WSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuY2xpZW50WTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZWQgdGFyZ2V0IGZvciBib3RoIHRvdWNoIGFuZCBtb3VzZSBldmVudHNcclxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IHRoYXQgaXMgYmVoaW5kIGN1cnNvciBvciB0b3VjaCBwb2ludGVyXHJcbiAgICogQHByb3BlcnR5IHRhcmdldFxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgdGFyZ2V0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS50YXJnZXQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb250YWluZXIgdGhhdCBpbml0aWF0ZWQgdGhlIHNlbnNvclxyXG4gICAqIEBwcm9wZXJ0eSBjb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuY29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhY2twYWQgcHJlc3N1cmVcclxuICAgKiBAcHJvcGVydHkgcHJlc3N1cmVcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBwcmVzc3VyZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEucHJlc3N1cmU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLlNlbnNvckV2ZW50ID0gU2Vuc29yRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgc3RhcnQgc2Vuc29yIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdTdGFydFNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnU3RhcnRTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5jbGFzcyBEcmFnU3RhcnRTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdTdGFydFNlbnNvckV2ZW50ID0gRHJhZ1N0YXJ0U2Vuc29yRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgbW92ZSBzZW5zb3IgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ01vdmVTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ01vdmVTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnU3RhcnRTZW5zb3JFdmVudC50eXBlID0gJ2RyYWc6c3RhcnQnO1xyXG5jbGFzcyBEcmFnTW92ZVNlbnNvckV2ZW50IGV4dGVuZHMgU2Vuc29yRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ01vdmVTZW5zb3JFdmVudCA9IERyYWdNb3ZlU2Vuc29yRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHN0b3Agc2Vuc29yIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RvcFNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1N0b3BTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdNb3ZlU2Vuc29yRXZlbnQudHlwZSA9ICdkcmFnOm1vdmUnO1xyXG5jbGFzcyBEcmFnU3RvcFNlbnNvckV2ZW50IGV4dGVuZHMgU2Vuc29yRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ1N0b3BTZW5zb3JFdmVudCA9IERyYWdTdG9wU2Vuc29yRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHByZXNzdXJlIHNlbnNvciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnUHJlc3N1cmVTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdTdG9wU2Vuc29yRXZlbnQudHlwZSA9ICdkcmFnOnN0b3AnO1xyXG5jbGFzcyBEcmFnUHJlc3N1cmVTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XHJcbmV4cG9ydHMuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQgPSBEcmFnUHJlc3N1cmVTZW5zb3JFdmVudDtcclxuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQudHlwZSA9ICdkcmFnOnByZXNzdXJlJztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nID0gU3ltYm9sKCdvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZycpO1xyXG5jb25zdCBvbk1vdXNlRG93biA9IFN5bWJvbCgnb25Nb3VzZURvd24nKTtcclxuY29uc3Qgb25Nb3VzZU1vdmUgPSBTeW1ib2woJ29uTW91c2VNb3ZlJyk7XHJcbmNvbnN0IG9uTW91c2VVcCA9IFN5bWJvbCgnb25Nb3VzZVVwJyk7XHJcbmNvbnN0IHN0YXJ0RHJhZyA9IFN5bWJvbCgnc3RhcnREcmFnJyk7XHJcbmNvbnN0IG9uRGlzdGFuY2VDaGFuZ2UgPSBTeW1ib2woJ29uRGlzdGFuY2VDaGFuZ2UnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHNlbnNvciBwaWNrcyB1cCBuYXRpdmUgYnJvd3NlciBtb3VzZSBldmVudHMgYW5kIGRpY3RhdGVzIGRyYWcgb3BlcmF0aW9uc1xyXG4gKiBAY2xhc3MgTW91c2VTZW5zb3JcclxuICogQG1vZHVsZSBNb3VzZVNlbnNvclxyXG4gKiBAZXh0ZW5kcyBTZW5zb3JcclxuICovXHJcbmNsYXNzIE1vdXNlU2Vuc29yIGV4dGVuZHMgX1NlbnNvcjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogTW91c2VTZW5zb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgTW91c2VTZW5zb3JcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lcnMsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgZG93biB0aW1lciB3aGljaCB3aWxsIGVuZCB1cCB0cmlnZ2VyaW5nIHRoZSBkcmFnIHN0YXJ0IG9wZXJhdGlvblxyXG4gICAgICogQHByb3BlcnR5IG1vdXNlRG93blRpbWVvdXRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubW91c2VEb3duVGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTYXZlIHBhZ2VYIGNvb3JkaW5hdGVzIGZvciBkZWxheSBkcmFnXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJyZX0gcGFnZVhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFnZVggPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2F2ZSBwYWdlWSBjb29yZGluYXRlcyBmb3IgZGVsYXkgZHJhZ1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1icmV9IHBhZ2VZXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBhZ2VZID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXSA9IHRoaXNbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VEb3duXSA9IHRoaXNbb25Nb3VzZURvd25dLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VNb3ZlXSA9IHRoaXNbb25Nb3VzZU1vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VVcF0gPSB0aGlzW29uTW91c2VVcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbc3RhcnREcmFnXSA9IHRoaXNbc3RhcnREcmFnXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSA9IHRoaXNbb25EaXN0YW5jZUNoYW5nZV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZG93biBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGRvd24gZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZURvd25dKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb250YWluZXIgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGV2ZW50LnRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcclxuXHJcbiAgICBpZiAoIWNvbnRhaW5lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBkZWxheSB9ID0gdGhpcztcclxuICAgIGNvbnN0IHsgcGFnZVgsIHBhZ2VZIH0gPSBldmVudDtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgcGFnZVgsIHBhZ2VZIH0pO1xyXG4gICAgdGhpcy5vbk1vdXNlRG93bkF0ID0gRGF0ZS5ub3coKTtcclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IGV2ZW50O1xyXG5cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0pO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgcHJldmVudE5hdGl2ZURyYWdTdGFydCk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuXHJcbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0oeyBwYWdlWDogdGhpcy5wYWdlWCwgcGFnZVk6IHRoaXMucGFnZVkgfSk7XHJcbiAgICB9LCBkZWxheS5tb3VzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCB0aGUgZHJhZ1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW3N0YXJ0RHJhZ10oKSB7XHJcbiAgICBjb25zdCBzdGFydEV2ZW50ID0gdGhpcy5zdGFydEV2ZW50O1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jdXJyZW50Q29udGFpbmVyO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RhcnRTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IHN0YXJ0RXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogc3RhcnRFdmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQ6IHN0YXJ0RXZlbnQudGFyZ2V0LFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IHN0YXJ0RXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCk7XHJcblxyXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXSwgdHJ1ZSk7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25Nb3VzZU1vdmVdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVjdCBjaGFuZ2UgaW4gZGlzdGFuY2UsIHN0YXJ0aW5nIGRyYWcgd2hlbiBib3RoXHJcbiAgICogZGVsYXkgYW5kIGRpc3RhbmNlIHJlcXVpcmVtZW50cyBhcmUgbWV0XHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25EaXN0YW5jZUNoYW5nZV0oZXZlbnQpIHtcclxuICAgIGNvbnN0IHsgcGFnZVgsIHBhZ2VZIH0gPSBldmVudDtcclxuICAgIGNvbnN0IHsgZGlzdGFuY2UgfSA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IHsgc3RhcnRFdmVudCwgZGVsYXkgfSA9IHRoaXM7XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IHBhZ2VYLCBwYWdlWSB9KTtcclxuXHJcbiAgICBpZiAoIXRoaXMuY3VycmVudENvbnRhaW5lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGltZUVsYXBzZWQgPSBEYXRlLm5vdygpIC0gdGhpcy5vbk1vdXNlRG93bkF0O1xyXG4gICAgY29uc3QgZGlzdGFuY2VUcmF2ZWxsZWQgPSAoMCwgX3V0aWxzLmRpc3RhbmNlKShzdGFydEV2ZW50LnBhZ2VYLCBzdGFydEV2ZW50LnBhZ2VZLCBwYWdlWCwgcGFnZVkpIHx8IDA7XHJcblxyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XHJcblxyXG4gICAgaWYgKHRpbWVFbGFwc2VkIDwgZGVsYXkubW91c2UpIHtcclxuICAgICAgLy8gbW92ZWQgZHVyaW5nIGRlbGF5XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZVRyYXZlbGxlZCA+PSBkaXN0YW5jZSkge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuICAgICAgdGhpc1tzdGFydERyYWddKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgbW92ZSBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlTW92ZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuXHJcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnTW92ZVNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgdXAgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlVXBdKGV2ZW50KSB7XHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy5tb3VzZURvd25UaW1lb3V0KTtcclxuXHJcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHByZXZlbnROYXRpdmVEcmFnU3RhcnQpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcblxyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdG9wU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uTW91c2VNb3ZlXSk7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb250ZXh0IG1lbnUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBDb250ZXh0IG1lbnUgZXZlbnRcclxuICAgKi9cclxuICBbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddKGV2ZW50KSB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gTW91c2VTZW5zb3I7XHJcbmZ1bmN0aW9uIHByZXZlbnROYXRpdmVEcmFnU3RhcnQoZXZlbnQpIHtcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX01vdXNlU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcblxyXG52YXIgX01vdXNlU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vdXNlU2Vuc29yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfTW91c2VTZW5zb3IyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxuY29uc3QgZGVmYXVsdERlYWx5ID0ge1xyXG4gIG1vdXNlOiAwLFxyXG4gIGRyYWc6IDAsXHJcbiAgdG91Y2g6IDEwMFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEJhc2Ugc2Vuc29yIGNsYXNzLiBFeHRlbmQgZnJvbSB0aGlzIGNsYXNzIHRvIGNyZWF0ZSBhIG5ldyBvciBjdXN0b20gc2Vuc29yXHJcbiAqIEBjbGFzcyBTZW5zb3JcclxuICogQG1vZHVsZSBTZW5zb3JcclxuICovXHJcbmNsYXNzIFNlbnNvciB7XHJcbiAgLyoqXHJcbiAgICogU2Vuc29yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFNlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGNvbnRhaW5lcnNcclxuICAgICAqIEBwcm9wZXJ0eSBjb250YWluZXJzXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb250YWluZXJzID0gWy4uLmNvbnRhaW5lcnNdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBkcmFnIHN0YXRlXHJcbiAgICAgKiBAcHJvcGVydHkgZHJhZ2dpbmdcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGNvbnRhaW5lclxyXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRDb250YWluZXJcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBldmVudCBvZiB0aGUgaW5pdGlhbCBzZW5zb3IgZG93blxyXG4gICAgICogQHByb3BlcnR5IHN0YXJ0RXZlbnRcclxuICAgICAqIEB0eXBlIHtFdmVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGFydEV2ZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWxheSBvZiBlYWNoIHNlbnNvclxyXG4gICAgICogQHByb3BlcnR5IGRlbGF5XHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlbGF5ID0gY2FsY0RlbGF5KG9wdGlvbnMuZGVsYXkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqIEByZXR1cm4ge1NlbnNvcn1cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKiBAcmV0dXJuIHtTZW5zb3J9XHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGNvbnRhaW5lciB0byB0aGlzIHNlbnNvciBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7Li4uSFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzIHlvdSB3YW50IHRvIGFkZCB0byB0aGlzIHNlbnNvclxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5hZGRDb250YWluZXIoZG9jdW1lbnQuYm9keSlcclxuICAgKi9cclxuICBhZGRDb250YWluZXIoLi4uY29udGFpbmVycykge1xyXG4gICAgdGhpcy5jb250YWluZXJzID0gWy4uLnRoaXMuY29udGFpbmVycywgLi4uY29udGFpbmVyc107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGNvbnRhaW5lciBmcm9tIHRoaXMgc2Vuc29yIGluc3RhbmNlXHJcbiAgICogQHBhcmFtIHsuLi5IVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnMgeW91IHdhbnQgdG8gcmVtb3ZlIGZyb20gdGhpcyBzZW5zb3JcclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUucmVtb3ZlQ29udGFpbmVyKGRvY3VtZW50LmJvZHkpXHJcbiAgICovXHJcbiAgcmVtb3ZlQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcclxuICAgIHRoaXMuY29udGFpbmVycyA9IHRoaXMuY29udGFpbmVycy5maWx0ZXIoY29udGFpbmVyID0+ICFjb250YWluZXJzLmluY2x1ZGVzKGNvbnRhaW5lcikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlcnMgZXZlbnQgb24gdGFyZ2V0IGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byB0cmlnZ2VyIGV2ZW50IG9uXHJcbiAgICogQHBhcmFtIHtTZW5zb3JFdmVudH0gc2Vuc29yRXZlbnQgLSBTZW5zb3IgZXZlbnQgdG8gdHJpZ2dlclxyXG4gICAqL1xyXG4gIHRyaWdnZXIoZWxlbWVudCwgc2Vuc29yRXZlbnQpIHtcclxuICAgIGNvbnN0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbiAgICBldmVudC5kZXRhaWwgPSBzZW5zb3JFdmVudDtcclxuICAgIGV2ZW50LmluaXRFdmVudChzZW5zb3JFdmVudC50eXBlLCB0cnVlLCB0cnVlKTtcclxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB0aGlzLmxhc3RFdmVudCA9IHNlbnNvckV2ZW50O1xyXG5cclxuICAgIHJldHVybiBzZW5zb3JFdmVudDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNlbnNvcjsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBkZWxheSBvZiBlYWNoIHNlbnNvciB0aHJvdWdoIHRoZSBkZWxheSBpbiB0aGUgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfE51bWJlcnxPYmplY3R9IG9wdGlvbnNEZWxheSAtIHRoZSBkZWxheSBpbiB0aGUgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmZ1bmN0aW9uIGNhbGNEZWxheShvcHRpb25zRGVsYXkpIHtcclxuICBjb25zdCBkZWxheSA9IHt9O1xyXG5cclxuICBpZiAob3B0aW9uc0RlbGF5ID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGVmYXVsdERlYWx5KTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2Ygb3B0aW9uc0RlbGF5ID09PSAnbnVtYmVyJykge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdERlYWx5KSB7XHJcbiAgICAgIGlmIChkZWZhdWx0RGVhbHkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgIGRlbGF5W2tleV0gPSBvcHRpb25zRGVsYXk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkZWxheTtcclxuICB9XHJcblxyXG4gIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHREZWFseSkge1xyXG4gICAgaWYgKGRlZmF1bHREZWFseS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgIGlmIChvcHRpb25zRGVsYXlba2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZGVsYXlba2V5XSA9IGRlZmF1bHREZWFseVtrZXldO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRlbGF5W2tleV0gPSBvcHRpb25zRGVsYXlba2V5XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRlbGF5O1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHRvdWNoQ29vcmRzO1xyXG4vKipcclxuICogUmV0dXJucyB0aGUgZmlyc3QgdG91Y2ggZXZlbnQgZm91bmQgaW4gdG91Y2hlcyBvciBjaGFuZ2VkVG91Y2hlcyBvZiBhIHRvdWNoIGV2ZW50cy5cclxuICogQHBhcmFtIHtUb3VjaEV2ZW50fSBldmVudCBhIHRvdWNoIGV2ZW50XHJcbiAqIEByZXR1cm4ge1RvdWNofSBhIHRvdWNoIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gdG91Y2hDb29yZHMoZXZlbnQgPSB7fSkge1xyXG4gIGNvbnN0IHsgdG91Y2hlcywgY2hhbmdlZFRvdWNoZXMgfSA9IGV2ZW50O1xyXG4gIHJldHVybiB0b3VjaGVzICYmIHRvdWNoZXNbMF0gfHwgY2hhbmdlZFRvdWNoZXMgJiYgY2hhbmdlZFRvdWNoZXNbMF07XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdG91Y2hDb29yZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxuXHJcbnZhciBfdG91Y2hDb29yZHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG91Y2hDb29yZHMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF90b3VjaENvb3JkczIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gZGlzdGFuY2U7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcclxuICogQHBhcmFtICB7TnVtYmVyfSB4MSBUaGUgWCBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnRcclxuICogQHBhcmFtICB7TnVtYmVyfSB5MSBUaGUgWSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnRcclxuICogQHBhcmFtICB7TnVtYmVyfSB4MiBUaGUgWCBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50XHJcbiAqIEBwYXJhbSAge051bWJlcn0geTIgVGhlIFkgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xyXG4gIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICoqIDIgKyAoeTIgLSB5MSkgKiogMik7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZGlzdGFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcclxuXHJcbnZhciBfZGlzdGFuY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzdGFuY2UpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9kaXN0YW5jZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZTtcclxuZnVuY3Rpb24gcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xyXG4gIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XHJcblxyXG52YXIgX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb3Nlc3Q7XHJcbmNvbnN0IG1hdGNoRnVuY3Rpb24gPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3I7XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjbG9zZXN0IHBhcmVudCBlbGVtZW50IG9mIGEgZ2l2ZW4gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuXHJcbiAqIHNlbGVjdG9yIHN0cmluZyBvciBtYXRjaGluZyBmdW5jdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGNoaWxkIGVsZW1lbnQgdG8gZmluZCBhIHBhcmVudCBvZlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgVGhlIHN0cmluZyBvciBmdW5jdGlvbiB0byB1c2UgdG8gbWF0Y2hcclxuICogICAgIHRoZSBwYXJlbnQgZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtFbGVtZW50fG51bGx9XHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9zZXN0KGVsZW1lbnQsIHZhbHVlKSB7XHJcbiAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNlbGVjdG9yID0gdmFsdWU7XHJcbiAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZTtcclxuICBjb25zdCBub2RlTGlzdCA9IHZhbHVlO1xyXG4gIGNvbnN0IHNpbmdsZUVsZW1lbnQgPSB2YWx1ZTtcclxuXHJcbiAgY29uc3QgaXNTZWxlY3RvciA9IEJvb2xlYW4odHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyk7XHJcbiAgY29uc3QgaXNGdW5jdGlvbiA9IEJvb2xlYW4odHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKTtcclxuICBjb25zdCBpc05vZGVMaXN0ID0gQm9vbGVhbih2YWx1ZSBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpO1xyXG4gIGNvbnN0IGlzRWxlbWVudCA9IEJvb2xlYW4odmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCk7XHJcblxyXG4gIGZ1bmN0aW9uIGNvbmRpdGlvbkZuKGN1cnJlbnRFbGVtZW50KSB7XHJcbiAgICBpZiAoIWN1cnJlbnRFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcclxuICAgIH0gZWxzZSBpZiAoaXNTZWxlY3Rvcikge1xyXG4gICAgICByZXR1cm4gbWF0Y2hGdW5jdGlvbi5jYWxsKGN1cnJlbnRFbGVtZW50LCBzZWxlY3Rvcik7XHJcbiAgICB9IGVsc2UgaWYgKGlzTm9kZUxpc3QpIHtcclxuICAgICAgcmV0dXJuIFsuLi5ub2RlTGlzdF0uaW5jbHVkZXMoY3VycmVudEVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIGlmIChpc0VsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIHNpbmdsZUVsZW1lbnQgPT09IGN1cnJlbnRFbGVtZW50O1xyXG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKSB7XHJcbiAgICAgIHJldHVybiBjYWxsYmFjayhjdXJyZW50RWxlbWVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxldCBjdXJyZW50ID0gZWxlbWVudDtcclxuXHJcbiAgZG8ge1xyXG4gICAgY3VycmVudCA9IGN1cnJlbnQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQgfHwgY3VycmVudC5jb3JyZXNwb25kaW5nRWxlbWVudCB8fCBjdXJyZW50O1xyXG5cclxuICAgIGlmIChjb25kaXRpb25GbihjdXJyZW50KSkge1xyXG4gICAgICByZXR1cm4gY3VycmVudDtcclxuICAgIH1cclxuXHJcbiAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xyXG4gIH0gd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBjdXJyZW50ICE9PSBkb2N1bWVudCk7XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2Nsb3Nlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcclxuXHJcbnZhciBfY2xvc2VzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9zZXN0KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfY2xvc2VzdDIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuc2Nyb2xsID0gZXhwb3J0cy5vbkRyYWdTdG9wID0gZXhwb3J0cy5vbkRyYWdNb3ZlID0gZXhwb3J0cy5vbkRyYWdTdGFydCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25EcmFnU3RhcnQgPSBleHBvcnRzLm9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdNb3ZlID0gZXhwb3J0cy5vbkRyYWdNb3ZlID0gU3ltYm9sKCdvbkRyYWdNb3ZlJyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBleHBvcnRzLm9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3Qgc2Nyb2xsID0gZXhwb3J0cy5zY3JvbGwgPSBTeW1ib2woJ3Njcm9sbCcpO1xyXG5cclxuLyoqXHJcbiAqIFNjcm9sbGFibGUgZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMuc3BlZWRcclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLnNlbnNpdGl2aXR5XHJcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnRbXX0gZGVmYXVsdE9wdGlvbnMuc2Nyb2xsYWJsZUVsZW1lbnRzXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgc3BlZWQ6IDYsXHJcbiAgc2Vuc2l0aXZpdHk6IDUwLFxyXG4gIHNjcm9sbGFibGVFbGVtZW50czogW11cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTY3JvbGxhYmxlIHBsdWdpbiB3aGljaCBzY3JvbGxzIHRoZSBjbG9zZXN0IHNjcm9sbGFibGUgcGFyZW50XHJcbiAqIEBjbGFzcyBTY3JvbGxhYmxlXHJcbiAqIEBtb2R1bGUgU2Nyb2xsYWJsZVxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgU2Nyb2xsYWJsZSBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsYWJsZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBTY3JvbGxhYmxlXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjcm9sbGFibGUgb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBvcHRpb25zLnNwZWVkXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gb3B0aW9ucy5zZW5zaXRpdml0eVxyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudFtdfSBvcHRpb25zLnNjcm9sbGFibGVFbGVtZW50c1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZWVwcyBjdXJyZW50IG1vdXNlIHBvc2l0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gY3VycmVudE1vdXNlUG9zaXRpb25cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRYXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY3VycmVudE1vdXNlUG9zaXRpb24uY2xpZW50WVxyXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjcm9sbCBhbmltYXRpb24gZnJhbWVcclxuICAgICAqIEBwcm9wZXJ0eSBzY3JvbGxBbmltYXRpb25GcmFtZVxyXG4gICAgICogQHR5cGUge051bWJlcnxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb3Nlc3Qgc2Nyb2xsYWJsZSBlbGVtZW50XHJcbiAgICAgKiBAcHJvcGVydHkgc2Nyb2xsYWJsZUVsZW1lbnRcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuaW1hdGlvbiBmcmFtZSBsb29raW5nIGZvciB0aGUgY2xvc2VzdCBzY3JvbGxhYmxlIGVsZW1lbnRcclxuICAgICAqIEBwcm9wZXJ0eSBmaW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZVxyXG4gICAgICogQHR5cGUge051bWJlcnxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbc2Nyb2xsXSA9IHRoaXNbc2Nyb2xsXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBvcHRpb25zIHBhc3NlZCB0aHJvdWdoIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuc2Nyb2xsYWJsZSB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY2xvc2VzdCBzY3JvbGxhYmxlIGVsZW1lbnRzIGJ5IGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgKi9cclxuICBnZXRTY3JvbGxhYmxlRWxlbWVudCh0YXJnZXQpIHtcclxuICAgIGlmICh0aGlzLmhhc0RlZmluZWRTY3JvbGxhYmxlRWxlbWVudHMoKSkge1xyXG4gICAgICByZXR1cm4gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIHRoaXMub3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHMpIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBjbG9zZXN0U2Nyb2xsYWJsZUVsZW1lbnQodGFyZ2V0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgc2Nyb2xsYWJsZSBlbGVtZW50IGhhdmUgYmVlbiBkZWZpbmVkIHZpYSBvcHRpb25zXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBoYXNEZWZpbmVkU2Nyb2xsYWJsZUVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5vcHRpb25zLnNjcm9sbGFibGVFbGVtZW50cy5sZW5ndGggIT09IDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdGFydCBoYW5kbGVyLiBGaW5kcyBjbG9zZXN0IHNjcm9sbGFibGUgcGFyZW50IGluIHNlcGFyYXRlIGZyYW1lXHJcbiAgICogQHBhcmFtIHtEcmFnU3RhcnRFdmVudH0gZHJhZ0V2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25EcmFnU3RhcnRdKGRyYWdFdmVudCkge1xyXG4gICAgdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSB0aGlzLmdldFNjcm9sbGFibGVFbGVtZW50KGRyYWdFdmVudC5zb3VyY2UpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG1vdmUgaGFuZGxlci4gUmVtZW1iZXJzIG1vdXNlIHBvc2l0aW9uIGFuZCBpbml0aWF0ZXMgc2Nyb2xsaW5nXHJcbiAgICogQHBhcmFtIHtEcmFnTW92ZUV2ZW50fSBkcmFnRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkRyYWdNb3ZlXShkcmFnRXZlbnQpIHtcclxuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gdGhpcy5nZXRTY3JvbGxhYmxlRWxlbWVudChkcmFnRXZlbnQuc2Vuc29yRXZlbnQudGFyZ2V0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghdGhpcy5zY3JvbGxhYmxlRWxlbWVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBkcmFnRXZlbnQuc2Vuc29yRXZlbnQ7XHJcbiAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XHJcbiAgICAgIHNjcm9sbE9mZnNldC55ID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgMDtcclxuICAgICAgc2Nyb2xsT2Zmc2V0LnggPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0IHx8IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbiA9IHtcclxuICAgICAgY2xpZW50WDogc2Vuc29yRXZlbnQuY2xpZW50WCAtIHNjcm9sbE9mZnNldC54LFxyXG4gICAgICBjbGllbnRZOiBzZW5zb3JFdmVudC5jbGllbnRZIC0gc2Nyb2xsT2Zmc2V0LnlcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzW3Njcm9sbF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdG9wIGhhbmRsZXIuIENhbmNlbHMgc2Nyb2xsIGFuaW1hdGlvbnMgYW5kIHJlc2V0cyBzdGF0ZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRHJhZ1N0b3BdKCkge1xyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSk7XHJcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lKTtcclxuXHJcbiAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gbnVsbDtcclxuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUgPSBudWxsO1xyXG4gICAgdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSA9IG51bGw7XHJcbiAgICB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjcm9sbCBmdW5jdGlvbiB0aGF0IGRvZXMgdGhlIGhlYXZ5bGlmdGluZ1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW3Njcm9sbF0oKSB7XHJcbiAgICBpZiAoIXRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgfHwgIXRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUpO1xyXG5cclxuICAgIGNvbnN0IHsgc3BlZWQsIHNlbnNpdGl2aXR5IH0gPSB0aGlzLm9wdGlvbnM7XHJcblxyXG4gICAgY29uc3QgcmVjdCA9IHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBjb25zdCBib3R0b21DdXRPZmYgPSByZWN0LmJvdHRvbSA+IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgIGNvbnN0IHRvcEN1dE9mZiA9IHJlY3QudG9wIDwgMDtcclxuICAgIGNvbnN0IGN1dE9mZiA9IHRvcEN1dE9mZiB8fCBib3R0b21DdXRPZmY7XHJcblxyXG4gICAgY29uc3QgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50ID0gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCk7XHJcbiAgICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9IHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQ7XHJcbiAgICBjb25zdCBjbGllbnRYID0gdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRYO1xyXG4gICAgY29uc3QgY2xpZW50WSA9IHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24uY2xpZW50WTtcclxuXHJcbiAgICBpZiAoc2Nyb2xsYWJsZUVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgc2Nyb2xsYWJsZUVsZW1lbnQgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhY3V0T2ZmKSB7XHJcbiAgICAgIGNvbnN0IHsgb2Zmc2V0SGVpZ2h0LCBvZmZzZXRXaWR0aCB9ID0gc2Nyb2xsYWJsZUVsZW1lbnQ7XHJcblxyXG4gICAgICBpZiAocmVjdC50b3AgKyBvZmZzZXRIZWlnaHQgLSBjbGllbnRZIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUb3AgKz0gc3BlZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50WSAtIHJlY3QudG9wIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUb3AgLT0gc3BlZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZWN0LmxlZnQgKyBvZmZzZXRXaWR0aCAtIGNsaWVudFggPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbExlZnQgKz0gc3BlZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50WCAtIHJlY3QubGVmdCA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsTGVmdCAtPSBzcGVlZDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgeyBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCB9ID0gd2luZG93O1xyXG5cclxuICAgICAgaWYgKGNsaWVudFkgPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgLT0gc3BlZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoaW5uZXJIZWlnaHQgLSBjbGllbnRZIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wICs9IHNwZWVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2xpZW50WCA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgLT0gc3BlZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoaW5uZXJXaWR0aCAtIGNsaWVudFggPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0ICs9IHNwZWVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzW3Njcm9sbF0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gU2Nyb2xsYWJsZTsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIGVsZW1lbnQgaGFzIG92ZXJmbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5mdW5jdGlvbiBoYXNPdmVyZmxvdyhlbGVtZW50KSB7XHJcbiAgY29uc3Qgb3ZlcmZsb3dSZWdleCA9IC8oYXV0b3xzY3JvbGwpLztcclxuICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XHJcblxyXG4gIGNvbnN0IG92ZXJmbG93ID0gY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cnKSArIGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXknKSArIGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXgnKTtcclxuXHJcbiAgcmV0dXJuIG92ZXJmbG93UmVnZXgudGVzdChvdmVyZmxvdyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCBlbGVtZW50IGlzIHN0YXRpY2FsbHkgcG9zaXRpb25lZFxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1N0YXRpY2FsbHlQb3NpdGlvbmVkKGVsZW1lbnQpIHtcclxuICBjb25zdCBwb3NpdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKTtcclxuICByZXR1cm4gcG9zaXRpb24gPT09ICdzdGF0aWMnO1xyXG59XHJcblxyXG4vKipcclxuICogRmluZHMgY2xvc2VzdCBzY3JvbGxhYmxlIGVsZW1lbnRcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNsb3Nlc3RTY3JvbGxhYmxlRWxlbWVudChlbGVtZW50KSB7XHJcbiAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBwb3NpdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKTtcclxuICBjb25zdCBleGNsdWRlU3RhdGljUGFyZW50cyA9IHBvc2l0aW9uID09PSAnYWJzb2x1dGUnO1xyXG5cclxuICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZWxlbWVudCwgcGFyZW50ID0+IHtcclxuICAgIGlmIChleGNsdWRlU3RhdGljUGFyZW50cyAmJiBpc1N0YXRpY2FsbHlQb3NpdGlvbmVkKHBhcmVudCkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc092ZXJmbG93KHBhcmVudCk7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChwb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCAhc2Nyb2xsYWJsZUVsZW1lbnQpIHtcclxuICAgIHJldHVybiBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHNjcm9sbGFibGVFbGVtZW50O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgZWxlbWVudCB0aGF0IHNjcm9sbHMgZG9jdW1lbnRcclxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKSB7XHJcbiAgcmV0dXJuIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX1Njcm9sbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcclxuXHJcbnZhciBfU2Nyb2xsYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TY3JvbGxhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfU2Nyb2xsYWJsZTIuZGVmYXVsdDtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IF9TY3JvbGxhYmxlLmRlZmF1bHRPcHRpb25zO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLk1pcnJvckRlc3Ryb3lFdmVudCA9IGV4cG9ydHMuTWlycm9yTW92ZUV2ZW50ID0gZXhwb3J0cy5NaXJyb3JBdHRhY2hlZEV2ZW50ID0gZXhwb3J0cy5NaXJyb3JDcmVhdGVkRXZlbnQgPSBleHBvcnRzLk1pcnJvckNyZWF0ZUV2ZW50ID0gZXhwb3J0cy5NaXJyb3JFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgbWlycm9yIGV2ZW50XHJcbiAqIEBjbGFzcyBNaXJyb3JFdmVudFxyXG4gKiBAbW9kdWxlIE1pcnJvckV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIE1pcnJvckV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgc291cmNlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgc291cmNlXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzb3VyY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgb3JpZ2luYWwgc291cmNlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxTb3VyY2VcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9yaWdpbmFsU291cmNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vcmlnaW5hbFNvdXJjZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgc291cmNlIGNvbnRhaW5lciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IHNvdXJjZUNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc291cmNlQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2VDb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5zb3IgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgc2Vuc29yRXZlbnRcclxuICAgKiBAdHlwZSB7U2Vuc29yRXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNlbnNvckV2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zZW5zb3JFdmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgZHJhZ0V2ZW50XHJcbiAgICogQHR5cGUge0RyYWdFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ0V2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBldmVudCB0aGF0IHRyaWdnZXJlZCBzZW5zb3IgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxFdmVudFxyXG4gICAqIEB0eXBlIHtFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3JpZ2luYWxFdmVudCgpIHtcclxuICAgIGlmICh0aGlzLnNlbnNvckV2ZW50KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLk1pcnJvckV2ZW50ID0gTWlycm9yRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1pcnJvciBjcmVhdGUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgTWlycm9yQ3JlYXRlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIE1pcnJvckNyZWF0ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgTWlycm9yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmNsYXNzIE1pcnJvckNyZWF0ZUV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge31cclxuXHJcbmV4cG9ydHMuTWlycm9yQ3JlYXRlRXZlbnQgPSBNaXJyb3JDcmVhdGVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWlycm9yIGNyZWF0ZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgTWlycm9yQ3JlYXRlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JDcmVhdGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBNaXJyb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuTWlycm9yQ3JlYXRlRXZlbnQudHlwZSA9ICdtaXJyb3I6Y3JlYXRlJztcclxuY2xhc3MgTWlycm9yQ3JlYXRlZEV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG1pcnJvclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbWlycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLk1pcnJvckNyZWF0ZWRFdmVudCA9IE1pcnJvckNyZWF0ZWRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNaXJyb3IgYXR0YWNoZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBNaXJyb3JBdHRhY2hlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIE1pcnJvckF0dGFjaGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIE1pcnJvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbk1pcnJvckNyZWF0ZWRFdmVudC50eXBlID0gJ21pcnJvcjpjcmVhdGVkJztcclxuY2xhc3MgTWlycm9yQXR0YWNoZWRFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBtaXJyb3IgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG1pcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5NaXJyb3JBdHRhY2hlZEV2ZW50ID0gTWlycm9yQXR0YWNoZWRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1pcnJvciBtb3ZlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBNaXJyb3JNb3ZlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JNb3ZlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgTWlycm9yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5NaXJyb3JBdHRhY2hlZEV2ZW50LnR5cGUgPSAnbWlycm9yOmF0dGFjaGVkJztcclxuY2xhc3MgTWlycm9yTW92ZUV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG1pcnJvclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbWlycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5zb3IgaGFzIGV4Y2VlZGVkIG1pcnJvcidzIHRocmVzaG9sZCBvbiB4IGF4aXNcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcGFzc2VkVGhyZXNoWCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEucGFzc2VkVGhyZXNoWDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbnNvciBoYXMgZXhjZWVkZWQgbWlycm9yJ3MgdGhyZXNob2xkIG9uIHkgYXhpc1xyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBwYXNzZWRUaHJlc2hZKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wYXNzZWRUaHJlc2hZO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5NaXJyb3JNb3ZlRXZlbnQgPSBNaXJyb3JNb3ZlRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWlycm9yIGRlc3Ryb3kgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBNaXJyb3JEZXN0cm95RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgTWlycm9yRGVzdHJveUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBNaXJyb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5NaXJyb3JNb3ZlRXZlbnQudHlwZSA9ICdtaXJyb3I6bW92ZSc7XHJcbk1pcnJvck1vdmVFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgTWlycm9yRGVzdHJveUV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG1pcnJvclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbWlycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuTWlycm9yRGVzdHJveUV2ZW50ID0gTWlycm9yRGVzdHJveUV2ZW50O1xyXG5NaXJyb3JEZXN0cm95RXZlbnQudHlwZSA9ICdtaXJyb3I6ZGVzdHJveSc7XHJcbk1pcnJvckRlc3Ryb3lFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfTWlycm9yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcclxuXHJcbk9iamVjdC5rZXlzKF9NaXJyb3JFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9NaXJyb3JFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZ2V0QXBwZW5kYWJsZUNvbnRhaW5lciA9IGV4cG9ydHMub25TY3JvbGwgPSBleHBvcnRzLm9uTWlycm9yTW92ZSA9IGV4cG9ydHMub25NaXJyb3JDcmVhdGVkID0gZXhwb3J0cy5vbkRyYWdTdG9wID0gZXhwb3J0cy5vbkRyYWdNb3ZlID0gZXhwb3J0cy5vbkRyYWdTdGFydCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxudmFyIF9NaXJyb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cclxuXHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gZXhwb3J0cy5vbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcclxuY29uc3Qgb25EcmFnTW92ZSA9IGV4cG9ydHMub25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xyXG5jb25zdCBvbkRyYWdTdG9wID0gZXhwb3J0cy5vbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XHJcbmNvbnN0IG9uTWlycm9yQ3JlYXRlZCA9IGV4cG9ydHMub25NaXJyb3JDcmVhdGVkID0gU3ltYm9sKCdvbk1pcnJvckNyZWF0ZWQnKTtcclxuY29uc3Qgb25NaXJyb3JNb3ZlID0gZXhwb3J0cy5vbk1pcnJvck1vdmUgPSBTeW1ib2woJ29uTWlycm9yTW92ZScpO1xyXG5jb25zdCBvblNjcm9sbCA9IGV4cG9ydHMub25TY3JvbGwgPSBTeW1ib2woJ29uU2Nyb2xsJyk7XHJcbmNvbnN0IGdldEFwcGVuZGFibGVDb250YWluZXIgPSBleHBvcnRzLmdldEFwcGVuZGFibGVDb250YWluZXIgPSBTeW1ib2woJ2dldEFwcGVuZGFibGVDb250YWluZXInKTtcclxuXHJcbi8qKlxyXG4gKiBNaXJyb3IgZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRlZmF1bHRPcHRpb25zLmNvbnN0cmFpbkRpbWVuc2lvbnNcclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkZWZhdWx0T3B0aW9ucy54QXhpc1xyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRlZmF1bHRPcHRpb25zLnlBeGlzXHJcbiAqIEBwcm9wZXJ0eSB7bnVsbH0gZGVmYXVsdE9wdGlvbnMuY3Vyc29yT2Zmc2V0WFxyXG4gKiBAcHJvcGVydHkge251bGx9IGRlZmF1bHRPcHRpb25zLmN1cnNvck9mZnNldFlcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcclxuICBjb25zdHJhaW5EaW1lbnNpb25zOiBmYWxzZSxcclxuICB4QXhpczogdHJ1ZSxcclxuICB5QXhpczogdHJ1ZSxcclxuICBjdXJzb3JPZmZzZXRYOiBudWxsLFxyXG4gIGN1cnNvck9mZnNldFk6IG51bGwsXHJcbiAgdGhyZXNob2xkWDogbnVsbCxcclxuICB0aHJlc2hvbGRZOiBudWxsXHJcbn07XHJcblxyXG4vKipcclxuICogTWlycm9yIHBsdWdpbiB3aGljaCBjb250cm9scyB0aGUgbWlycm9yIHBvc2l0aW9uaW5nIHdoaWxlIGRyYWdnaW5nXHJcbiAqIEBjbGFzcyBNaXJyb3JcclxuICogQG1vZHVsZSBNaXJyb3JcclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIE1pcnJvciBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogTWlycm9yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIE1pcnJvclxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNaXJyb3Igb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gb3B0aW9ucy5jb25zdHJhaW5EaW1lbnNpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG9wdGlvbnMueEF4aXNcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gb3B0aW9ucy55QXhpc1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8bnVsbH0gb3B0aW9ucy5jdXJzb3JPZmZzZXRYXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxudWxsfSBvcHRpb25zLmN1cnNvck9mZnNldFlcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufSBvcHRpb25zLmFwcGVuZFRvXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIHRoaXMuZ2V0T3B0aW9ucygpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjcm9sbCBvZmZzZXQgZm9yIHRvdWNoIGRldmljZXMgYmVjYXVzZSB0aGUgbWlycm9yIGlzIHBvc2l0aW9uZWQgZml4ZWRcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzY3JvbGxPZmZzZXRcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY3JvbGxPZmZzZXQueFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjcm9sbE9mZnNldC55XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsIHNjcm9sbCBvZmZzZXQgZm9yIHRvdWNoIGRldmljZXMgYmVjYXVzZSB0aGUgbWlycm9yIGlzIHBvc2l0aW9uZWQgZml4ZWRcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzY3JvbGxPZmZzZXRcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY3JvbGxPZmZzZXQueFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjcm9sbE9mZnNldC55XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldCA9IHtcclxuICAgICAgeDogd2luZG93LnNjcm9sbFgsXHJcbiAgICAgIHk6IHdpbmRvdy5zY3JvbGxZXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnTW92ZV0gPSB0aGlzW29uRHJhZ01vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1pcnJvckNyZWF0ZWRdID0gdGhpc1tvbk1pcnJvckNyZWF0ZWRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTWlycm9yTW92ZV0gPSB0aGlzW29uTWlycm9yTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25TY3JvbGxdID0gdGhpc1tvblNjcm9sbF0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKS5vbignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9uKCdtaXJyb3I6bW92ZScsIHRoaXNbb25NaXJyb3JNb3ZlXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vZmYoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSkub2ZmKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub2ZmKCdtaXJyb3I6bW92ZScsIHRoaXNbb25NaXJyb3JNb3ZlXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5taXJyb3IgfHwge307XHJcbiAgfVxyXG5cclxuICBbb25EcmFnU3RhcnRdKGRyYWdFdmVudCkge1xyXG4gICAgaWYgKGRyYWdFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXNbb25TY3JvbGxdLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQgPSB7XHJcbiAgICAgIHg6IHdpbmRvdy5zY3JvbGxYLFxyXG4gICAgICB5OiB3aW5kb3cuc2Nyb2xsWVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCB7IHNvdXJjZSwgb3JpZ2luYWxTb3VyY2UsIHNvdXJjZUNvbnRhaW5lciwgc2Vuc29yRXZlbnQgfSA9IGRyYWdFdmVudDtcclxuXHJcbiAgICAvLyBMYXN0IHNlbnNvciBwb3NpdGlvbiBvZiBtaXJyb3IgbW92ZVxyXG4gICAgdGhpcy5sYXN0TWlycm9yTW92ZWRDbGllbnQgPSB7XHJcbiAgICAgIHg6IHNlbnNvckV2ZW50LmNsaWVudFgsXHJcbiAgICAgIHk6IHNlbnNvckV2ZW50LmNsaWVudFlcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgbWlycm9yQ3JlYXRlRXZlbnQgPSBuZXcgX01pcnJvckV2ZW50Lk1pcnJvckNyZWF0ZUV2ZW50KHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgZHJhZ0V2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckNyZWF0ZUV2ZW50KTtcclxuXHJcbiAgICBpZiAoaXNOYXRpdmVEcmFnRXZlbnQoc2Vuc29yRXZlbnQpIHx8IG1pcnJvckNyZWF0ZUV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFwcGVuZGFibGVDb250YWluZXIgPSB0aGlzW2dldEFwcGVuZGFibGVDb250YWluZXJdKHNvdXJjZSkgfHwgc291cmNlQ29udGFpbmVyO1xyXG4gICAgdGhpcy5taXJyb3IgPSBzb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xyXG5cclxuICAgIGNvbnN0IG1pcnJvckNyZWF0ZWRFdmVudCA9IG5ldyBfTWlycm9yRXZlbnQuTWlycm9yQ3JlYXRlZEV2ZW50KHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgZHJhZ0V2ZW50LFxyXG4gICAgICBtaXJyb3I6IHRoaXMubWlycm9yXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBtaXJyb3JBdHRhY2hlZEV2ZW50ID0gbmV3IF9NaXJyb3JFdmVudC5NaXJyb3JBdHRhY2hlZEV2ZW50KHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgZHJhZ0V2ZW50LFxyXG4gICAgICBtaXJyb3I6IHRoaXMubWlycm9yXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckNyZWF0ZWRFdmVudCk7XHJcbiAgICBhcHBlbmRhYmxlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubWlycm9yKTtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yQXR0YWNoZWRFdmVudCk7XHJcbiAgfVxyXG5cclxuICBbb25EcmFnTW92ZV0oZHJhZ0V2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMubWlycm9yIHx8IGRyYWdFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHNvdXJjZSwgb3JpZ2luYWxTb3VyY2UsIHNvdXJjZUNvbnRhaW5lciwgc2Vuc29yRXZlbnQgfSA9IGRyYWdFdmVudDtcclxuXHJcbiAgICBsZXQgcGFzc2VkVGhyZXNoWCA9IHRydWU7XHJcbiAgICBsZXQgcGFzc2VkVGhyZXNoWSA9IHRydWU7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy50aHJlc2hvbGRYIHx8IHRoaXMub3B0aW9ucy50aHJlc2hvbGRZKSB7XHJcbiAgICAgIGNvbnN0IHsgeDogbGFzdFgsIHk6IGxhc3RZIH0gPSB0aGlzLmxhc3RNaXJyb3JNb3ZlZENsaWVudDtcclxuXHJcbiAgICAgIGlmIChNYXRoLmFicyhsYXN0WCAtIHNlbnNvckV2ZW50LmNsaWVudFgpIDwgdGhpcy5vcHRpb25zLnRocmVzaG9sZFgpIHtcclxuICAgICAgICBwYXNzZWRUaHJlc2hYID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sYXN0TWlycm9yTW92ZWRDbGllbnQueCA9IHNlbnNvckV2ZW50LmNsaWVudFg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChNYXRoLmFicyhsYXN0WSAtIHNlbnNvckV2ZW50LmNsaWVudFkpIDwgdGhpcy5vcHRpb25zLnRocmVzaG9sZFkpIHtcclxuICAgICAgICBwYXNzZWRUaHJlc2hZID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sYXN0TWlycm9yTW92ZWRDbGllbnQueSA9IHNlbnNvckV2ZW50LmNsaWVudFk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcGFzc2VkVGhyZXNoWCAmJiAhcGFzc2VkVGhyZXNoWSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1pcnJvck1vdmVFdmVudCA9IG5ldyBfTWlycm9yRXZlbnQuTWlycm9yTW92ZUV2ZW50KHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgZHJhZ0V2ZW50LFxyXG4gICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxyXG4gICAgICBwYXNzZWRUaHJlc2hYLFxyXG4gICAgICBwYXNzZWRUaHJlc2hZXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvck1vdmVFdmVudCk7XHJcbiAgfVxyXG5cclxuICBbb25EcmFnU3RvcF0oZHJhZ0V2ZW50KSB7XHJcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXNbb25TY3JvbGxdLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcblxyXG4gICAgaWYgKCF0aGlzLm1pcnJvcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBzb3VyY2UsIHNvdXJjZUNvbnRhaW5lciwgc2Vuc29yRXZlbnQgfSA9IGRyYWdFdmVudDtcclxuXHJcbiAgICBjb25zdCBtaXJyb3JEZXN0cm95RXZlbnQgPSBuZXcgX01pcnJvckV2ZW50Lk1pcnJvckRlc3Ryb3lFdmVudCh7XHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcclxuICAgICAgc291cmNlQ29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgZHJhZ0V2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckRlc3Ryb3lFdmVudCk7XHJcblxyXG4gICAgaWYgKCFtaXJyb3JEZXN0cm95RXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICB0aGlzLm1pcnJvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubWlycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIFtvblNjcm9sbF0oKSB7XHJcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHtcclxuICAgICAgeDogd2luZG93LnNjcm9sbFggLSB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQueCxcclxuICAgICAgeTogd2luZG93LnNjcm9sbFkgLSB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQueVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1pcnJvciBjcmVhdGVkIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge01pcnJvckNyZWF0ZWRFdmVudH0gbWlycm9yRXZlbnRcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uTWlycm9yQ3JlYXRlZF0oeyBtaXJyb3IsIHNvdXJjZSwgc2Vuc29yRXZlbnQgfSkge1xyXG4gICAgY29uc3QgbWlycm9yQ2xhc3NlcyA9IHRoaXMuZHJhZ2dhYmxlLmdldENsYXNzTmFtZXNGb3IoJ21pcnJvcicpO1xyXG5cclxuICAgIGNvbnN0IHNldFN0YXRlID0gKF9yZWYpID0+IHtcclxuICAgICAgbGV0IHsgbWlycm9yT2Zmc2V0LCBpbml0aWFsWCwgaW5pdGlhbFkgfSA9IF9yZWYsXHJcbiAgICAgICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnbWlycm9yT2Zmc2V0JywgJ2luaXRpYWxYJywgJ2luaXRpYWxZJ10pO1xyXG5cclxuICAgICAgdGhpcy5taXJyb3JPZmZzZXQgPSBtaXJyb3JPZmZzZXQ7XHJcbiAgICAgIHRoaXMuaW5pdGlhbFggPSBpbml0aWFsWDtcclxuICAgICAgdGhpcy5pbml0aWFsWSA9IGluaXRpYWxZO1xyXG4gICAgICB0aGlzLmxhc3RNb3ZlZFggPSBpbml0aWFsWDtcclxuICAgICAgdGhpcy5sYXN0TW92ZWRZID0gaW5pdGlhbFk7XHJcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7IG1pcnJvck9mZnNldCwgaW5pdGlhbFgsIGluaXRpYWxZIH0sIGFyZ3MpO1xyXG4gICAgfTtcclxuXHJcbiAgICBtaXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHJcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSB7XHJcbiAgICAgIG1pcnJvcixcclxuICAgICAgc291cmNlLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgbWlycm9yQ2xhc3NlcyxcclxuICAgICAgc2Nyb2xsT2Zmc2V0OiB0aGlzLnNjcm9sbE9mZnNldCxcclxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxyXG4gICAgICBwYXNzZWRUaHJlc2hYOiB0cnVlLFxyXG4gICAgICBwYXNzZWRUaHJlc2hZOiB0cnVlXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW5pdGlhbFN0YXRlKVxyXG4gICAgLy8gRml4IHJlZmxvdyBoZXJlXHJcbiAgICAudGhlbihjb21wdXRlTWlycm9yRGltZW5zaW9ucykudGhlbihjYWxjdWxhdGVNaXJyb3JPZmZzZXQpLnRoZW4ocmVzZXRNaXJyb3IpLnRoZW4oYWRkTWlycm9yQ2xhc3NlcykudGhlbihwb3NpdGlvbk1pcnJvcih7IGluaXRpYWw6IHRydWUgfSkpLnRoZW4ocmVtb3ZlTWlycm9ySUQpLnRoZW4oc2V0U3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlycm9yIG1vdmUgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7TWlycm9yTW92ZUV2ZW50fSBtaXJyb3JFdmVudFxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V8bnVsbH1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbk1pcnJvck1vdmVdKG1pcnJvckV2ZW50KSB7XHJcbiAgICBpZiAobWlycm9yRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZXRTdGF0ZSA9IChfcmVmMikgPT4ge1xyXG4gICAgICBsZXQgeyBsYXN0TW92ZWRYLCBsYXN0TW92ZWRZIH0gPSBfcmVmMixcclxuICAgICAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnbGFzdE1vdmVkWCcsICdsYXN0TW92ZWRZJ10pO1xyXG5cclxuICAgICAgdGhpcy5sYXN0TW92ZWRYID0gbGFzdE1vdmVkWDtcclxuICAgICAgdGhpcy5sYXN0TW92ZWRZID0gbGFzdE1vdmVkWTtcclxuXHJcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7IGxhc3RNb3ZlZFgsIGxhc3RNb3ZlZFkgfSwgYXJncyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcclxuICAgICAgbWlycm9yOiBtaXJyb3JFdmVudC5taXJyb3IsXHJcbiAgICAgIHNlbnNvckV2ZW50OiBtaXJyb3JFdmVudC5zZW5zb3JFdmVudCxcclxuICAgICAgbWlycm9yT2Zmc2V0OiB0aGlzLm1pcnJvck9mZnNldCxcclxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxyXG4gICAgICBpbml0aWFsWDogdGhpcy5pbml0aWFsWCxcclxuICAgICAgaW5pdGlhbFk6IHRoaXMuaW5pdGlhbFksXHJcbiAgICAgIHNjcm9sbE9mZnNldDogdGhpcy5zY3JvbGxPZmZzZXQsXHJcbiAgICAgIHBhc3NlZFRocmVzaFg6IG1pcnJvckV2ZW50LnBhc3NlZFRocmVzaFgsXHJcbiAgICAgIHBhc3NlZFRocmVzaFk6IG1pcnJvckV2ZW50LnBhc3NlZFRocmVzaFksXHJcbiAgICAgIGxhc3RNb3ZlZFg6IHRoaXMubGFzdE1vdmVkWCxcclxuICAgICAgbGFzdE1vdmVkWTogdGhpcy5sYXN0TW92ZWRZXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW5pdGlhbFN0YXRlKS50aGVuKHBvc2l0aW9uTWlycm9yKHsgcmFmOiB0cnVlIH0pKS50aGVuKHNldFN0YXRlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYXBwZW5kYWJsZSBjb250YWluZXIgZm9yIG1pcnJvciBiYXNlZCBvbiB0aGUgYXBwZW5kVG8gb3B0aW9uXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMuc291cmNlIC0gQ3VycmVudCBzb3VyY2VcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgKi9cclxuICBbZ2V0QXBwZW5kYWJsZUNvbnRhaW5lcl0oc291cmNlKSB7XHJcbiAgICBjb25zdCBhcHBlbmRUbyA9IHRoaXMub3B0aW9ucy5hcHBlbmRUbztcclxuXHJcbiAgICBpZiAodHlwZW9mIGFwcGVuZFRvID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcHBlbmRUbyk7XHJcbiAgICB9IGVsc2UgaWYgKGFwcGVuZFRvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGFwcGVuZFRvO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXBwZW5kVG8gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIGFwcGVuZFRvKHNvdXJjZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gc291cmNlLnBhcmVudE5vZGU7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBNaXJyb3I7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbXB1dGVzIG1pcnJvciBkaW1lbnNpb25zIGJhc2VkIG9uIHRoZSBzb3VyY2UgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFkZHMgc291cmNlUmVjdCB0byBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLnNvdXJjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmZ1bmN0aW9uIGNvbXB1dGVNaXJyb3JEaW1lbnNpb25zKF9yZWYzKSB7XHJcbiAgbGV0IHsgc291cmNlIH0gPSBfcmVmMyxcclxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMywgWydzb3VyY2UnXSk7XHJcblxyXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIGNvbnN0IHNvdXJjZVJlY3QgPSBzb3VyY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICByZXNvbHZlKF9leHRlbmRzKHsgc291cmNlLCBzb3VyY2VSZWN0IH0sIGFyZ3MpKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgbWlycm9yIG9mZnNldFxyXG4gKiBBZGRzIG1pcnJvck9mZnNldCB0byBzdGF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcclxuICogQHBhcmFtIHtTZW5zb3JFdmVudH0gc3RhdGUuc2Vuc29yRXZlbnRcclxuICogQHBhcmFtIHtET01SZWN0fSBzdGF0ZS5zb3VyY2VSZWN0XHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVNaXJyb3JPZmZzZXQoX3JlZjQpIHtcclxuICBsZXQgeyBzZW5zb3JFdmVudCwgc291cmNlUmVjdCwgb3B0aW9ucyB9ID0gX3JlZjQsXHJcbiAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjQsIFsnc2Vuc29yRXZlbnQnLCAnc291cmNlUmVjdCcsICdvcHRpb25zJ10pO1xyXG5cclxuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBjb25zdCB0b3AgPSBvcHRpb25zLmN1cnNvck9mZnNldFkgPT09IG51bGwgPyBzZW5zb3JFdmVudC5jbGllbnRZIC0gc291cmNlUmVjdC50b3AgOiBvcHRpb25zLmN1cnNvck9mZnNldFk7XHJcbiAgICBjb25zdCBsZWZ0ID0gb3B0aW9ucy5jdXJzb3JPZmZzZXRYID09PSBudWxsID8gc2Vuc29yRXZlbnQuY2xpZW50WCAtIHNvdXJjZVJlY3QubGVmdCA6IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WDtcclxuXHJcbiAgICBjb25zdCBtaXJyb3JPZmZzZXQgPSB7IHRvcCwgbGVmdCB9O1xyXG5cclxuICAgIHJlc29sdmUoX2V4dGVuZHMoeyBzZW5zb3JFdmVudCwgc291cmNlUmVjdCwgbWlycm9yT2Zmc2V0LCBvcHRpb25zIH0sIGFyZ3MpKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGx5cyBtaXJyb3Igc3R5bGVzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5taXJyb3JcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUuc291cmNlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZS5vcHRpb25zXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNldE1pcnJvcihfcmVmNSkge1xyXG4gIGxldCB7IG1pcnJvciwgc291cmNlLCBvcHRpb25zIH0gPSBfcmVmNSxcclxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNSwgWydtaXJyb3InLCAnc291cmNlJywgJ29wdGlvbnMnXSk7XHJcblxyXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIGxldCBvZmZzZXRIZWlnaHQ7XHJcbiAgICBsZXQgb2Zmc2V0V2lkdGg7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9ucykge1xyXG4gICAgICBjb25zdCBjb21wdXRlZFNvdXJjZVN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoc291cmNlKTtcclxuICAgICAgb2Zmc2V0SGVpZ2h0ID0gY29tcHV0ZWRTb3VyY2VTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0Jyk7XHJcbiAgICAgIG9mZnNldFdpZHRoID0gY29tcHV0ZWRTb3VyY2VTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKTtcclxuICAgIH1cclxuXHJcbiAgICBtaXJyb3Iuc3R5bGUuZGlzcGxheSA9IG51bGw7XHJcbiAgICBtaXJyb3Iuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xyXG4gICAgbWlycm9yLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcbiAgICBtaXJyb3Iuc3R5bGUudG9wID0gMDtcclxuICAgIG1pcnJvci5zdHlsZS5sZWZ0ID0gMDtcclxuICAgIG1pcnJvci5zdHlsZS5tYXJnaW4gPSAwO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmNvbnN0cmFpbkRpbWVuc2lvbnMpIHtcclxuICAgICAgbWlycm9yLnN0eWxlLmhlaWdodCA9IG9mZnNldEhlaWdodDtcclxuICAgICAgbWlycm9yLnN0eWxlLndpZHRoID0gb2Zmc2V0V2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzb2x2ZShfZXh0ZW5kcyh7IG1pcnJvciwgc291cmNlLCBvcHRpb25zIH0sIGFyZ3MpKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGx5cyBtaXJyb3IgY2xhc3Mgb24gbWlycm9yIGVsZW1lbnRcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLm1pcnJvclxyXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBzdGF0ZS5taXJyb3JDbGFzc2VzXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRNaXJyb3JDbGFzc2VzKF9yZWY2KSB7XHJcbiAgbGV0IHsgbWlycm9yLCBtaXJyb3JDbGFzc2VzIH0gPSBfcmVmNixcclxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNiwgWydtaXJyb3InLCAnbWlycm9yQ2xhc3NlcyddKTtcclxuXHJcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgbWlycm9yLmNsYXNzTGlzdC5hZGQoLi4ubWlycm9yQ2xhc3Nlcyk7XHJcbiAgICByZXNvbHZlKF9leHRlbmRzKHsgbWlycm9yLCBtaXJyb3JDbGFzc2VzIH0sIGFyZ3MpKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgc291cmNlIElEIGZyb20gY2xvbmVkIG1pcnJvciBlbGVtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5taXJyb3JcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZU1pcnJvcklEKF9yZWY3KSB7XHJcbiAgbGV0IHsgbWlycm9yIH0gPSBfcmVmNyxcclxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNywgWydtaXJyb3InXSk7XHJcblxyXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIG1pcnJvci5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XHJcbiAgICBkZWxldGUgbWlycm9yLmlkO1xyXG4gICAgcmVzb2x2ZShfZXh0ZW5kcyh7IG1pcnJvciB9LCBhcmdzKSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQb3NpdGlvbnMgbWlycm9yIHdpdGggdHJhbnNsYXRlM2RcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLm1pcnJvclxyXG4gKiBAcGFyYW0ge1NlbnNvckV2ZW50fSBzdGF0ZS5zZW5zb3JFdmVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUubWlycm9yT2Zmc2V0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0ZS5pbml0aWFsWVxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdGUuaW5pdGlhbFhcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlLm9wdGlvbnNcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHBvc2l0aW9uTWlycm9yKHsgd2l0aEZyYW1lID0gZmFsc2UsIGluaXRpYWwgPSBmYWxzZSB9ID0ge30pIHtcclxuICByZXR1cm4gKF9yZWY4KSA9PiB7XHJcbiAgICBsZXQge1xyXG4gICAgICBtaXJyb3IsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBtaXJyb3JPZmZzZXQsXHJcbiAgICAgIGluaXRpYWxZLFxyXG4gICAgICBpbml0aWFsWCxcclxuICAgICAgc2Nyb2xsT2Zmc2V0LFxyXG4gICAgICBvcHRpb25zLFxyXG4gICAgICBwYXNzZWRUaHJlc2hYLFxyXG4gICAgICBwYXNzZWRUaHJlc2hZLFxyXG4gICAgICBsYXN0TW92ZWRYLFxyXG4gICAgICBsYXN0TW92ZWRZXHJcbiAgICB9ID0gX3JlZjgsXHJcbiAgICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmOCwgWydtaXJyb3InLCAnc2Vuc29yRXZlbnQnLCAnbWlycm9yT2Zmc2V0JywgJ2luaXRpYWxZJywgJ2luaXRpYWxYJywgJ3Njcm9sbE9mZnNldCcsICdvcHRpb25zJywgJ3Bhc3NlZFRocmVzaFgnLCAncGFzc2VkVGhyZXNoWScsICdsYXN0TW92ZWRYJywgJ2xhc3RNb3ZlZFknXSk7XHJcblxyXG4gICAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBfZXh0ZW5kcyh7XHJcbiAgICAgICAgbWlycm9yLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG1pcnJvck9mZnNldCxcclxuICAgICAgICBvcHRpb25zXHJcbiAgICAgIH0sIGFyZ3MpO1xyXG5cclxuICAgICAgaWYgKG1pcnJvck9mZnNldCkge1xyXG4gICAgICAgIGNvbnN0IHggPSBwYXNzZWRUaHJlc2hYID8gTWF0aC5yb3VuZCgoc2Vuc29yRXZlbnQuY2xpZW50WCAtIG1pcnJvck9mZnNldC5sZWZ0IC0gc2Nyb2xsT2Zmc2V0LngpIC8gKG9wdGlvbnMudGhyZXNob2xkWCB8fCAxKSkgKiAob3B0aW9ucy50aHJlc2hvbGRYIHx8IDEpIDogTWF0aC5yb3VuZChsYXN0TW92ZWRYKTtcclxuICAgICAgICBjb25zdCB5ID0gcGFzc2VkVGhyZXNoWSA/IE1hdGgucm91bmQoKHNlbnNvckV2ZW50LmNsaWVudFkgLSBtaXJyb3JPZmZzZXQudG9wIC0gc2Nyb2xsT2Zmc2V0LnkpIC8gKG9wdGlvbnMudGhyZXNob2xkWSB8fCAxKSkgKiAob3B0aW9ucy50aHJlc2hvbGRZIHx8IDEpIDogTWF0aC5yb3VuZChsYXN0TW92ZWRZKTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMueEF4aXMgJiYgb3B0aW9ucy55QXhpcyB8fCBpbml0aWFsKSB7XHJcbiAgICAgICAgICBtaXJyb3Iuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7eH1weCwgJHt5fXB4LCAwKWA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnhBeGlzICYmICFvcHRpb25zLnlBeGlzKSB7XHJcbiAgICAgICAgICBtaXJyb3Iuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7eH1weCwgJHtpbml0aWFsWX1weCwgMClgO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy55QXhpcyAmJiAhb3B0aW9ucy54QXhpcykge1xyXG4gICAgICAgICAgbWlycm9yLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke2luaXRpYWxYfXB4LCAke3l9cHgsIDApYDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpbml0aWFsKSB7XHJcbiAgICAgICAgICByZXN1bHQuaW5pdGlhbFggPSB4O1xyXG4gICAgICAgICAgcmVzdWx0LmluaXRpYWxZID0geTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdC5sYXN0TW92ZWRYID0geDtcclxuICAgICAgICByZXN1bHQubGFzdE1vdmVkWSA9IHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgIH0sIHsgZnJhbWU6IHdpdGhGcmFtZSB9KTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogV3JhcHMgZnVuY3Rpb25zIGluIHByb21pc2Ugd2l0aCBwb3RlbnRpYWwgYW5pbWF0aW9uIGZyYW1lIG9wdGlvblxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMucmFmXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoUHJvbWlzZShjYWxsYmFjaywgeyByYWYgPSBmYWxzZSB9ID0ge30pIHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgaWYgKHJhZikge1xyXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIGNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2Vuc29yIGV2ZW50IHdhcyB0cmlnZ2VyZWQgYnkgYSBuYXRpdmUgYnJvd3NlciBkcmFnIGV2ZW50XHJcbiAqIEBwYXJhbSB7U2Vuc29yRXZlbnR9IHNlbnNvckV2ZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpc05hdGl2ZURyYWdFdmVudChzZW5zb3JFdmVudCkge1xyXG4gIHJldHVybiAoL15kcmFnLy50ZXN0KHNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQudHlwZSlcclxuICApO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX01pcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG5cclxudmFyIF9NaXJyb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWlycm9yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfTWlycm9yMi5kZWZhdWx0O1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gX01pcnJvci5kZWZhdWx0T3B0aW9ucztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uSW5pdGlhbGl6ZSA9IFN5bWJvbCgnb25Jbml0aWFsaXplJyk7XHJcbmNvbnN0IG9uRGVzdHJveSA9IFN5bWJvbCgnb25EZXN0cm95Jyk7XHJcblxyXG4vKipcclxuICogRm9jdXNhYmxlIGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge307XHJcblxyXG4vKipcclxuICogRm9jdXNhYmxlIHBsdWdpblxyXG4gKiBAY2xhc3MgRm9jdXNhYmxlXHJcbiAqIEBtb2R1bGUgRm9jdXNhYmxlXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBGb2N1c2FibGUgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIEZvY3VzYWJsZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBGb2N1c2FibGVcclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9jdXNhYmxlIG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIHRoaXMuZ2V0T3B0aW9ucygpKTtcclxuXHJcbiAgICB0aGlzW29uSW5pdGlhbGl6ZV0gPSB0aGlzW29uSW5pdGlhbGl6ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EZXN0cm95XSA9IHRoaXNbb25EZXN0cm95XS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgbGlzdGVuZXJzIHRvIGRyYWdnYWJsZVxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnZ2FibGU6aW5pdGlhbGl6ZScsIHRoaXNbb25Jbml0aWFsaXplXSkub24oJ2RyYWdnYWJsZTpkZXN0cm95JywgdGhpc1tvbkRlc3Ryb3ldKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIGxpc3RlbmVycyBmcm9tIGRyYWdnYWJsZVxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZ2dhYmxlOmluaXRpYWxpemUnLCB0aGlzW29uSW5pdGlhbGl6ZV0pLm9mZignZHJhZ2dhYmxlOmRlc3Ryb3knLCB0aGlzW29uRGVzdHJveV0pO1xyXG5cclxuICAgIC8vIFJlbW92ZSBtb2RpZmllZCBlbGVtZW50cyB3aGVuIGRldGFjaFxyXG4gICAgdGhpc1tvbkRlc3Ryb3ldKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5mb2N1c2FibGUgfHwge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGRyYWdnYWJsZSBjb250YWluZXJzIGFuZCBlbGVtZW50c1xyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XHJcbiAgICovXHJcbiAgZ2V0RWxlbWVudHMoKSB7XHJcbiAgICByZXR1cm4gWy4uLnRoaXMuZHJhZ2dhYmxlLmNvbnRhaW5lcnMsIC4uLnRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzKCldO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW50aWFsaXplIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkluaXRpYWxpemVdKCkge1xyXG4gICAgLy8gQ2FuIHdhaXQgdW50aWwgdGhlIG5leHQgYmVzdCBmcmFtZSBpcyBhdmFpbGFibGVcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMuZ2V0RWxlbWVudHMoKS5mb3JFYWNoKGVsZW1lbnQgPT4gZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzdHJveSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25EZXN0cm95XSgpIHtcclxuICAgIC8vIENhbiB3YWl0IHVudGlsIHRoZSBuZXh0IGJlc3QgZnJhbWUgaXMgYXZhaWxhYmxlXHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB0aGlzLmdldEVsZW1lbnRzKCkuZm9yRWFjaChlbGVtZW50ID0+IHN0cmlwRWxlbWVudChlbGVtZW50KSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IEZvY3VzYWJsZTsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBtaXNzaW5nIHRhYmluZGV4IGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBzbyB0aGV5IGNhbiBiZSByZXNldCB3aGVuIGRyYWdnYWJsZSBnZXRzIGRlc3Ryb3llZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjb25zdCB7SFRNTEVsZW1lbnRbXX0gZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5jb25zdCBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXggPSBbXTtcclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0ZXMgZWxlbWVudCB3aXRoIHRhYmluZGV4IGF0dHJpYnV0ZXNcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCkge1xyXG4gIGNvbnN0IGhhc01pc3NpbmdUYWJJbmRleCA9IEJvb2xlYW4oIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpICYmIGVsZW1lbnQudGFiSW5kZXggPT09IC0xKTtcclxuXHJcbiAgaWYgKGhhc01pc3NpbmdUYWJJbmRleCkge1xyXG4gICAgZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4LnB1c2goZWxlbWVudCk7XHJcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gMDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGVsZW1lbnRzIHRhYmluZGV4IGF0dHJpYnV0ZXNcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaXBFbGVtZW50KGVsZW1lbnQpIHtcclxuICBjb25zdCB0YWJJbmRleEVsZW1lbnRQb3NpdGlvbiA9IGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleC5pbmRleE9mKGVsZW1lbnQpO1xyXG5cclxuICBpZiAodGFiSW5kZXhFbGVtZW50UG9zaXRpb24gIT09IC0xKSB7XHJcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gLTE7XHJcbiAgICBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXguc3BsaWNlKHRhYkluZGV4RWxlbWVudFBvc2l0aW9uLCAxKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRm9jdXNhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XHJcblxyXG52YXIgX0ZvY3VzYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Gb2N1c2FibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Gb2N1c2FibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbi8qKlxyXG4gKiBBbGwgZHJhZ2dhYmxlIHBsdWdpbnMgaW5oZXJpdCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAY2xhc3MgQWJzdHJhY3RQbHVnaW5cclxuICogQG1vZHVsZSBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgQWJzdHJhY3RQbHVnaW4ge1xyXG4gIC8qKlxyXG4gICAqIEFic3RyYWN0UGx1Z2luIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIEFic3RyYWN0UGx1Z2luXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgICAqIEBwcm9wZXJ0eSBkcmFnZ2FibGVcclxuICAgICAqIEB0eXBlIHtEcmFnZ2FibGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3ZlcnJpZGUgdG8gYWRkIGxpc3RlbmVyc1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPdmVycmlkZSB0byByZW1vdmUgbGlzdGVuZXJzXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gQWJzdHJhY3RQbHVnaW47XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkluaXRpYWxpemUgPSBTeW1ib2woJ29uSW5pdGlhbGl6ZScpO1xyXG5jb25zdCBvbkRlc3Ryb3kgPSBTeW1ib2woJ29uRGVzdHJveScpO1xyXG5jb25zdCBhbm5vdW5jZUV2ZW50ID0gU3ltYm9sKCdhbm5vdW5jZUV2ZW50Jyk7XHJcbmNvbnN0IGFubm91bmNlTWVzc2FnZSA9IFN5bWJvbCgnYW5ub3VuY2VNZXNzYWdlJyk7XHJcblxyXG5jb25zdCBBUklBX1JFTEVWQU5UID0gJ2FyaWEtcmVsZXZhbnQnO1xyXG5jb25zdCBBUklBX0FUT01JQyA9ICdhcmlhLWF0b21pYyc7XHJcbmNvbnN0IEFSSUFfTElWRSA9ICdhcmlhLWxpdmUnO1xyXG5jb25zdCBST0xFID0gJ3JvbGUnO1xyXG5cclxuLyoqXHJcbiAqIEFubm91bmNlbWVudCBkZWZhdWx0IG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWZhdWx0T3B0aW9ucy5leHBpcmVcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcclxuICBleHBpcmU6IDcwMDBcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbm5vdW5jZW1lbnQgcGx1Z2luXHJcbiAqIEBjbGFzcyBBbm5vdW5jZW1lbnRcclxuICogQG1vZHVsZSBBbm5vdW5jZW1lbnRcclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIEFubm91bmNlbWVudCBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogQW5ub3VuY2VtZW50IGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIEFubm91bmNlbWVudFxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQbHVnaW4gb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3JpZ2luYWwgZHJhZ2dhYmxlIHRyaWdnZXIgbWV0aG9kLiBIYWNrIHVudGlsIHdlIGhhdmUgb25BbGwgb3Igb24oJ2FsbCcpXHJcbiAgICAgKiBAcHJvcGVydHkgb3JpZ2luYWxUcmlnZ2VyTWV0aG9kXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kID0gdGhpcy5kcmFnZ2FibGUudHJpZ2dlcjtcclxuXHJcbiAgICB0aGlzW29uSW5pdGlhbGl6ZV0gPSB0aGlzW29uSW5pdGlhbGl6ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EZXN0cm95XSA9IHRoaXNbb25EZXN0cm95XS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgbGlzdGVuZXJzIHRvIGRyYWdnYWJsZVxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnZ2FibGU6aW5pdGlhbGl6ZScsIHRoaXNbb25Jbml0aWFsaXplXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBsaXN0ZW5lcnMgZnJvbSBkcmFnZ2FibGVcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWdnYWJsZTpkZXN0cm95JywgdGhpc1tvbkRlc3Ryb3ldKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgcGFzc2VkIGluIG9wdGlvbnNcclxuICAgKi9cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuYW5ub3VuY2VtZW50cyB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFubm91bmNlcyBldmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtBYnN0cmFjdEV2ZW50fSBldmVudFxyXG4gICAqL1xyXG4gIFthbm5vdW5jZUV2ZW50XShldmVudCkge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMub3B0aW9uc1tldmVudC50eXBlXTtcclxuXHJcbiAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhpc1thbm5vdW5jZU1lc3NhZ2VdKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtZXNzYWdlICYmIHR5cGVvZiBtZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRoaXNbYW5ub3VuY2VNZXNzYWdlXShtZXNzYWdlKGV2ZW50KSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbm5vdW5jZXMgbWVzc2FnZSB0byBzY3JlZW4gcmVhZGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxyXG4gICAqL1xyXG4gIFthbm5vdW5jZU1lc3NhZ2VdKG1lc3NhZ2UpIHtcclxuICAgIGFubm91bmNlKG1lc3NhZ2UsIHsgZXhwaXJlOiB0aGlzLm9wdGlvbnMuZXhwaXJlIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBoYW5kZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkluaXRpYWxpemVdKCkge1xyXG4gICAgLy8gSGFjayB1bnRpbCB0aGVyZSBpcyBhbiBhcGkgZm9yIGxpc3RlbmluZyBmb3IgYWxsIGV2ZW50c1xyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlciA9IGV2ZW50ID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aGlzW2Fubm91bmNlRXZlbnRdKGV2ZW50KTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBvcmlnaW5hbCB0cmlnZ2VyIGlzIGNhbGxlZFxyXG4gICAgICAgIHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kLmNhbGwodGhpcy5kcmFnZ2FibGUsIGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgaGFuZGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25EZXN0cm95XSgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIgPSB0aGlzLm9yaWdpbmFsVHJpZ2dlck1ldGhvZDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFubm91bmNlbWVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0IHtIVE1MRWxlbWVudH0gbGl2ZVJlZ2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuY29uc3QgbGl2ZVJlZ2lvbiA9IGNyZWF0ZVJlZ2lvbigpO1xyXG5cclxuLyoqXHJcbiAqIEFubm91bmNlcyBtZXNzYWdlIHZpYSBsaXZlIHJlZ2lvblxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5leHBpcmVcclxuICovXHJcbmZ1bmN0aW9uIGFubm91bmNlKG1lc3NhZ2UsIHsgZXhwaXJlIH0pIHtcclxuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG4gIGVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xyXG4gIGxpdmVSZWdpb24uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XHJcblxyXG4gIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgIGxpdmVSZWdpb24ucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XHJcbiAgfSwgZXhwaXJlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgcmVnaW9uIGVsZW1lbnRcclxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZWdpb24oKSB7XHJcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCAnZHJhZ2dhYmxlLWxpdmUtcmVnaW9uJyk7XHJcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoQVJJQV9SRUxFVkFOVCwgJ2FkZGl0aW9ucycpO1xyXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKEFSSUFfQVRPTUlDLCAndHJ1ZScpO1xyXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKEFSSUFfTElWRSwgJ2Fzc2VydGl2ZScpO1xyXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKFJPTEUsICdsb2cnKTtcclxuXHJcbiAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XHJcbiAgZWxlbWVudC5zdHlsZS53aWR0aCA9ICcxcHgnO1xyXG4gIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzFweCc7XHJcbiAgZWxlbWVudC5zdHlsZS50b3AgPSAnLTFweCc7XHJcbiAgZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG5cclxuICByZXR1cm4gZWxlbWVudDtcclxufVxyXG5cclxuLy8gQXBwZW5kIGxpdmUgcmVnaW9uIGVsZW1lbnQgYXMgZWFybHkgYXMgcG9zc2libGVcclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcclxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpdmVSZWdpb24pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQW5ub3VuY2VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XHJcblxyXG52YXIgX0Fubm91bmNlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Bbm5vdW5jZW1lbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Bbm5vdW5jZW1lbnQyLmRlZmF1bHQ7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfQW5ub3VuY2VtZW50LmRlZmF1bHRPcHRpb25zO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkRyYWdnYWJsZURlc3Ryb3lFdmVudCA9IGV4cG9ydHMuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCA9IGV4cG9ydHMuRHJhZ2dhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIGRyYWdnYWJsZSBldmVudFxyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlRXZlbnRcclxuICogQG1vZHVsZSBEcmFnZ2FibGVFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBEcmFnZ2FibGVFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICogQHByb3BlcnR5IGRyYWdnYWJsZVxyXG4gICAqIEB0eXBlIHtEcmFnZ2FibGV9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyYWdnYWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ2dhYmxlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnZ2FibGVFdmVudCA9IERyYWdnYWJsZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnZ2FibGUgaW5pdGlhbGl6ZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdnYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnZ2FibGVFdmVudC50eXBlID0gJ2RyYWdnYWJsZSc7XHJcbmNsYXNzIERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQgZXh0ZW5kcyBEcmFnZ2FibGVFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5EcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50ID0gRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWdnYWJsZSBkZXN0b3J5IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ2dhYmxlRGVzdHJveUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdnYWJsZURlc3Ryb3lFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQudHlwZSA9ICdkcmFnZ2FibGU6aW5pdGlhbGl6ZSc7XHJcbmNsYXNzIERyYWdnYWJsZURlc3Ryb3lFdmVudCBleHRlbmRzIERyYWdnYWJsZUV2ZW50IHt9XHJcbmV4cG9ydHMuRHJhZ2dhYmxlRGVzdHJveUV2ZW50ID0gRHJhZ2dhYmxlRGVzdHJveUV2ZW50O1xyXG5EcmFnZ2FibGVEZXN0cm95RXZlbnQudHlwZSA9ICdkcmFnZ2FibGU6ZGVzdHJveSc7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuRHJhZ1N0b3BwZWRFdmVudCA9IGV4cG9ydHMuRHJhZ1N0b3BFdmVudCA9IGV4cG9ydHMuRHJhZ1ByZXNzdXJlRXZlbnQgPSBleHBvcnRzLkRyYWdPdXRDb250YWluZXJFdmVudCA9IGV4cG9ydHMuRHJhZ092ZXJDb250YWluZXJFdmVudCA9IGV4cG9ydHMuRHJhZ091dEV2ZW50ID0gZXhwb3J0cy5EcmFnT3ZlckV2ZW50ID0gZXhwb3J0cy5EcmFnTW92ZUV2ZW50ID0gZXhwb3J0cy5EcmFnU3RhcnRFdmVudCA9IGV4cG9ydHMuRHJhZ0V2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKipcclxuICogQmFzZSBkcmFnIGV2ZW50XHJcbiAqIEBjbGFzcyBEcmFnRXZlbnRcclxuICogQG1vZHVsZSBEcmFnRXZlbnRcclxuICogQGV4dGVuZHMgQWJzdHJhY3RFdmVudFxyXG4gKi9cclxuY2xhc3MgRHJhZ0V2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIHNvdXJjZSBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IHNvdXJjZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc291cmNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG9yaWdpbmFsIHNvdXJjZSBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG9yaWdpbmFsU291cmNlXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvcmlnaW5hbFNvdXJjZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxTb3VyY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG1pcnJvclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbWlycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIHNvdXJjZSBjb250YWluZXIgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBzb3VyY2VDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNvdXJjZUNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Vuc29yIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IHNlbnNvckV2ZW50XHJcbiAgICogQHR5cGUge1NlbnNvckV2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzZW5zb3JFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc2Vuc29yRXZlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBldmVudCB0aGF0IHRyaWdnZXJlZCBzZW5zb3IgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxFdmVudFxyXG4gICAqIEB0eXBlIHtFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3JpZ2luYWxFdmVudCgpIHtcclxuICAgIGlmICh0aGlzLnNlbnNvckV2ZW50KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdFdmVudCA9IERyYWdFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHN0YXJ0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1N0YXJ0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1N0YXJ0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnRXZlbnQudHlwZSA9ICdkcmFnJztcclxuY2xhc3MgRHJhZ1N0YXJ0RXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ1N0YXJ0RXZlbnQgPSBEcmFnU3RhcnRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBtb3ZlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdNb3ZlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdNb3ZlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdTdGFydEV2ZW50LnR5cGUgPSAnZHJhZzpzdGFydCc7XHJcbkRyYWdTdGFydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBEcmFnTW92ZUV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdNb3ZlRXZlbnQgPSBEcmFnTW92ZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBvdmVyIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnT3ZlckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ092ZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnTW92ZUV2ZW50LnR5cGUgPSAnZHJhZzptb3ZlJztcclxuY2xhc3MgRHJhZ092ZXJFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBjb250YWluZXIgeW91IGFyZSBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgZWxlbWVudCB5b3UgYXJlIG92ZXJcclxuICAgKiBAcHJvcGVydHkgb3ZlclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ092ZXJFdmVudCA9IERyYWdPdmVyRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG91dCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ091dEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ091dEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdPdmVyRXZlbnQudHlwZSA9ICdkcmFnOm92ZXInO1xyXG5EcmFnT3ZlckV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBEcmFnT3V0RXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIHlvdSBhcmUgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGVsZW1lbnQgeW91IGxlZnRcclxuICAgKiBAcHJvcGVydHkgb3ZlclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ091dEV2ZW50ID0gRHJhZ091dEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgb3ZlciBjb250YWluZXIgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnT3ZlckNvbnRhaW5lckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdPdmVyQ29udGFpbmVyRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnT3V0RXZlbnQudHlwZSA9ICdkcmFnOm91dCc7XHJcbmNsYXNzIERyYWdPdmVyQ29udGFpbmVyRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIHlvdSBhcmUgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnT3ZlckNvbnRhaW5lckV2ZW50ID0gRHJhZ092ZXJDb250YWluZXJFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgb3V0IGNvbnRhaW5lciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ091dENvbnRhaW5lckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ091dENvbnRhaW5lckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdPdmVyQ29udGFpbmVyRXZlbnQudHlwZSA9ICdkcmFnOm92ZXI6Y29udGFpbmVyJztcclxuY2xhc3MgRHJhZ091dENvbnRhaW5lckV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciB5b3UgbGVmdFxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnT3V0Q29udGFpbmVyRXZlbnQgPSBEcmFnT3V0Q29udGFpbmVyRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBwcmVzc3VyZSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdQcmVzc3VyZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdQcmVzc3VyZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ091dENvbnRhaW5lckV2ZW50LnR5cGUgPSAnZHJhZzpvdXQ6Y29udGFpbmVyJztcclxuY2xhc3MgRHJhZ1ByZXNzdXJlRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBQcmVzc3VyZSBhcHBsaWVkIG9uIGRyYWdnYWJsZSBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IHByZXNzdXJlXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcHJlc3N1cmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnByZXNzdXJlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnUHJlc3N1cmVFdmVudCA9IERyYWdQcmVzc3VyZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHN0b3AgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1N0b3BFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1N0b3BFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ1ByZXNzdXJlRXZlbnQudHlwZSA9ICdkcmFnOnByZXNzdXJlJztcclxuY2xhc3MgRHJhZ1N0b3BFdmVudCBleHRlbmRzIERyYWdFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5EcmFnU3RvcEV2ZW50ID0gRHJhZ1N0b3BFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgc3RvcHBlZCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1N0b3BwZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdTdG9wcGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ1N0b3BFdmVudC50eXBlID0gJ2RyYWc6c3RvcCc7XHJcbmNsYXNzIERyYWdTdG9wcGVkRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge31cclxuZXhwb3J0cy5EcmFnU3RvcHBlZEV2ZW50ID0gRHJhZ1N0b3BwZWRFdmVudDtcclxuRHJhZ1N0b3BwZWRFdmVudC50eXBlID0gJ2RyYWc6c3RvcHBlZCc7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0RyYWdFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcblxyXG5PYmplY3Qua2V5cyhfRHJhZ0V2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX0RyYWdFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbnZhciBfRHJhZ2dhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5cclxuT2JqZWN0LmtleXMoX0RyYWdnYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX0RyYWdnYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9QbHVnaW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcbk9iamVjdC5rZXlzKF9QbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1BsdWdpbnNba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX1NlbnNvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuT2JqZWN0LmtleXMoX1NlbnNvcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfU2Vuc29yc1trZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbnZhciBfRHJhZ2dhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcblxyXG52YXIgX0RyYWdnYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnZ2FibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9EcmFnZ2FibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9EcmFnZ2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcclxuXHJcbnZhciBfRHJhZ2dhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RyYWdnYWJsZSk7XHJcblxyXG52YXIgX1NvcnRhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdPdmVyQ29udGFpbmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyQ29udGFpbmVyJyk7XHJcbmNvbnN0IG9uRHJhZ092ZXIgPSBTeW1ib2woJ29uRHJhZ092ZXInKTtcclxuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW5ub3VuY2VtZW50IG1lc3NhZ2Ugd2hlbiBhIERyYWdnYWJsZSBlbGVtZW50IGhhcyBiZWVuIHNvcnRlZCB3aXRoIGFub3RoZXIgRHJhZ2dhYmxlIGVsZW1lbnRcclxuICogb3IgbW92ZWQgaW50byBhIG5ldyBjb250YWluZXJcclxuICogQHBhcmFtIHtTb3J0YWJsZVNvcnRlZEV2ZW50fSBzb3J0YWJsZUV2ZW50XHJcbiAqIEByZXR1cm4ge1N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIG9uU29ydGFibGVTb3J0ZWREZWZhdWx0QW5ub3VuY2VtZW50KHsgZHJhZ0V2ZW50IH0pIHtcclxuICBjb25zdCBzb3VyY2VUZXh0ID0gZHJhZ0V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50LnNvdXJjZS5pZCB8fCAnc29ydGFibGUgZWxlbWVudCc7XHJcblxyXG4gIGlmIChkcmFnRXZlbnQub3Zlcikge1xyXG4gICAgY29uc3Qgb3ZlclRleHQgPSBkcmFnRXZlbnQub3Zlci50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50Lm92ZXIuaWQgfHwgJ3NvcnRhYmxlIGVsZW1lbnQnO1xyXG4gICAgY29uc3QgaXNGb2xsb3dpbmcgPSBkcmFnRXZlbnQuc291cmNlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGRyYWdFdmVudC5vdmVyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xyXG5cclxuICAgIGlmIChpc0ZvbGxvd2luZykge1xyXG4gICAgICByZXR1cm4gYFBsYWNlZCAke3NvdXJjZVRleHR9IGFmdGVyICR7b3ZlclRleHR9YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBgUGxhY2VkICR7c291cmNlVGV4dH0gYmVmb3JlICR7b3ZlclRleHR9YDtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gbmVlZCB0byBmaWd1cmUgb3V0IGhvdyB0byBjb21wdXRlIGNvbnRhaW5lciBuYW1lXHJcbiAgICByZXR1cm4gYFBsYWNlZCAke3NvdXJjZVRleHR9IGludG8gYSBkaWZmZXJlbnQgY29udGFpbmVyYDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAY29uc3Qge09iamVjdH0gZGVmYXVsdEFubm91bmNlbWVudHNcclxuICogQGNvbnN0IHtGdW5jdGlvbn0gZGVmYXVsdEFubm91bmNlbWVudHNbJ3NvcnRhYmxlOnNvcnRlZCddXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0QW5ub3VuY2VtZW50cyA9IHtcclxuICAnc29ydGFibGU6c29ydGVkJzogb25Tb3J0YWJsZVNvcnRlZERlZmF1bHRBbm5vdW5jZW1lbnRcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTb3J0YWJsZSBpcyBidWlsdCBvbiB0b3Agb2YgRHJhZ2dhYmxlIGFuZCBhbGxvd3Mgc29ydGluZyBvZiBkcmFnZ2FibGUgZWxlbWVudHMuIFNvcnRhYmxlIHdpbGwga2VlcFxyXG4gKiB0cmFjayBvZiB0aGUgb3JpZ2luYWwgaW5kZXggYW5kIGVtaXRzIHRoZSBuZXcgaW5kZXggYXMgeW91IGRyYWcgb3ZlciBkcmFnZ2FibGUgZWxlbWVudHMuXHJcbiAqIEBjbGFzcyBTb3J0YWJsZVxyXG4gKiBAbW9kdWxlIFNvcnRhYmxlXHJcbiAqIEBleHRlbmRzIERyYWdnYWJsZVxyXG4gKi9cclxuY2xhc3MgU29ydGFibGUgZXh0ZW5kcyBfRHJhZ2dhYmxlMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBTb3J0YWJsZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBTb3J0YWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIFNvcnRhYmxlIGNvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIFNvcnRhYmxlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lcnMsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XHJcbiAgICAgIGFubm91bmNlbWVudHM6IF9leHRlbmRzKHt9LCBkZWZhdWx0QW5ub3VuY2VtZW50cywgb3B0aW9ucy5hbm5vdW5jZW1lbnRzIHx8IHt9KVxyXG4gICAgfSkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc3RhcnQgaW5kZXggb2Ygc291cmNlIG9uIGRyYWcgc3RhcnRcclxuICAgICAqIEBwcm9wZXJ0eSBzdGFydEluZGV4XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc3RhcnQgY29udGFpbmVyIG9uIGRyYWcgc3RhcnRcclxuICAgICAqIEBwcm9wZXJ0eSBzdGFydENvbnRhaW5lclxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0YXJ0Q29udGFpbmVyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ092ZXJDb250YWluZXJdID0gdGhpc1tvbkRyYWdPdmVyQ29udGFpbmVyXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzpvdmVyOmNvbnRhaW5lcicsIHRoaXNbb25EcmFnT3ZlckNvbnRhaW5lcl0pLm9uKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95cyBTb3J0YWJsZSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgc3VwZXIuZGVzdHJveSgpO1xyXG5cclxuICAgIHRoaXMub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzpvdmVyOmNvbnRhaW5lcicsIHRoaXNbb25EcmFnT3ZlckNvbnRhaW5lcl0pLm9mZignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpbmRleCBvZiBlbGVtZW50IHdpdGhpbiBpdHMgY29udGFpbmVyIGR1cmluZyBkcmFnIG9wZXJhdGlvbiwgaS5lLiBleGNsdWRpbmcgbWlycm9yIGFuZCBvcmlnaW5hbCBzb3VyY2VcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gQW4gZWxlbWVudFxyXG4gICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgKi9cclxuICBpbmRleChlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRTb3J0YWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKGVsZW1lbnQucGFyZW50Tm9kZSkuaW5kZXhPZihlbGVtZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgc29ydGFibGUgZWxlbWVudHMgZm9yIGEgZ2l2ZW4gY29udGFpbmVyLCBleGNsdWRpbmcgdGhlIG1pcnJvciBhbmRcclxuICAgKiBvcmlnaW5hbCBzb3VyY2UgZWxlbWVudCBpZiBwcmVzZW50XHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnRbXX1cclxuICAgKi9cclxuICBnZXRTb3J0YWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gICAgY29uc3QgYWxsU29ydGFibGVFbGVtZW50cyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xyXG5cclxuICAgIHJldHVybiBbLi4uYWxsU29ydGFibGVFbGVtZW50c10uZmlsdGVyKGNoaWxkRWxlbWVudCA9PiB7XHJcbiAgICAgIHJldHVybiBjaGlsZEVsZW1lbnQgIT09IHRoaXMub3JpZ2luYWxTb3VyY2UgJiYgY2hpbGRFbGVtZW50ICE9PSB0aGlzLm1pcnJvciAmJiBjaGlsZEVsZW1lbnQucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0YXJ0RXZlbnR9IGV2ZW50IC0gRHJhZyBzdGFydCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcclxuICAgIHRoaXMuc3RhcnRDb250YWluZXIgPSBldmVudC5zb3VyY2UucGFyZW50Tm9kZTtcclxuICAgIHRoaXMuc3RhcnRJbmRleCA9IHRoaXMuaW5kZXgoZXZlbnQuc291cmNlKTtcclxuXHJcbiAgICBjb25zdCBzb3J0YWJsZVN0YXJ0RXZlbnQgPSBuZXcgX1NvcnRhYmxlRXZlbnQuU29ydGFibGVTdGFydEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcclxuICAgICAgc3RhcnRJbmRleDogdGhpcy5zdGFydEluZGV4LFxyXG4gICAgICBzdGFydENvbnRhaW5lcjogdGhpcy5zdGFydENvbnRhaW5lclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHNvcnRhYmxlU3RhcnRFdmVudCk7XHJcblxyXG4gICAgaWYgKHNvcnRhYmxlU3RhcnRFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBvdmVyIGNvbnRhaW5lciBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyQ29udGFpbmVyRXZlbnR9IGV2ZW50IC0gRHJhZyBvdmVyIGNvbnRhaW5lciBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdmVyQ29udGFpbmVyXShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyIH0gPSBldmVudDtcclxuICAgIGNvbnN0IG9sZEluZGV4ID0gdGhpcy5pbmRleChzb3VyY2UpO1xyXG5cclxuICAgIGNvbnN0IHNvcnRhYmxlU29ydEV2ZW50ID0gbmV3IF9Tb3J0YWJsZUV2ZW50LlNvcnRhYmxlU29ydEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcclxuICAgICAgY3VycmVudEluZGV4OiBvbGRJbmRleCxcclxuICAgICAgc291cmNlLFxyXG4gICAgICBvdmVyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTb3J0RXZlbnQpO1xyXG5cclxuICAgIGlmIChzb3J0YWJsZVNvcnRFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0U29ydGFibGVFbGVtZW50c0ZvckNvbnRhaW5lcihvdmVyQ29udGFpbmVyKTtcclxuICAgIGNvbnN0IG1vdmVzID0gbW92ZSh7IHNvdXJjZSwgb3Zlciwgb3ZlckNvbnRhaW5lciwgY2hpbGRyZW4gfSk7XHJcblxyXG4gICAgaWYgKCFtb3Zlcykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBvbGRDb250YWluZXIsIG5ld0NvbnRhaW5lciB9ID0gbW92ZXM7XHJcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuaW5kZXgoZXZlbnQuc291cmNlKTtcclxuXHJcbiAgICBjb25zdCBzb3J0YWJsZVNvcnRlZEV2ZW50ID0gbmV3IF9Tb3J0YWJsZUV2ZW50LlNvcnRhYmxlU29ydGVkRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBvbGRJbmRleCxcclxuICAgICAgbmV3SW5kZXgsXHJcbiAgICAgIG9sZENvbnRhaW5lcixcclxuICAgICAgbmV3Q29udGFpbmVyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTb3J0ZWRFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG92ZXIgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnT3ZlckV2ZW50fSBldmVudCAtIERyYWcgb3ZlciBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdmVyXShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50Lm92ZXIgPT09IGV2ZW50Lm9yaWdpbmFsU291cmNlIHx8IGV2ZW50Lm92ZXIgPT09IGV2ZW50LnNvdXJjZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBzb3VyY2UsIG92ZXIsIG92ZXJDb250YWluZXIgfSA9IGV2ZW50O1xyXG4gICAgY29uc3Qgb2xkSW5kZXggPSB0aGlzLmluZGV4KHNvdXJjZSk7XHJcblxyXG4gICAgY29uc3Qgc29ydGFibGVTb3J0RXZlbnQgPSBuZXcgX1NvcnRhYmxlRXZlbnQuU29ydGFibGVTb3J0RXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBjdXJyZW50SW5kZXg6IG9sZEluZGV4LFxyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG92ZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVNvcnRFdmVudCk7XHJcblxyXG4gICAgaWYgKHNvcnRhYmxlU29ydEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihvdmVyQ29udGFpbmVyKTtcclxuICAgIGNvbnN0IG1vdmVzID0gbW92ZSh7IHNvdXJjZSwgb3Zlciwgb3ZlckNvbnRhaW5lciwgY2hpbGRyZW4gfSk7XHJcblxyXG4gICAgaWYgKCFtb3Zlcykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBvbGRDb250YWluZXIsIG5ld0NvbnRhaW5lciB9ID0gbW92ZXM7XHJcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuaW5kZXgoc291cmNlKTtcclxuXHJcbiAgICBjb25zdCBzb3J0YWJsZVNvcnRlZEV2ZW50ID0gbmV3IF9Tb3J0YWJsZUV2ZW50LlNvcnRhYmxlU29ydGVkRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBvbGRJbmRleCxcclxuICAgICAgbmV3SW5kZXgsXHJcbiAgICAgIG9sZENvbnRhaW5lcixcclxuICAgICAgbmV3Q29udGFpbmVyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTb3J0ZWRFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0b3AgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RvcEV2ZW50fSBldmVudCAtIERyYWcgc3RvcCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdG9wXShldmVudCkge1xyXG4gICAgY29uc3Qgc29ydGFibGVTdG9wRXZlbnQgPSBuZXcgX1NvcnRhYmxlRXZlbnQuU29ydGFibGVTdG9wRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBvbGRJbmRleDogdGhpcy5zdGFydEluZGV4LFxyXG4gICAgICBuZXdJbmRleDogdGhpcy5pbmRleChldmVudC5zb3VyY2UpLFxyXG4gICAgICBvbGRDb250YWluZXI6IHRoaXMuc3RhcnRDb250YWluZXIsXHJcbiAgICAgIG5ld0NvbnRhaW5lcjogZXZlbnQuc291cmNlLnBhcmVudE5vZGVcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVN0b3BFdmVudCk7XHJcblxyXG4gICAgdGhpcy5zdGFydEluZGV4ID0gbnVsbDtcclxuICAgIHRoaXMuc3RhcnRDb250YWluZXIgPSBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gU29ydGFibGU7XHJcbmZ1bmN0aW9uIGluZGV4KGVsZW1lbnQpIHtcclxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChlbGVtZW50LnBhcmVudE5vZGUuY2hpbGRyZW4sIGVsZW1lbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtb3ZlKHsgc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyLCBjaGlsZHJlbiB9KSB7XHJcbiAgY29uc3QgZW1wdHlPdmVyQ29udGFpbmVyID0gIWNoaWxkcmVuLmxlbmd0aDtcclxuICBjb25zdCBkaWZmZXJlbnRDb250YWluZXIgPSBzb3VyY2UucGFyZW50Tm9kZSAhPT0gb3ZlckNvbnRhaW5lcjtcclxuICBjb25zdCBzYW1lQ29udGFpbmVyID0gb3ZlciAmJiBzb3VyY2UucGFyZW50Tm9kZSA9PT0gb3Zlci5wYXJlbnROb2RlO1xyXG5cclxuICBpZiAoZW1wdHlPdmVyQ29udGFpbmVyKSB7XHJcbiAgICByZXR1cm4gbW92ZUluc2lkZUVtcHR5Q29udGFpbmVyKHNvdXJjZSwgb3ZlckNvbnRhaW5lcik7XHJcbiAgfSBlbHNlIGlmIChzYW1lQ29udGFpbmVyKSB7XHJcbiAgICByZXR1cm4gbW92ZVdpdGhpbkNvbnRhaW5lcihzb3VyY2UsIG92ZXIpO1xyXG4gIH0gZWxzZSBpZiAoZGlmZmVyZW50Q29udGFpbmVyKSB7XHJcbiAgICByZXR1cm4gbW92ZU91dHNpZGVDb250YWluZXIoc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtb3ZlSW5zaWRlRW1wdHlDb250YWluZXIoc291cmNlLCBvdmVyQ29udGFpbmVyKSB7XHJcbiAgY29uc3Qgb2xkQ29udGFpbmVyID0gc291cmNlLnBhcmVudE5vZGU7XHJcblxyXG4gIG92ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoc291cmNlKTtcclxuXHJcbiAgcmV0dXJuIHsgb2xkQ29udGFpbmVyLCBuZXdDb250YWluZXI6IG92ZXJDb250YWluZXIgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gbW92ZVdpdGhpbkNvbnRhaW5lcihzb3VyY2UsIG92ZXIpIHtcclxuICBjb25zdCBvbGRJbmRleCA9IGluZGV4KHNvdXJjZSk7XHJcbiAgY29uc3QgbmV3SW5kZXggPSBpbmRleChvdmVyKTtcclxuXHJcbiAgaWYgKG9sZEluZGV4IDwgbmV3SW5kZXgpIHtcclxuICAgIHNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzb3VyY2UsIG92ZXIubmV4dEVsZW1lbnRTaWJsaW5nKTtcclxuICB9IGVsc2Uge1xyXG4gICAgc291cmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNvdXJjZSwgb3Zlcik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBvbGRDb250YWluZXI6IHNvdXJjZS5wYXJlbnROb2RlLCBuZXdDb250YWluZXI6IHNvdXJjZS5wYXJlbnROb2RlIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vdmVPdXRzaWRlQ29udGFpbmVyKHNvdXJjZSwgb3Zlciwgb3ZlckNvbnRhaW5lcikge1xyXG4gIGNvbnN0IG9sZENvbnRhaW5lciA9IHNvdXJjZS5wYXJlbnROb2RlO1xyXG5cclxuICBpZiAob3Zlcikge1xyXG4gICAgb3Zlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzb3VyY2UsIG92ZXIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBuZWVkIHRvIGZpZ3VyZSBvdXQgcHJvcGVyIHBvc2l0aW9uXHJcbiAgICBvdmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHNvdXJjZSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBvbGRDb250YWluZXIsIG5ld0NvbnRhaW5lcjogc291cmNlLnBhcmVudE5vZGUgfTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbmNvbnN0IGNhbmNlbGVkID0gU3ltYm9sKCdjYW5jZWxlZCcpO1xyXG5cclxuLyoqXHJcbiAqIEFsbCBldmVudHMgZmlyZWQgYnkgZHJhZ2dhYmxlIGluaGVyaXQgdGhpcyBjbGFzcy4gWW91IGNhbiBjYWxsIGBjYW5jZWwoKWAgdG9cclxuICogY2FuY2VsIGEgc3BlY2lmaWMgZXZlbnQgb3IgeW91IGNhbiBjaGVjayBpZiBhbiBldmVudCBoYXMgYmVlbiBjYW5jZWxlZCBieVxyXG4gKiBjYWxsaW5nIGBjYW5jZWxlZCgpYC5cclxuICogQGFic3RyYWN0XHJcbiAqIEBjbGFzcyBBYnN0cmFjdEV2ZW50XHJcbiAqIEBtb2R1bGUgQWJzdHJhY3RFdmVudFxyXG4gKi9cclxuY2xhc3MgQWJzdHJhY3RFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEFic3RyYWN0RXZlbnQgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgQWJzdHJhY3RFdmVudFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gRXZlbnQgZGF0YVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBFdmVudCB0eXBlXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBwcm9wZXJ0eSB0eXBlXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XHJcbiAgICB0aGlzW2NhbmNlbGVkXSA9IGZhbHNlO1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWQtb25seSB0eXBlXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHJldHVybiB7U3RyaW5nfVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRXZlbnQgY2FuY2VsYWJsZVxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGdldCB0eXBlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudHlwZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWQtb25seSBjYW5jZWxhYmxlXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgY2FuY2VsYWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmNhbmNlbGFibGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYW5jZWxzIHRoZSBldmVudCBpbnN0YW5jZVxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqL1xyXG4gIGNhbmNlbCgpIHtcclxuICAgIHRoaXNbY2FuY2VsZWRdID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGV2ZW50IGhhcyBiZWVuIGNhbmNlbGVkXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBjYW5jZWxlZCgpIHtcclxuICAgIHJldHVybiBCb29sZWFuKHRoaXNbY2FuY2VsZWRdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgbmV3IGV2ZW50IGluc3RhbmNlIHdpdGggZXhpc3RpbmcgZXZlbnQgZGF0YS5cclxuICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIG92ZXJyaWRpbmcgb2YgZXZlbnQgZGF0YS5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG4gICAqIEByZXR1cm4ge0Fic3RyYWN0RXZlbnR9XHJcbiAgICovXHJcbiAgY2xvbmUoZGF0YSkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKF9leHRlbmRzKHt9LCB0aGlzLmRhdGEsIGRhdGEpKTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gQWJzdHJhY3RFdmVudDtcclxuQWJzdHJhY3RFdmVudC50eXBlID0gJ2V2ZW50JztcclxuQWJzdHJhY3RFdmVudC5jYW5jZWxhYmxlID0gZmFsc2U7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuU29ydGFibGVTdG9wRXZlbnQgPSBleHBvcnRzLlNvcnRhYmxlU29ydGVkRXZlbnQgPSBleHBvcnRzLlNvcnRhYmxlU29ydEV2ZW50ID0gZXhwb3J0cy5Tb3J0YWJsZVN0YXJ0RXZlbnQgPSBleHBvcnRzLlNvcnRhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIHNvcnRhYmxlIGV2ZW50XHJcbiAqIEBjbGFzcyBTb3J0YWJsZUV2ZW50XHJcbiAqIEBtb2R1bGUgU29ydGFibGVFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBTb3J0YWJsZUV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBkcmFnIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgc29ydGFibGUgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgZHJhZ0V2ZW50XHJcbiAgICogQHR5cGUge0RyYWdFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ0V2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLlNvcnRhYmxlRXZlbnQgPSBTb3J0YWJsZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU29ydGFibGUgc3RhcnQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFNvcnRhYmxlU3RhcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNvcnRhYmxlU3RhcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTb3J0YWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuU29ydGFibGVFdmVudC50eXBlID0gJ3NvcnRhYmxlJztcclxuY2xhc3MgU29ydGFibGVTdGFydEV2ZW50IGV4dGVuZHMgU29ydGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGluZGV4IG9mIHNvdXJjZSBvbiBzb3J0YWJsZSBzdGFydFxyXG4gICAqIEBwcm9wZXJ0eSBzdGFydEluZGV4XHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc3RhcnRJbmRleCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc3RhcnRJbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGNvbnRhaW5lciBvbiBzb3J0YWJsZSBzdGFydFxyXG4gICAqIEBwcm9wZXJ0eSBzdGFydENvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc3RhcnRDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN0YXJ0Q29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Tb3J0YWJsZVN0YXJ0RXZlbnQgPSBTb3J0YWJsZVN0YXJ0RXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU29ydGFibGUgc29ydCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFNvcnRhYmxlU29ydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNvcnRhYmxlU29ydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTb3J0YWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblNvcnRhYmxlU3RhcnRFdmVudC50eXBlID0gJ3NvcnRhYmxlOnN0YXJ0JztcclxuU29ydGFibGVTdGFydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBTb3J0YWJsZVNvcnRFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBJbmRleCBvZiBjdXJyZW50IGRyYWdnYWJsZSBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IGN1cnJlbnRJbmRleFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGN1cnJlbnRJbmRleCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuY3VycmVudEluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGVsZW1lbnQgeW91IGFyZSBob3ZlcmluZyBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIGVsZW1lbnQgeW91IGFyZSBob3ZlcmluZyBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudC5vdmVyQ29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Tb3J0YWJsZVNvcnRFdmVudCA9IFNvcnRhYmxlU29ydEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTb3J0YWJsZSBzb3J0ZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgU29ydGFibGVTb3J0ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU29ydGFibGVTb3J0ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNvcnRhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblNvcnRhYmxlU29ydEV2ZW50LnR5cGUgPSAnc29ydGFibGU6c29ydCc7XHJcblNvcnRhYmxlU29ydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBTb3J0YWJsZVNvcnRlZEV2ZW50IGV4dGVuZHMgU29ydGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEluZGV4IG9mIGxhc3Qgc29ydGVkIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IG9sZEluZGV4XHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb2xkSW5kZXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9sZEluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTmV3IGluZGV4IG9mIHRoaXMgc29ydGVkIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IG5ld0luZGV4XHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbmV3SW5kZXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0luZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT2xkIGNvbnRhaW5lciBvZiBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBvbGRDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9sZENvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub2xkQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTmV3IGNvbnRhaW5lciBvZiBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBuZXdDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG5ld0NvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubmV3Q29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Tb3J0YWJsZVNvcnRlZEV2ZW50ID0gU29ydGFibGVTb3J0ZWRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNvcnRhYmxlIHN0b3AgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFNvcnRhYmxlU3RvcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU29ydGFibGVTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU29ydGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblNvcnRhYmxlU29ydGVkRXZlbnQudHlwZSA9ICdzb3J0YWJsZTpzb3J0ZWQnO1xyXG5jbGFzcyBTb3J0YWJsZVN0b3BFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBpbmRleCBvbiBzb3J0YWJsZSBzdGFydFxyXG4gICAqIEBwcm9wZXJ0eSBvbGRJbmRleFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9sZEluZGV4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vbGRJbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5ldyBpbmRleCBvZiBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBuZXdJbmRleFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG5ld0luZGV4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5uZXdJbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9yaWdpbmFsIGNvbnRhaW5lciBvZiBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBvbGRDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9sZENvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub2xkQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTmV3IGNvbnRhaW5lciBvZiBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBuZXdDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG5ld0NvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubmV3Q29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLlNvcnRhYmxlU3RvcEV2ZW50ID0gU29ydGFibGVTdG9wRXZlbnQ7XHJcblNvcnRhYmxlU3RvcEV2ZW50LnR5cGUgPSAnc29ydGFibGU6c3RvcCc7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NvcnRhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cclxuT2JqZWN0LmtleXMoX1NvcnRhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfU29ydGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbnZhciBfU29ydGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcclxuXHJcbnZhciBfU29ydGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU29ydGFibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Tb3J0YWJsZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pXHJcbi8qKioqKiovIF0pO1xyXG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@shopify/draggable/lib/sortable.js\n");

/***/ }),

/***/ "./node_modules/@shopify/draggable/lib/swappable.js":
/*!**********************************************************!*\
  !*** ./node_modules/@shopify/draggable/lib/swappable.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(true)\r\n\t\tmodule.exports = factory();\r\n\telse {}\r\n})(window, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __nested_webpack_require_571__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId]) {\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_571__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__nested_webpack_require_571__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__nested_webpack_require_571__.c = installedModules;\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__nested_webpack_require_571__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__nested_webpack_require_571__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// define __esModule on exports\r\n/******/ \t__nested_webpack_require_571__.r = function(exports) {\r\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\r\n/******/ \t\t}\r\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\r\n/******/ \t};\r\n/******/\r\n/******/ \t// create a fake namespace object\r\n/******/ \t// mode & 1: value is a module id, require it\r\n/******/ \t// mode & 2: merge all properties of value into the ns\r\n/******/ \t// mode & 4: return value when already ns object\r\n/******/ \t// mode & 8|1: behave like require\r\n/******/ \t__nested_webpack_require_571__.t = function(value, mode) {\r\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_571__(value);\r\n/******/ \t\tif(mode & 8) return value;\r\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\r\n/******/ \t\tvar ns = Object.create(null);\r\n/******/ \t\t__nested_webpack_require_571__.r(ns);\r\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\r\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_571__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\r\n/******/ \t\treturn ns;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__nested_webpack_require_571__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__nested_webpack_require_571__.d(getter, 'a', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__nested_webpack_require_571__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__nested_webpack_require_571__.p = \"\";\r\n/******/\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __nested_webpack_require_571__(__nested_webpack_require_571__.s = 48);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __nested_webpack_require_4119__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SensorEvent = __nested_webpack_require_4119__(19);\r\n\r\nObject.keys(_SensorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SensorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports, __nested_webpack_require_4586__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_4586__(22);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Sensor2.default;\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports, __nested_webpack_require_4985__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_4985__(30);\r\n\r\nObject.defineProperty(exports, 'closest', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_closest).default;\r\n  }\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_4985__(28);\r\n\r\nObject.defineProperty(exports, 'requestNextAnimationFrame', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_requestNextAnimationFrame).default;\r\n  }\r\n});\r\n\r\nvar _distance = __nested_webpack_require_4985__(26);\r\n\r\nObject.defineProperty(exports, 'distance', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_distance).default;\r\n  }\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_4985__(24);\r\n\r\nObject.defineProperty(exports, 'touchCoords', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_touchCoords).default;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports, __nested_webpack_require_6109__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractEvent = __nested_webpack_require_6109__(46);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractEvent2.default;\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports, __nested_webpack_require_6536__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_6536__(39);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _AbstractPlugin2.default;\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports, __nested_webpack_require_6967__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_6967__(1);\r\n\r\nObject.defineProperty(exports, 'Sensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Sensor).default;\r\n  }\r\n});\r\n\r\nvar _MouseSensor = __nested_webpack_require_6967__(21);\r\n\r\nObject.defineProperty(exports, 'MouseSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_MouseSensor).default;\r\n  }\r\n});\r\n\r\nvar _TouchSensor = __nested_webpack_require_6967__(18);\r\n\r\nObject.defineProperty(exports, 'TouchSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_TouchSensor).default;\r\n  }\r\n});\r\n\r\nvar _DragSensor = __nested_webpack_require_6967__(16);\r\n\r\nObject.defineProperty(exports, 'DragSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_DragSensor).default;\r\n  }\r\n});\r\n\r\nvar _ForceTouchSensor = __nested_webpack_require_6967__(14);\r\n\r\nObject.defineProperty(exports, 'ForceTouchSensor', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_ForceTouchSensor).default;\r\n  }\r\n});\r\n\r\nvar _SensorEvent = __nested_webpack_require_6967__(0);\r\n\r\nObject.keys(_SensorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SensorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports, __nested_webpack_require_8573__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Announcement = __nested_webpack_require_8573__(41);\r\n\r\nObject.defineProperty(exports, 'Announcement', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Announcement).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultAnnouncementOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Announcement.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Focusable = __nested_webpack_require_8573__(38);\r\n\r\nObject.defineProperty(exports, 'Focusable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Focusable).default;\r\n  }\r\n});\r\n\r\nvar _Mirror = __nested_webpack_require_8573__(36);\r\n\r\nObject.defineProperty(exports, 'Mirror', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Mirror).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultMirrorOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Mirror.defaultOptions;\r\n  }\r\n});\r\n\r\nvar _Scrollable = __nested_webpack_require_8573__(32);\r\n\r\nObject.defineProperty(exports, 'Scrollable', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _interopRequireDefault(_Scrollable).default;\r\n  }\r\n});\r\nObject.defineProperty(exports, 'defaultScrollableOptions', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _Scrollable.defaultOptions;\r\n  }\r\n});\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports, __nested_webpack_require_10116__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DraggableEvent = __nested_webpack_require_10116__(42);\r\n\r\nObject.keys(_DraggableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DraggableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ (function(module, exports, __nested_webpack_require_10592__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragEvent = __nested_webpack_require_10592__(43);\r\n\r\nObject.keys(_DragEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DragEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ (function(module, exports, __nested_webpack_require_11053__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SwappableEvent = __nested_webpack_require_11053__(47);\r\n\r\nObject.keys(_SwappableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SwappableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * The Emitter is a simple emitter class that provides you with `on()`, `off()` and `trigger()` methods\r\n * @class Emitter\r\n * @module Emitter\r\n */\r\nclass Emitter {\r\n  constructor() {\r\n    this.callbacks = {};\r\n  }\r\n\r\n  /**\r\n   * Registers callbacks by event name\r\n   * @param {String} type\r\n   * @param {...Function} callbacks\r\n   */\r\n  on(type, ...callbacks) {\r\n    if (!this.callbacks[type]) {\r\n      this.callbacks[type] = [];\r\n    }\r\n\r\n    this.callbacks[type].push(...callbacks);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Unregisters callbacks by event name\r\n   * @param {String} type\r\n   * @param {Function} callback\r\n   */\r\n  off(type, callback) {\r\n    if (!this.callbacks[type]) {\r\n      return null;\r\n    }\r\n\r\n    const copy = this.callbacks[type].slice(0);\r\n\r\n    for (let i = 0; i < copy.length; i++) {\r\n      if (callback === copy[i]) {\r\n        this.callbacks[type].splice(i, 1);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Triggers event callbacks by event object\r\n   * @param {AbstractEvent} event\r\n   */\r\n  trigger(event) {\r\n    if (!this.callbacks[event.type]) {\r\n      return null;\r\n    }\r\n\r\n    const callbacks = [...this.callbacks[event.type]];\r\n    const caughtErrors = [];\r\n\r\n    for (let i = callbacks.length - 1; i >= 0; i--) {\r\n      const callback = callbacks[i];\r\n\r\n      try {\r\n        callback(event);\r\n      } catch (error) {\r\n        caughtErrors.push(error);\r\n      }\r\n    }\r\n\r\n    if (caughtErrors.length) {\r\n      /* eslint-disable no-console */\r\n      console.error(`Draggable caught errors while triggering '${event.type}'`, caughtErrors);\r\n      /* eslint-disable no-console */\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\nexports.default = Emitter;\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ (function(module, exports, __nested_webpack_require_13394__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Emitter = __nested_webpack_require_13394__(10);\r\n\r\nvar _Emitter2 = _interopRequireDefault(_Emitter);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Emitter2.default;\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ (function(module, exports, __nested_webpack_require_13798__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _utils = __nested_webpack_require_13798__(2);\r\n\r\nvar _Plugins = __nested_webpack_require_13798__(6);\r\n\r\nvar _Emitter = __nested_webpack_require_13798__(11);\r\n\r\nvar _Emitter2 = _interopRequireDefault(_Emitter);\r\n\r\nvar _Sensors = __nested_webpack_require_13798__(5);\r\n\r\nvar _DraggableEvent = __nested_webpack_require_13798__(7);\r\n\r\nvar _DragEvent = __nested_webpack_require_13798__(8);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragMove = Symbol('onDragMove');\r\nconst onDragStop = Symbol('onDragStop');\r\nconst onDragPressure = Symbol('onDragPressure');\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['drag:start']\r\n * @const {Function} defaultAnnouncements['drag:stop']\r\n */\r\nconst defaultAnnouncements = {\r\n  'drag:start': event => `Picked up ${event.source.textContent.trim() || event.source.id || 'draggable element'}`,\r\n  'drag:stop': event => `Released ${event.source.textContent.trim() || event.source.id || 'draggable element'}`\r\n};\r\n\r\nconst defaultClasses = {\r\n  'container:dragging': 'draggable-container--is-dragging',\r\n  'source:dragging': 'draggable-source--is-dragging',\r\n  'source:placed': 'draggable-source--placed',\r\n  'container:placed': 'draggable-container--placed',\r\n  'body:dragging': 'draggable--is-dragging',\r\n  'draggable:over': 'draggable--over',\r\n  'container:over': 'draggable-container--over',\r\n  'source:original': 'draggable--original',\r\n  mirror: 'draggable-mirror'\r\n};\r\n\r\nconst defaultOptions = exports.defaultOptions = {\r\n  draggable: '.draggable-source',\r\n  handle: null,\r\n  delay: {},\r\n  distance: 0,\r\n  placedTimeout: 800,\r\n  plugins: [],\r\n  sensors: [],\r\n  exclude: {\r\n    plugins: [],\r\n    sensors: []\r\n  }\r\n};\r\n\r\n/**\r\n * This is the core draggable library that does the heavy lifting\r\n * @class Draggable\r\n * @module Draggable\r\n */\r\nclass Draggable {\r\n\r\n  /**\r\n   * Draggable constructor.\r\n   * @constructs Draggable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Draggable containers\r\n   * @param {Object} options - Options for draggable\r\n   */\r\n\r\n  /**\r\n   * Default plugins draggable uses\r\n   * @static\r\n   * @property {Object} Plugins\r\n   * @property {Announcement} Plugins.Announcement\r\n   * @property {Focusable} Plugins.Focusable\r\n   * @property {Mirror} Plugins.Mirror\r\n   * @property {Scrollable} Plugins.Scrollable\r\n   * @type {Object}\r\n   */\r\n  constructor(containers = [document.body], options = {}) {\r\n    /**\r\n     * Draggable containers\r\n     * @property containers\r\n     * @type {HTMLElement[]}\r\n     */\r\n    if (containers instanceof NodeList || containers instanceof Array) {\r\n      this.containers = [...containers];\r\n    } else if (containers instanceof HTMLElement) {\r\n      this.containers = [containers];\r\n    } else {\r\n      throw new Error('Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`');\r\n    }\r\n\r\n    this.options = _extends({}, defaultOptions, options, {\r\n      classes: _extends({}, defaultClasses, options.classes || {}),\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {}),\r\n      exclude: {\r\n        plugins: options.exclude && options.exclude.plugins || [],\r\n        sensors: options.exclude && options.exclude.sensors || []\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Draggables event emitter\r\n     * @property emitter\r\n     * @type {Emitter}\r\n     */\r\n    this.emitter = new _Emitter2.default();\r\n\r\n    /**\r\n     * Current drag state\r\n     * @property dragging\r\n     * @type {Boolean}\r\n     */\r\n    this.dragging = false;\r\n\r\n    /**\r\n     * Active plugins\r\n     * @property plugins\r\n     * @type {Plugin[]}\r\n     */\r\n    this.plugins = [];\r\n\r\n    /**\r\n     * Active sensors\r\n     * @property sensors\r\n     * @type {Sensor[]}\r\n     */\r\n    this.sensors = [];\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onDragPressure] = this[onDragPressure].bind(this);\r\n\r\n    document.addEventListener('drag:start', this[onDragStart], true);\r\n    document.addEventListener('drag:move', this[onDragMove], true);\r\n    document.addEventListener('drag:stop', this[onDragStop], true);\r\n    document.addEventListener('drag:pressure', this[onDragPressure], true);\r\n\r\n    const defaultPlugins = Object.values(Draggable.Plugins).filter(Plugin => !this.options.exclude.plugins.includes(Plugin));\r\n    const defaultSensors = Object.values(Draggable.Sensors).filter(sensor => !this.options.exclude.sensors.includes(sensor));\r\n\r\n    this.addPlugin(...[...defaultPlugins, ...this.options.plugins]);\r\n    this.addSensor(...[...defaultSensors, ...this.options.sensors]);\r\n\r\n    const draggableInitializedEvent = new _DraggableEvent.DraggableInitializedEvent({\r\n      draggable: this\r\n    });\r\n\r\n    this.on('mirror:created', ({ mirror }) => this.mirror = mirror);\r\n    this.on('mirror:destroy', () => this.mirror = null);\r\n\r\n    this.trigger(draggableInitializedEvent);\r\n  }\r\n\r\n  /**\r\n   * Destroys Draggable instance. This removes all internal event listeners and\r\n   * deactivates sensors and plugins\r\n   */\r\n\r\n\r\n  /**\r\n   * Default sensors draggable uses\r\n   * @static\r\n   * @property {Object} Sensors\r\n   * @property {MouseSensor} Sensors.MouseSensor\r\n   * @property {TouchSensor} Sensors.TouchSensor\r\n   * @type {Object}\r\n   */\r\n  destroy() {\r\n    document.removeEventListener('drag:start', this[onDragStart], true);\r\n    document.removeEventListener('drag:move', this[onDragMove], true);\r\n    document.removeEventListener('drag:stop', this[onDragStop], true);\r\n    document.removeEventListener('drag:pressure', this[onDragPressure], true);\r\n\r\n    const draggableDestroyEvent = new _DraggableEvent.DraggableDestroyEvent({\r\n      draggable: this\r\n    });\r\n\r\n    this.trigger(draggableDestroyEvent);\r\n\r\n    this.removePlugin(...this.plugins.map(plugin => plugin.constructor));\r\n    this.removeSensor(...this.sensors.map(sensor => sensor.constructor));\r\n  }\r\n\r\n  /**\r\n   * Adds plugin to this draggable instance. This will end up calling the attach method of the plugin\r\n   * @param {...typeof Plugin} plugins - Plugins that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addPlugin(CustomA11yPlugin, CustomMirrorPlugin)\r\n   */\r\n  addPlugin(...plugins) {\r\n    const activePlugins = plugins.map(Plugin => new Plugin(this));\r\n\r\n    activePlugins.forEach(plugin => plugin.attach());\r\n    this.plugins = [...this.plugins, ...activePlugins];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes plugins that are already attached to this draggable instance. This will end up calling\r\n   * the detach method of the plugin\r\n   * @param {...typeof Plugin} plugins - Plugins that you want detached from draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removePlugin(MirrorPlugin, CustomMirrorPlugin)\r\n   */\r\n  removePlugin(...plugins) {\r\n    const removedPlugins = this.plugins.filter(plugin => plugins.includes(plugin.constructor));\r\n\r\n    removedPlugins.forEach(plugin => plugin.detach());\r\n    this.plugins = this.plugins.filter(plugin => !plugins.includes(plugin.constructor));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds sensors to this draggable instance. This will end up calling the attach method of the sensor\r\n   * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addSensor(ForceTouchSensor, CustomSensor)\r\n   */\r\n  addSensor(...sensors) {\r\n    const activeSensors = sensors.map(Sensor => new Sensor(this.containers, this.options));\r\n\r\n    activeSensors.forEach(sensor => sensor.attach());\r\n    this.sensors = [...this.sensors, ...activeSensors];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes sensors that are already attached to this draggable instance. This will end up calling\r\n   * the detach method of the sensor\r\n   * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removeSensor(TouchSensor, DragSensor)\r\n   */\r\n  removeSensor(...sensors) {\r\n    const removedSensors = this.sensors.filter(sensor => sensors.includes(sensor.constructor));\r\n\r\n    removedSensors.forEach(sensor => sensor.detach());\r\n    this.sensors = this.sensors.filter(sensor => !sensors.includes(sensor.constructor));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds container to this draggable instance\r\n   * @param {...HTMLElement} containers - Containers you want to add to draggable\r\n   * @return {Draggable}\r\n   * @example draggable.addContainer(document.body)\r\n   */\r\n  addContainer(...containers) {\r\n    this.containers = [...this.containers, ...containers];\r\n    this.sensors.forEach(sensor => sensor.addContainer(...containers));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes container from this draggable instance\r\n   * @param {...HTMLElement} containers - Containers you want to remove from draggable\r\n   * @return {Draggable}\r\n   * @example draggable.removeContainer(document.body)\r\n   */\r\n  removeContainer(...containers) {\r\n    this.containers = this.containers.filter(container => !containers.includes(container));\r\n    this.sensors.forEach(sensor => sensor.removeContainer(...containers));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds listener for draggable events\r\n   * @param {String} type - Event name\r\n   * @param {...Function} callbacks - Event callbacks\r\n   * @return {Draggable}\r\n   * @example draggable.on('drag:start', (dragEvent) => dragEvent.cancel());\r\n   */\r\n  on(type, ...callbacks) {\r\n    this.emitter.on(type, ...callbacks);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes listener from draggable\r\n   * @param {String} type - Event name\r\n   * @param {Function} callback - Event callback\r\n   * @return {Draggable}\r\n   * @example draggable.off('drag:start', handlerFunction);\r\n   */\r\n  off(type, callback) {\r\n    this.emitter.off(type, callback);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Triggers draggable event\r\n   * @param {AbstractEvent} event - Event instance\r\n   * @return {Draggable}\r\n   * @example draggable.trigger(event);\r\n   */\r\n  trigger(event) {\r\n    this.emitter.trigger(event);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns class name for class identifier\r\n   * @param {String} name - Name of class identifier\r\n   * @return {String|null}\r\n   */\r\n  getClassNameFor(name) {\r\n    return this.getClassNamesFor(name)[0];\r\n  }\r\n\r\n  /**\r\n   * Returns class names for class identifier\r\n   * @return {String[]}\r\n   */\r\n  getClassNamesFor(name) {\r\n    const classNames = this.options.classes[name];\r\n\r\n    if (classNames instanceof Array) {\r\n      return classNames;\r\n    } else if (typeof classNames === 'string' || classNames instanceof String) {\r\n      return [classNames];\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if this draggable instance is currently dragging\r\n   * @return {Boolean}\r\n   */\r\n  isDragging() {\r\n    return Boolean(this.dragging);\r\n  }\r\n\r\n  /**\r\n   * Returns all draggable elements\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getDraggableElements() {\r\n    return this.containers.reduce((current, container) => {\r\n      return [...current, ...this.getDraggableElementsForContainer(container)];\r\n    }, []);\r\n  }\r\n\r\n  /**\r\n   * Returns draggable elements for a given container, excluding the mirror and\r\n   * original source element if present\r\n   * @param {HTMLElement} container\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getDraggableElementsForContainer(container) {\r\n    const allDraggableElements = container.querySelectorAll(this.options.draggable);\r\n\r\n    return [...allDraggableElements].filter(childElement => {\r\n      return childElement !== this.originalSource && childElement !== this.mirror;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragStart](event) {\r\n    const sensorEvent = getSensorEvent(event);\r\n    const { target, container } = sensorEvent;\r\n\r\n    if (!this.containers.includes(container)) {\r\n      return;\r\n    }\r\n\r\n    if (this.options.handle && target && !(0, _utils.closest)(target, this.options.handle)) {\r\n      sensorEvent.cancel();\r\n      return;\r\n    }\r\n\r\n    // Find draggable source element\r\n    this.originalSource = (0, _utils.closest)(target, this.options.draggable);\r\n    this.sourceContainer = container;\r\n\r\n    if (!this.originalSource) {\r\n      sensorEvent.cancel();\r\n      return;\r\n    }\r\n\r\n    if (this.lastPlacedSource && this.lastPlacedContainer) {\r\n      clearTimeout(this.placedTimeoutID);\r\n      this.lastPlacedSource.classList.remove(...this.getClassNamesFor('source:placed'));\r\n      this.lastPlacedContainer.classList.remove(...this.getClassNamesFor('container:placed'));\r\n    }\r\n\r\n    this.source = this.originalSource.cloneNode(true);\r\n    this.originalSource.parentNode.insertBefore(this.source, this.originalSource);\r\n    this.originalSource.style.display = 'none';\r\n\r\n    const dragEvent = new _DragEvent.DragStartEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sourceContainer: container,\r\n      sensorEvent\r\n    });\r\n\r\n    this.trigger(dragEvent);\r\n\r\n    this.dragging = !dragEvent.canceled();\r\n\r\n    if (dragEvent.canceled()) {\r\n      this.source.parentNode.removeChild(this.source);\r\n      this.originalSource.style.display = null;\r\n      return;\r\n    }\r\n\r\n    this.originalSource.classList.add(...this.getClassNamesFor('source:original'));\r\n    this.source.classList.add(...this.getClassNamesFor('source:dragging'));\r\n    this.sourceContainer.classList.add(...this.getClassNamesFor('container:dragging'));\r\n    document.body.classList.add(...this.getClassNamesFor('body:dragging'));\r\n    applyUserSelect(document.body, 'none');\r\n\r\n    requestAnimationFrame(() => {\r\n      const oldSensorEvent = getSensorEvent(event);\r\n      const newSensorEvent = oldSensorEvent.clone({ target: this.source });\r\n\r\n      this[onDragMove](_extends({}, event, {\r\n        detail: newSensorEvent\r\n      }));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag move handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = getSensorEvent(event);\r\n    const { container } = sensorEvent;\r\n    let target = sensorEvent.target;\r\n\r\n    const dragMoveEvent = new _DragEvent.DragMoveEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sourceContainer: container,\r\n      sensorEvent\r\n    });\r\n\r\n    this.trigger(dragMoveEvent);\r\n\r\n    if (dragMoveEvent.canceled()) {\r\n      sensorEvent.cancel();\r\n    }\r\n\r\n    target = (0, _utils.closest)(target, this.options.draggable);\r\n    const withinCorrectContainer = (0, _utils.closest)(sensorEvent.target, this.containers);\r\n    const overContainer = sensorEvent.overContainer || withinCorrectContainer;\r\n    const isLeavingContainer = this.currentOverContainer && overContainer !== this.currentOverContainer;\r\n    const isLeavingDraggable = this.currentOver && target !== this.currentOver;\r\n    const isOverContainer = overContainer && this.currentOverContainer !== overContainer;\r\n    const isOverDraggable = withinCorrectContainer && target && this.currentOver !== target;\r\n\r\n    if (isLeavingDraggable) {\r\n      const dragOutEvent = new _DragEvent.DragOutEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        over: this.currentOver,\r\n        overContainer: this.currentOverContainer\r\n      });\r\n\r\n      this.currentOver.classList.remove(...this.getClassNamesFor('draggable:over'));\r\n      this.currentOver = null;\r\n\r\n      this.trigger(dragOutEvent);\r\n    }\r\n\r\n    if (isLeavingContainer) {\r\n      const dragOutContainerEvent = new _DragEvent.DragOutContainerEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer: this.currentOverContainer\r\n      });\r\n\r\n      this.currentOverContainer.classList.remove(...this.getClassNamesFor('container:over'));\r\n      this.currentOverContainer = null;\r\n\r\n      this.trigger(dragOutContainerEvent);\r\n    }\r\n\r\n    if (isOverContainer) {\r\n      overContainer.classList.add(...this.getClassNamesFor('container:over'));\r\n\r\n      const dragOverContainerEvent = new _DragEvent.DragOverContainerEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer\r\n      });\r\n\r\n      this.currentOverContainer = overContainer;\r\n\r\n      this.trigger(dragOverContainerEvent);\r\n    }\r\n\r\n    if (isOverDraggable) {\r\n      target.classList.add(...this.getClassNamesFor('draggable:over'));\r\n\r\n      const dragOverEvent = new _DragEvent.DragOverEvent({\r\n        source: this.source,\r\n        originalSource: this.originalSource,\r\n        sourceContainer: container,\r\n        sensorEvent,\r\n        overContainer,\r\n        over: target\r\n      });\r\n\r\n      this.currentOver = target;\r\n\r\n      this.trigger(dragOverEvent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragStop](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    this.dragging = false;\r\n\r\n    const dragStopEvent = new _DragEvent.DragStopEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sensorEvent: event.sensorEvent,\r\n      sourceContainer: this.sourceContainer\r\n    });\r\n\r\n    this.trigger(dragStopEvent);\r\n\r\n    this.source.parentNode.insertBefore(this.originalSource, this.source);\r\n    this.source.parentNode.removeChild(this.source);\r\n    this.originalSource.style.display = '';\r\n\r\n    this.source.classList.remove(...this.getClassNamesFor('source:dragging'));\r\n    this.originalSource.classList.remove(...this.getClassNamesFor('source:original'));\r\n    this.originalSource.classList.add(...this.getClassNamesFor('source:placed'));\r\n    this.sourceContainer.classList.add(...this.getClassNamesFor('container:placed'));\r\n    this.sourceContainer.classList.remove(...this.getClassNamesFor('container:dragging'));\r\n    document.body.classList.remove(...this.getClassNamesFor('body:dragging'));\r\n    applyUserSelect(document.body, '');\r\n\r\n    if (this.currentOver) {\r\n      this.currentOver.classList.remove(...this.getClassNamesFor('draggable:over'));\r\n    }\r\n\r\n    if (this.currentOverContainer) {\r\n      this.currentOverContainer.classList.remove(...this.getClassNamesFor('container:over'));\r\n    }\r\n\r\n    this.lastPlacedSource = this.originalSource;\r\n    this.lastPlacedContainer = this.sourceContainer;\r\n\r\n    this.placedTimeoutID = setTimeout(() => {\r\n      if (this.lastPlacedSource) {\r\n        this.lastPlacedSource.classList.remove(...this.getClassNamesFor('source:placed'));\r\n      }\r\n\r\n      if (this.lastPlacedContainer) {\r\n        this.lastPlacedContainer.classList.remove(...this.getClassNamesFor('container:placed'));\r\n      }\r\n\r\n      this.lastPlacedSource = null;\r\n      this.lastPlacedContainer = null;\r\n    }, this.options.placedTimeout);\r\n\r\n    const dragStoppedEvent = new _DragEvent.DragStoppedEvent({\r\n      source: this.source,\r\n      originalSource: this.originalSource,\r\n      sensorEvent: event.sensorEvent,\r\n      sourceContainer: this.sourceContainer\r\n    });\r\n\r\n    this.trigger(dragStoppedEvent);\r\n\r\n    this.source = null;\r\n    this.originalSource = null;\r\n    this.currentOverContainer = null;\r\n    this.currentOver = null;\r\n    this.sourceContainer = null;\r\n  }\r\n\r\n  /**\r\n   * Drag pressure handler\r\n   * @private\r\n   * @param {Event} event - DOM Drag event\r\n   */\r\n  [onDragPressure](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = getSensorEvent(event);\r\n    const source = this.source || (0, _utils.closest)(sensorEvent.originalEvent.target, this.options.draggable);\r\n\r\n    const dragPressureEvent = new _DragEvent.DragPressureEvent({\r\n      sensorEvent,\r\n      source,\r\n      pressure: sensorEvent.pressure\r\n    });\r\n\r\n    this.trigger(dragPressureEvent);\r\n  }\r\n}\r\n\r\nexports.default = Draggable;\r\nDraggable.Plugins = { Announcement: _Plugins.Announcement, Focusable: _Plugins.Focusable, Mirror: _Plugins.Mirror, Scrollable: _Plugins.Scrollable };\r\nDraggable.Sensors = { MouseSensor: _Sensors.MouseSensor, TouchSensor: _Sensors.TouchSensor };\r\nfunction getSensorEvent(event) {\r\n  return event.detail;\r\n}\r\n\r\nfunction applyUserSelect(element, value) {\r\n  element.style.webkitUserSelect = value;\r\n  element.style.mozUserSelect = value;\r\n  element.style.msUserSelect = value;\r\n  element.style.oUserSelect = value;\r\n  element.style.userSelect = value;\r\n}\r\n\r\n/***/ }),\r\n/* 13 */\r\n/***/ (function(module, exports, __nested_webpack_require_34931__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Sensor = __nested_webpack_require_34931__(1);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_34931__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMouseForceWillBegin = Symbol('onMouseForceWillBegin');\r\nconst onMouseForceDown = Symbol('onMouseForceDown');\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseForceChange = Symbol('onMouseForceChange');\r\nconst onMouseMove = Symbol('onMouseMove');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst onMouseForceGlobalChange = Symbol('onMouseForceGlobalChange');\r\n\r\n/**\r\n * This sensor picks up native force touch events and dictates drag operations\r\n * @class ForceTouchSensor\r\n * @module ForceTouchSensor\r\n * @extends Sensor\r\n */\r\nclass ForceTouchSensor extends _Sensor2.default {\r\n  /**\r\n   * ForceTouchSensor constructor.\r\n   * @constructs ForceTouchSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed\r\n     * @property mightDrag\r\n     * @type {Boolean}\r\n     */\r\n    this.mightDrag = false;\r\n\r\n    this[onMouseForceWillBegin] = this[onMouseForceWillBegin].bind(this);\r\n    this[onMouseForceDown] = this[onMouseForceDown].bind(this);\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseForceChange] = this[onMouseForceChange].bind(this);\r\n    this[onMouseMove] = this[onMouseMove].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    for (const container of this.containers) {\r\n      container.addEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\r\n      container.addEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\r\n      container.addEventListener('mousedown', this[onMouseDown], true);\r\n      container.addEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\r\n    }\r\n\r\n    document.addEventListener('mousemove', this[onMouseMove]);\r\n    document.addEventListener('mouseup', this[onMouseUp]);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    for (const container of this.containers) {\r\n      container.removeEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\r\n      container.removeEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\r\n      container.removeEventListener('mousedown', this[onMouseDown], true);\r\n      container.removeEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\r\n    }\r\n\r\n    document.removeEventListener('mousemove', this[onMouseMove]);\r\n    document.removeEventListener('mouseup', this[onMouseUp]);\r\n  }\r\n\r\n  /**\r\n   * Mouse force will begin handler\r\n   * @private\r\n   * @param {Event} event - Mouse force will begin event\r\n   */\r\n  [onMouseForceWillBegin](event) {\r\n    event.preventDefault();\r\n    this.mightDrag = true;\r\n  }\r\n\r\n  /**\r\n   * Mouse force down handler\r\n   * @private\r\n   * @param {Event} event - Mouse force down event\r\n   */\r\n  [onMouseForceDown](event) {\r\n    if (this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = event.currentTarget;\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragStartEvent);\r\n\r\n    this.currentContainer = container;\r\n    this.dragging = !dragStartEvent.canceled();\r\n    this.mightDrag = false;\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target: null,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.mightDrag = false;\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    if (!this.mightDrag) {\r\n      return;\r\n    }\r\n\r\n    // Need workaround for real click\r\n    // Cancel potential drag events\r\n    event.stopPropagation();\r\n    event.stopImmediatePropagation();\r\n    event.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler\r\n   * @private\r\n   * @param {Event} event - Mouse force will begin event\r\n   */\r\n  [onMouseMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse force change handler\r\n   * @private\r\n   * @param {Event} event - Mouse force change event\r\n   */\r\n  [onMouseForceChange](event) {\r\n    if (this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = event.target;\r\n    const container = event.currentTarget;\r\n\r\n    const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({\r\n      pressure: event.webkitForce,\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragPressureEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse force global change handler\r\n   * @private\r\n   * @param {Event} event - Mouse force global change event\r\n   */\r\n  [onMouseForceGlobalChange](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = event.target;\r\n\r\n    const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({\r\n      pressure: event.webkitForce,\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragPressureEvent);\r\n  }\r\n}\r\nexports.default = ForceTouchSensor;\r\n\r\n/***/ }),\r\n/* 14 */\r\n/***/ (function(module, exports, __nested_webpack_require_41671__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _ForceTouchSensor = __nested_webpack_require_41671__(13);\r\n\r\nvar _ForceTouchSensor2 = _interopRequireDefault(_ForceTouchSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _ForceTouchSensor2.default;\r\n\r\n/***/ }),\r\n/* 15 */\r\n/***/ (function(module, exports, __nested_webpack_require_42111__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_42111__(2);\r\n\r\nvar _Sensor = __nested_webpack_require_42111__(1);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_42111__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragEnd = Symbol('onDragEnd');\r\nconst onDrop = Symbol('onDrop');\r\nconst reset = Symbol('reset');\r\n\r\n/**\r\n * This sensor picks up native browser drag events and dictates drag operations\r\n * @class DragSensor\r\n * @module DragSensor\r\n * @extends Sensor\r\n */\r\nclass DragSensor extends _Sensor2.default {\r\n  /**\r\n   * DragSensor constructor.\r\n   * @constructs DragSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Mouse down timer which will end up setting the draggable attribute, unless canceled\r\n     * @property mouseDownTimeout\r\n     * @type {Number}\r\n     */\r\n    this.mouseDownTimeout = null;\r\n\r\n    /**\r\n     * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed\r\n     * @property draggableElement\r\n     * @type {HTMLElement}\r\n     */\r\n    this.draggableElement = null;\r\n\r\n    /**\r\n     * Native draggable element could be links or images, their draggable state will be disabled during drag operation\r\n     * @property nativeDraggableElement\r\n     * @type {HTMLElement}\r\n     */\r\n    this.nativeDraggableElement = null;\r\n\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragEnd] = this[onDragEnd].bind(this);\r\n    this[onDrop] = this[onDrop].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {Event} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    // Need for firefox. \"text\" key is needed for IE\r\n    event.dataTransfer.setData('text', '');\r\n    event.dataTransfer.effectAllowed = this.options.type;\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    this.currentContainer = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!this.currentContainer) {\r\n      return;\r\n    }\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    // Workaround\r\n    setTimeout(() => {\r\n      this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n      if (dragStartEvent.canceled()) {\r\n        this.dragging = false;\r\n      } else {\r\n        this.dragging = true;\r\n      }\r\n    }, 0);\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {Event} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = this.currentContainer;\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragMoveEvent);\r\n\r\n    if (!dragMoveEvent.canceled()) {\r\n      event.preventDefault();\r\n      event.dataTransfer.dropEffect = this.options.type;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag end handler\r\n   * @private\r\n   * @param {Event} event - Drag end event\r\n   */\r\n  [onDragEnd](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp], true);\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n    const container = this.currentContainer;\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(container, dragStopEvent);\r\n\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n\r\n    this[reset]();\r\n  }\r\n\r\n  /**\r\n   * Drop handler\r\n   * @private\r\n   * @param {Event} event - Drop event\r\n   */\r\n  [onDrop](event) {\r\n    // eslint-disable-line class-methods-use-this\r\n    event.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    // Firefox bug for inputs within draggables https://bugzilla.mozilla.org/show_bug.cgi?id=739071\r\n    if (event.target && (event.target.form || event.target.contenteditable)) {\r\n      return;\r\n    }\r\n\r\n    const nativeDraggableElement = (0, _utils.closest)(event.target, element => element.draggable);\r\n\r\n    if (nativeDraggableElement) {\r\n      nativeDraggableElement.draggable = false;\r\n      this.nativeDraggableElement = nativeDraggableElement;\r\n    }\r\n\r\n    document.addEventListener('mouseup', this[onMouseUp], true);\r\n    document.addEventListener('dragstart', this[onDragStart], false);\r\n    document.addEventListener('dragover', this[onDragOver], false);\r\n    document.addEventListener('dragend', this[onDragEnd], false);\r\n    document.addEventListener('drop', this[onDrop], false);\r\n\r\n    const target = (0, _utils.closest)(event.target, this.options.draggable);\r\n\r\n    if (!target) {\r\n      return;\r\n    }\r\n\r\n    this.startEvent = event;\r\n\r\n    this.mouseDownTimeout = setTimeout(() => {\r\n      target.draggable = true;\r\n      this.draggableElement = target;\r\n    }, this.delay.drag);\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp]() {\r\n    this[reset]();\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [reset]() {\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp], true);\r\n    document.removeEventListener('dragstart', this[onDragStart], false);\r\n    document.removeEventListener('dragover', this[onDragOver], false);\r\n    document.removeEventListener('dragend', this[onDragEnd], false);\r\n    document.removeEventListener('drop', this[onDrop], false);\r\n\r\n    if (this.nativeDraggableElement) {\r\n      this.nativeDraggableElement.draggable = true;\r\n      this.nativeDraggableElement = null;\r\n    }\r\n\r\n    if (this.draggableElement) {\r\n      this.draggableElement.draggable = false;\r\n      this.draggableElement = null;\r\n    }\r\n  }\r\n}\r\nexports.default = DragSensor;\r\n\r\n/***/ }),\r\n/* 16 */\r\n/***/ (function(module, exports, __nested_webpack_require_49384__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragSensor = __nested_webpack_require_49384__(15);\r\n\r\nvar _DragSensor2 = _interopRequireDefault(_DragSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _DragSensor2.default;\r\n\r\n/***/ }),\r\n/* 17 */\r\n/***/ (function(module, exports, __nested_webpack_require_49800__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_49800__(2);\r\n\r\nvar _Sensor = __nested_webpack_require_49800__(1);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_49800__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onTouchStart = Symbol('onTouchStart');\r\nconst onTouchEnd = Symbol('onTouchEnd');\r\nconst onTouchMove = Symbol('onTouchMove');\r\nconst startDrag = Symbol('startDrag');\r\nconst onDistanceChange = Symbol('onDistanceChange');\r\n\r\n/**\r\n * Prevents scrolling when set to true\r\n * @var {Boolean} preventScrolling\r\n */\r\nlet preventScrolling = false;\r\n\r\n// WebKit requires cancelable `touchmove` events to be added as early as possible\r\nwindow.addEventListener('touchmove', event => {\r\n  if (!preventScrolling) {\r\n    return;\r\n  }\r\n\r\n  // Prevent scrolling\r\n  event.preventDefault();\r\n}, { passive: false });\r\n\r\n/**\r\n * This sensor picks up native browser touch events and dictates drag operations\r\n * @class TouchSensor\r\n * @module TouchSensor\r\n * @extends Sensor\r\n */\r\nclass TouchSensor extends _Sensor2.default {\r\n  /**\r\n   * TouchSensor constructor.\r\n   * @constructs TouchSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Closest scrollable container so accidental scroll can cancel long touch\r\n     * @property currentScrollableParent\r\n     * @type {HTMLElement}\r\n     */\r\n    this.currentScrollableParent = null;\r\n\r\n    /**\r\n     * TimeoutID for managing delay\r\n     * @property tapTimeout\r\n     * @type {Number}\r\n     */\r\n    this.tapTimeout = null;\r\n\r\n    /**\r\n     * touchMoved indicates if touch has moved during tapTimeout\r\n     * @property touchMoved\r\n     * @type {Boolean}\r\n     */\r\n    this.touchMoved = false;\r\n\r\n    /**\r\n     * Save pageX coordinates for delay drag\r\n     * @property {Numbre} pageX\r\n     * @private\r\n     */\r\n    this.pageX = null;\r\n\r\n    /**\r\n     * Save pageY coordinates for delay drag\r\n     * @property {Numbre} pageY\r\n     * @private\r\n     */\r\n    this.pageY = null;\r\n\r\n    this[onTouchStart] = this[onTouchStart].bind(this);\r\n    this[onTouchEnd] = this[onTouchEnd].bind(this);\r\n    this[onTouchMove] = this[onTouchMove].bind(this);\r\n    this[startDrag] = this[startDrag].bind(this);\r\n    this[onDistanceChange] = this[onDistanceChange].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('touchstart', this[onTouchStart]);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('touchstart', this[onTouchStart]);\r\n  }\r\n\r\n  /**\r\n   * Touch start handler\r\n   * @private\r\n   * @param {Event} event - Touch start event\r\n   */\r\n  [onTouchStart](event) {\r\n    const container = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!container) {\r\n      return;\r\n    }\r\n    const { distance = 0 } = this.options;\r\n    const { delay } = this;\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n    this.onTouchStartAt = Date.now();\r\n    this.startEvent = event;\r\n    this.currentContainer = container;\r\n\r\n    document.addEventListener('touchend', this[onTouchEnd]);\r\n    document.addEventListener('touchcancel', this[onTouchEnd]);\r\n    document.addEventListener('touchmove', this[onDistanceChange]);\r\n    container.addEventListener('contextmenu', onContextMenu);\r\n\r\n    if (distance) {\r\n      preventScrolling = true;\r\n    }\r\n\r\n    this.tapTimeout = window.setTimeout(() => {\r\n      this[onDistanceChange]({ touches: [{ pageX: this.pageX, pageY: this.pageY }] });\r\n    }, delay.touch);\r\n  }\r\n\r\n  /**\r\n   * Start the drag\r\n   * @private\r\n   */\r\n  [startDrag]() {\r\n    const startEvent = this.startEvent;\r\n    const container = this.currentContainer;\r\n    const touch = (0, _utils.touchCoords)(startEvent);\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: touch.pageX,\r\n      clientY: touch.pageY,\r\n      target: startEvent.target,\r\n      container,\r\n      originalEvent: startEvent\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n    this.dragging = !dragStartEvent.canceled();\r\n\r\n    if (this.dragging) {\r\n      document.addEventListener('touchmove', this[onTouchMove]);\r\n    }\r\n    preventScrolling = this.dragging;\r\n  }\r\n\r\n  /**\r\n   * Touch move handler prior to drag start.\r\n   * @private\r\n   * @param {Event} event - Touch move event\r\n   */\r\n  [onDistanceChange](event) {\r\n    const { distance } = this.options;\r\n    const { startEvent, delay } = this;\r\n    const start = (0, _utils.touchCoords)(startEvent);\r\n    const current = (0, _utils.touchCoords)(event);\r\n    const timeElapsed = Date.now() - this.onTouchStartAt;\r\n    const distanceTravelled = (0, _utils.distance)(start.pageX, start.pageY, current.pageX, current.pageY);\r\n\r\n    Object.assign(this, current);\r\n\r\n    clearTimeout(this.tapTimeout);\r\n\r\n    if (timeElapsed < delay.touch) {\r\n      // moved during delay\r\n      document.removeEventListener('touchmove', this[onDistanceChange]);\r\n    } else if (distanceTravelled >= distance) {\r\n      document.removeEventListener('touchmove', this[onDistanceChange]);\r\n      this[startDrag]();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler while dragging\r\n   * @private\r\n   * @param {Event} event - Touch move event\r\n   */\r\n  [onTouchMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n    const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: pageX,\r\n      clientY: pageY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Touch end handler\r\n   * @private\r\n   * @param {Event} event - Touch end event\r\n   */\r\n  [onTouchEnd](event) {\r\n    clearTimeout(this.tapTimeout);\r\n    preventScrolling = false;\r\n\r\n    document.removeEventListener('touchend', this[onTouchEnd]);\r\n    document.removeEventListener('touchcancel', this[onTouchEnd]);\r\n    document.removeEventListener('touchmove', this[onDistanceChange]);\r\n\r\n    if (this.currentContainer) {\r\n      this.currentContainer.removeEventListener('contextmenu', onContextMenu);\r\n    }\r\n\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('touchmove', this[onTouchMove]);\r\n\r\n    const { pageX, pageY } = (0, _utils.touchCoords)(event);\r\n    const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);\r\n\r\n    event.preventDefault();\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: pageX,\r\n      clientY: pageY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n  }\r\n}\r\n\r\nexports.default = TouchSensor;\r\nfunction onContextMenu(event) {\r\n  event.preventDefault();\r\n  event.stopPropagation();\r\n}\r\n\r\n/***/ }),\r\n/* 18 */\r\n/***/ (function(module, exports, __nested_webpack_require_57280__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _TouchSensor = __nested_webpack_require_57280__(17);\r\n\r\nvar _TouchSensor2 = _interopRequireDefault(_TouchSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _TouchSensor2.default;\r\n\r\n/***/ }),\r\n/* 19 */\r\n/***/ (function(module, exports, __nested_webpack_require_57700__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DragPressureSensorEvent = exports.DragStopSensorEvent = exports.DragMoveSensorEvent = exports.DragStartSensorEvent = exports.SensorEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_57700__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base sensor event\r\n * @class SensorEvent\r\n * @module SensorEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SensorEvent extends _AbstractEvent2.default {\r\n  /**\r\n   * Original browser event that triggered a sensor\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    return this.data.originalEvent;\r\n  }\r\n\r\n  /**\r\n   * Normalized clientX for both touch and mouse events\r\n   * @property clientX\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get clientX() {\r\n    return this.data.clientX;\r\n  }\r\n\r\n  /**\r\n   * Normalized clientY for both touch and mouse events\r\n   * @property clientY\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get clientY() {\r\n    return this.data.clientY;\r\n  }\r\n\r\n  /**\r\n   * Normalized target for both touch and mouse events\r\n   * Returns the element that is behind cursor or touch pointer\r\n   * @property target\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get target() {\r\n    return this.data.target;\r\n  }\r\n\r\n  /**\r\n   * Container that initiated the sensor\r\n   * @property container\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get container() {\r\n    return this.data.container;\r\n  }\r\n\r\n  /**\r\n   * Trackpad pressure\r\n   * @property pressure\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get pressure() {\r\n    return this.data.pressure;\r\n  }\r\n}\r\n\r\nexports.SensorEvent = SensorEvent; /**\r\n                                    * Drag start sensor event\r\n                                    * @class DragStartSensorEvent\r\n                                    * @module DragStartSensorEvent\r\n                                    * @extends SensorEvent\r\n                                    */\r\n\r\nclass DragStartSensorEvent extends SensorEvent {}\r\n\r\nexports.DragStartSensorEvent = DragStartSensorEvent; /**\r\n                                                      * Drag move sensor event\r\n                                                      * @class DragMoveSensorEvent\r\n                                                      * @module DragMoveSensorEvent\r\n                                                      * @extends SensorEvent\r\n                                                      */\r\n\r\nDragStartSensorEvent.type = 'drag:start';\r\nclass DragMoveSensorEvent extends SensorEvent {}\r\n\r\nexports.DragMoveSensorEvent = DragMoveSensorEvent; /**\r\n                                                    * Drag stop sensor event\r\n                                                    * @class DragStopSensorEvent\r\n                                                    * @module DragStopSensorEvent\r\n                                                    * @extends SensorEvent\r\n                                                    */\r\n\r\nDragMoveSensorEvent.type = 'drag:move';\r\nclass DragStopSensorEvent extends SensorEvent {}\r\n\r\nexports.DragStopSensorEvent = DragStopSensorEvent; /**\r\n                                                    * Drag pressure sensor event\r\n                                                    * @class DragPressureSensorEvent\r\n                                                    * @module DragPressureSensorEvent\r\n                                                    * @extends SensorEvent\r\n                                                    */\r\n\r\nDragStopSensorEvent.type = 'drag:stop';\r\nclass DragPressureSensorEvent extends SensorEvent {}\r\nexports.DragPressureSensorEvent = DragPressureSensorEvent;\r\nDragPressureSensorEvent.type = 'drag:pressure';\r\n\r\n/***/ }),\r\n/* 20 */\r\n/***/ (function(module, exports, __nested_webpack_require_61691__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _utils = __nested_webpack_require_61691__(2);\r\n\r\nvar _Sensor = __nested_webpack_require_61691__(1);\r\n\r\nvar _Sensor2 = _interopRequireDefault(_Sensor);\r\n\r\nvar _SensorEvent = __nested_webpack_require_61691__(0);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onContextMenuWhileDragging = Symbol('onContextMenuWhileDragging');\r\nconst onMouseDown = Symbol('onMouseDown');\r\nconst onMouseMove = Symbol('onMouseMove');\r\nconst onMouseUp = Symbol('onMouseUp');\r\nconst startDrag = Symbol('startDrag');\r\nconst onDistanceChange = Symbol('onDistanceChange');\r\n\r\n/**\r\n * This sensor picks up native browser mouse events and dictates drag operations\r\n * @class MouseSensor\r\n * @module MouseSensor\r\n * @extends Sensor\r\n */\r\nclass MouseSensor extends _Sensor2.default {\r\n  /**\r\n   * MouseSensor constructor.\r\n   * @constructs MouseSensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, options);\r\n\r\n    /**\r\n     * Mouse down timer which will end up triggering the drag start operation\r\n     * @property mouseDownTimeout\r\n     * @type {Number}\r\n     */\r\n    this.mouseDownTimeout = null;\r\n\r\n    /**\r\n     * Save pageX coordinates for delay drag\r\n     * @property {Numbre} pageX\r\n     * @private\r\n     */\r\n    this.pageX = null;\r\n\r\n    /**\r\n     * Save pageY coordinates for delay drag\r\n     * @property {Numbre} pageY\r\n     * @private\r\n     */\r\n    this.pageY = null;\r\n\r\n    this[onContextMenuWhileDragging] = this[onContextMenuWhileDragging].bind(this);\r\n    this[onMouseDown] = this[onMouseDown].bind(this);\r\n    this[onMouseMove] = this[onMouseMove].bind(this);\r\n    this[onMouseUp] = this[onMouseUp].bind(this);\r\n    this[startDrag] = this[startDrag].bind(this);\r\n    this[onDistanceChange] = this[onDistanceChange].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   */\r\n  attach() {\r\n    document.addEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   */\r\n  detach() {\r\n    document.removeEventListener('mousedown', this[onMouseDown], true);\r\n  }\r\n\r\n  /**\r\n   * Mouse down handler\r\n   * @private\r\n   * @param {Event} event - Mouse down event\r\n   */\r\n  [onMouseDown](event) {\r\n    if (event.button !== 0 || event.ctrlKey || event.metaKey) {\r\n      return;\r\n    }\r\n    const container = (0, _utils.closest)(event.target, this.containers);\r\n\r\n    if (!container) {\r\n      return;\r\n    }\r\n\r\n    const { delay } = this;\r\n    const { pageX, pageY } = event;\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n    this.onMouseDownAt = Date.now();\r\n    this.startEvent = event;\r\n\r\n    this.currentContainer = container;\r\n    document.addEventListener('mouseup', this[onMouseUp]);\r\n    document.addEventListener('dragstart', preventNativeDragStart);\r\n    document.addEventListener('mousemove', this[onDistanceChange]);\r\n\r\n    this.mouseDownTimeout = window.setTimeout(() => {\r\n      this[onDistanceChange]({ pageX: this.pageX, pageY: this.pageY });\r\n    }, delay.mouse);\r\n  }\r\n\r\n  /**\r\n   * Start the drag\r\n   * @private\r\n   */\r\n  [startDrag]() {\r\n    const startEvent = this.startEvent;\r\n    const container = this.currentContainer;\r\n\r\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\r\n      clientX: startEvent.clientX,\r\n      clientY: startEvent.clientY,\r\n      target: startEvent.target,\r\n      container,\r\n      originalEvent: startEvent\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStartEvent);\r\n\r\n    this.dragging = !dragStartEvent.canceled();\r\n\r\n    if (this.dragging) {\r\n      document.addEventListener('contextmenu', this[onContextMenuWhileDragging], true);\r\n      document.addEventListener('mousemove', this[onMouseMove]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect change in distance, starting drag when both\r\n   * delay and distance requirements are met\r\n   * @private\r\n   * @param {Event} event - Mouse move event\r\n   */\r\n  [onDistanceChange](event) {\r\n    const { pageX, pageY } = event;\r\n    const { distance } = this.options;\r\n    const { startEvent, delay } = this;\r\n\r\n    Object.assign(this, { pageX, pageY });\r\n\r\n    if (!this.currentContainer) {\r\n      return;\r\n    }\r\n\r\n    const timeElapsed = Date.now() - this.onMouseDownAt;\r\n    const distanceTravelled = (0, _utils.distance)(startEvent.pageX, startEvent.pageY, pageX, pageY) || 0;\r\n\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    if (timeElapsed < delay.mouse) {\r\n      // moved during delay\r\n      document.removeEventListener('mousemove', this[onDistanceChange]);\r\n    } else if (distanceTravelled >= distance) {\r\n      document.removeEventListener('mousemove', this[onDistanceChange]);\r\n      this[startDrag]();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mouse move handler\r\n   * @private\r\n   * @param {Event} event - Mouse move event\r\n   */\r\n  [onMouseMove](event) {\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragMoveEvent);\r\n  }\r\n\r\n  /**\r\n   * Mouse up handler\r\n   * @private\r\n   * @param {Event} event - Mouse up event\r\n   */\r\n  [onMouseUp](event) {\r\n    clearTimeout(this.mouseDownTimeout);\r\n\r\n    if (event.button !== 0) {\r\n      return;\r\n    }\r\n\r\n    document.removeEventListener('mouseup', this[onMouseUp]);\r\n    document.removeEventListener('dragstart', preventNativeDragStart);\r\n    document.removeEventListener('mousemove', this[onDistanceChange]);\r\n\r\n    if (!this.dragging) {\r\n      return;\r\n    }\r\n\r\n    const target = document.elementFromPoint(event.clientX, event.clientY);\r\n\r\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      target,\r\n      container: this.currentContainer,\r\n      originalEvent: event\r\n    });\r\n\r\n    this.trigger(this.currentContainer, dragStopEvent);\r\n\r\n    document.removeEventListener('contextmenu', this[onContextMenuWhileDragging], true);\r\n    document.removeEventListener('mousemove', this[onMouseMove]);\r\n\r\n    this.currentContainer = null;\r\n    this.dragging = false;\r\n    this.startEvent = null;\r\n  }\r\n\r\n  /**\r\n   * Context menu handler\r\n   * @private\r\n   * @param {Event} event - Context menu event\r\n   */\r\n  [onContextMenuWhileDragging](event) {\r\n    event.preventDefault();\r\n  }\r\n}\r\n\r\nexports.default = MouseSensor;\r\nfunction preventNativeDragStart(event) {\r\n  event.preventDefault();\r\n}\r\n\r\n/***/ }),\r\n/* 21 */\r\n/***/ (function(module, exports, __nested_webpack_require_68563__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _MouseSensor = __nested_webpack_require_68563__(20);\r\n\r\nvar _MouseSensor2 = _interopRequireDefault(_MouseSensor);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _MouseSensor2.default;\r\n\r\n/***/ }),\r\n/* 22 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst defaultDealy = {\r\n  mouse: 0,\r\n  drag: 0,\r\n  touch: 100\r\n};\r\n\r\n/**\r\n * Base sensor class. Extend from this class to create a new or custom sensor\r\n * @class Sensor\r\n * @module Sensor\r\n */\r\nclass Sensor {\r\n  /**\r\n   * Sensor constructor.\r\n   * @constructs Sensor\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\r\n   * @param {Object} options - Options\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    /**\r\n     * Current containers\r\n     * @property containers\r\n     * @type {HTMLElement[]}\r\n     */\r\n    this.containers = [...containers];\r\n\r\n    /**\r\n     * Current options\r\n     * @property options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, options);\r\n\r\n    /**\r\n     * Current drag state\r\n     * @property dragging\r\n     * @type {Boolean}\r\n     */\r\n    this.dragging = false;\r\n\r\n    /**\r\n     * Current container\r\n     * @property currentContainer\r\n     * @type {HTMLElement}\r\n     */\r\n    this.currentContainer = null;\r\n\r\n    /**\r\n     * The event of the initial sensor down\r\n     * @property startEvent\r\n     * @type {Event}\r\n     */\r\n    this.startEvent = null;\r\n\r\n    /**\r\n     * The delay of each sensor\r\n     * @property delay\r\n     * @type {Object}\r\n     */\r\n    this.delay = calcDelay(options.delay);\r\n  }\r\n\r\n  /**\r\n   * Attaches sensors event listeners to the DOM\r\n   * @return {Sensor}\r\n   */\r\n  attach() {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Detaches sensors event listeners to the DOM\r\n   * @return {Sensor}\r\n   */\r\n  detach() {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds container to this sensor instance\r\n   * @param {...HTMLElement} containers - Containers you want to add to this sensor\r\n   * @example draggable.addContainer(document.body)\r\n   */\r\n  addContainer(...containers) {\r\n    this.containers = [...this.containers, ...containers];\r\n  }\r\n\r\n  /**\r\n   * Removes container from this sensor instance\r\n   * @param {...HTMLElement} containers - Containers you want to remove from this sensor\r\n   * @example draggable.removeContainer(document.body)\r\n   */\r\n  removeContainer(...containers) {\r\n    this.containers = this.containers.filter(container => !containers.includes(container));\r\n  }\r\n\r\n  /**\r\n   * Triggers event on target element\r\n   * @param {HTMLElement} element - Element to trigger event on\r\n   * @param {SensorEvent} sensorEvent - Sensor event to trigger\r\n   */\r\n  trigger(element, sensorEvent) {\r\n    const event = document.createEvent('Event');\r\n    event.detail = sensorEvent;\r\n    event.initEvent(sensorEvent.type, true, true);\r\n    element.dispatchEvent(event);\r\n    this.lastEvent = sensorEvent;\r\n\r\n    return sensorEvent;\r\n  }\r\n}\r\n\r\nexports.default = Sensor; /**\r\n                           * Calculate the delay of each sensor through the delay in the options\r\n                           * @param {undefined|Number|Object} optionsDelay - the delay in the options\r\n                           * @return {Object}\r\n                           */\r\n\r\nfunction calcDelay(optionsDelay) {\r\n  const delay = {};\r\n\r\n  if (optionsDelay === undefined) {\r\n    return _extends({}, defaultDealy);\r\n  }\r\n\r\n  if (typeof optionsDelay === 'number') {\r\n    for (const key in defaultDealy) {\r\n      if (defaultDealy.hasOwnProperty(key)) {\r\n        delay[key] = optionsDelay;\r\n      }\r\n    }\r\n    return delay;\r\n  }\r\n\r\n  for (const key in defaultDealy) {\r\n    if (defaultDealy.hasOwnProperty(key)) {\r\n      if (optionsDelay[key] === undefined) {\r\n        delay[key] = defaultDealy[key];\r\n      } else {\r\n        delay[key] = optionsDelay[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  return delay;\r\n}\r\n\r\n/***/ }),\r\n/* 23 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = touchCoords;\r\n/**\r\n * Returns the first touch event found in touches or changedTouches of a touch events.\r\n * @param {TouchEvent} event a touch event\r\n * @return {Touch} a touch object\r\n */\r\nfunction touchCoords(event = {}) {\r\n  const { touches, changedTouches } = event;\r\n  return touches && touches[0] || changedTouches && changedTouches[0];\r\n}\r\n\r\n/***/ }),\r\n/* 24 */\r\n/***/ (function(module, exports, __nested_webpack_require_73520__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _touchCoords = __nested_webpack_require_73520__(23);\r\n\r\nvar _touchCoords2 = _interopRequireDefault(_touchCoords);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _touchCoords2.default;\r\n\r\n/***/ }),\r\n/* 25 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = distance;\r\n/**\r\n * Returns the distance between two points\r\n * @param  {Number} x1 The X position of the first point\r\n * @param  {Number} y1 The Y position of the first point\r\n * @param  {Number} x2 The X position of the second point\r\n * @param  {Number} y2 The Y position of the second point\r\n * @return {Number}\r\n */\r\nfunction distance(x1, y1, x2, y2) {\r\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\r\n}\r\n\r\n/***/ }),\r\n/* 26 */\r\n/***/ (function(module, exports, __nested_webpack_require_74541__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _distance = __nested_webpack_require_74541__(25);\r\n\r\nvar _distance2 = _interopRequireDefault(_distance);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _distance2.default;\r\n\r\n/***/ }),\r\n/* 27 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = requestNextAnimationFrame;\r\nfunction requestNextAnimationFrame(callback) {\r\n  return requestAnimationFrame(() => {\r\n    requestAnimationFrame(callback);\r\n  });\r\n}\r\n\r\n/***/ }),\r\n/* 28 */\r\n/***/ (function(module, exports, __nested_webpack_require_75300__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _requestNextAnimationFrame = __nested_webpack_require_75300__(27);\r\n\r\nvar _requestNextAnimationFrame2 = _interopRequireDefault(_requestNextAnimationFrame);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _requestNextAnimationFrame2.default;\r\n\r\n/***/ }),\r\n/* 29 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = closest;\r\nconst matchFunction = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector;\r\n\r\n/**\r\n * Get the closest parent element of a given element that matches the given\r\n * selector string or matching function\r\n *\r\n * @param {Element} element The child element to find a parent of\r\n * @param {String|Function} selector The string or function to use to match\r\n *     the parent element\r\n * @return {Element|null}\r\n */\r\nfunction closest(element, value) {\r\n  if (!element) {\r\n    return null;\r\n  }\r\n\r\n  const selector = value;\r\n  const callback = value;\r\n  const nodeList = value;\r\n  const singleElement = value;\r\n\r\n  const isSelector = Boolean(typeof value === 'string');\r\n  const isFunction = Boolean(typeof value === 'function');\r\n  const isNodeList = Boolean(value instanceof NodeList || value instanceof Array);\r\n  const isElement = Boolean(value instanceof HTMLElement);\r\n\r\n  function conditionFn(currentElement) {\r\n    if (!currentElement) {\r\n      return currentElement;\r\n    } else if (isSelector) {\r\n      return matchFunction.call(currentElement, selector);\r\n    } else if (isNodeList) {\r\n      return [...nodeList].includes(currentElement);\r\n    } else if (isElement) {\r\n      return singleElement === currentElement;\r\n    } else if (isFunction) {\r\n      return callback(currentElement);\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  let current = element;\r\n\r\n  do {\r\n    current = current.correspondingUseElement || current.correspondingElement || current;\r\n\r\n    if (conditionFn(current)) {\r\n      return current;\r\n    }\r\n\r\n    current = current.parentNode;\r\n  } while (current && current !== document.body && current !== document);\r\n\r\n  return null;\r\n}\r\n\r\n/***/ }),\r\n/* 30 */\r\n/***/ (function(module, exports, __nested_webpack_require_77730__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _closest = __nested_webpack_require_77730__(29);\r\n\r\nvar _closest2 = _interopRequireDefault(_closest);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _closest2.default;\r\n\r\n/***/ }),\r\n/* 31 */\r\n/***/ (function(module, exports, __nested_webpack_require_78134__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = exports.scroll = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_78134__(4);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _utils = __nested_webpack_require_78134__(2);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = exports.onDragStart = Symbol('onDragStart');\r\nconst onDragMove = exports.onDragMove = Symbol('onDragMove');\r\nconst onDragStop = exports.onDragStop = Symbol('onDragStop');\r\nconst scroll = exports.scroll = Symbol('scroll');\r\n\r\n/**\r\n * Scrollable default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.speed\r\n * @property {Number} defaultOptions.sensitivity\r\n * @property {HTMLElement[]} defaultOptions.scrollableElements\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  speed: 6,\r\n  sensitivity: 50,\r\n  scrollableElements: []\r\n};\r\n\r\n/**\r\n * Scrollable plugin which scrolls the closest scrollable parent\r\n * @class Scrollable\r\n * @module Scrollable\r\n * @extends AbstractPlugin\r\n */\r\nclass Scrollable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Scrollable constructor.\r\n   * @constructs Scrollable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Scrollable options\r\n     * @property {Object} options\r\n     * @property {Number} options.speed\r\n     * @property {Number} options.sensitivity\r\n     * @property {HTMLElement[]} options.scrollableElements\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Keeps current mouse position\r\n     * @property {Object} currentMousePosition\r\n     * @property {Number} currentMousePosition.clientX\r\n     * @property {Number} currentMousePosition.clientY\r\n     * @type {Object|null}\r\n     */\r\n    this.currentMousePosition = null;\r\n\r\n    /**\r\n     * Scroll animation frame\r\n     * @property scrollAnimationFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.scrollAnimationFrame = null;\r\n\r\n    /**\r\n     * Closest scrollable element\r\n     * @property scrollableElement\r\n     * @type {HTMLElement|null}\r\n     */\r\n    this.scrollableElement = null;\r\n\r\n    /**\r\n     * Animation frame looking for the closest scrollable element\r\n     * @property findScrollableElementFrame\r\n     * @type {Number|null}\r\n     */\r\n    this.findScrollableElementFrame = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[scroll] = this[scroll].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.scrollable || {};\r\n  }\r\n\r\n  /**\r\n   * Returns closest scrollable elements by element\r\n   * @param {HTMLElement} target\r\n   * @return {HTMLElement}\r\n   */\r\n  getScrollableElement(target) {\r\n    if (this.hasDefinedScrollableElements()) {\r\n      return (0, _utils.closest)(target, this.options.scrollableElements) || document.documentElement;\r\n    } else {\r\n      return closestScrollableElement(target);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if at least one scrollable element have been defined via options\r\n   * @param {HTMLElement} target\r\n   * @return {Boolean}\r\n   */\r\n  hasDefinedScrollableElements() {\r\n    return Boolean(this.options.scrollableElements.length !== 0);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler. Finds closest scrollable parent in separate frame\r\n   * @param {DragStartEvent} dragEvent\r\n   * @private\r\n   */\r\n  [onDragStart](dragEvent) {\r\n    this.findScrollableElementFrame = requestAnimationFrame(() => {\r\n      this.scrollableElement = this.getScrollableElement(dragEvent.source);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Drag move handler. Remembers mouse position and initiates scrolling\r\n   * @param {DragMoveEvent} dragEvent\r\n   * @private\r\n   */\r\n  [onDragMove](dragEvent) {\r\n    this.findScrollableElementFrame = requestAnimationFrame(() => {\r\n      this.scrollableElement = this.getScrollableElement(dragEvent.sensorEvent.target);\r\n    });\r\n\r\n    if (!this.scrollableElement) {\r\n      return;\r\n    }\r\n\r\n    const sensorEvent = dragEvent.sensorEvent;\r\n    const scrollOffset = { x: 0, y: 0 };\r\n\r\n    if ('ontouchstart' in window) {\r\n      scrollOffset.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\r\n      scrollOffset.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;\r\n    }\r\n\r\n    this.currentMousePosition = {\r\n      clientX: sensorEvent.clientX - scrollOffset.x,\r\n      clientY: sensorEvent.clientY - scrollOffset.y\r\n    };\r\n\r\n    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler. Cancels scroll animations and resets state\r\n   * @private\r\n   */\r\n  [onDragStop]() {\r\n    cancelAnimationFrame(this.scrollAnimationFrame);\r\n    cancelAnimationFrame(this.findScrollableElementFrame);\r\n\r\n    this.scrollableElement = null;\r\n    this.scrollAnimationFrame = null;\r\n    this.findScrollableElementFrame = null;\r\n    this.currentMousePosition = null;\r\n  }\r\n\r\n  /**\r\n   * Scroll function that does the heavylifting\r\n   * @private\r\n   */\r\n  [scroll]() {\r\n    if (!this.scrollableElement || !this.currentMousePosition) {\r\n      return;\r\n    }\r\n\r\n    cancelAnimationFrame(this.scrollAnimationFrame);\r\n\r\n    const { speed, sensitivity } = this.options;\r\n\r\n    const rect = this.scrollableElement.getBoundingClientRect();\r\n    const bottomCutOff = rect.bottom > window.innerHeight;\r\n    const topCutOff = rect.top < 0;\r\n    const cutOff = topCutOff || bottomCutOff;\r\n\r\n    const documentScrollingElement = getDocumentScrollingElement();\r\n    const scrollableElement = this.scrollableElement;\r\n    const clientX = this.currentMousePosition.clientX;\r\n    const clientY = this.currentMousePosition.clientY;\r\n\r\n    if (scrollableElement !== document.body && scrollableElement !== document.documentElement && !cutOff) {\r\n      const { offsetHeight, offsetWidth } = scrollableElement;\r\n\r\n      if (rect.top + offsetHeight - clientY < sensitivity) {\r\n        scrollableElement.scrollTop += speed;\r\n      } else if (clientY - rect.top < sensitivity) {\r\n        scrollableElement.scrollTop -= speed;\r\n      }\r\n\r\n      if (rect.left + offsetWidth - clientX < sensitivity) {\r\n        scrollableElement.scrollLeft += speed;\r\n      } else if (clientX - rect.left < sensitivity) {\r\n        scrollableElement.scrollLeft -= speed;\r\n      }\r\n    } else {\r\n      const { innerHeight, innerWidth } = window;\r\n\r\n      if (clientY < sensitivity) {\r\n        documentScrollingElement.scrollTop -= speed;\r\n      } else if (innerHeight - clientY < sensitivity) {\r\n        documentScrollingElement.scrollTop += speed;\r\n      }\r\n\r\n      if (clientX < sensitivity) {\r\n        documentScrollingElement.scrollLeft -= speed;\r\n      } else if (innerWidth - clientX < sensitivity) {\r\n        documentScrollingElement.scrollLeft += speed;\r\n      }\r\n    }\r\n\r\n    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\r\n  }\r\n}\r\n\r\nexports.default = Scrollable; /**\r\n                               * Returns true if the passed element has overflow\r\n                               * @param {HTMLElement} element\r\n                               * @return {Boolean}\r\n                               * @private\r\n                               */\r\n\r\nfunction hasOverflow(element) {\r\n  const overflowRegex = /(auto|scroll)/;\r\n  const computedStyles = getComputedStyle(element, null);\r\n\r\n  const overflow = computedStyles.getPropertyValue('overflow') + computedStyles.getPropertyValue('overflow-y') + computedStyles.getPropertyValue('overflow-x');\r\n\r\n  return overflowRegex.test(overflow);\r\n}\r\n\r\n/**\r\n * Returns true if the passed element is statically positioned\r\n * @param {HTMLElement} element\r\n * @return {Boolean}\r\n * @private\r\n */\r\nfunction isStaticallyPositioned(element) {\r\n  const position = getComputedStyle(element).getPropertyValue('position');\r\n  return position === 'static';\r\n}\r\n\r\n/**\r\n * Finds closest scrollable element\r\n * @param {HTMLElement} element\r\n * @return {HTMLElement}\r\n * @private\r\n */\r\nfunction closestScrollableElement(element) {\r\n  if (!element) {\r\n    return getDocumentScrollingElement();\r\n  }\r\n\r\n  const position = getComputedStyle(element).getPropertyValue('position');\r\n  const excludeStaticParents = position === 'absolute';\r\n\r\n  const scrollableElement = (0, _utils.closest)(element, parent => {\r\n    if (excludeStaticParents && isStaticallyPositioned(parent)) {\r\n      return false;\r\n    }\r\n    return hasOverflow(parent);\r\n  });\r\n\r\n  if (position === 'fixed' || !scrollableElement) {\r\n    return getDocumentScrollingElement();\r\n  } else {\r\n    return scrollableElement;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns element that scrolls document\r\n * @return {HTMLElement}\r\n * @private\r\n */\r\nfunction getDocumentScrollingElement() {\r\n  return document.scrollingElement || document.documentElement;\r\n}\r\n\r\n/***/ }),\r\n/* 32 */\r\n/***/ (function(module, exports, __nested_webpack_require_88056__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Scrollable = __nested_webpack_require_88056__(31);\r\n\r\nvar _Scrollable2 = _interopRequireDefault(_Scrollable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Scrollable2.default;\r\nexports.defaultOptions = _Scrollable.defaultOptions;\r\n\r\n/***/ }),\r\n/* 33 */\r\n/***/ (function(module, exports, __nested_webpack_require_88563__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.MirrorDestroyEvent = exports.MirrorMoveEvent = exports.MirrorAttachedEvent = exports.MirrorCreatedEvent = exports.MirrorCreateEvent = exports.MirrorEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_88563__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base mirror event\r\n * @class MirrorEvent\r\n * @module MirrorEvent\r\n * @extends AbstractEvent\r\n */\r\nclass MirrorEvent extends _AbstractEvent2.default {\r\n  /**\r\n   * Draggables source element\r\n   * @property source\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get source() {\r\n    return this.data.source;\r\n  }\r\n\r\n  /**\r\n   * Draggables original source element\r\n   * @property originalSource\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get originalSource() {\r\n    return this.data.originalSource;\r\n  }\r\n\r\n  /**\r\n   * Draggables source container element\r\n   * @property sourceContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get sourceContainer() {\r\n    return this.data.sourceContainer;\r\n  }\r\n\r\n  /**\r\n   * Sensor event\r\n   * @property sensorEvent\r\n   * @type {SensorEvent}\r\n   * @readonly\r\n   */\r\n  get sensorEvent() {\r\n    return this.data.sensorEvent;\r\n  }\r\n\r\n  /**\r\n   * Drag event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n\r\n  /**\r\n   * Original event that triggered sensor event\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    if (this.sensorEvent) {\r\n      return this.sensorEvent.originalEvent;\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexports.MirrorEvent = MirrorEvent; /**\r\n                                    * Mirror create event\r\n                                    * @class MirrorCreateEvent\r\n                                    * @module MirrorCreateEvent\r\n                                    * @extends MirrorEvent\r\n                                    */\r\n\r\nclass MirrorCreateEvent extends MirrorEvent {}\r\n\r\nexports.MirrorCreateEvent = MirrorCreateEvent; /**\r\n                                                * Mirror created event\r\n                                                * @class MirrorCreatedEvent\r\n                                                * @module MirrorCreatedEvent\r\n                                                * @extends MirrorEvent\r\n                                                */\r\n\r\nMirrorCreateEvent.type = 'mirror:create';\r\nclass MirrorCreatedEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\n\r\nexports.MirrorCreatedEvent = MirrorCreatedEvent; /**\r\n                                                  * Mirror attached event\r\n                                                  * @class MirrorAttachedEvent\r\n                                                  * @module MirrorAttachedEvent\r\n                                                  * @extends MirrorEvent\r\n                                                  */\r\n\r\nMirrorCreatedEvent.type = 'mirror:created';\r\nclass MirrorAttachedEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\n\r\nexports.MirrorAttachedEvent = MirrorAttachedEvent; /**\r\n                                                    * Mirror move event\r\n                                                    * @class MirrorMoveEvent\r\n                                                    * @module MirrorMoveEvent\r\n                                                    * @extends MirrorEvent\r\n                                                    */\r\n\r\nMirrorAttachedEvent.type = 'mirror:attached';\r\nclass MirrorMoveEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n\r\n  /**\r\n   * Sensor has exceeded mirror's threshold on x axis\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  get passedThreshX() {\r\n    return this.data.passedThreshX;\r\n  }\r\n\r\n  /**\r\n   * Sensor has exceeded mirror's threshold on y axis\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  get passedThreshY() {\r\n    return this.data.passedThreshY;\r\n  }\r\n}\r\n\r\nexports.MirrorMoveEvent = MirrorMoveEvent; /**\r\n                                            * Mirror destroy event\r\n                                            * @class MirrorDestroyEvent\r\n                                            * @module MirrorDestroyEvent\r\n                                            * @extends MirrorEvent\r\n                                            */\r\n\r\nMirrorMoveEvent.type = 'mirror:move';\r\nMirrorMoveEvent.cancelable = true;\r\nclass MirrorDestroyEvent extends MirrorEvent {\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n}\r\nexports.MirrorDestroyEvent = MirrorDestroyEvent;\r\nMirrorDestroyEvent.type = 'mirror:destroy';\r\nMirrorDestroyEvent.cancelable = true;\r\n\r\n/***/ }),\r\n/* 34 */\r\n/***/ (function(module, exports, __nested_webpack_require_94015__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _MirrorEvent = __nested_webpack_require_94015__(33);\r\n\r\nObject.keys(_MirrorEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _MirrorEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\n/***/ }),\r\n/* 35 */\r\n/***/ (function(module, exports, __nested_webpack_require_94483__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = exports.getAppendableContainer = exports.onScroll = exports.onMirrorMove = exports.onMirrorCreated = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_94483__(4);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nvar _MirrorEvent = __nested_webpack_require_94483__(34);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\r\n\r\nconst onDragStart = exports.onDragStart = Symbol('onDragStart');\r\nconst onDragMove = exports.onDragMove = Symbol('onDragMove');\r\nconst onDragStop = exports.onDragStop = Symbol('onDragStop');\r\nconst onMirrorCreated = exports.onMirrorCreated = Symbol('onMirrorCreated');\r\nconst onMirrorMove = exports.onMirrorMove = Symbol('onMirrorMove');\r\nconst onScroll = exports.onScroll = Symbol('onScroll');\r\nconst getAppendableContainer = exports.getAppendableContainer = Symbol('getAppendableContainer');\r\n\r\n/**\r\n * Mirror default options\r\n * @property {Object} defaultOptions\r\n * @property {Boolean} defaultOptions.constrainDimensions\r\n * @property {Boolean} defaultOptions.xAxis\r\n * @property {Boolean} defaultOptions.yAxis\r\n * @property {null} defaultOptions.cursorOffsetX\r\n * @property {null} defaultOptions.cursorOffsetY\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  constrainDimensions: false,\r\n  xAxis: true,\r\n  yAxis: true,\r\n  cursorOffsetX: null,\r\n  cursorOffsetY: null,\r\n  thresholdX: null,\r\n  thresholdY: null\r\n};\r\n\r\n/**\r\n * Mirror plugin which controls the mirror positioning while dragging\r\n * @class Mirror\r\n * @module Mirror\r\n * @extends AbstractPlugin\r\n */\r\nclass Mirror extends _AbstractPlugin2.default {\r\n  /**\r\n   * Mirror constructor.\r\n   * @constructs Mirror\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Mirror options\r\n     * @property {Object} options\r\n     * @property {Boolean} options.constrainDimensions\r\n     * @property {Boolean} options.xAxis\r\n     * @property {Boolean} options.yAxis\r\n     * @property {Number|null} options.cursorOffsetX\r\n     * @property {Number|null} options.cursorOffsetY\r\n     * @property {String|HTMLElement|Function} options.appendTo\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Scroll offset for touch devices because the mirror is positioned fixed\r\n     * @property {Object} scrollOffset\r\n     * @property {Number} scrollOffset.x\r\n     * @property {Number} scrollOffset.y\r\n     */\r\n    this.scrollOffset = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Initial scroll offset for touch devices because the mirror is positioned fixed\r\n     * @property {Object} scrollOffset\r\n     * @property {Number} scrollOffset.x\r\n     * @property {Number} scrollOffset.y\r\n     */\r\n    this.initialScrollOffset = {\r\n      x: window.scrollX,\r\n      y: window.scrollY\r\n    };\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragMove] = this[onDragMove].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\r\n    this[onMirrorMove] = this[onMirrorMove].bind(this);\r\n    this[onScroll] = this[onScroll].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches plugins event listeners\r\n   */\r\n  attach() {\r\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]).on('mirror:created', this[onMirrorCreated]).on('mirror:move', this[onMirrorMove]);\r\n  }\r\n\r\n  /**\r\n   * Detaches plugins event listeners\r\n   */\r\n  detach() {\r\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]).off('mirror:created', this[onMirrorCreated]).off('mirror:move', this[onMirrorMove]);\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.mirror || {};\r\n  }\r\n\r\n  [onDragStart](dragEvent) {\r\n    if (dragEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    if ('ontouchstart' in window) {\r\n      document.addEventListener('scroll', this[onScroll], true);\r\n    }\r\n\r\n    this.initialScrollOffset = {\r\n      x: window.scrollX,\r\n      y: window.scrollY\r\n    };\r\n\r\n    const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    // Last sensor position of mirror move\r\n    this.lastMirrorMovedClient = {\r\n      x: sensorEvent.clientX,\r\n      y: sensorEvent.clientY\r\n    };\r\n\r\n    const mirrorCreateEvent = new _MirrorEvent.MirrorCreateEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent\r\n    });\r\n\r\n    this.draggable.trigger(mirrorCreateEvent);\r\n\r\n    if (isNativeDragEvent(sensorEvent) || mirrorCreateEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const appendableContainer = this[getAppendableContainer](source) || sourceContainer;\r\n    this.mirror = source.cloneNode(true);\r\n\r\n    const mirrorCreatedEvent = new _MirrorEvent.MirrorCreatedEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror\r\n    });\r\n\r\n    const mirrorAttachedEvent = new _MirrorEvent.MirrorAttachedEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror\r\n    });\r\n\r\n    this.draggable.trigger(mirrorCreatedEvent);\r\n    appendableContainer.appendChild(this.mirror);\r\n    this.draggable.trigger(mirrorAttachedEvent);\r\n  }\r\n\r\n  [onDragMove](dragEvent) {\r\n    if (!this.mirror || dragEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    let passedThreshX = true;\r\n    let passedThreshY = true;\r\n\r\n    if (this.options.thresholdX || this.options.thresholdY) {\r\n      const { x: lastX, y: lastY } = this.lastMirrorMovedClient;\r\n\r\n      if (Math.abs(lastX - sensorEvent.clientX) < this.options.thresholdX) {\r\n        passedThreshX = false;\r\n      } else {\r\n        this.lastMirrorMovedClient.x = sensorEvent.clientX;\r\n      }\r\n\r\n      if (Math.abs(lastY - sensorEvent.clientY) < this.options.thresholdY) {\r\n        passedThreshY = false;\r\n      } else {\r\n        this.lastMirrorMovedClient.y = sensorEvent.clientY;\r\n      }\r\n\r\n      if (!passedThreshX && !passedThreshY) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const mirrorMoveEvent = new _MirrorEvent.MirrorMoveEvent({\r\n      source,\r\n      originalSource,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent,\r\n      mirror: this.mirror,\r\n      passedThreshX,\r\n      passedThreshY\r\n    });\r\n\r\n    this.draggable.trigger(mirrorMoveEvent);\r\n  }\r\n\r\n  [onDragStop](dragEvent) {\r\n    if ('ontouchstart' in window) {\r\n      document.removeEventListener('scroll', this[onScroll], true);\r\n    }\r\n\r\n    this.initialScrollOffset = { x: 0, y: 0 };\r\n    this.scrollOffset = { x: 0, y: 0 };\r\n\r\n    if (!this.mirror) {\r\n      return;\r\n    }\r\n\r\n    const { source, sourceContainer, sensorEvent } = dragEvent;\r\n\r\n    const mirrorDestroyEvent = new _MirrorEvent.MirrorDestroyEvent({\r\n      source,\r\n      mirror: this.mirror,\r\n      sourceContainer,\r\n      sensorEvent,\r\n      dragEvent\r\n    });\r\n\r\n    this.draggable.trigger(mirrorDestroyEvent);\r\n\r\n    if (!mirrorDestroyEvent.canceled()) {\r\n      this.mirror.parentNode.removeChild(this.mirror);\r\n    }\r\n  }\r\n\r\n  [onScroll]() {\r\n    this.scrollOffset = {\r\n      x: window.scrollX - this.initialScrollOffset.x,\r\n      y: window.scrollY - this.initialScrollOffset.y\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Mirror created handler\r\n   * @param {MirrorCreatedEvent} mirrorEvent\r\n   * @return {Promise}\r\n   * @private\r\n   */\r\n  [onMirrorCreated]({ mirror, source, sensorEvent }) {\r\n    const mirrorClasses = this.draggable.getClassNamesFor('mirror');\r\n\r\n    const setState = (_ref) => {\r\n      let { mirrorOffset, initialX, initialY } = _ref,\r\n          args = _objectWithoutProperties(_ref, ['mirrorOffset', 'initialX', 'initialY']);\r\n\r\n      this.mirrorOffset = mirrorOffset;\r\n      this.initialX = initialX;\r\n      this.initialY = initialY;\r\n      this.lastMovedX = initialX;\r\n      this.lastMovedY = initialY;\r\n      return _extends({ mirrorOffset, initialX, initialY }, args);\r\n    };\r\n\r\n    mirror.style.display = 'none';\r\n\r\n    const initialState = {\r\n      mirror,\r\n      source,\r\n      sensorEvent,\r\n      mirrorClasses,\r\n      scrollOffset: this.scrollOffset,\r\n      options: this.options,\r\n      passedThreshX: true,\r\n      passedThreshY: true\r\n    };\r\n\r\n    return Promise.resolve(initialState)\r\n    // Fix reflow here\r\n    .then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({ initial: true })).then(removeMirrorID).then(setState);\r\n  }\r\n\r\n  /**\r\n   * Mirror move handler\r\n   * @param {MirrorMoveEvent} mirrorEvent\r\n   * @return {Promise|null}\r\n   * @private\r\n   */\r\n  [onMirrorMove](mirrorEvent) {\r\n    if (mirrorEvent.canceled()) {\r\n      return null;\r\n    }\r\n\r\n    const setState = (_ref2) => {\r\n      let { lastMovedX, lastMovedY } = _ref2,\r\n          args = _objectWithoutProperties(_ref2, ['lastMovedX', 'lastMovedY']);\r\n\r\n      this.lastMovedX = lastMovedX;\r\n      this.lastMovedY = lastMovedY;\r\n\r\n      return _extends({ lastMovedX, lastMovedY }, args);\r\n    };\r\n\r\n    const initialState = {\r\n      mirror: mirrorEvent.mirror,\r\n      sensorEvent: mirrorEvent.sensorEvent,\r\n      mirrorOffset: this.mirrorOffset,\r\n      options: this.options,\r\n      initialX: this.initialX,\r\n      initialY: this.initialY,\r\n      scrollOffset: this.scrollOffset,\r\n      passedThreshX: mirrorEvent.passedThreshX,\r\n      passedThreshY: mirrorEvent.passedThreshY,\r\n      lastMovedX: this.lastMovedX,\r\n      lastMovedY: this.lastMovedY\r\n    };\r\n\r\n    return Promise.resolve(initialState).then(positionMirror({ raf: true })).then(setState);\r\n  }\r\n\r\n  /**\r\n   * Returns appendable container for mirror based on the appendTo option\r\n   * @private\r\n   * @param {Object} options\r\n   * @param {HTMLElement} options.source - Current source\r\n   * @return {HTMLElement}\r\n   */\r\n  [getAppendableContainer](source) {\r\n    const appendTo = this.options.appendTo;\r\n\r\n    if (typeof appendTo === 'string') {\r\n      return document.querySelector(appendTo);\r\n    } else if (appendTo instanceof HTMLElement) {\r\n      return appendTo;\r\n    } else if (typeof appendTo === 'function') {\r\n      return appendTo(source);\r\n    } else {\r\n      return source.parentNode;\r\n    }\r\n  }\r\n}\r\n\r\nexports.default = Mirror; /**\r\n                           * Computes mirror dimensions based on the source element\r\n                           * Adds sourceRect to state\r\n                           * @param {Object} state\r\n                           * @param {HTMLElement} state.source\r\n                           * @return {Promise}\r\n                           * @private\r\n                           */\r\n\r\nfunction computeMirrorDimensions(_ref3) {\r\n  let { source } = _ref3,\r\n      args = _objectWithoutProperties(_ref3, ['source']);\r\n\r\n  return withPromise(resolve => {\r\n    const sourceRect = source.getBoundingClientRect();\r\n    resolve(_extends({ source, sourceRect }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Calculates mirror offset\r\n * Adds mirrorOffset to state\r\n * @param {Object} state\r\n * @param {SensorEvent} state.sensorEvent\r\n * @param {DOMRect} state.sourceRect\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction calculateMirrorOffset(_ref4) {\r\n  let { sensorEvent, sourceRect, options } = _ref4,\r\n      args = _objectWithoutProperties(_ref4, ['sensorEvent', 'sourceRect', 'options']);\r\n\r\n  return withPromise(resolve => {\r\n    const top = options.cursorOffsetY === null ? sensorEvent.clientY - sourceRect.top : options.cursorOffsetY;\r\n    const left = options.cursorOffsetX === null ? sensorEvent.clientX - sourceRect.left : options.cursorOffsetX;\r\n\r\n    const mirrorOffset = { top, left };\r\n\r\n    resolve(_extends({ sensorEvent, sourceRect, mirrorOffset, options }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Applys mirror styles\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {HTMLElement} state.source\r\n * @param {Object} state.options\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction resetMirror(_ref5) {\r\n  let { mirror, source, options } = _ref5,\r\n      args = _objectWithoutProperties(_ref5, ['mirror', 'source', 'options']);\r\n\r\n  return withPromise(resolve => {\r\n    let offsetHeight;\r\n    let offsetWidth;\r\n\r\n    if (options.constrainDimensions) {\r\n      const computedSourceStyles = getComputedStyle(source);\r\n      offsetHeight = computedSourceStyles.getPropertyValue('height');\r\n      offsetWidth = computedSourceStyles.getPropertyValue('width');\r\n    }\r\n\r\n    mirror.style.display = null;\r\n    mirror.style.position = 'fixed';\r\n    mirror.style.pointerEvents = 'none';\r\n    mirror.style.top = 0;\r\n    mirror.style.left = 0;\r\n    mirror.style.margin = 0;\r\n\r\n    if (options.constrainDimensions) {\r\n      mirror.style.height = offsetHeight;\r\n      mirror.style.width = offsetWidth;\r\n    }\r\n\r\n    resolve(_extends({ mirror, source, options }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Applys mirror class on mirror element\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {String[]} state.mirrorClasses\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction addMirrorClasses(_ref6) {\r\n  let { mirror, mirrorClasses } = _ref6,\r\n      args = _objectWithoutProperties(_ref6, ['mirror', 'mirrorClasses']);\r\n\r\n  return withPromise(resolve => {\r\n    mirror.classList.add(...mirrorClasses);\r\n    resolve(_extends({ mirror, mirrorClasses }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Removes source ID from cloned mirror element\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction removeMirrorID(_ref7) {\r\n  let { mirror } = _ref7,\r\n      args = _objectWithoutProperties(_ref7, ['mirror']);\r\n\r\n  return withPromise(resolve => {\r\n    mirror.removeAttribute('id');\r\n    delete mirror.id;\r\n    resolve(_extends({ mirror }, args));\r\n  });\r\n}\r\n\r\n/**\r\n * Positions mirror with translate3d\r\n * @param {Object} state\r\n * @param {HTMLElement} state.mirror\r\n * @param {SensorEvent} state.sensorEvent\r\n * @param {Object} state.mirrorOffset\r\n * @param {Number} state.initialY\r\n * @param {Number} state.initialX\r\n * @param {Object} state.options\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction positionMirror({ withFrame = false, initial = false } = {}) {\r\n  return (_ref8) => {\r\n    let {\r\n      mirror,\r\n      sensorEvent,\r\n      mirrorOffset,\r\n      initialY,\r\n      initialX,\r\n      scrollOffset,\r\n      options,\r\n      passedThreshX,\r\n      passedThreshY,\r\n      lastMovedX,\r\n      lastMovedY\r\n    } = _ref8,\r\n        args = _objectWithoutProperties(_ref8, ['mirror', 'sensorEvent', 'mirrorOffset', 'initialY', 'initialX', 'scrollOffset', 'options', 'passedThreshX', 'passedThreshY', 'lastMovedX', 'lastMovedY']);\r\n\r\n    return withPromise(resolve => {\r\n      const result = _extends({\r\n        mirror,\r\n        sensorEvent,\r\n        mirrorOffset,\r\n        options\r\n      }, args);\r\n\r\n      if (mirrorOffset) {\r\n        const x = passedThreshX ? Math.round((sensorEvent.clientX - mirrorOffset.left - scrollOffset.x) / (options.thresholdX || 1)) * (options.thresholdX || 1) : Math.round(lastMovedX);\r\n        const y = passedThreshY ? Math.round((sensorEvent.clientY - mirrorOffset.top - scrollOffset.y) / (options.thresholdY || 1)) * (options.thresholdY || 1) : Math.round(lastMovedY);\r\n\r\n        if (options.xAxis && options.yAxis || initial) {\r\n          mirror.style.transform = `translate3d(${x}px, ${y}px, 0)`;\r\n        } else if (options.xAxis && !options.yAxis) {\r\n          mirror.style.transform = `translate3d(${x}px, ${initialY}px, 0)`;\r\n        } else if (options.yAxis && !options.xAxis) {\r\n          mirror.style.transform = `translate3d(${initialX}px, ${y}px, 0)`;\r\n        }\r\n\r\n        if (initial) {\r\n          result.initialX = x;\r\n          result.initialY = y;\r\n        }\r\n\r\n        result.lastMovedX = x;\r\n        result.lastMovedY = y;\r\n      }\r\n\r\n      resolve(result);\r\n    }, { frame: withFrame });\r\n  };\r\n}\r\n\r\n/**\r\n * Wraps functions in promise with potential animation frame option\r\n * @param {Function} callback\r\n * @param {Object} options\r\n * @param {Boolean} options.raf\r\n * @return {Promise}\r\n * @private\r\n */\r\nfunction withPromise(callback, { raf = false } = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    if (raf) {\r\n      requestAnimationFrame(() => {\r\n        callback(resolve, reject);\r\n      });\r\n    } else {\r\n      callback(resolve, reject);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Returns true if the sensor event was triggered by a native browser drag event\r\n * @param {SensorEvent} sensorEvent\r\n */\r\nfunction isNativeDragEvent(sensorEvent) {\r\n  return (/^drag/.test(sensorEvent.originalEvent.type)\r\n  );\r\n}\r\n\r\n/***/ }),\r\n/* 36 */\r\n/***/ (function(module, exports, __nested_webpack_require_111997__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Mirror = __nested_webpack_require_111997__(35);\r\n\r\nvar _Mirror2 = _interopRequireDefault(_Mirror);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Mirror2.default;\r\nexports.defaultOptions = _Mirror.defaultOptions;\r\n\r\n/***/ }),\r\n/* 37 */\r\n/***/ (function(module, exports, __nested_webpack_require_112484__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_112484__(4);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onInitialize = Symbol('onInitialize');\r\nconst onDestroy = Symbol('onDestroy');\r\n\r\n/**\r\n * Focusable default options\r\n * @property {Object} defaultOptions\r\n * @type {Object}\r\n */\r\nconst defaultOptions = {};\r\n\r\n/**\r\n * Focusable plugin\r\n * @class Focusable\r\n * @module Focusable\r\n * @extends AbstractPlugin\r\n */\r\nclass Focusable extends _AbstractPlugin2.default {\r\n  /**\r\n   * Focusable constructor.\r\n   * @constructs Focusable\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Focusable options\r\n     * @property {Object} options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    this[onInitialize] = this[onInitialize].bind(this);\r\n    this[onDestroy] = this[onDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches listeners to draggable\r\n   */\r\n  attach() {\r\n    this.draggable.on('draggable:initialize', this[onInitialize]).on('draggable:destroy', this[onDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Detaches listeners from draggable\r\n   */\r\n  detach() {\r\n    this.draggable.off('draggable:initialize', this[onInitialize]).off('draggable:destroy', this[onDestroy]);\r\n\r\n    // Remove modified elements when detach\r\n    this[onDestroy]();\r\n  }\r\n\r\n  /**\r\n   * Returns options passed through draggable\r\n   * @return {Object}\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.focusable || {};\r\n  }\r\n\r\n  /**\r\n   * Returns draggable containers and elements\r\n   * @return {HTMLElement[]}\r\n   */\r\n  getElements() {\r\n    return [...this.draggable.containers, ...this.draggable.getDraggableElements()];\r\n  }\r\n\r\n  /**\r\n   * Intialize handler\r\n   * @private\r\n   */\r\n  [onInitialize]() {\r\n    // Can wait until the next best frame is available\r\n    requestAnimationFrame(() => {\r\n      this.getElements().forEach(element => decorateElement(element));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Destroy handler\r\n   * @private\r\n   */\r\n  [onDestroy]() {\r\n    // Can wait until the next best frame is available\r\n    requestAnimationFrame(() => {\r\n      this.getElements().forEach(element => stripElement(element));\r\n    });\r\n  }\r\n}\r\n\r\nexports.default = Focusable; /**\r\n                              * Keeps track of all the elements that are missing tabindex attributes\r\n                              * so they can be reset when draggable gets destroyed\r\n                              * @const {HTMLElement[]} elementsWithMissingTabIndex\r\n                              */\r\n\r\nconst elementsWithMissingTabIndex = [];\r\n\r\n/**\r\n * Decorates element with tabindex attributes\r\n * @param {HTMLElement} element\r\n * @return {Object}\r\n * @private\r\n */\r\nfunction decorateElement(element) {\r\n  const hasMissingTabIndex = Boolean(!element.getAttribute('tabindex') && element.tabIndex === -1);\r\n\r\n  if (hasMissingTabIndex) {\r\n    elementsWithMissingTabIndex.push(element);\r\n    element.tabIndex = 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Removes elements tabindex attributes\r\n * @param {HTMLElement} element\r\n * @private\r\n */\r\nfunction stripElement(element) {\r\n  const tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);\r\n\r\n  if (tabIndexElementPosition !== -1) {\r\n    element.tabIndex = -1;\r\n    elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);\r\n  }\r\n}\r\n\r\n/***/ }),\r\n/* 38 */\r\n/***/ (function(module, exports, __nested_webpack_require_116396__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _Focusable = __nested_webpack_require_116396__(37);\r\n\r\nvar _Focusable2 = _interopRequireDefault(_Focusable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Focusable2.default;\r\n\r\n/***/ }),\r\n/* 39 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n/**\r\n * All draggable plugins inherit from this class.\r\n * @abstract\r\n * @class AbstractPlugin\r\n * @module AbstractPlugin\r\n */\r\nclass AbstractPlugin {\r\n  /**\r\n   * AbstractPlugin constructor.\r\n   * @constructs AbstractPlugin\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    /**\r\n     * Draggable instance\r\n     * @property draggable\r\n     * @type {Draggable}\r\n     */\r\n    this.draggable = draggable;\r\n  }\r\n\r\n  /**\r\n   * Override to add listeners\r\n   * @abstract\r\n   */\r\n  attach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n\r\n  /**\r\n   * Override to remove listeners\r\n   * @abstract\r\n   */\r\n  detach() {\r\n    throw new Error('Not Implemented');\r\n  }\r\n}\r\nexports.default = AbstractPlugin;\r\n\r\n/***/ }),\r\n/* 40 */\r\n/***/ (function(module, exports, __nested_webpack_require_117720__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _AbstractPlugin = __nested_webpack_require_117720__(4);\r\n\r\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onInitialize = Symbol('onInitialize');\r\nconst onDestroy = Symbol('onDestroy');\r\nconst announceEvent = Symbol('announceEvent');\r\nconst announceMessage = Symbol('announceMessage');\r\n\r\nconst ARIA_RELEVANT = 'aria-relevant';\r\nconst ARIA_ATOMIC = 'aria-atomic';\r\nconst ARIA_LIVE = 'aria-live';\r\nconst ROLE = 'role';\r\n\r\n/**\r\n * Announcement default options\r\n * @property {Object} defaultOptions\r\n * @property {Number} defaultOptions.expire\r\n * @type {Object}\r\n */\r\nconst defaultOptions = exports.defaultOptions = {\r\n  expire: 7000\r\n};\r\n\r\n/**\r\n * Announcement plugin\r\n * @class Announcement\r\n * @module Announcement\r\n * @extends AbstractPlugin\r\n */\r\nclass Announcement extends _AbstractPlugin2.default {\r\n  /**\r\n   * Announcement constructor.\r\n   * @constructs Announcement\r\n   * @param {Draggable} draggable - Draggable instance\r\n   */\r\n  constructor(draggable) {\r\n    super(draggable);\r\n\r\n    /**\r\n     * Plugin options\r\n     * @property options\r\n     * @type {Object}\r\n     */\r\n    this.options = _extends({}, defaultOptions, this.getOptions());\r\n\r\n    /**\r\n     * Original draggable trigger method. Hack until we have onAll or on('all')\r\n     * @property originalTriggerMethod\r\n     * @type {Function}\r\n     */\r\n    this.originalTriggerMethod = this.draggable.trigger;\r\n\r\n    this[onInitialize] = this[onInitialize].bind(this);\r\n    this[onDestroy] = this[onDestroy].bind(this);\r\n  }\r\n\r\n  /**\r\n   * Attaches listeners to draggable\r\n   */\r\n  attach() {\r\n    this.draggable.on('draggable:initialize', this[onInitialize]);\r\n  }\r\n\r\n  /**\r\n   * Detaches listeners from draggable\r\n   */\r\n  detach() {\r\n    this.draggable.off('draggable:destroy', this[onDestroy]);\r\n  }\r\n\r\n  /**\r\n   * Returns passed in options\r\n   */\r\n  getOptions() {\r\n    return this.draggable.options.announcements || {};\r\n  }\r\n\r\n  /**\r\n   * Announces event\r\n   * @private\r\n   * @param {AbstractEvent} event\r\n   */\r\n  [announceEvent](event) {\r\n    const message = this.options[event.type];\r\n\r\n    if (message && typeof message === 'string') {\r\n      this[announceMessage](message);\r\n    }\r\n\r\n    if (message && typeof message === 'function') {\r\n      this[announceMessage](message(event));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Announces message to screen reader\r\n   * @private\r\n   * @param {String} message\r\n   */\r\n  [announceMessage](message) {\r\n    announce(message, { expire: this.options.expire });\r\n  }\r\n\r\n  /**\r\n   * Initialize hander\r\n   * @private\r\n   */\r\n  [onInitialize]() {\r\n    // Hack until there is an api for listening for all events\r\n    this.draggable.trigger = event => {\r\n      try {\r\n        this[announceEvent](event);\r\n      } finally {\r\n        // Ensure that original trigger is called\r\n        this.originalTriggerMethod.call(this.draggable, event);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Destroy hander\r\n   * @private\r\n   */\r\n  [onDestroy]() {\r\n    this.draggable.trigger = this.originalTriggerMethod;\r\n  }\r\n}\r\n\r\nexports.default = Announcement; /**\r\n                                 * @const {HTMLElement} liveRegion\r\n                                 */\r\n\r\nconst liveRegion = createRegion();\r\n\r\n/**\r\n * Announces message via live region\r\n * @param {String} message\r\n * @param {Object} options\r\n * @param {Number} options.expire\r\n */\r\nfunction announce(message, { expire }) {\r\n  const element = document.createElement('div');\r\n\r\n  element.textContent = message;\r\n  liveRegion.appendChild(element);\r\n\r\n  return setTimeout(() => {\r\n    liveRegion.removeChild(element);\r\n  }, expire);\r\n}\r\n\r\n/**\r\n * Creates region element\r\n * @return {HTMLElement}\r\n */\r\nfunction createRegion() {\r\n  const element = document.createElement('div');\r\n\r\n  element.setAttribute('id', 'draggable-live-region');\r\n  element.setAttribute(ARIA_RELEVANT, 'additions');\r\n  element.setAttribute(ARIA_ATOMIC, 'true');\r\n  element.setAttribute(ARIA_LIVE, 'assertive');\r\n  element.setAttribute(ROLE, 'log');\r\n\r\n  element.style.position = 'fixed';\r\n  element.style.width = '1px';\r\n  element.style.height = '1px';\r\n  element.style.top = '-1px';\r\n  element.style.overflow = 'hidden';\r\n\r\n  return element;\r\n}\r\n\r\n// Append live region element as early as possible\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  document.body.appendChild(liveRegion);\r\n});\r\n\r\n/***/ }),\r\n/* 41 */\r\n/***/ (function(module, exports, __nested_webpack_require_122608__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultOptions = undefined;\r\n\r\nvar _Announcement = __nested_webpack_require_122608__(40);\r\n\r\nvar _Announcement2 = _interopRequireDefault(_Announcement);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Announcement2.default;\r\nexports.defaultOptions = _Announcement.defaultOptions;\r\n\r\n/***/ }),\r\n/* 42 */\r\n/***/ (function(module, exports, __nested_webpack_require_123125__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DraggableDestroyEvent = exports.DraggableInitializedEvent = exports.DraggableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_123125__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base draggable event\r\n * @class DraggableEvent\r\n * @module DraggableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DraggableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Draggable instance\r\n   * @property draggable\r\n   * @type {Draggable}\r\n   * @readonly\r\n   */\r\n  get draggable() {\r\n    return this.data.draggable;\r\n  }\r\n}\r\n\r\nexports.DraggableEvent = DraggableEvent; /**\r\n                                          * Draggable initialized event\r\n                                          * @class DraggableInitializedEvent\r\n                                          * @module DraggableInitializedEvent\r\n                                          * @extends DraggableEvent\r\n                                          */\r\n\r\nDraggableEvent.type = 'draggable';\r\nclass DraggableInitializedEvent extends DraggableEvent {}\r\n\r\nexports.DraggableInitializedEvent = DraggableInitializedEvent; /**\r\n                                                                * Draggable destory event\r\n                                                                * @class DraggableInitializedEvent\r\n                                                                * @module DraggableDestroyEvent\r\n                                                                * @extends DraggableDestroyEvent\r\n                                                                */\r\n\r\nDraggableInitializedEvent.type = 'draggable:initialize';\r\nclass DraggableDestroyEvent extends DraggableEvent {}\r\nexports.DraggableDestroyEvent = DraggableDestroyEvent;\r\nDraggableDestroyEvent.type = 'draggable:destroy';\r\n\r\n/***/ }),\r\n/* 43 */\r\n/***/ (function(module, exports, __nested_webpack_require_125189__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DragStoppedEvent = exports.DragStopEvent = exports.DragPressureEvent = exports.DragOutContainerEvent = exports.DragOverContainerEvent = exports.DragOutEvent = exports.DragOverEvent = exports.DragMoveEvent = exports.DragStartEvent = exports.DragEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_125189__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base drag event\r\n * @class DragEvent\r\n * @module DragEvent\r\n * @extends AbstractEvent\r\n */\r\nclass DragEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Draggables source element\r\n   * @property source\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get source() {\r\n    return this.data.source;\r\n  }\r\n\r\n  /**\r\n   * Draggables original source element\r\n   * @property originalSource\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get originalSource() {\r\n    return this.data.originalSource;\r\n  }\r\n\r\n  /**\r\n   * Draggables mirror element\r\n   * @property mirror\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get mirror() {\r\n    return this.data.mirror;\r\n  }\r\n\r\n  /**\r\n   * Draggables source container element\r\n   * @property sourceContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get sourceContainer() {\r\n    return this.data.sourceContainer;\r\n  }\r\n\r\n  /**\r\n   * Sensor event\r\n   * @property sensorEvent\r\n   * @type {SensorEvent}\r\n   * @readonly\r\n   */\r\n  get sensorEvent() {\r\n    return this.data.sensorEvent;\r\n  }\r\n\r\n  /**\r\n   * Original event that triggered sensor event\r\n   * @property originalEvent\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  get originalEvent() {\r\n    if (this.sensorEvent) {\r\n      return this.sensorEvent.originalEvent;\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexports.DragEvent = DragEvent; /**\r\n                                * Drag start event\r\n                                * @class DragStartEvent\r\n                                * @module DragStartEvent\r\n                                * @extends DragEvent\r\n                                */\r\n\r\nDragEvent.type = 'drag';\r\nclass DragStartEvent extends DragEvent {}\r\n\r\nexports.DragStartEvent = DragStartEvent; /**\r\n                                          * Drag move event\r\n                                          * @class DragMoveEvent\r\n                                          * @module DragMoveEvent\r\n                                          * @extends DragEvent\r\n                                          */\r\n\r\nDragStartEvent.type = 'drag:start';\r\nDragStartEvent.cancelable = true;\r\nclass DragMoveEvent extends DragEvent {}\r\n\r\nexports.DragMoveEvent = DragMoveEvent; /**\r\n                                        * Drag over event\r\n                                        * @class DragOverEvent\r\n                                        * @module DragOverEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragMoveEvent.type = 'drag:move';\r\nclass DragOverEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you are over\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n}\r\n\r\nexports.DragOverEvent = DragOverEvent; /**\r\n                                        * Drag out event\r\n                                        * @class DragOutEvent\r\n                                        * @module DragOutEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragOverEvent.type = 'drag:over';\r\nDragOverEvent.cancelable = true;\r\nclass DragOutEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n\r\n  /**\r\n   * Draggable element you left\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n}\r\n\r\nexports.DragOutEvent = DragOutEvent; /**\r\n                                      * Drag over container event\r\n                                      * @class DragOverContainerEvent\r\n                                      * @module DragOverContainerEvent\r\n                                      * @extends DragEvent\r\n                                      */\r\n\r\nDragOutEvent.type = 'drag:out';\r\nclass DragOverContainerEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.DragOverContainerEvent = DragOverContainerEvent; /**\r\n                                                          * Drag out container event\r\n                                                          * @class DragOutContainerEvent\r\n                                                          * @module DragOutContainerEvent\r\n                                                          * @extends DragEvent\r\n                                                          */\r\n\r\nDragOverContainerEvent.type = 'drag:over:container';\r\nclass DragOutContainerEvent extends DragEvent {\r\n\r\n  /**\r\n   * Draggable container you left\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.DragOutContainerEvent = DragOutContainerEvent; /**\r\n                                                        * Drag pressure event\r\n                                                        * @class DragPressureEvent\r\n                                                        * @module DragPressureEvent\r\n                                                        * @extends DragEvent\r\n                                                        */\r\n\r\nDragOutContainerEvent.type = 'drag:out:container';\r\nclass DragPressureEvent extends DragEvent {\r\n\r\n  /**\r\n   * Pressure applied on draggable element\r\n   * @property pressure\r\n   * @type {Number}\r\n   * @readonly\r\n   */\r\n  get pressure() {\r\n    return this.data.pressure;\r\n  }\r\n}\r\n\r\nexports.DragPressureEvent = DragPressureEvent; /**\r\n                                                * Drag stop event\r\n                                                * @class DragStopEvent\r\n                                                * @module DragStopEvent\r\n                                                * @extends DragEvent\r\n                                                */\r\n\r\nDragPressureEvent.type = 'drag:pressure';\r\nclass DragStopEvent extends DragEvent {}\r\n\r\nexports.DragStopEvent = DragStopEvent; /**\r\n                                        * Drag stopped event\r\n                                        * @class DragStoppedEvent\r\n                                        * @module DragStoppedEvent\r\n                                        * @extends DragEvent\r\n                                        */\r\n\r\nDragStopEvent.type = 'drag:stop';\r\nclass DragStoppedEvent extends DragEvent {}\r\nexports.DragStoppedEvent = DragStoppedEvent;\r\nDragStoppedEvent.type = 'drag:stopped';\r\n\r\n/***/ }),\r\n/* 44 */\r\n/***/ (function(module, exports, __nested_webpack_require_132714__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _DragEvent = __nested_webpack_require_132714__(8);\r\n\r\nObject.keys(_DragEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DragEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _DraggableEvent = __nested_webpack_require_132714__(7);\r\n\r\nObject.keys(_DraggableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _DraggableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Plugins = __nested_webpack_require_132714__(6);\r\n\r\nObject.keys(_Plugins).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _Plugins[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Sensors = __nested_webpack_require_132714__(5);\r\n\r\nObject.keys(_Sensors).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _Sensors[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Draggable = __nested_webpack_require_132714__(12);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Draggable2.default;\r\n\r\n/***/ }),\r\n/* 45 */\r\n/***/ (function(module, exports, __nested_webpack_require_134297__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _Draggable = __nested_webpack_require_134297__(44);\r\n\r\nvar _Draggable2 = _interopRequireDefault(_Draggable);\r\n\r\nvar _SwappableEvent = __nested_webpack_require_134297__(9);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst onDragStart = Symbol('onDragStart');\r\nconst onDragOver = Symbol('onDragOver');\r\nconst onDragStop = Symbol('onDragStop');\r\n\r\n/**\r\n * Returns an announcement message when the Draggable element is swapped with another draggable element\r\n * @param {SwappableSwappedEvent} swappableEvent\r\n * @return {String}\r\n */\r\nfunction onSwappableSwappedDefaultAnnouncement({ dragEvent, swappedElement }) {\r\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'swappable element';\r\n  const overText = swappedElement.textContent.trim() || swappedElement.id || 'swappable element';\r\n\r\n  return `Swapped ${sourceText} with ${overText}`;\r\n}\r\n\r\n/**\r\n * @const {Object} defaultAnnouncements\r\n * @const {Function} defaultAnnouncements['swappabled:swapped']\r\n */\r\nconst defaultAnnouncements = {\r\n  'swappabled:swapped': onSwappableSwappedDefaultAnnouncement\r\n};\r\n\r\n/**\r\n * Swappable is built on top of Draggable and allows swapping of draggable elements.\r\n * Order is irrelevant to Swappable.\r\n * @class Swappable\r\n * @module Swappable\r\n * @extends Draggable\r\n */\r\nclass Swappable extends _Draggable2.default {\r\n  /**\r\n   * Swappable constructor.\r\n   * @constructs Swappable\r\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Swappable containers\r\n   * @param {Object} options - Options for Swappable\r\n   */\r\n  constructor(containers = [], options = {}) {\r\n    super(containers, _extends({}, options, {\r\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {})\r\n    }));\r\n\r\n    /**\r\n     * Last draggable element that was dragged over\r\n     * @property lastOver\r\n     * @type {HTMLElement}\r\n     */\r\n    this.lastOver = null;\r\n\r\n    this[onDragStart] = this[onDragStart].bind(this);\r\n    this[onDragOver] = this[onDragOver].bind(this);\r\n    this[onDragStop] = this[onDragStop].bind(this);\r\n\r\n    this.on('drag:start', this[onDragStart]).on('drag:over', this[onDragOver]).on('drag:stop', this[onDragStop]);\r\n  }\r\n\r\n  /**\r\n   * Destroys Swappable instance.\r\n   */\r\n  destroy() {\r\n    super.destroy();\r\n\r\n    this.off('drag:start', this._onDragStart).off('drag:over', this._onDragOver).off('drag:stop', this._onDragStop);\r\n  }\r\n\r\n  /**\r\n   * Drag start handler\r\n   * @private\r\n   * @param {DragStartEvent} event - Drag start event\r\n   */\r\n  [onDragStart](event) {\r\n    const swappableStartEvent = new _SwappableEvent.SwappableStartEvent({\r\n      dragEvent: event\r\n    });\r\n\r\n    this.trigger(swappableStartEvent);\r\n\r\n    if (swappableStartEvent.canceled()) {\r\n      event.cancel();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drag over handler\r\n   * @private\r\n   * @param {DragOverEvent} event - Drag over event\r\n   */\r\n  [onDragOver](event) {\r\n    if (event.over === event.originalSource || event.over === event.source || event.canceled()) {\r\n      return;\r\n    }\r\n\r\n    const swappableSwapEvent = new _SwappableEvent.SwappableSwapEvent({\r\n      dragEvent: event,\r\n      over: event.over,\r\n      overContainer: event.overContainer\r\n    });\r\n\r\n    this.trigger(swappableSwapEvent);\r\n\r\n    if (swappableSwapEvent.canceled()) {\r\n      return;\r\n    }\r\n\r\n    // swap originally swapped element back\r\n    if (this.lastOver && this.lastOver !== event.over) {\r\n      swap(this.lastOver, event.source);\r\n    }\r\n\r\n    if (this.lastOver === event.over) {\r\n      this.lastOver = null;\r\n    } else {\r\n      this.lastOver = event.over;\r\n    }\r\n\r\n    swap(event.source, event.over);\r\n\r\n    const swappableSwappedEvent = new _SwappableEvent.SwappableSwappedEvent({\r\n      dragEvent: event,\r\n      swappedElement: event.over\r\n    });\r\n\r\n    this.trigger(swappableSwappedEvent);\r\n  }\r\n\r\n  /**\r\n   * Drag stop handler\r\n   * @private\r\n   * @param {DragStopEvent} event - Drag stop event\r\n   */\r\n  [onDragStop](event) {\r\n    const swappableStopEvent = new _SwappableEvent.SwappableStopEvent({\r\n      dragEvent: event\r\n    });\r\n\r\n    this.trigger(swappableStopEvent);\r\n    this.lastOver = null;\r\n  }\r\n}\r\n\r\nexports.default = Swappable;\r\nfunction withTempElement(callback) {\r\n  const tmpElement = document.createElement('div');\r\n  callback(tmpElement);\r\n  tmpElement.parentNode.removeChild(tmpElement);\r\n}\r\n\r\nfunction swap(source, over) {\r\n  const overParent = over.parentNode;\r\n  const sourceParent = source.parentNode;\r\n\r\n  withTempElement(tmpElement => {\r\n    sourceParent.insertBefore(tmpElement, source);\r\n    overParent.insertBefore(source, over);\r\n    sourceParent.insertBefore(over, tmpElement);\r\n  });\r\n}\r\n\r\n/***/ }),\r\n/* 46 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nconst canceled = Symbol('canceled');\r\n\r\n/**\r\n * All events fired by draggable inherit this class. You can call `cancel()` to\r\n * cancel a specific event or you can check if an event has been canceled by\r\n * calling `canceled()`.\r\n * @abstract\r\n * @class AbstractEvent\r\n * @module AbstractEvent\r\n */\r\nclass AbstractEvent {\r\n\r\n  /**\r\n   * AbstractEvent constructor.\r\n   * @constructs AbstractEvent\r\n   * @param {object} data - Event data\r\n   */\r\n\r\n  /**\r\n   * Event type\r\n   * @static\r\n   * @abstract\r\n   * @property type\r\n   * @type {String}\r\n   */\r\n  constructor(data) {\r\n    this[canceled] = false;\r\n    this.data = data;\r\n  }\r\n\r\n  /**\r\n   * Read-only type\r\n   * @abstract\r\n   * @return {String}\r\n   */\r\n\r\n\r\n  /**\r\n   * Event cancelable\r\n   * @static\r\n   * @abstract\r\n   * @property cancelable\r\n   * @type {Boolean}\r\n   */\r\n  get type() {\r\n    return this.constructor.type;\r\n  }\r\n\r\n  /**\r\n   * Read-only cancelable\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  get cancelable() {\r\n    return this.constructor.cancelable;\r\n  }\r\n\r\n  /**\r\n   * Cancels the event instance\r\n   * @abstract\r\n   */\r\n  cancel() {\r\n    this[canceled] = true;\r\n  }\r\n\r\n  /**\r\n   * Check if event has been canceled\r\n   * @abstract\r\n   * @return {Boolean}\r\n   */\r\n  canceled() {\r\n    return Boolean(this[canceled]);\r\n  }\r\n\r\n  /**\r\n   * Returns new event instance with existing event data.\r\n   * This method allows for overriding of event data.\r\n   * @param {Object} data\r\n   * @return {AbstractEvent}\r\n   */\r\n  clone(data) {\r\n    return new this.constructor(_extends({}, this.data, data));\r\n  }\r\n}\r\nexports.default = AbstractEvent;\r\nAbstractEvent.type = 'event';\r\nAbstractEvent.cancelable = false;\r\n\r\n/***/ }),\r\n/* 47 */\r\n/***/ (function(module, exports, __nested_webpack_require_141509__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.SwappableStopEvent = exports.SwappableSwappedEvent = exports.SwappableSwapEvent = exports.SwappableStartEvent = exports.SwappableEvent = undefined;\r\n\r\nvar _AbstractEvent = __nested_webpack_require_141509__(3);\r\n\r\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Base swappable event\r\n * @class SwappableEvent\r\n * @module SwappableEvent\r\n * @extends AbstractEvent\r\n */\r\nclass SwappableEvent extends _AbstractEvent2.default {\r\n\r\n  /**\r\n   * Original drag event that triggered this swappable event\r\n   * @property dragEvent\r\n   * @type {DragEvent}\r\n   * @readonly\r\n   */\r\n  get dragEvent() {\r\n    return this.data.dragEvent;\r\n  }\r\n}\r\n\r\nexports.SwappableEvent = SwappableEvent; /**\r\n                                          * Swappable start event\r\n                                          * @class SwappableStartEvent\r\n                                          * @module SwappableStartEvent\r\n                                          * @extends SwappableEvent\r\n                                          */\r\n\r\nSwappableEvent.type = 'swappable';\r\nclass SwappableStartEvent extends SwappableEvent {}\r\n\r\nexports.SwappableStartEvent = SwappableStartEvent; /**\r\n                                                    * Swappable swap event\r\n                                                    * @class SwappableSwapEvent\r\n                                                    * @module SwappableSwapEvent\r\n                                                    * @extends SwappableEvent\r\n                                                    */\r\n\r\nSwappableStartEvent.type = 'swappable:start';\r\nSwappableStartEvent.cancelable = true;\r\nclass SwappableSwapEvent extends SwappableEvent {\r\n\r\n  /**\r\n   * Draggable element you are over\r\n   * @property over\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get over() {\r\n    return this.data.over;\r\n  }\r\n\r\n  /**\r\n   * Draggable container you are over\r\n   * @property overContainer\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get overContainer() {\r\n    return this.data.overContainer;\r\n  }\r\n}\r\n\r\nexports.SwappableSwapEvent = SwappableSwapEvent; /**\r\n                                                  * Swappable swapped event\r\n                                                  * @class SwappableSwappedEvent\r\n                                                  * @module SwappableSwappedEvent\r\n                                                  * @extends SwappableEvent\r\n                                                  */\r\n\r\nSwappableSwapEvent.type = 'swappable:swap';\r\nSwappableSwapEvent.cancelable = true;\r\nclass SwappableSwappedEvent extends SwappableEvent {\r\n\r\n  /**\r\n   * The draggable element that you swapped with\r\n   * @property swappedElement\r\n   * @type {HTMLElement}\r\n   * @readonly\r\n   */\r\n  get swappedElement() {\r\n    return this.data.swappedElement;\r\n  }\r\n}\r\n\r\nexports.SwappableSwappedEvent = SwappableSwappedEvent; /**\r\n                                                        * Swappable stop event\r\n                                                        * @class SwappableStopEvent\r\n                                                        * @module SwappableStopEvent\r\n                                                        * @extends SwappableEvent\r\n                                                        */\r\n\r\nSwappableSwappedEvent.type = 'swappable:swapped';\r\nclass SwappableStopEvent extends SwappableEvent {}\r\nexports.SwappableStopEvent = SwappableStopEvent;\r\nSwappableStopEvent.type = 'swappable:stop';\r\n\r\n/***/ }),\r\n/* 48 */\r\n/***/ (function(module, exports, __nested_webpack_require_145262__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _SwappableEvent = __nested_webpack_require_145262__(9);\r\n\r\nObject.keys(_SwappableEvent).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function () {\r\n      return _SwappableEvent[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _Swappable = __nested_webpack_require_145262__(45);\r\n\r\nvar _Swappable2 = _interopRequireDefault(_Swappable);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nexports.default = _Swappable2.default;\r\n\r\n/***/ })\r\n/******/ ]);\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9zd2FwcGFibGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUswQjtBQUNoQyxDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw4QkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGVBQWUsOEJBQW1CO0FBQ2xDLG1EQUFtRCwrQkFBK0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLGlFQUFpRSxpQkFBaUI7QUFDbEY7QUFDQSwwREFBMEQsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGdDQUFnQyw4QkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBbUI7QUFDOUIsa0RBQWtELGdDQUFnQztBQUNsRiwwRUFBMEUsOEJBQW1CLDRCQUE0QixvQkFBb0I7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsMENBQTBDO0FBQzFDLFdBQVcsOEJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQW1CLENBQUMsOEJBQW1C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Q3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGNBQWMsZ0NBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBbUI7QUFDdEM7QUFDQSx1Q0FBdUMsdUNBQXVDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3QkFBd0IsZ0NBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLGVBQWU7QUFDakMsY0FBYztBQUNkO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCLGlDQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLGlCQUFpQixpQ0FBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9saWIvc3dhcHBhYmxlLmpzPzE5MDUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuXHRcdGRlZmluZShcIlN3YXBwYWJsZVwiLCBbXSwgZmFjdG9yeSk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcblx0XHRleHBvcnRzW1wiU3dhcHBhYmxlXCJdID0gZmFjdG9yeSgpO1xyXG5cdGVsc2VcclxuXHRcdHJvb3RbXCJTd2FwcGFibGVcIl0gPSBmYWN0b3J5KCk7XHJcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XHJcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXHJcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcclxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XHJcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcclxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcclxuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXHJcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxyXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxyXG4vKioqKioqLyBcdFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXHJcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxyXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG4vKioqKioqLyBcdH1cclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xyXG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XHJcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcclxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XHJcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xyXG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XHJcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcclxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA0OCk7XHJcbi8qKioqKiovIH0pXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKioqKiovIChbXHJcbi8qIDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcblxyXG5PYmplY3Qua2V5cyhfU2Vuc29yRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfU2Vuc29yRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcblxyXG52YXIgX1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9TZW5zb3IyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfY2xvc2VzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjbG9zZXN0Jywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xvc2VzdCkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX2Rpc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2Rpc3RhbmNlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzdGFuY2UpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfdG91Y2hDb29yZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndG91Y2hDb29yZHMnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b3VjaENvb3JkcykuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTZW5zb3InLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfTW91c2VTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTW91c2VTZW5zb3InLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Nb3VzZVNlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Ub3VjaFNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdUb3VjaFNlbnNvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RvdWNoU2Vuc29yKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX0RyYWdTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRHJhZ1NlbnNvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RyYWdTZW5zb3IpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfRm9yY2VUb3VjaFNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdGb3JjZVRvdWNoU2Vuc29yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRm9yY2VUb3VjaFNlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG5PYmplY3Qua2V5cyhfU2Vuc29yRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfU2Vuc29yRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fubm91bmNlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdBbm5vdW5jZW1lbnQnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Bbm5vdW5jZW1lbnQpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0QW5ub3VuY2VtZW50T3B0aW9ucycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9Bbm5vdW5jZW1lbnQuZGVmYXVsdE9wdGlvbnM7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfRm9jdXNhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0ZvY3VzYWJsZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZvY3VzYWJsZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9NaXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTWlycm9yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWlycm9yKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGVmYXVsdE1pcnJvck9wdGlvbnMnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfTWlycm9yLmRlZmF1bHRPcHRpb25zO1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1Njcm9sbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU2Nyb2xsYWJsZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Njcm9sbGFibGUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0U2Nyb2xsYWJsZU9wdGlvbnMnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfU2Nyb2xsYWJsZS5kZWZhdWx0T3B0aW9ucztcclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9EcmFnZ2FibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xyXG5cclxuT2JqZWN0LmtleXMoX0RyYWdnYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX0RyYWdnYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0RyYWdFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xyXG5cclxuT2JqZWN0LmtleXMoX0RyYWdFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9EcmFnRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU3dhcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcclxuXHJcbk9iamVjdC5rZXlzKF9Td2FwcGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9Td2FwcGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuLyoqXHJcbiAqIFRoZSBFbWl0dGVyIGlzIGEgc2ltcGxlIGVtaXR0ZXIgY2xhc3MgdGhhdCBwcm92aWRlcyB5b3Ugd2l0aCBgb24oKWAsIGBvZmYoKWAgYW5kIGB0cmlnZ2VyKClgIG1ldGhvZHNcclxuICogQGNsYXNzIEVtaXR0ZXJcclxuICogQG1vZHVsZSBFbWl0dGVyXHJcbiAqL1xyXG5jbGFzcyBFbWl0dGVyIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGJ5IGV2ZW50IG5hbWVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxyXG4gICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGNhbGxiYWNrc1xyXG4gICAqL1xyXG4gIG9uKHR5cGUsIC4uLmNhbGxiYWNrcykge1xyXG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1t0eXBlXSkge1xyXG4gICAgICB0aGlzLmNhbGxiYWNrc1t0eXBlXSA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdLnB1c2goLi4uY2FsbGJhY2tzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVucmVnaXN0ZXJzIGNhbGxiYWNrcyBieSBldmVudCBuYW1lXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIG9mZih0eXBlLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1t0eXBlXSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb3B5ID0gdGhpcy5jYWxsYmFja3NbdHlwZV0uc2xpY2UoMCk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3B5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChjYWxsYmFjayA9PT0gY29weVtpXSkge1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdLnNwbGljZShpLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlcnMgZXZlbnQgY2FsbGJhY2tzIGJ5IGV2ZW50IG9iamVjdFxyXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RFdmVudH0gZXZlbnRcclxuICAgKi9cclxuICB0cmlnZ2VyKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50LnR5cGVdKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNhbGxiYWNrcyA9IFsuLi50aGlzLmNhbGxiYWNrc1tldmVudC50eXBlXV07XHJcbiAgICBjb25zdCBjYXVnaHRFcnJvcnMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjYWxsYmFjayhldmVudCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY2F1Z2h0RXJyb3JzLnB1c2goZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNhdWdodEVycm9ycy5sZW5ndGgpIHtcclxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBEcmFnZ2FibGUgY2F1Z2h0IGVycm9ycyB3aGlsZSB0cmlnZ2VyaW5nICcke2V2ZW50LnR5cGV9J2AsIGNhdWdodEVycm9ycyk7XHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gRW1pdHRlcjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cclxudmFyIF9FbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VtaXR0ZXIpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9FbWl0dGVyMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxudmFyIF9QbHVnaW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcbnZhciBfRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5cclxudmFyIF9FbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VtaXR0ZXIpO1xyXG5cclxudmFyIF9TZW5zb3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcbnZhciBfRHJhZ2dhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5cclxudmFyIF9EcmFnRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdNb3ZlID0gU3ltYm9sKCdvbkRyYWdNb3ZlJyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3Qgb25EcmFnUHJlc3N1cmUgPSBTeW1ib2woJ29uRHJhZ1ByZXNzdXJlJyk7XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtPYmplY3R9IGRlZmF1bHRBbm5vdW5jZW1lbnRzXHJcbiAqIEBjb25zdCB7RnVuY3Rpb259IGRlZmF1bHRBbm5vdW5jZW1lbnRzWydkcmFnOnN0YXJ0J11cclxuICogQGNvbnN0IHtGdW5jdGlvbn0gZGVmYXVsdEFubm91bmNlbWVudHNbJ2RyYWc6c3RvcCddXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0QW5ub3VuY2VtZW50cyA9IHtcclxuICAnZHJhZzpzdGFydCc6IGV2ZW50ID0+IGBQaWNrZWQgdXAgJHtldmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGV2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnfWAsXHJcbiAgJ2RyYWc6c3RvcCc6IGV2ZW50ID0+IGBSZWxlYXNlZCAke2V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZXZlbnQuc291cmNlLmlkIHx8ICdkcmFnZ2FibGUgZWxlbWVudCd9YFxyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdENsYXNzZXMgPSB7XHJcbiAgJ2NvbnRhaW5lcjpkcmFnZ2luZyc6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1pcy1kcmFnZ2luZycsXHJcbiAgJ3NvdXJjZTpkcmFnZ2luZyc6ICdkcmFnZ2FibGUtc291cmNlLS1pcy1kcmFnZ2luZycsXHJcbiAgJ3NvdXJjZTpwbGFjZWQnOiAnZHJhZ2dhYmxlLXNvdXJjZS0tcGxhY2VkJyxcclxuICAnY29udGFpbmVyOnBsYWNlZCc6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1wbGFjZWQnLFxyXG4gICdib2R5OmRyYWdnaW5nJzogJ2RyYWdnYWJsZS0taXMtZHJhZ2dpbmcnLFxyXG4gICdkcmFnZ2FibGU6b3Zlcic6ICdkcmFnZ2FibGUtLW92ZXInLFxyXG4gICdjb250YWluZXI6b3Zlcic6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1vdmVyJyxcclxuICAnc291cmNlOm9yaWdpbmFsJzogJ2RyYWdnYWJsZS0tb3JpZ2luYWwnLFxyXG4gIG1pcnJvcjogJ2RyYWdnYWJsZS1taXJyb3InXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgZHJhZ2dhYmxlOiAnLmRyYWdnYWJsZS1zb3VyY2UnLFxyXG4gIGhhbmRsZTogbnVsbCxcclxuICBkZWxheToge30sXHJcbiAgZGlzdGFuY2U6IDAsXHJcbiAgcGxhY2VkVGltZW91dDogODAwLFxyXG4gIHBsdWdpbnM6IFtdLFxyXG4gIHNlbnNvcnM6IFtdLFxyXG4gIGV4Y2x1ZGU6IHtcclxuICAgIHBsdWdpbnM6IFtdLFxyXG4gICAgc2Vuc29yczogW11cclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB0aGUgY29yZSBkcmFnZ2FibGUgbGlicmFyeSB0aGF0IGRvZXMgdGhlIGhlYXZ5IGxpZnRpbmdcclxuICogQGNsYXNzIERyYWdnYWJsZVxyXG4gKiBAbW9kdWxlIERyYWdnYWJsZVxyXG4gKi9cclxuY2xhc3MgRHJhZ2dhYmxlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIERyYWdnYWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIERyYWdnYWJsZSBjb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciBkcmFnZ2FibGVcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogRGVmYXVsdCBwbHVnaW5zIGRyYWdnYWJsZSB1c2VzXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBQbHVnaW5zXHJcbiAgICogQHByb3BlcnR5IHtBbm5vdW5jZW1lbnR9IFBsdWdpbnMuQW5ub3VuY2VtZW50XHJcbiAgICogQHByb3BlcnR5IHtGb2N1c2FibGV9IFBsdWdpbnMuRm9jdXNhYmxlXHJcbiAgICogQHByb3BlcnR5IHtNaXJyb3J9IFBsdWdpbnMuTWlycm9yXHJcbiAgICogQHByb3BlcnR5IHtTY3JvbGxhYmxlfSBQbHVnaW5zLlNjcm9sbGFibGVcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbZG9jdW1lbnQuYm9keV0sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmFnZ2FibGUgY29udGFpbmVyc1xyXG4gICAgICogQHByb3BlcnR5IGNvbnRhaW5lcnNcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudFtdfVxyXG4gICAgICovXHJcbiAgICBpZiAoY29udGFpbmVycyBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGNvbnRhaW5lcnMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICB0aGlzLmNvbnRhaW5lcnMgPSBbLi4uY29udGFpbmVyc107XHJcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5lcnMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICB0aGlzLmNvbnRhaW5lcnMgPSBbY29udGFpbmVyc107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyYWdnYWJsZSBjb250YWluZXJzIGFyZSBleHBlY3RlZCB0byBiZSBvZiB0eXBlIGBOb2RlTGlzdGAsIGBIVE1MRWxlbWVudFtdYCBvciBgSFRNTEVsZW1lbnRgJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zLCB7XHJcbiAgICAgIGNsYXNzZXM6IF9leHRlbmRzKHt9LCBkZWZhdWx0Q2xhc3Nlcywgb3B0aW9ucy5jbGFzc2VzIHx8IHt9KSxcclxuICAgICAgYW5ub3VuY2VtZW50czogX2V4dGVuZHMoe30sIGRlZmF1bHRBbm5vdW5jZW1lbnRzLCBvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pLFxyXG4gICAgICBleGNsdWRlOiB7XHJcbiAgICAgICAgcGx1Z2luczogb3B0aW9ucy5leGNsdWRlICYmIG9wdGlvbnMuZXhjbHVkZS5wbHVnaW5zIHx8IFtdLFxyXG4gICAgICAgIHNlbnNvcnM6IG9wdGlvbnMuZXhjbHVkZSAmJiBvcHRpb25zLmV4Y2x1ZGUuc2Vuc29ycyB8fCBbXVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZXMgZXZlbnQgZW1pdHRlclxyXG4gICAgICogQHByb3BlcnR5IGVtaXR0ZXJcclxuICAgICAqIEB0eXBlIHtFbWl0dGVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgX0VtaXR0ZXIyLmRlZmF1bHQoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgZHJhZyBzdGF0ZVxyXG4gICAgICogQHByb3BlcnR5IGRyYWdnaW5nXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWN0aXZlIHBsdWdpbnNcclxuICAgICAqIEBwcm9wZXJ0eSBwbHVnaW5zXHJcbiAgICAgKiBAdHlwZSB7UGx1Z2luW119XHJcbiAgICAgKi9cclxuICAgIHRoaXMucGx1Z2lucyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWN0aXZlIHNlbnNvcnNcclxuICAgICAqIEBwcm9wZXJ0eSBzZW5zb3JzXHJcbiAgICAgKiBAdHlwZSB7U2Vuc29yW119XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2Vuc29ycyA9IFtdO1xyXG5cclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnTW92ZV0gPSB0aGlzW29uRHJhZ01vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdQcmVzc3VyZV0gPSB0aGlzW29uRHJhZ1ByZXNzdXJlXS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZzpwcmVzc3VyZScsIHRoaXNbb25EcmFnUHJlc3N1cmVdLCB0cnVlKTtcclxuXHJcbiAgICBjb25zdCBkZWZhdWx0UGx1Z2lucyA9IE9iamVjdC52YWx1ZXMoRHJhZ2dhYmxlLlBsdWdpbnMpLmZpbHRlcihQbHVnaW4gPT4gIXRoaXMub3B0aW9ucy5leGNsdWRlLnBsdWdpbnMuaW5jbHVkZXMoUGx1Z2luKSk7XHJcbiAgICBjb25zdCBkZWZhdWx0U2Vuc29ycyA9IE9iamVjdC52YWx1ZXMoRHJhZ2dhYmxlLlNlbnNvcnMpLmZpbHRlcihzZW5zb3IgPT4gIXRoaXMub3B0aW9ucy5leGNsdWRlLnNlbnNvcnMuaW5jbHVkZXMoc2Vuc29yKSk7XHJcblxyXG4gICAgdGhpcy5hZGRQbHVnaW4oLi4uWy4uLmRlZmF1bHRQbHVnaW5zLCAuLi50aGlzLm9wdGlvbnMucGx1Z2luc10pO1xyXG4gICAgdGhpcy5hZGRTZW5zb3IoLi4uWy4uLmRlZmF1bHRTZW5zb3JzLCAuLi50aGlzLm9wdGlvbnMuc2Vuc29yc10pO1xyXG5cclxuICAgIGNvbnN0IGRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQgPSBuZXcgX0RyYWdnYWJsZUV2ZW50LkRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQoe1xyXG4gICAgICBkcmFnZ2FibGU6IHRoaXNcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMub24oJ21pcnJvcjpjcmVhdGVkJywgKHsgbWlycm9yIH0pID0+IHRoaXMubWlycm9yID0gbWlycm9yKTtcclxuICAgIHRoaXMub24oJ21pcnJvcjpkZXN0cm95JywgKCkgPT4gdGhpcy5taXJyb3IgPSBudWxsKTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95cyBEcmFnZ2FibGUgaW5zdGFuY2UuIFRoaXMgcmVtb3ZlcyBhbGwgaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXJzIGFuZFxyXG4gICAqIGRlYWN0aXZhdGVzIHNlbnNvcnMgYW5kIHBsdWdpbnNcclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmF1bHQgc2Vuc29ycyBkcmFnZ2FibGUgdXNlc1xyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcHJvcGVydHkge09iamVjdH0gU2Vuc29yc1xyXG4gICAqIEBwcm9wZXJ0eSB7TW91c2VTZW5zb3J9IFNlbnNvcnMuTW91c2VTZW5zb3JcclxuICAgKiBAcHJvcGVydHkge1RvdWNoU2Vuc29yfSBTZW5zb3JzLlRvdWNoU2Vuc29yXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnOnByZXNzdXJlJywgdGhpc1tvbkRyYWdQcmVzc3VyZV0sIHRydWUpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdnYWJsZURlc3Ryb3lFdmVudCA9IG5ldyBfRHJhZ2dhYmxlRXZlbnQuRHJhZ2dhYmxlRGVzdHJveUV2ZW50KHtcclxuICAgICAgZHJhZ2dhYmxlOiB0aGlzXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ2dhYmxlRGVzdHJveUV2ZW50KTtcclxuXHJcbiAgICB0aGlzLnJlbW92ZVBsdWdpbiguLi50aGlzLnBsdWdpbnMubWFwKHBsdWdpbiA9PiBwbHVnaW4uY29uc3RydWN0b3IpKTtcclxuICAgIHRoaXMucmVtb3ZlU2Vuc29yKC4uLnRoaXMuc2Vuc29ycy5tYXAoc2Vuc29yID0+IHNlbnNvci5jb25zdHJ1Y3RvcikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBwbHVnaW4gdG8gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2UuIFRoaXMgd2lsbCBlbmQgdXAgY2FsbGluZyB0aGUgYXR0YWNoIG1ldGhvZCBvZiB0aGUgcGx1Z2luXHJcbiAgICogQHBhcmFtIHsuLi50eXBlb2YgUGx1Z2lufSBwbHVnaW5zIC0gUGx1Z2lucyB0aGF0IHlvdSB3YW50IGF0dGFjaGVkIHRvIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUuYWRkUGx1Z2luKEN1c3RvbUExMXlQbHVnaW4sIEN1c3RvbU1pcnJvclBsdWdpbilcclxuICAgKi9cclxuICBhZGRQbHVnaW4oLi4ucGx1Z2lucykge1xyXG4gICAgY29uc3QgYWN0aXZlUGx1Z2lucyA9IHBsdWdpbnMubWFwKFBsdWdpbiA9PiBuZXcgUGx1Z2luKHRoaXMpKTtcclxuXHJcbiAgICBhY3RpdmVQbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHBsdWdpbi5hdHRhY2goKSk7XHJcbiAgICB0aGlzLnBsdWdpbnMgPSBbLi4udGhpcy5wbHVnaW5zLCAuLi5hY3RpdmVQbHVnaW5zXTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgcGx1Z2lucyB0aGF0IGFyZSBhbHJlYWR5IGF0dGFjaGVkIHRvIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlLiBUaGlzIHdpbGwgZW5kIHVwIGNhbGxpbmdcclxuICAgKiB0aGUgZGV0YWNoIG1ldGhvZCBvZiB0aGUgcGx1Z2luXHJcbiAgICogQHBhcmFtIHsuLi50eXBlb2YgUGx1Z2lufSBwbHVnaW5zIC0gUGx1Z2lucyB0aGF0IHlvdSB3YW50IGRldGFjaGVkIGZyb20gZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5yZW1vdmVQbHVnaW4oTWlycm9yUGx1Z2luLCBDdXN0b21NaXJyb3JQbHVnaW4pXHJcbiAgICovXHJcbiAgcmVtb3ZlUGx1Z2luKC4uLnBsdWdpbnMpIHtcclxuICAgIGNvbnN0IHJlbW92ZWRQbHVnaW5zID0gdGhpcy5wbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gcGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4uY29uc3RydWN0b3IpKTtcclxuXHJcbiAgICByZW1vdmVkUGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiBwbHVnaW4uZGV0YWNoKCkpO1xyXG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gIXBsdWdpbnMuaW5jbHVkZXMocGx1Z2luLmNvbnN0cnVjdG9yKSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIHNlbnNvcnMgdG8gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2UuIFRoaXMgd2lsbCBlbmQgdXAgY2FsbGluZyB0aGUgYXR0YWNoIG1ldGhvZCBvZiB0aGUgc2Vuc29yXHJcbiAgICogQHBhcmFtIHsuLi50eXBlb2YgU2Vuc29yfSBzZW5zb3JzIC0gU2Vuc29ycyB0aGF0IHlvdSB3YW50IGF0dGFjaGVkIHRvIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUuYWRkU2Vuc29yKEZvcmNlVG91Y2hTZW5zb3IsIEN1c3RvbVNlbnNvcilcclxuICAgKi9cclxuICBhZGRTZW5zb3IoLi4uc2Vuc29ycykge1xyXG4gICAgY29uc3QgYWN0aXZlU2Vuc29ycyA9IHNlbnNvcnMubWFwKFNlbnNvciA9PiBuZXcgU2Vuc29yKHRoaXMuY29udGFpbmVycywgdGhpcy5vcHRpb25zKSk7XHJcblxyXG4gICAgYWN0aXZlU2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IuYXR0YWNoKCkpO1xyXG4gICAgdGhpcy5zZW5zb3JzID0gWy4uLnRoaXMuc2Vuc29ycywgLi4uYWN0aXZlU2Vuc29yc107XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIHNlbnNvcnMgdGhhdCBhcmUgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZS4gVGhpcyB3aWxsIGVuZCB1cCBjYWxsaW5nXHJcbiAgICogdGhlIGRldGFjaCBtZXRob2Qgb2YgdGhlIHNlbnNvclxyXG4gICAqIEBwYXJhbSB7Li4udHlwZW9mIFNlbnNvcn0gc2Vuc29ycyAtIFNlbnNvcnMgdGhhdCB5b3Ugd2FudCBhdHRhY2hlZCB0byBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLnJlbW92ZVNlbnNvcihUb3VjaFNlbnNvciwgRHJhZ1NlbnNvcilcclxuICAgKi9cclxuICByZW1vdmVTZW5zb3IoLi4uc2Vuc29ycykge1xyXG4gICAgY29uc3QgcmVtb3ZlZFNlbnNvcnMgPSB0aGlzLnNlbnNvcnMuZmlsdGVyKHNlbnNvciA9PiBzZW5zb3JzLmluY2x1ZGVzKHNlbnNvci5jb25zdHJ1Y3RvcikpO1xyXG5cclxuICAgIHJlbW92ZWRTZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5kZXRhY2goKSk7XHJcbiAgICB0aGlzLnNlbnNvcnMgPSB0aGlzLnNlbnNvcnMuZmlsdGVyKHNlbnNvciA9PiAhc2Vuc29ycy5pbmNsdWRlcyhzZW5zb3IuY29uc3RydWN0b3IpKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgY29udGFpbmVyIHRvIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICogQHBhcmFtIHsuLi5IVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnMgeW91IHdhbnQgdG8gYWRkIHRvIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUuYWRkQ29udGFpbmVyKGRvY3VtZW50LmJvZHkpXHJcbiAgICovXHJcbiAgYWRkQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcclxuICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi50aGlzLmNvbnRhaW5lcnMsIC4uLmNvbnRhaW5lcnNdO1xyXG4gICAgdGhpcy5zZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5hZGRDb250YWluZXIoLi4uY29udGFpbmVycykpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGNvbnRhaW5lciBmcm9tIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICogQHBhcmFtIHsuLi5IVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnMgeW91IHdhbnQgdG8gcmVtb3ZlIGZyb20gZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5yZW1vdmVDb250YWluZXIoZG9jdW1lbnQuYm9keSlcclxuICAgKi9cclxuICByZW1vdmVDb250YWluZXIoLi4uY29udGFpbmVycykge1xyXG4gICAgdGhpcy5jb250YWluZXJzID0gdGhpcy5jb250YWluZXJzLmZpbHRlcihjb250YWluZXIgPT4gIWNvbnRhaW5lcnMuaW5jbHVkZXMoY29udGFpbmVyKSk7XHJcbiAgICB0aGlzLnNlbnNvcnMuZm9yRWFjaChzZW5zb3IgPT4gc2Vuc29yLnJlbW92ZUNvbnRhaW5lciguLi5jb250YWluZXJzKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgbGlzdGVuZXIgZm9yIGRyYWdnYWJsZSBldmVudHNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIEV2ZW50IG5hbWVcclxuICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBjYWxsYmFja3MgLSBFdmVudCBjYWxsYmFja3NcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLm9uKCdkcmFnOnN0YXJ0JywgKGRyYWdFdmVudCkgPT4gZHJhZ0V2ZW50LmNhbmNlbCgpKTtcclxuICAgKi9cclxuICBvbih0eXBlLCAuLi5jYWxsYmFja3MpIHtcclxuICAgIHRoaXMuZW1pdHRlci5vbih0eXBlLCAuLi5jYWxsYmFja3MpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGxpc3RlbmVyIGZyb20gZHJhZ2dhYmxlXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBFdmVudCBuYW1lXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBFdmVudCBjYWxsYmFja1xyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUub2ZmKCdkcmFnOnN0YXJ0JywgaGFuZGxlckZ1bmN0aW9uKTtcclxuICAgKi9cclxuICBvZmYodHlwZSwgY2FsbGJhY2spIHtcclxuICAgIHRoaXMuZW1pdHRlci5vZmYodHlwZSwgY2FsbGJhY2spO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmlnZ2VycyBkcmFnZ2FibGUgZXZlbnRcclxuICAgKiBAcGFyYW0ge0Fic3RyYWN0RXZlbnR9IGV2ZW50IC0gRXZlbnQgaW5zdGFuY2VcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLnRyaWdnZXIoZXZlbnQpO1xyXG4gICAqL1xyXG4gIHRyaWdnZXIoZXZlbnQpIHtcclxuICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKGV2ZW50KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjbGFzcyBuYW1lIGZvciBjbGFzcyBpZGVudGlmaWVyXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIGNsYXNzIGlkZW50aWZpZXJcclxuICAgKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cclxuICAgKi9cclxuICBnZXRDbGFzc05hbWVGb3IobmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcihuYW1lKVswXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY2xhc3MgbmFtZXMgZm9yIGNsYXNzIGlkZW50aWZpZXJcclxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cclxuICAgKi9cclxuICBnZXRDbGFzc05hbWVzRm9yKG5hbWUpIHtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSB0aGlzLm9wdGlvbnMuY2xhc3Nlc1tuYW1lXTtcclxuXHJcbiAgICBpZiAoY2xhc3NOYW1lcyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ3N0cmluZycgfHwgY2xhc3NOYW1lcyBpbnN0YW5jZW9mIFN0cmluZykge1xyXG4gICAgICByZXR1cm4gW2NsYXNzTmFtZXNdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlIGlzIGN1cnJlbnRseSBkcmFnZ2luZ1xyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaXNEcmFnZ2luZygpIHtcclxuICAgIHJldHVybiBCb29sZWFuKHRoaXMuZHJhZ2dpbmcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbGwgZHJhZ2dhYmxlIGVsZW1lbnRzXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnRbXX1cclxuICAgKi9cclxuICBnZXREcmFnZ2FibGVFbGVtZW50cygpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcnMucmVkdWNlKChjdXJyZW50LCBjb250YWluZXIpID0+IHtcclxuICAgICAgcmV0dXJuIFsuLi5jdXJyZW50LCAuLi50aGlzLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKGNvbnRhaW5lcildO1xyXG4gICAgfSwgW10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBkcmFnZ2FibGUgZWxlbWVudHMgZm9yIGEgZ2l2ZW4gY29udGFpbmVyLCBleGNsdWRpbmcgdGhlIG1pcnJvciBhbmRcclxuICAgKiBvcmlnaW5hbCBzb3VyY2UgZWxlbWVudCBpZiBwcmVzZW50XHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnRbXX1cclxuICAgKi9cclxuICBnZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihjb250YWluZXIpIHtcclxuICAgIGNvbnN0IGFsbERyYWdnYWJsZUVsZW1lbnRzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XHJcblxyXG4gICAgcmV0dXJuIFsuLi5hbGxEcmFnZ2FibGVFbGVtZW50c10uZmlsdGVyKGNoaWxkRWxlbWVudCA9PiB7XHJcbiAgICAgIHJldHVybiBjaGlsZEVsZW1lbnQgIT09IHRoaXMub3JpZ2luYWxTb3VyY2UgJiYgY2hpbGRFbGVtZW50ICE9PSB0aGlzLm1pcnJvcjtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdGFydCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERPTSBEcmFnIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xyXG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XHJcbiAgICBjb25zdCB7IHRhcmdldCwgY29udGFpbmVyIH0gPSBzZW5zb3JFdmVudDtcclxuXHJcbiAgICBpZiAoIXRoaXMuY29udGFpbmVycy5pbmNsdWRlcyhjb250YWluZXIpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmhhbmRsZSAmJiB0YXJnZXQgJiYgISgwLCBfdXRpbHMuY2xvc2VzdCkodGFyZ2V0LCB0aGlzLm9wdGlvbnMuaGFuZGxlKSkge1xyXG4gICAgICBzZW5zb3JFdmVudC5jYW5jZWwoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbmQgZHJhZ2dhYmxlIHNvdXJjZSBlbGVtZW50XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlID0gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xyXG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIgPSBjb250YWluZXI7XHJcblxyXG4gICAgaWYgKCF0aGlzLm9yaWdpbmFsU291cmNlKSB7XHJcbiAgICAgIHNlbnNvckV2ZW50LmNhbmNlbCgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubGFzdFBsYWNlZFNvdXJjZSAmJiB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGxhY2VkVGltZW91dElEKTtcclxuICAgICAgdGhpcy5sYXN0UGxhY2VkU291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xyXG4gICAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpwbGFjZWQnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zb3VyY2UgPSB0aGlzLm9yaWdpbmFsU291cmNlLmNsb25lTm9kZSh0cnVlKTtcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5zb3VyY2UsIHRoaXMub3JpZ2luYWxTb3VyY2UpO1xyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuICAgIGNvbnN0IGRyYWdFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdTdGFydEV2ZW50KHtcclxuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdFdmVudCk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2luZyA9ICFkcmFnRXZlbnQuY2FuY2VsZWQoKTtcclxuXHJcbiAgICBpZiAoZHJhZ0V2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgdGhpcy5zb3VyY2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNvdXJjZSk7XHJcbiAgICAgIHRoaXMub3JpZ2luYWxTb3VyY2Uuc3R5bGUuZGlzcGxheSA9IG51bGw7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6b3JpZ2luYWwnKSk7XHJcbiAgICB0aGlzLnNvdXJjZS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOmRyYWdnaW5nJykpO1xyXG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpkcmFnZ2luZycpKTtcclxuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2JvZHk6ZHJhZ2dpbmcnKSk7XHJcbiAgICBhcHBseVVzZXJTZWxlY3QoZG9jdW1lbnQuYm9keSwgJ25vbmUnKTtcclxuXHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICBjb25zdCBvbGRTZW5zb3JFdmVudCA9IGdldFNlbnNvckV2ZW50KGV2ZW50KTtcclxuICAgICAgY29uc3QgbmV3U2Vuc29yRXZlbnQgPSBvbGRTZW5zb3JFdmVudC5jbG9uZSh7IHRhcmdldDogdGhpcy5zb3VyY2UgfSk7XHJcblxyXG4gICAgICB0aGlzW29uRHJhZ01vdmVdKF9leHRlbmRzKHt9LCBldmVudCwge1xyXG4gICAgICAgIGRldGFpbDogbmV3U2Vuc29yRXZlbnRcclxuICAgICAgfSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG1vdmUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBET00gRHJhZyBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdNb3ZlXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZW5zb3JFdmVudCA9IGdldFNlbnNvckV2ZW50KGV2ZW50KTtcclxuICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSBzZW5zb3JFdmVudDtcclxuICAgIGxldCB0YXJnZXQgPSBzZW5zb3JFdmVudC50YXJnZXQ7XHJcblxyXG4gICAgY29uc3QgZHJhZ01vdmVFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdNb3ZlRXZlbnQoe1xyXG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ01vdmVFdmVudCk7XHJcblxyXG4gICAgaWYgKGRyYWdNb3ZlRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICBzZW5zb3JFdmVudC5jYW5jZWwoKTtcclxuICAgIH1cclxuXHJcbiAgICB0YXJnZXQgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XHJcbiAgICBjb25zdCB3aXRoaW5Db3JyZWN0Q29udGFpbmVyID0gKDAsIF91dGlscy5jbG9zZXN0KShzZW5zb3JFdmVudC50YXJnZXQsIHRoaXMuY29udGFpbmVycyk7XHJcbiAgICBjb25zdCBvdmVyQ29udGFpbmVyID0gc2Vuc29yRXZlbnQub3ZlckNvbnRhaW5lciB8fCB3aXRoaW5Db3JyZWN0Q29udGFpbmVyO1xyXG4gICAgY29uc3QgaXNMZWF2aW5nQ29udGFpbmVyID0gdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciAmJiBvdmVyQ29udGFpbmVyICE9PSB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyO1xyXG4gICAgY29uc3QgaXNMZWF2aW5nRHJhZ2dhYmxlID0gdGhpcy5jdXJyZW50T3ZlciAmJiB0YXJnZXQgIT09IHRoaXMuY3VycmVudE92ZXI7XHJcbiAgICBjb25zdCBpc092ZXJDb250YWluZXIgPSBvdmVyQ29udGFpbmVyICYmIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgIT09IG92ZXJDb250YWluZXI7XHJcbiAgICBjb25zdCBpc092ZXJEcmFnZ2FibGUgPSB3aXRoaW5Db3JyZWN0Q29udGFpbmVyICYmIHRhcmdldCAmJiB0aGlzLmN1cnJlbnRPdmVyICE9PSB0YXJnZXQ7XHJcblxyXG4gICAgaWYgKGlzTGVhdmluZ0RyYWdnYWJsZSkge1xyXG4gICAgICBjb25zdCBkcmFnT3V0RXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnT3V0RXZlbnQoe1xyXG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgICAgb3ZlcjogdGhpcy5jdXJyZW50T3ZlcixcclxuICAgICAgICBvdmVyQ29udGFpbmVyOiB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5jdXJyZW50T3Zlci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJhZ2dhYmxlOm92ZXInKSk7XHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXIgPSBudWxsO1xyXG5cclxuICAgICAgdGhpcy50cmlnZ2VyKGRyYWdPdXRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzTGVhdmluZ0NvbnRhaW5lcikge1xyXG4gICAgICBjb25zdCBkcmFnT3V0Q29udGFpbmVyRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnT3V0Q29udGFpbmVyRXZlbnQoe1xyXG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgICAgb3ZlckNvbnRhaW5lcjogdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lclxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpvdmVyJykpO1xyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyID0gbnVsbDtcclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3V0Q29udGFpbmVyRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc092ZXJDb250YWluZXIpIHtcclxuICAgICAgb3ZlckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOm92ZXInKSk7XHJcblxyXG4gICAgICBjb25zdCBkcmFnT3ZlckNvbnRhaW5lckV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ092ZXJDb250YWluZXJFdmVudCh7XHJcbiAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcclxuICAgICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgICBvdmVyQ29udGFpbmVyXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciA9IG92ZXJDb250YWluZXI7XHJcblxyXG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ092ZXJDb250YWluZXJFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzT3ZlckRyYWdnYWJsZSkge1xyXG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2RyYWdnYWJsZTpvdmVyJykpO1xyXG5cclxuICAgICAgY29uc3QgZHJhZ092ZXJFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdPdmVyRXZlbnQoe1xyXG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgICAgb3ZlckNvbnRhaW5lcixcclxuICAgICAgICBvdmVyOiB0YXJnZXRcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyID0gdGFyZ2V0O1xyXG5cclxuICAgICAgdGhpcy50cmlnZ2VyKGRyYWdPdmVyRXZlbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdG9wIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRE9NIERyYWcgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RvcF0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnU3RvcEV2ZW50KHtcclxuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNlbnNvckV2ZW50OiBldmVudC5zZW5zb3JFdmVudCxcclxuICAgICAgc291cmNlQ29udGFpbmVyOiB0aGlzLnNvdXJjZUNvbnRhaW5lclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdTdG9wRXZlbnQpO1xyXG5cclxuICAgIHRoaXMuc291cmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMub3JpZ2luYWxTb3VyY2UsIHRoaXMuc291cmNlKTtcclxuICAgIHRoaXMuc291cmNlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zb3VyY2UpO1xyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcblxyXG4gICAgdGhpcy5zb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpkcmFnZ2luZycpKTtcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpvcmlnaW5hbCcpKTtcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XHJcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOnBsYWNlZCcpKTtcclxuICAgIHRoaXMuc291cmNlQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6ZHJhZ2dpbmcnKSk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdib2R5OmRyYWdnaW5nJykpO1xyXG4gICAgYXBwbHlVc2VyU2VsZWN0KGRvY3VtZW50LmJvZHksICcnKTtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50T3Zlcikge1xyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcmFnZ2FibGU6b3ZlcicpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lcikge1xyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6b3ZlcicpKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxhc3RQbGFjZWRTb3VyY2UgPSB0aGlzLm9yaWdpbmFsU291cmNlO1xyXG4gICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyID0gdGhpcy5zb3VyY2VDb250YWluZXI7XHJcblxyXG4gICAgdGhpcy5wbGFjZWRUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKHRoaXMubGFzdFBsYWNlZFNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMubGFzdFBsYWNlZENvbnRhaW5lcikge1xyXG4gICAgICAgIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOnBsYWNlZCcpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5sYXN0UGxhY2VkU291cmNlID0gbnVsbDtcclxuICAgICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyID0gbnVsbDtcclxuICAgIH0sIHRoaXMub3B0aW9ucy5wbGFjZWRUaW1lb3V0KTtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RvcHBlZEV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ1N0b3BwZWRFdmVudCh7XHJcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzZW5zb3JFdmVudDogZXZlbnQuc2Vuc29yRXZlbnQsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogdGhpcy5zb3VyY2VDb250YWluZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnU3RvcHBlZEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlID0gbnVsbDtcclxuICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgPSBudWxsO1xyXG4gICAgdGhpcy5jdXJyZW50T3ZlciA9IG51bGw7XHJcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHByZXNzdXJlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRE9NIERyYWcgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnUHJlc3N1cmVdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xyXG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2UgfHwgKDAsIF91dGlscy5jbG9zZXN0KShzZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50LnRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ1ByZXNzdXJlRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnUHJlc3N1cmVFdmVudCh7XHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIHByZXNzdXJlOiBzZW5zb3JFdmVudC5wcmVzc3VyZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdQcmVzc3VyZUV2ZW50KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IERyYWdnYWJsZTtcclxuRHJhZ2dhYmxlLlBsdWdpbnMgPSB7IEFubm91bmNlbWVudDogX1BsdWdpbnMuQW5ub3VuY2VtZW50LCBGb2N1c2FibGU6IF9QbHVnaW5zLkZvY3VzYWJsZSwgTWlycm9yOiBfUGx1Z2lucy5NaXJyb3IsIFNjcm9sbGFibGU6IF9QbHVnaW5zLlNjcm9sbGFibGUgfTtcclxuRHJhZ2dhYmxlLlNlbnNvcnMgPSB7IE1vdXNlU2Vuc29yOiBfU2Vuc29ycy5Nb3VzZVNlbnNvciwgVG91Y2hTZW5zb3I6IF9TZW5zb3JzLlRvdWNoU2Vuc29yIH07XHJcbmZ1bmN0aW9uIGdldFNlbnNvckV2ZW50KGV2ZW50KSB7XHJcbiAgcmV0dXJuIGV2ZW50LmRldGFpbDtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlVc2VyU2VsZWN0KGVsZW1lbnQsIHZhbHVlKSB7XHJcbiAgZWxlbWVudC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gdmFsdWU7XHJcbiAgZWxlbWVudC5zdHlsZS5tb3pVc2VyU2VsZWN0ID0gdmFsdWU7XHJcbiAgZWxlbWVudC5zdHlsZS5tc1VzZXJTZWxlY3QgPSB2YWx1ZTtcclxuICBlbGVtZW50LnN0eWxlLm9Vc2VyU2VsZWN0ID0gdmFsdWU7XHJcbiAgZWxlbWVudC5zdHlsZS51c2VyU2VsZWN0ID0gdmFsdWU7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbnZhciBfU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcik7XHJcblxyXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbk1vdXNlRm9yY2VXaWxsQmVnaW4gPSBTeW1ib2woJ29uTW91c2VGb3JjZVdpbGxCZWdpbicpO1xyXG5jb25zdCBvbk1vdXNlRm9yY2VEb3duID0gU3ltYm9sKCdvbk1vdXNlRm9yY2VEb3duJyk7XHJcbmNvbnN0IG9uTW91c2VEb3duID0gU3ltYm9sKCdvbk1vdXNlRG93bicpO1xyXG5jb25zdCBvbk1vdXNlRm9yY2VDaGFuZ2UgPSBTeW1ib2woJ29uTW91c2VGb3JjZUNoYW5nZScpO1xyXG5jb25zdCBvbk1vdXNlTW92ZSA9IFN5bWJvbCgnb25Nb3VzZU1vdmUnKTtcclxuY29uc3Qgb25Nb3VzZVVwID0gU3ltYm9sKCdvbk1vdXNlVXAnKTtcclxuY29uc3Qgb25Nb3VzZUZvcmNlR2xvYmFsQ2hhbmdlID0gU3ltYm9sKCdvbk1vdXNlRm9yY2VHbG9iYWxDaGFuZ2UnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHNlbnNvciBwaWNrcyB1cCBuYXRpdmUgZm9yY2UgdG91Y2ggZXZlbnRzIGFuZCBkaWN0YXRlcyBkcmFnIG9wZXJhdGlvbnNcclxuICogQGNsYXNzIEZvcmNlVG91Y2hTZW5zb3JcclxuICogQG1vZHVsZSBGb3JjZVRvdWNoU2Vuc29yXHJcbiAqIEBleHRlbmRzIFNlbnNvclxyXG4gKi9cclxuY2xhc3MgRm9yY2VUb3VjaFNlbnNvciBleHRlbmRzIF9TZW5zb3IyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIEZvcmNlVG91Y2hTZW5zb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgRm9yY2VUb3VjaFNlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmFnZ2FibGUgZWxlbWVudCBuZWVkcyB0byBiZSByZW1lbWJlcmVkIHRvIHVuc2V0IHRoZSBkcmFnZ2FibGUgYXR0cmlidXRlIGFmdGVyIGRyYWcgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWRcclxuICAgICAqIEBwcm9wZXJ0eSBtaWdodERyYWdcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXNbb25Nb3VzZUZvcmNlV2lsbEJlZ2luXSA9IHRoaXNbb25Nb3VzZUZvcmNlV2lsbEJlZ2luXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlRm9yY2VEb3duXSA9IHRoaXNbb25Nb3VzZUZvcmNlRG93bl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Nb3VzZURvd25dID0gdGhpc1tvbk1vdXNlRG93bl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Nb3VzZUZvcmNlQ2hhbmdlXSA9IHRoaXNbb25Nb3VzZUZvcmNlQ2hhbmdlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlTW92ZV0gPSB0aGlzW29uTW91c2VNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlVXBdID0gdGhpc1tvbk1vdXNlVXBdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgdGhpcy5jb250YWluZXJzKSB7XHJcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luJywgdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dLCBmYWxzZSk7XHJcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNlZG93bicsIHRoaXNbb25Nb3VzZUZvcmNlRG93bl0sIGZhbHNlKTtcclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2VjaGFuZ2VkJywgdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgdGhpcy5jb250YWluZXJzKSB7XHJcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luJywgdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dLCBmYWxzZSk7XHJcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNlZG93bicsIHRoaXNbb25Nb3VzZUZvcmNlRG93bl0sIGZhbHNlKTtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2VjaGFuZ2VkJywgdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBmb3JjZSB3aWxsIGJlZ2luIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2Ugd2lsbCBiZWdpbiBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRm9yY2VXaWxsQmVnaW5dKGV2ZW50KSB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgdGhpcy5taWdodERyYWcgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZm9yY2UgZG93biBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGZvcmNlIGRvd24gZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZUZvcmNlRG93bl0oZXZlbnQpIHtcclxuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gZXZlbnQuY3VycmVudFRhcmdldDtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCk7XHJcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgdXAgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlVXBdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdG9wU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQ6IG51bGwsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMubWlnaHREcmFnID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBkb3duIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZG93biBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRG93bl0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5taWdodERyYWcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5lZWQgd29ya2Fyb3VuZCBmb3IgcmVhbCBjbGlja1xyXG4gICAgLy8gQ2FuY2VsIHBvdGVudGlhbCBkcmFnIGV2ZW50c1xyXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2Ugd2lsbCBiZWdpbiBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlTW92ZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuXHJcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnTW92ZVNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZm9yY2UgY2hhbmdlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2UgY2hhbmdlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VGb3JjZUNoYW5nZV0oZXZlbnQpIHtcclxuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xyXG5cclxuICAgIGNvbnN0IGRyYWdQcmVzc3VyZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnUHJlc3N1cmVTZW5zb3JFdmVudCh7XHJcbiAgICAgIHByZXNzdXJlOiBldmVudC53ZWJraXRGb3JjZSxcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnUHJlc3N1cmVFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBmb3JjZSBnbG9iYWwgY2hhbmdlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2UgZ2xvYmFsIGNoYW5nZSBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRm9yY2VHbG9iYWxDaGFuZ2VdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuXHJcbiAgICBjb25zdCBkcmFnUHJlc3N1cmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQoe1xyXG4gICAgICBwcmVzc3VyZTogZXZlbnQud2Via2l0Rm9yY2UsXHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnUHJlc3N1cmVFdmVudCk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEZvcmNlVG91Y2hTZW5zb3I7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0ZvcmNlVG91Y2hTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHJcbnZhciBfRm9yY2VUb3VjaFNlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Gb3JjZVRvdWNoU2Vuc29yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfRm9yY2VUb3VjaFNlbnNvcjIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uTW91c2VEb3duID0gU3ltYm9sKCdvbk1vdXNlRG93bicpO1xyXG5jb25zdCBvbk1vdXNlVXAgPSBTeW1ib2woJ29uTW91c2VVcCcpO1xyXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcclxuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xyXG5jb25zdCBvbkRyYWdFbmQgPSBTeW1ib2woJ29uRHJhZ0VuZCcpO1xyXG5jb25zdCBvbkRyb3AgPSBTeW1ib2woJ29uRHJvcCcpO1xyXG5jb25zdCByZXNldCA9IFN5bWJvbCgncmVzZXQnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHNlbnNvciBwaWNrcyB1cCBuYXRpdmUgYnJvd3NlciBkcmFnIGV2ZW50cyBhbmQgZGljdGF0ZXMgZHJhZyBvcGVyYXRpb25zXHJcbiAqIEBjbGFzcyBEcmFnU2Vuc29yXHJcbiAqIEBtb2R1bGUgRHJhZ1NlbnNvclxyXG4gKiBAZXh0ZW5kcyBTZW5zb3JcclxuICovXHJcbmNsYXNzIERyYWdTZW5zb3IgZXh0ZW5kcyBfU2Vuc29yMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBEcmFnU2Vuc29yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIERyYWdTZW5zb3JcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lcnMsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgZG93biB0aW1lciB3aGljaCB3aWxsIGVuZCB1cCBzZXR0aW5nIHRoZSBkcmFnZ2FibGUgYXR0cmlidXRlLCB1bmxlc3MgY2FuY2VsZWRcclxuICAgICAqIEBwcm9wZXJ0eSBtb3VzZURvd25UaW1lb3V0XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhZ2dhYmxlIGVsZW1lbnQgbmVlZHMgdG8gYmUgcmVtZW1iZXJlZCB0byB1bnNldCB0aGUgZHJhZ2dhYmxlIGF0dHJpYnV0ZSBhZnRlciBkcmFnIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkXHJcbiAgICAgKiBAcHJvcGVydHkgZHJhZ2dhYmxlRWxlbWVudFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYWdnYWJsZUVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTmF0aXZlIGRyYWdnYWJsZSBlbGVtZW50IGNvdWxkIGJlIGxpbmtzIG9yIGltYWdlcywgdGhlaXIgZHJhZ2dhYmxlIHN0YXRlIHdpbGwgYmUgZGlzYWJsZWQgZHVyaW5nIGRyYWcgb3BlcmF0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkgbmF0aXZlRHJhZ2dhYmxlRWxlbWVudFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25Nb3VzZURvd25dID0gdGhpc1tvbk1vdXNlRG93bl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Nb3VzZVVwXSA9IHRoaXNbb25Nb3VzZVVwXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnRW5kXSA9IHRoaXNbb25EcmFnRW5kXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyb3BdID0gdGhpc1tvbkRyb3BdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBEcmFnIHN0YXJ0IGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xyXG4gICAgLy8gTmVlZCBmb3IgZmlyZWZveC4gXCJ0ZXh0XCIga2V5IGlzIG5lZWRlZCBmb3IgSUVcclxuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKCd0ZXh0JywgJycpO1xyXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSB0aGlzLm9wdGlvbnMudHlwZTtcclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC50YXJnZXQsIHRoaXMuY29udGFpbmVycyk7XHJcblxyXG4gICAgaWYgKCF0aGlzLmN1cnJlbnRDb250YWluZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RhcnRTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBXb3JrYXJvdW5kXHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0YXJ0RXZlbnQpO1xyXG5cclxuICAgICAgaWYgKGRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0sIDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBvdmVyIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRHJhZyBvdmVyIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ092ZXJdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XHJcblxyXG4gICAgY29uc3QgZHJhZ01vdmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ01vdmVTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGNvbnRhaW5lciwgZHJhZ01vdmVFdmVudCk7XHJcblxyXG4gICAgaWYgKCFkcmFnTW92ZUV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSB0aGlzLm9wdGlvbnMudHlwZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgZW5kIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRHJhZyBlbmQgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnRW5kXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdLCB0cnVlKTtcclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jdXJyZW50Q29udGFpbmVyO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdG9wU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdTdG9wRXZlbnQpO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tyZXNldF0oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyb3AgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBEcm9wIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJvcF0oZXZlbnQpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGRvd24gaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBkb3duIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VEb3duXShldmVudCkge1xyXG4gICAgLy8gRmlyZWZveCBidWcgZm9yIGlucHV0cyB3aXRoaW4gZHJhZ2dhYmxlcyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03MzkwNzFcclxuICAgIGlmIChldmVudC50YXJnZXQgJiYgKGV2ZW50LnRhcmdldC5mb3JtIHx8IGV2ZW50LnRhcmdldC5jb250ZW50ZWRpdGFibGUpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC50YXJnZXQsIGVsZW1lbnQgPT4gZWxlbWVudC5kcmFnZ2FibGUpO1xyXG5cclxuICAgIGlmIChuYXRpdmVEcmFnZ2FibGVFbGVtZW50KSB7XHJcbiAgICAgIG5hdGl2ZURyYWdnYWJsZUVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9IG5hdGl2ZURyYWdnYWJsZUVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzW29uRHJhZ092ZXJdLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpc1tvbkRyYWdFbmRdLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpc1tvbkRyb3BdLCBmYWxzZSk7XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xyXG5cclxuICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBldmVudDtcclxuXHJcbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGFyZ2V0LmRyYWdnYWJsZSA9IHRydWU7XHJcbiAgICAgIHRoaXMuZHJhZ2dhYmxlRWxlbWVudCA9IHRhcmdldDtcclxuICAgIH0sIHRoaXMuZGVsYXkuZHJhZyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSB1cCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIHVwIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VVcF0oKSB7XHJcbiAgICB0aGlzW3Jlc2V0XSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgdXAgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxyXG4gICAqL1xyXG4gIFtyZXNldF0oKSB7XHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy5tb3VzZURvd25UaW1lb3V0KTtcclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0sIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCB0aGlzW29uRHJhZ0VuZF0sIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzW29uRHJvcF0sIGZhbHNlKTtcclxuXHJcbiAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50KSB7XHJcbiAgICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudC5kcmFnZ2FibGUgPSB0cnVlO1xyXG4gICAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmRyYWdnYWJsZUVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmRyYWdnYWJsZUVsZW1lbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnU2Vuc29yO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9EcmFnU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcblxyXG52YXIgX0RyYWdTZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ1NlbnNvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0RyYWdTZW5zb3IyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcbnZhciBfU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbnZhciBfU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcik7XHJcblxyXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvblRvdWNoU3RhcnQgPSBTeW1ib2woJ29uVG91Y2hTdGFydCcpO1xyXG5jb25zdCBvblRvdWNoRW5kID0gU3ltYm9sKCdvblRvdWNoRW5kJyk7XHJcbmNvbnN0IG9uVG91Y2hNb3ZlID0gU3ltYm9sKCdvblRvdWNoTW92ZScpO1xyXG5jb25zdCBzdGFydERyYWcgPSBTeW1ib2woJ3N0YXJ0RHJhZycpO1xyXG5jb25zdCBvbkRpc3RhbmNlQ2hhbmdlID0gU3ltYm9sKCdvbkRpc3RhbmNlQ2hhbmdlJyk7XHJcblxyXG4vKipcclxuICogUHJldmVudHMgc2Nyb2xsaW5nIHdoZW4gc2V0IHRvIHRydWVcclxuICogQHZhciB7Qm9vbGVhbn0gcHJldmVudFNjcm9sbGluZ1xyXG4gKi9cclxubGV0IHByZXZlbnRTY3JvbGxpbmcgPSBmYWxzZTtcclxuXHJcbi8vIFdlYktpdCByZXF1aXJlcyBjYW5jZWxhYmxlIGB0b3VjaG1vdmVgIGV2ZW50cyB0byBiZSBhZGRlZCBhcyBlYXJseSBhcyBwb3NzaWJsZVxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZXZlbnQgPT4ge1xyXG4gIGlmICghcHJldmVudFNjcm9sbGluZykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gUHJldmVudCBzY3JvbGxpbmdcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG59LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgc2Vuc29yIHBpY2tzIHVwIG5hdGl2ZSBicm93c2VyIHRvdWNoIGV2ZW50cyBhbmQgZGljdGF0ZXMgZHJhZyBvcGVyYXRpb25zXHJcbiAqIEBjbGFzcyBUb3VjaFNlbnNvclxyXG4gKiBAbW9kdWxlIFRvdWNoU2Vuc29yXHJcbiAqIEBleHRlbmRzIFNlbnNvclxyXG4gKi9cclxuY2xhc3MgVG91Y2hTZW5zb3IgZXh0ZW5kcyBfU2Vuc29yMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBUb3VjaFNlbnNvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBUb3VjaFNlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXN0IHNjcm9sbGFibGUgY29udGFpbmVyIHNvIGFjY2lkZW50YWwgc2Nyb2xsIGNhbiBjYW5jZWwgbG9uZyB0b3VjaFxyXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRTY3JvbGxhYmxlUGFyZW50XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudFNjcm9sbGFibGVQYXJlbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGltZW91dElEIGZvciBtYW5hZ2luZyBkZWxheVxyXG4gICAgICogQHByb3BlcnR5IHRhcFRpbWVvdXRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudGFwVGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0b3VjaE1vdmVkIGluZGljYXRlcyBpZiB0b3VjaCBoYXMgbW92ZWQgZHVyaW5nIHRhcFRpbWVvdXRcclxuICAgICAqIEBwcm9wZXJ0eSB0b3VjaE1vdmVkXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy50b3VjaE1vdmVkID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTYXZlIHBhZ2VYIGNvb3JkaW5hdGVzIGZvciBkZWxheSBkcmFnXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJyZX0gcGFnZVhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFnZVggPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2F2ZSBwYWdlWSBjb29yZGluYXRlcyBmb3IgZGVsYXkgZHJhZ1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1icmV9IHBhZ2VZXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBhZ2VZID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uVG91Y2hTdGFydF0gPSB0aGlzW29uVG91Y2hTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Ub3VjaEVuZF0gPSB0aGlzW29uVG91Y2hFbmRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uVG91Y2hNb3ZlXSA9IHRoaXNbb25Ub3VjaE1vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW3N0YXJ0RHJhZ10gPSB0aGlzW3N0YXJ0RHJhZ10uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0gPSB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXNbb25Ub3VjaFN0YXJ0XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXNbb25Ub3VjaFN0YXJ0XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUb3VjaCBzdGFydCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRvdWNoIHN0YXJ0IGV2ZW50XHJcbiAgICovXHJcbiAgW29uVG91Y2hTdGFydF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xyXG5cclxuICAgIGlmICghY29udGFpbmVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgZGlzdGFuY2UgPSAwIH0gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCB7IGRlbGF5IH0gPSB0aGlzO1xyXG4gICAgY29uc3QgeyBwYWdlWCwgcGFnZVkgfSA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKGV2ZW50KTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgcGFnZVgsIHBhZ2VZIH0pO1xyXG4gICAgdGhpcy5vblRvdWNoU3RhcnRBdCA9IERhdGUubm93KCk7XHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBldmVudDtcclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzW29uVG91Y2hFbmRdKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSk7XHJcblxyXG4gICAgaWYgKGRpc3RhbmNlKSB7XHJcbiAgICAgIHByZXZlbnRTY3JvbGxpbmcgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudGFwVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSh7IHRvdWNoZXM6IFt7IHBhZ2VYOiB0aGlzLnBhZ2VYLCBwYWdlWTogdGhpcy5wYWdlWSB9XSB9KTtcclxuICAgIH0sIGRlbGF5LnRvdWNoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IHRoZSBkcmFnXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbc3RhcnREcmFnXSgpIHtcclxuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSB0aGlzLnN0YXJ0RXZlbnQ7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XHJcbiAgICBjb25zdCB0b3VjaCA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKHN0YXJ0RXZlbnQpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RhcnRTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IHRvdWNoLnBhZ2VYLFxyXG4gICAgICBjbGllbnRZOiB0b3VjaC5wYWdlWSxcclxuICAgICAgdGFyZ2V0OiBzdGFydEV2ZW50LnRhcmdldCxcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBzdGFydEV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2luZyA9ICFkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpO1xyXG5cclxuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25Ub3VjaE1vdmVdKTtcclxuICAgIH1cclxuICAgIHByZXZlbnRTY3JvbGxpbmcgPSB0aGlzLmRyYWdnaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVG91Y2ggbW92ZSBoYW5kbGVyIHByaW9yIHRvIGRyYWcgc3RhcnQuXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRvdWNoIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25EaXN0YW5jZUNoYW5nZV0oZXZlbnQpIHtcclxuICAgIGNvbnN0IHsgZGlzdGFuY2UgfSA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IHsgc3RhcnRFdmVudCwgZGVsYXkgfSA9IHRoaXM7XHJcbiAgICBjb25zdCBzdGFydCA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKHN0YXJ0RXZlbnQpO1xyXG4gICAgY29uc3QgY3VycmVudCA9ICgwLCBfdXRpbHMudG91Y2hDb29yZHMpKGV2ZW50KTtcclxuICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gRGF0ZS5ub3coKSAtIHRoaXMub25Ub3VjaFN0YXJ0QXQ7XHJcbiAgICBjb25zdCBkaXN0YW5jZVRyYXZlbGxlZCA9ICgwLCBfdXRpbHMuZGlzdGFuY2UpKHN0YXJ0LnBhZ2VYLCBzdGFydC5wYWdlWSwgY3VycmVudC5wYWdlWCwgY3VycmVudC5wYWdlWSk7XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjdXJyZW50KTtcclxuXHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy50YXBUaW1lb3V0KTtcclxuXHJcbiAgICBpZiAodGltZUVsYXBzZWQgPCBkZWxheS50b3VjaCkge1xyXG4gICAgICAvLyBtb3ZlZCBkdXJpbmcgZGVsYXlcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlVHJhdmVsbGVkID49IGRpc3RhbmNlKSB7XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG4gICAgICB0aGlzW3N0YXJ0RHJhZ10oKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIG1vdmUgaGFuZGxlciB3aGlsZSBkcmFnZ2luZ1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUb3VjaCBtb3ZlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uVG91Y2hNb3ZlXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgcGFnZVgsIHBhZ2VZIH0gPSAoMCwgX3V0aWxzLnRvdWNoQ29vcmRzKShldmVudCk7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHBhZ2VYIC0gd2luZG93LnNjcm9sbFgsIHBhZ2VZIC0gd2luZG93LnNjcm9sbFkpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdNb3ZlU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBwYWdlWCxcclxuICAgICAgY2xpZW50WTogcGFnZVksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRvdWNoIGVuZCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRvdWNoIGVuZCBldmVudFxyXG4gICAqL1xyXG4gIFtvblRvdWNoRW5kXShldmVudCkge1xyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGFwVGltZW91dCk7XHJcbiAgICBwcmV2ZW50U2Nyb2xsaW5nID0gZmFsc2U7XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzW29uVG91Y2hFbmRdKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpc1tvblRvdWNoRW5kXSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50Q29udGFpbmVyKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudENvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvblRvdWNoTW92ZV0pO1xyXG5cclxuICAgIGNvbnN0IHsgcGFnZVgsIHBhZ2VZIH0gPSAoMCwgX3V0aWxzLnRvdWNoQ29vcmRzKShldmVudCk7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHBhZ2VYIC0gd2luZG93LnNjcm9sbFgsIHBhZ2VZIC0gd2luZG93LnNjcm9sbFkpO1xyXG5cclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0b3BTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IHBhZ2VYLFxyXG4gICAgICBjbGllbnRZOiBwYWdlWSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdG9wRXZlbnQpO1xyXG5cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IG51bGw7XHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gVG91Y2hTZW5zb3I7XHJcbmZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1RvdWNoU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcblxyXG52YXIgX1RvdWNoU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RvdWNoU2Vuc29yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfVG91Y2hTZW5zb3IyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdTdG9wU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdNb3ZlU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdTdGFydFNlbnNvckV2ZW50ID0gZXhwb3J0cy5TZW5zb3JFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2Ugc2Vuc29yIGV2ZW50XHJcbiAqIEBjbGFzcyBTZW5zb3JFdmVudFxyXG4gKiBAbW9kdWxlIFNlbnNvckV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIFNlbnNvckV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIE9yaWdpbmFsIGJyb3dzZXIgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgYSBzZW5zb3JcclxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxFdmVudFxyXG4gICAqIEB0eXBlIHtFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3JpZ2luYWxFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxFdmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZWQgY2xpZW50WCBmb3IgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzXHJcbiAgICogQHByb3BlcnR5IGNsaWVudFhcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjbGllbnRYKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jbGllbnRYO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplZCBjbGllbnRZIGZvciBib3RoIHRvdWNoIGFuZCBtb3VzZSBldmVudHNcclxuICAgKiBAcHJvcGVydHkgY2xpZW50WVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGNsaWVudFkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNsaWVudFk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOb3JtYWxpemVkIHRhcmdldCBmb3IgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzXHJcbiAgICogUmV0dXJucyB0aGUgZWxlbWVudCB0aGF0IGlzIGJlaGluZCBjdXJzb3Igb3IgdG91Y2ggcG9pbnRlclxyXG4gICAqIEBwcm9wZXJ0eSB0YXJnZXRcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHRhcmdldCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEudGFyZ2V0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udGFpbmVyIHRoYXQgaW5pdGlhdGVkIHRoZSBzZW5zb3JcclxuICAgKiBAcHJvcGVydHkgY29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYWNrcGFkIHByZXNzdXJlXHJcbiAgICogQHByb3BlcnR5IHByZXNzdXJlXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcHJlc3N1cmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnByZXNzdXJlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5TZW5zb3JFdmVudCA9IFNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHN0YXJ0IHNlbnNvciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RhcnRTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1N0YXJ0U2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuY2xhc3MgRHJhZ1N0YXJ0U2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5EcmFnU3RhcnRTZW5zb3JFdmVudCA9IERyYWdTdGFydFNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG1vdmUgc2Vuc29yIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdNb3ZlU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdNb3ZlU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQudHlwZSA9ICdkcmFnOnN0YXJ0JztcclxuY2xhc3MgRHJhZ01vdmVTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdNb3ZlU2Vuc29yRXZlbnQgPSBEcmFnTW92ZVNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdG9wIHNlbnNvciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1N0b3BTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdTdG9wU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnTW92ZVNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzptb3ZlJztcclxuY2xhc3MgRHJhZ1N0b3BTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdTdG9wU2Vuc29yRXZlbnQgPSBEcmFnU3RvcFNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBwcmVzc3VyZSBzZW5zb3IgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdQcmVzc3VyZVNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnU3RvcFNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzpzdG9wJztcclxuY2xhc3MgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxyXG5leHBvcnRzLkRyYWdQcmVzc3VyZVNlbnNvckV2ZW50ID0gRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQ7XHJcbkRyYWdQcmVzc3VyZVNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzpwcmVzc3VyZSc7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcbnZhciBfU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbnZhciBfU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcik7XHJcblxyXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZyA9IFN5bWJvbCgnb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmcnKTtcclxuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XHJcbmNvbnN0IG9uTW91c2VNb3ZlID0gU3ltYm9sKCdvbk1vdXNlTW92ZScpO1xyXG5jb25zdCBvbk1vdXNlVXAgPSBTeW1ib2woJ29uTW91c2VVcCcpO1xyXG5jb25zdCBzdGFydERyYWcgPSBTeW1ib2woJ3N0YXJ0RHJhZycpO1xyXG5jb25zdCBvbkRpc3RhbmNlQ2hhbmdlID0gU3ltYm9sKCdvbkRpc3RhbmNlQ2hhbmdlJyk7XHJcblxyXG4vKipcclxuICogVGhpcyBzZW5zb3IgcGlja3MgdXAgbmF0aXZlIGJyb3dzZXIgbW91c2UgZXZlbnRzIGFuZCBkaWN0YXRlcyBkcmFnIG9wZXJhdGlvbnNcclxuICogQGNsYXNzIE1vdXNlU2Vuc29yXHJcbiAqIEBtb2R1bGUgTW91c2VTZW5zb3JcclxuICogQGV4dGVuZHMgU2Vuc29yXHJcbiAqL1xyXG5jbGFzcyBNb3VzZVNlbnNvciBleHRlbmRzIF9TZW5zb3IyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIE1vdXNlU2Vuc29yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIE1vdXNlU2Vuc29yXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGRvd24gdGltZXIgd2hpY2ggd2lsbCBlbmQgdXAgdHJpZ2dlcmluZyB0aGUgZHJhZyBzdGFydCBvcGVyYXRpb25cclxuICAgICAqIEBwcm9wZXJ0eSBtb3VzZURvd25UaW1lb3V0XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2F2ZSBwYWdlWCBjb29yZGluYXRlcyBmb3IgZGVsYXkgZHJhZ1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1icmV9IHBhZ2VYXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBhZ2VYID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNhdmUgcGFnZVkgY29vcmRpbmF0ZXMgZm9yIGRlbGF5IGRyYWdcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYnJlfSBwYWdlWVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5wYWdlWSA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10gPSB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlRG93bl0gPSB0aGlzW29uTW91c2VEb3duXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlTW92ZV0gPSB0aGlzW29uTW91c2VNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlVXBdID0gdGhpc1tvbk1vdXNlVXBdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW3N0YXJ0RHJhZ10gPSB0aGlzW3N0YXJ0RHJhZ10uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0gPSB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGRvd24gaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBkb3duIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VEb3duXShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29udGFpbmVyID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC50YXJnZXQsIHRoaXMuY29udGFpbmVycyk7XHJcblxyXG4gICAgaWYgKCFjb250YWluZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgZGVsYXkgfSA9IHRoaXM7XHJcbiAgICBjb25zdCB7IHBhZ2VYLCBwYWdlWSB9ID0gZXZlbnQ7XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IHBhZ2VYLCBwYWdlWSB9KTtcclxuICAgIHRoaXMub25Nb3VzZURvd25BdCA9IERhdGUubm93KCk7XHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBldmVudDtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHByZXZlbnROYXRpdmVEcmFnU3RhcnQpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcblxyXG4gICAgdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKHsgcGFnZVg6IHRoaXMucGFnZVgsIHBhZ2VZOiB0aGlzLnBhZ2VZIH0pO1xyXG4gICAgfSwgZGVsYXkubW91c2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdGhlIGRyYWdcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtzdGFydERyYWddKCkge1xyXG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IHRoaXMuc3RhcnRFdmVudDtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbnRhaW5lcjtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBzdGFydEV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IHN0YXJ0RXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0OiBzdGFydEV2ZW50LnRhcmdldCxcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBzdGFydEV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2luZyA9ICFkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpO1xyXG5cclxuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10sIHRydWUpO1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uTW91c2VNb3ZlXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlY3QgY2hhbmdlIGluIGRpc3RhbmNlLCBzdGFydGluZyBkcmFnIHdoZW4gYm90aFxyXG4gICAqIGRlbGF5IGFuZCBkaXN0YW5jZSByZXF1aXJlbWVudHMgYXJlIG1ldFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBtb3ZlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRGlzdGFuY2VDaGFuZ2VdKGV2ZW50KSB7XHJcbiAgICBjb25zdCB7IHBhZ2VYLCBwYWdlWSB9ID0gZXZlbnQ7XHJcbiAgICBjb25zdCB7IGRpc3RhbmNlIH0gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCB7IHN0YXJ0RXZlbnQsIGRlbGF5IH0gPSB0aGlzO1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBwYWdlWCwgcGFnZVkgfSk7XHJcblxyXG4gICAgaWYgKCF0aGlzLmN1cnJlbnRDb250YWluZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gRGF0ZS5ub3coKSAtIHRoaXMub25Nb3VzZURvd25BdDtcclxuICAgIGNvbnN0IGRpc3RhbmNlVHJhdmVsbGVkID0gKDAsIF91dGlscy5kaXN0YW5jZSkoc3RhcnRFdmVudC5wYWdlWCwgc3RhcnRFdmVudC5wYWdlWSwgcGFnZVgsIHBhZ2VZKSB8fCAwO1xyXG5cclxuICAgIGNsZWFyVGltZW91dCh0aGlzLm1vdXNlRG93blRpbWVvdXQpO1xyXG5cclxuICAgIGlmICh0aW1lRWxhcHNlZCA8IGRlbGF5Lm1vdXNlKSB7XHJcbiAgICAgIC8vIG1vdmVkIGR1cmluZyBkZWxheVxyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcclxuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2VUcmF2ZWxsZWQgPj0gZGlzdGFuY2UpIHtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XHJcbiAgICAgIHRoaXNbc3RhcnREcmFnXSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgbW92ZSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZU1vdmVdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ01vdmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ01vdmVTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIHVwIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgdXAgZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZVVwXShldmVudCkge1xyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XHJcblxyXG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBwcmV2ZW50TmF0aXZlRHJhZ1N0YXJ0KTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xyXG5cclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RvcFNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdG9wRXZlbnQpO1xyXG5cclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xyXG5cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IG51bGw7XHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udGV4dCBtZW51IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gQ29udGV4dCBtZW51IGV2ZW50XHJcbiAgICovXHJcbiAgW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXShldmVudCkge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1vdXNlU2Vuc29yO1xyXG5mdW5jdGlvbiBwcmV2ZW50TmF0aXZlRHJhZ1N0YXJ0KGV2ZW50KSB7XHJcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Nb3VzZVNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG5cclxudmFyIF9Nb3VzZVNlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Nb3VzZVNlbnNvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX01vdXNlU2Vuc29yMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbmNvbnN0IGRlZmF1bHREZWFseSA9IHtcclxuICBtb3VzZTogMCxcclxuICBkcmFnOiAwLFxyXG4gIHRvdWNoOiAxMDBcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCYXNlIHNlbnNvciBjbGFzcy4gRXh0ZW5kIGZyb20gdGhpcyBjbGFzcyB0byBjcmVhdGUgYSBuZXcgb3IgY3VzdG9tIHNlbnNvclxyXG4gKiBAY2xhc3MgU2Vuc29yXHJcbiAqIEBtb2R1bGUgU2Vuc29yXHJcbiAqL1xyXG5jbGFzcyBTZW5zb3Ige1xyXG4gIC8qKlxyXG4gICAqIFNlbnNvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBTZW5zb3JcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBjb250YWluZXJzXHJcbiAgICAgKiBAcHJvcGVydHkgY29udGFpbmVyc1xyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi5jb250YWluZXJzXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgZHJhZyBzdGF0ZVxyXG4gICAgICogQHByb3BlcnR5IGRyYWdnaW5nXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBjb250YWluZXJcclxuICAgICAqIEBwcm9wZXJ0eSBjdXJyZW50Q29udGFpbmVyXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZXZlbnQgb2YgdGhlIGluaXRpYWwgc2Vuc29yIGRvd25cclxuICAgICAqIEBwcm9wZXJ0eSBzdGFydEV2ZW50XHJcbiAgICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVsYXkgb2YgZWFjaCBzZW5zb3JcclxuICAgICAqIEBwcm9wZXJ0eSBkZWxheVxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kZWxheSA9IGNhbGNEZWxheShvcHRpb25zLmRlbGF5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKiBAcmV0dXJuIHtTZW5zb3J9XHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICogQHJldHVybiB7U2Vuc29yfVxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBjb250YWluZXIgdG8gdGhpcyBzZW5zb3IgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0gey4uLkhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVycyB5b3Ugd2FudCB0byBhZGQgdG8gdGhpcyBzZW5zb3JcclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUuYWRkQ29udGFpbmVyKGRvY3VtZW50LmJvZHkpXHJcbiAgICovXHJcbiAgYWRkQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcclxuICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi50aGlzLmNvbnRhaW5lcnMsIC4uLmNvbnRhaW5lcnNdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBjb250YWluZXIgZnJvbSB0aGlzIHNlbnNvciBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7Li4uSFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzIHlvdSB3YW50IHRvIHJlbW92ZSBmcm9tIHRoaXMgc2Vuc29yXHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLnJlbW92ZUNvbnRhaW5lcihkb2N1bWVudC5ib2R5KVxyXG4gICAqL1xyXG4gIHJlbW92ZUNvbnRhaW5lciguLi5jb250YWluZXJzKSB7XHJcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSB0aGlzLmNvbnRhaW5lcnMuZmlsdGVyKGNvbnRhaW5lciA9PiAhY29udGFpbmVycy5pbmNsdWRlcyhjb250YWluZXIpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXJzIGV2ZW50IG9uIHRhcmdldCBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gdHJpZ2dlciBldmVudCBvblxyXG4gICAqIEBwYXJhbSB7U2Vuc29yRXZlbnR9IHNlbnNvckV2ZW50IC0gU2Vuc29yIGV2ZW50IHRvIHRyaWdnZXJcclxuICAgKi9cclxuICB0cmlnZ2VyKGVsZW1lbnQsIHNlbnNvckV2ZW50KSB7XHJcbiAgICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xyXG4gICAgZXZlbnQuZGV0YWlsID0gc2Vuc29yRXZlbnQ7XHJcbiAgICBldmVudC5pbml0RXZlbnQoc2Vuc29yRXZlbnQudHlwZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgdGhpcy5sYXN0RXZlbnQgPSBzZW5zb3JFdmVudDtcclxuXHJcbiAgICByZXR1cm4gc2Vuc29yRXZlbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBTZW5zb3I7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIENhbGN1bGF0ZSB0aGUgZGVsYXkgb2YgZWFjaCBzZW5zb3IgdGhyb3VnaCB0aGUgZGVsYXkgaW4gdGhlIG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3VuZGVmaW5lZHxOdW1iZXJ8T2JqZWN0fSBvcHRpb25zRGVsYXkgLSB0aGUgZGVsYXkgaW4gdGhlIG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5mdW5jdGlvbiBjYWxjRGVsYXkob3B0aW9uc0RlbGF5KSB7XHJcbiAgY29uc3QgZGVsYXkgPSB7fTtcclxuXHJcbiAgaWYgKG9wdGlvbnNEZWxheSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRlZmF1bHREZWFseSk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIG9wdGlvbnNEZWxheSA9PT0gJ251bWJlcicpIHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHREZWFseSkge1xyXG4gICAgICBpZiAoZGVmYXVsdERlYWx5Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICBkZWxheVtrZXldID0gb3B0aW9uc0RlbGF5O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVsYXk7XHJcbiAgfVxyXG5cclxuICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0RGVhbHkpIHtcclxuICAgIGlmIChkZWZhdWx0RGVhbHkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICBpZiAob3B0aW9uc0RlbGF5W2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGRlbGF5W2tleV0gPSBkZWZhdWx0RGVhbHlba2V5XTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkZWxheVtrZXldID0gb3B0aW9uc0RlbGF5W2tleV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBkZWxheTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSB0b3VjaENvb3JkcztcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGZpcnN0IHRvdWNoIGV2ZW50IGZvdW5kIGluIHRvdWNoZXMgb3IgY2hhbmdlZFRvdWNoZXMgb2YgYSB0b3VjaCBldmVudHMuXHJcbiAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnQgYSB0b3VjaCBldmVudFxyXG4gKiBAcmV0dXJuIHtUb3VjaH0gYSB0b3VjaCBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIHRvdWNoQ29vcmRzKGV2ZW50ID0ge30pIHtcclxuICBjb25zdCB7IHRvdWNoZXMsIGNoYW5nZWRUb3VjaGVzIH0gPSBldmVudDtcclxuICByZXR1cm4gdG91Y2hlcyAmJiB0b3VjaGVzWzBdIHx8IGNoYW5nZWRUb3VjaGVzICYmIGNoYW5nZWRUb3VjaGVzWzBdO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3RvdWNoQ29vcmRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcblxyXG52YXIgX3RvdWNoQ29vcmRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvdWNoQ29vcmRzKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfdG91Y2hDb29yZHMyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGRpc3RhbmNlO1xyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXHJcbiAqIEBwYXJhbSAge051bWJlcn0geDEgVGhlIFggcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50XHJcbiAqIEBwYXJhbSAge051bWJlcn0geTEgVGhlIFkgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50XHJcbiAqIEBwYXJhbSAge051bWJlcn0geDIgVGhlIFggcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHkyIFRoZSBZIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnRcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcclxuICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqKiAyICsgKHkyIC0geTEpICoqIDIpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2Rpc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XHJcblxyXG52YXIgX2Rpc3RhbmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc3RhbmNlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfZGlzdGFuY2UyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWU7XHJcbmZ1bmN0aW9uIHJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHtcclxuICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xyXG5cclxudmFyIF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBjbG9zZXN0O1xyXG5jb25zdCBtYXRjaEZ1bmN0aW9uID0gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgY2xvc2VzdCBwYXJlbnQgZWxlbWVudCBvZiBhIGdpdmVuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBnaXZlblxyXG4gKiBzZWxlY3RvciBzdHJpbmcgb3IgbWF0Y2hpbmcgZnVuY3Rpb25cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBjaGlsZCBlbGVtZW50IHRvIGZpbmQgYSBwYXJlbnQgb2ZcclxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIFRoZSBzdHJpbmcgb3IgZnVuY3Rpb24gdG8gdXNlIHRvIG1hdGNoXHJcbiAqICAgICB0aGUgcGFyZW50IGVsZW1lbnRcclxuICogQHJldHVybiB7RWxlbWVudHxudWxsfVxyXG4gKi9cclxuZnVuY3Rpb24gY2xvc2VzdChlbGVtZW50LCB2YWx1ZSkge1xyXG4gIGlmICghZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzZWxlY3RvciA9IHZhbHVlO1xyXG4gIGNvbnN0IGNhbGxiYWNrID0gdmFsdWU7XHJcbiAgY29uc3Qgbm9kZUxpc3QgPSB2YWx1ZTtcclxuICBjb25zdCBzaW5nbGVFbGVtZW50ID0gdmFsdWU7XHJcblxyXG4gIGNvbnN0IGlzU2VsZWN0b3IgPSBCb29sZWFuKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpO1xyXG4gIGNvbnN0IGlzRnVuY3Rpb24gPSBCb29sZWFuKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyk7XHJcbiAgY29uc3QgaXNOb2RlTGlzdCA9IEJvb2xlYW4odmFsdWUgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KTtcclxuICBjb25zdCBpc0VsZW1lbnQgPSBCb29sZWFuKHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpO1xyXG5cclxuICBmdW5jdGlvbiBjb25kaXRpb25GbihjdXJyZW50RWxlbWVudCkge1xyXG4gICAgaWYgKCFjdXJyZW50RWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XHJcbiAgICB9IGVsc2UgaWYgKGlzU2VsZWN0b3IpIHtcclxuICAgICAgcmV0dXJuIG1hdGNoRnVuY3Rpb24uY2FsbChjdXJyZW50RWxlbWVudCwgc2VsZWN0b3IpO1xyXG4gICAgfSBlbHNlIGlmIChpc05vZGVMaXN0KSB7XHJcbiAgICAgIHJldHVybiBbLi4ubm9kZUxpc3RdLmluY2x1ZGVzKGN1cnJlbnRFbGVtZW50KTtcclxuICAgIH0gZWxzZSBpZiAoaXNFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBzaW5nbGVFbGVtZW50ID09PSBjdXJyZW50RWxlbWVudDtcclxuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbikge1xyXG4gICAgICByZXR1cm4gY2FsbGJhY2soY3VycmVudEVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsZXQgY3VycmVudCA9IGVsZW1lbnQ7XHJcblxyXG4gIGRvIHtcclxuICAgIGN1cnJlbnQgPSBjdXJyZW50LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50IHx8IGN1cnJlbnQuY29ycmVzcG9uZGluZ0VsZW1lbnQgfHwgY3VycmVudDtcclxuXHJcbiAgICBpZiAoY29uZGl0aW9uRm4oY3VycmVudCkpIHtcclxuICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcclxuICB9IHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQpO1xyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9jbG9zZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XHJcblxyXG52YXIgX2Nsb3Nlc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xvc2VzdCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX2Nsb3Nlc3QyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLnNjcm9sbCA9IGV4cG9ydHMub25EcmFnU3RvcCA9IGV4cG9ydHMub25EcmFnTW92ZSA9IGV4cG9ydHMub25EcmFnU3RhcnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gZXhwb3J0cy5vbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcclxuY29uc3Qgb25EcmFnTW92ZSA9IGV4cG9ydHMub25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xyXG5jb25zdCBvbkRyYWdTdG9wID0gZXhwb3J0cy5vbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XHJcbmNvbnN0IHNjcm9sbCA9IGV4cG9ydHMuc2Nyb2xsID0gU3ltYm9sKCdzY3JvbGwnKTtcclxuXHJcbi8qKlxyXG4gKiBTY3JvbGxhYmxlIGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLnNwZWVkXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWZhdWx0T3B0aW9ucy5zZW5zaXRpdml0eVxyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50W119IGRlZmF1bHRPcHRpb25zLnNjcm9sbGFibGVFbGVtZW50c1xyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xyXG4gIHNwZWVkOiA2LFxyXG4gIHNlbnNpdGl2aXR5OiA1MCxcclxuICBzY3JvbGxhYmxlRWxlbWVudHM6IFtdXHJcbn07XHJcblxyXG4vKipcclxuICogU2Nyb2xsYWJsZSBwbHVnaW4gd2hpY2ggc2Nyb2xscyB0aGUgY2xvc2VzdCBzY3JvbGxhYmxlIHBhcmVudFxyXG4gKiBAY2xhc3MgU2Nyb2xsYWJsZVxyXG4gKiBAbW9kdWxlIFNjcm9sbGFibGVcclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIFNjcm9sbGFibGUgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIFNjcm9sbGFibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgU2Nyb2xsYWJsZVxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY3JvbGxhYmxlIG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gb3B0aW9ucy5zcGVlZFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG9wdGlvbnMuc2Vuc2l0aXZpdHlcclxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnRbXX0gb3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2VlcHMgY3VycmVudCBtb3VzZSBwb3NpdGlvblxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IGN1cnJlbnRNb3VzZVBvc2l0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY3VycmVudE1vdXNlUG9zaXRpb24uY2xpZW50WFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGN1cnJlbnRNb3VzZVBvc2l0aW9uLmNsaWVudFlcclxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbiA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY3JvbGwgYW5pbWF0aW9uIGZyYW1lXHJcbiAgICAgKiBAcHJvcGVydHkgc2Nyb2xsQW5pbWF0aW9uRnJhbWVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXN0IHNjcm9sbGFibGUgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHNjcm9sbGFibGVFbGVtZW50XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zY3JvbGxhYmxlRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbmltYXRpb24gZnJhbWUgbG9va2luZyBmb3IgdGhlIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBlbGVtZW50XHJcbiAgICAgKiBAcHJvcGVydHkgZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW3Njcm9sbF0gPSB0aGlzW3Njcm9sbF0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgb3B0aW9ucyBwYXNzZWQgdGhyb3VnaCBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXHJcbiAgZ2V0T3B0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLnNjcm9sbGFibGUgfHwge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBlbGVtZW50cyBieSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAgICovXHJcbiAgZ2V0U2Nyb2xsYWJsZUVsZW1lbnQodGFyZ2V0KSB7XHJcbiAgICBpZiAodGhpcy5oYXNEZWZpbmVkU2Nyb2xsYWJsZUVsZW1lbnRzKCkpIHtcclxuICAgICAgcmV0dXJuICgwLCBfdXRpbHMuY2xvc2VzdCkodGFyZ2V0LCB0aGlzLm9wdGlvbnMuc2Nyb2xsYWJsZUVsZW1lbnRzKSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gY2xvc2VzdFNjcm9sbGFibGVFbGVtZW50KHRhcmdldCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgYXQgbGVhc3Qgb25lIHNjcm9sbGFibGUgZWxlbWVudCBoYXZlIGJlZW4gZGVmaW5lZCB2aWEgb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaGFzRGVmaW5lZFNjcm9sbGFibGVFbGVtZW50cygpIHtcclxuICAgIHJldHVybiBCb29sZWFuKHRoaXMub3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHMubGVuZ3RoICE9PSAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlci4gRmluZHMgY2xvc2VzdCBzY3JvbGxhYmxlIHBhcmVudCBpbiBzZXBhcmF0ZSBmcmFtZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0YXJ0RXZlbnR9IGRyYWdFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRHJhZ1N0YXJ0XShkcmFnRXZlbnQpIHtcclxuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gdGhpcy5nZXRTY3JvbGxhYmxlRWxlbWVudChkcmFnRXZlbnQuc291cmNlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBtb3ZlIGhhbmRsZXIuIFJlbWVtYmVycyBtb3VzZSBwb3NpdGlvbiBhbmQgaW5pdGlhdGVzIHNjcm9sbGluZ1xyXG4gICAqIEBwYXJhbSB7RHJhZ01vdmVFdmVudH0gZHJhZ0V2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25EcmFnTW92ZV0oZHJhZ0V2ZW50KSB7XHJcbiAgICB0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgdGhpcy5zY3JvbGxhYmxlRWxlbWVudCA9IHRoaXMuZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZHJhZ0V2ZW50LnNlbnNvckV2ZW50LnRhcmdldCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZHJhZ0V2ZW50LnNlbnNvckV2ZW50O1xyXG4gICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcblxyXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xyXG4gICAgICBzY3JvbGxPZmZzZXQueSA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IDA7XHJcbiAgICAgIHNjcm9sbE9mZnNldC54ID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCB8fCAwO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24gPSB7XHJcbiAgICAgIGNsaWVudFg6IHNlbnNvckV2ZW50LmNsaWVudFggLSBzY3JvbGxPZmZzZXQueCxcclxuICAgICAgY2xpZW50WTogc2Vuc29yRXZlbnQuY2xpZW50WSAtIHNjcm9sbE9mZnNldC55XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpc1tzY3JvbGxdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RvcCBoYW5kbGVyLiBDYW5jZWxzIHNjcm9sbCBhbmltYXRpb25zIGFuZCByZXNldHMgc3RhdGVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdG9wXSgpIHtcclxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUpO1xyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSk7XHJcblxyXG4gICAgdGhpcy5zY3JvbGxhYmxlRWxlbWVudCA9IG51bGw7XHJcbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcclxuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSBudWxsO1xyXG4gICAgdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbiA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY3JvbGwgZnVuY3Rpb24gdGhhdCBkb2VzIHRoZSBoZWF2eWxpZnRpbmdcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtzY3JvbGxdKCkge1xyXG4gICAgaWYgKCF0aGlzLnNjcm9sbGFibGVFbGVtZW50IHx8ICF0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lKTtcclxuXHJcbiAgICBjb25zdCB7IHNwZWVkLCBzZW5zaXRpdml0eSB9ID0gdGhpcy5vcHRpb25zO1xyXG5cclxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnNjcm9sbGFibGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgY29uc3QgYm90dG9tQ3V0T2ZmID0gcmVjdC5ib3R0b20gPiB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICBjb25zdCB0b3BDdXRPZmYgPSByZWN0LnRvcCA8IDA7XHJcbiAgICBjb25zdCBjdXRPZmYgPSB0b3BDdXRPZmYgfHwgYm90dG9tQ3V0T2ZmO1xyXG5cclxuICAgIGNvbnN0IGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCA9IGdldERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCgpO1xyXG4gICAgY29uc3Qgc2Nyb2xsYWJsZUVsZW1lbnQgPSB0aGlzLnNjcm9sbGFibGVFbGVtZW50O1xyXG4gICAgY29uc3QgY2xpZW50WCA9IHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24uY2xpZW50WDtcclxuICAgIGNvbnN0IGNsaWVudFkgPSB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uLmNsaWVudFk7XHJcblxyXG4gICAgaWYgKHNjcm9sbGFibGVFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIHNjcm9sbGFibGVFbGVtZW50ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgIWN1dE9mZikge1xyXG4gICAgICBjb25zdCB7IG9mZnNldEhlaWdodCwgb2Zmc2V0V2lkdGggfSA9IHNjcm9sbGFibGVFbGVtZW50O1xyXG5cclxuICAgICAgaWYgKHJlY3QudG9wICsgb2Zmc2V0SGVpZ2h0IC0gY2xpZW50WSA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsVG9wICs9IHNwZWVkO1xyXG4gICAgICB9IGVsc2UgaWYgKGNsaWVudFkgLSByZWN0LnRvcCA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsVG9wIC09IHNwZWVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVjdC5sZWZ0ICsgb2Zmc2V0V2lkdGggLSBjbGllbnRYIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxMZWZ0ICs9IHNwZWVkO1xyXG4gICAgICB9IGVsc2UgaWYgKGNsaWVudFggLSByZWN0LmxlZnQgPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbExlZnQgLT0gc3BlZWQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHsgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGggfSA9IHdpbmRvdztcclxuXHJcbiAgICAgIGlmIChjbGllbnRZIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wIC09IHNwZWVkO1xyXG4gICAgICB9IGVsc2UgaWYgKGlubmVySGVpZ2h0IC0gY2xpZW50WSA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCArPSBzcGVlZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNsaWVudFggPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0IC09IHNwZWVkO1xyXG4gICAgICB9IGVsc2UgaWYgKGlubmVyV2lkdGggLSBjbGllbnRYIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCArPSBzcGVlZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpc1tzY3JvbGxdKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNjcm9sbGFibGU7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCBlbGVtZW50IGhhcyBvdmVyZmxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuZnVuY3Rpb24gaGFzT3ZlcmZsb3coZWxlbWVudCkge1xyXG4gIGNvbnN0IG92ZXJmbG93UmVnZXggPSAvKGF1dG98c2Nyb2xsKS87XHJcbiAgY29uc3QgY29tcHV0ZWRTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xyXG5cclxuICBjb25zdCBvdmVyZmxvdyA9IGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93JykgKyBjb21wdXRlZFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdy15JykgKyBjb21wdXRlZFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdy14Jyk7XHJcblxyXG4gIHJldHVybiBvdmVyZmxvd1JlZ2V4LnRlc3Qob3ZlcmZsb3cpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgZWxlbWVudCBpcyBzdGF0aWNhbGx5IHBvc2l0aW9uZWRcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNTdGF0aWNhbGx5UG9zaXRpb25lZChlbGVtZW50KSB7XHJcbiAgY29uc3QgcG9zaXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJyk7XHJcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAnc3RhdGljJztcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmRzIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9zZXN0U2Nyb2xsYWJsZUVsZW1lbnQoZWxlbWVudCkge1xyXG4gIGlmICghZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIGdldERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCgpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcG9zaXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJyk7XHJcbiAgY29uc3QgZXhjbHVkZVN0YXRpY1BhcmVudHMgPSBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJztcclxuXHJcbiAgY29uc3Qgc2Nyb2xsYWJsZUVsZW1lbnQgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGVsZW1lbnQsIHBhcmVudCA9PiB7XHJcbiAgICBpZiAoZXhjbHVkZVN0YXRpY1BhcmVudHMgJiYgaXNTdGF0aWNhbGx5UG9zaXRpb25lZChwYXJlbnQpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBoYXNPdmVyZmxvdyhwYXJlbnQpO1xyXG4gIH0pO1xyXG5cclxuICBpZiAocG9zaXRpb24gPT09ICdmaXhlZCcgfHwgIXNjcm9sbGFibGVFbGVtZW50KSB7XHJcbiAgICByZXR1cm4gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBzY3JvbGxhYmxlRWxlbWVudDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGVsZW1lbnQgdGhhdCBzY3JvbGxzIGRvY3VtZW50XHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCkge1xyXG4gIHJldHVybiBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9TY3JvbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XHJcblxyXG52YXIgX1Njcm9sbGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Nyb2xsYWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX1Njcm9sbGFibGUyLmRlZmF1bHQ7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfU2Nyb2xsYWJsZS5kZWZhdWx0T3B0aW9ucztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5NaXJyb3JEZXN0cm95RXZlbnQgPSBleHBvcnRzLk1pcnJvck1vdmVFdmVudCA9IGV4cG9ydHMuTWlycm9yQXR0YWNoZWRFdmVudCA9IGV4cG9ydHMuTWlycm9yQ3JlYXRlZEV2ZW50ID0gZXhwb3J0cy5NaXJyb3JDcmVhdGVFdmVudCA9IGV4cG9ydHMuTWlycm9yRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIG1pcnJvciBldmVudFxyXG4gKiBAY2xhc3MgTWlycm9yRXZlbnRcclxuICogQG1vZHVsZSBNaXJyb3JFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBNaXJyb3JFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIHNvdXJjZSBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IHNvdXJjZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc291cmNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG9yaWdpbmFsIHNvdXJjZSBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG9yaWdpbmFsU291cmNlXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvcmlnaW5hbFNvdXJjZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxTb3VyY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIHNvdXJjZSBjb250YWluZXIgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBzb3VyY2VDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNvdXJjZUNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Vuc29yIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IHNlbnNvckV2ZW50XHJcbiAgICogQHR5cGUge1NlbnNvckV2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzZW5zb3JFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc2Vuc29yRXZlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IGRyYWdFdmVudFxyXG4gICAqIEB0eXBlIHtEcmFnRXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyYWdFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgc2Vuc29yIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IG9yaWdpbmFsRXZlbnRcclxuICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9yaWdpbmFsRXZlbnQoKSB7XHJcbiAgICBpZiAodGhpcy5zZW5zb3JFdmVudCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5NaXJyb3JFdmVudCA9IE1pcnJvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNaXJyb3IgY3JlYXRlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIE1pcnJvckNyZWF0ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JDcmVhdGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIE1pcnJvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5jbGFzcyBNaXJyb3JDcmVhdGVFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHt9XHJcblxyXG5leHBvcnRzLk1pcnJvckNyZWF0ZUV2ZW50ID0gTWlycm9yQ3JlYXRlRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1pcnJvciBjcmVhdGVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIE1pcnJvckNyZWF0ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgTWlycm9yQ3JlYXRlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgTWlycm9yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbk1pcnJvckNyZWF0ZUV2ZW50LnR5cGUgPSAnbWlycm9yOmNyZWF0ZSc7XHJcbmNsYXNzIE1pcnJvckNyZWF0ZWRFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBtaXJyb3IgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG1pcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5NaXJyb3JDcmVhdGVkRXZlbnQgPSBNaXJyb3JDcmVhdGVkRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWlycm9yIGF0dGFjaGVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgTWlycm9yQXR0YWNoZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JBdHRhY2hlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBNaXJyb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5NaXJyb3JDcmVhdGVkRXZlbnQudHlwZSA9ICdtaXJyb3I6Y3JlYXRlZCc7XHJcbmNsYXNzIE1pcnJvckF0dGFjaGVkRXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgbWlycm9yIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbWlycm9yXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBtaXJyb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuTWlycm9yQXR0YWNoZWRFdmVudCA9IE1pcnJvckF0dGFjaGVkRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNaXJyb3IgbW92ZSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgTWlycm9yTW92ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgTWlycm9yTW92ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIE1pcnJvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuTWlycm9yQXR0YWNoZWRFdmVudC50eXBlID0gJ21pcnJvcjphdHRhY2hlZCc7XHJcbmNsYXNzIE1pcnJvck1vdmVFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBtaXJyb3IgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG1pcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Vuc29yIGhhcyBleGNlZWRlZCBtaXJyb3IncyB0aHJlc2hvbGQgb24geCBheGlzXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHBhc3NlZFRocmVzaFgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnBhc3NlZFRocmVzaFg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5zb3IgaGFzIGV4Y2VlZGVkIG1pcnJvcidzIHRocmVzaG9sZCBvbiB5IGF4aXNcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcGFzc2VkVGhyZXNoWSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEucGFzc2VkVGhyZXNoWTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuTWlycm9yTW92ZUV2ZW50ID0gTWlycm9yTW92ZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1pcnJvciBkZXN0cm95IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgTWlycm9yRGVzdHJveUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIE1pcnJvckRlc3Ryb3lFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgTWlycm9yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuTWlycm9yTW92ZUV2ZW50LnR5cGUgPSAnbWlycm9yOm1vdmUnO1xyXG5NaXJyb3JNb3ZlRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIE1pcnJvckRlc3Ryb3lFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBtaXJyb3IgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG1pcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLk1pcnJvckRlc3Ryb3lFdmVudCA9IE1pcnJvckRlc3Ryb3lFdmVudDtcclxuTWlycm9yRGVzdHJveUV2ZW50LnR5cGUgPSAnbWlycm9yOmRlc3Ryb3knO1xyXG5NaXJyb3JEZXN0cm95RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX01pcnJvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XHJcblxyXG5PYmplY3Qua2V5cyhfTWlycm9yRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfTWlycm9yRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmdldEFwcGVuZGFibGVDb250YWluZXIgPSBleHBvcnRzLm9uU2Nyb2xsID0gZXhwb3J0cy5vbk1pcnJvck1vdmUgPSBleHBvcnRzLm9uTWlycm9yQ3JlYXRlZCA9IGV4cG9ydHMub25EcmFnU3RvcCA9IGV4cG9ydHMub25EcmFnTW92ZSA9IGV4cG9ydHMub25EcmFnU3RhcnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbnZhciBfTWlycm9yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XHJcblxyXG5jb25zdCBvbkRyYWdTdGFydCA9IGV4cG9ydHMub25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XHJcbmNvbnN0IG9uRHJhZ01vdmUgPSBleHBvcnRzLm9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcclxuY29uc3Qgb25EcmFnU3RvcCA9IGV4cG9ydHMub25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xyXG5jb25zdCBvbk1pcnJvckNyZWF0ZWQgPSBleHBvcnRzLm9uTWlycm9yQ3JlYXRlZCA9IFN5bWJvbCgnb25NaXJyb3JDcmVhdGVkJyk7XHJcbmNvbnN0IG9uTWlycm9yTW92ZSA9IGV4cG9ydHMub25NaXJyb3JNb3ZlID0gU3ltYm9sKCdvbk1pcnJvck1vdmUnKTtcclxuY29uc3Qgb25TY3JvbGwgPSBleHBvcnRzLm9uU2Nyb2xsID0gU3ltYm9sKCdvblNjcm9sbCcpO1xyXG5jb25zdCBnZXRBcHBlbmRhYmxlQ29udGFpbmVyID0gZXhwb3J0cy5nZXRBcHBlbmRhYmxlQ29udGFpbmVyID0gU3ltYm9sKCdnZXRBcHBlbmRhYmxlQ29udGFpbmVyJyk7XHJcblxyXG4vKipcclxuICogTWlycm9yIGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkZWZhdWx0T3B0aW9ucy5jb25zdHJhaW5EaW1lbnNpb25zXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVmYXVsdE9wdGlvbnMueEF4aXNcclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkZWZhdWx0T3B0aW9ucy55QXhpc1xyXG4gKiBAcHJvcGVydHkge251bGx9IGRlZmF1bHRPcHRpb25zLmN1cnNvck9mZnNldFhcclxuICogQHByb3BlcnR5IHtudWxsfSBkZWZhdWx0T3B0aW9ucy5jdXJzb3JPZmZzZXRZXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgY29uc3RyYWluRGltZW5zaW9uczogZmFsc2UsXHJcbiAgeEF4aXM6IHRydWUsXHJcbiAgeUF4aXM6IHRydWUsXHJcbiAgY3Vyc29yT2Zmc2V0WDogbnVsbCxcclxuICBjdXJzb3JPZmZzZXRZOiBudWxsLFxyXG4gIHRocmVzaG9sZFg6IG51bGwsXHJcbiAgdGhyZXNob2xkWTogbnVsbFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1pcnJvciBwbHVnaW4gd2hpY2ggY29udHJvbHMgdGhlIG1pcnJvciBwb3NpdGlvbmluZyB3aGlsZSBkcmFnZ2luZ1xyXG4gKiBAY2xhc3MgTWlycm9yXHJcbiAqIEBtb2R1bGUgTWlycm9yXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBNaXJyb3IgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIE1pcnJvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBNaXJyb3JcclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWlycm9yIG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBvcHRpb25zLnhBeGlzXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG9wdGlvbnMueUF4aXNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfG51bGx9IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8bnVsbH0gb3B0aW9ucy5jdXJzb3JPZmZzZXRZXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbn0gb3B0aW9ucy5hcHBlbmRUb1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY3JvbGwgb2Zmc2V0IGZvciB0b3VjaCBkZXZpY2VzIGJlY2F1c2UgdGhlIG1pcnJvciBpcyBwb3NpdGlvbmVkIGZpeGVkXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gc2Nyb2xsT2Zmc2V0XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc2Nyb2xsT2Zmc2V0LnhcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY3JvbGxPZmZzZXQueVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbCBzY3JvbGwgb2Zmc2V0IGZvciB0b3VjaCBkZXZpY2VzIGJlY2F1c2UgdGhlIG1pcnJvciBpcyBwb3NpdGlvbmVkIGZpeGVkXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gc2Nyb2xsT2Zmc2V0XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc2Nyb2xsT2Zmc2V0LnhcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY3JvbGxPZmZzZXQueVxyXG4gICAgICovXHJcbiAgICB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQgPSB7XHJcbiAgICAgIHg6IHdpbmRvdy5zY3JvbGxYLFxyXG4gICAgICB5OiB3aW5kb3cuc2Nyb2xsWVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25NaXJyb3JDcmVhdGVkXSA9IHRoaXNbb25NaXJyb3JDcmVhdGVkXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1pcnJvck1vdmVdID0gdGhpc1tvbk1pcnJvck1vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uU2Nyb2xsXSA9IHRoaXNbb25TY3JvbGxdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9uKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSkub24oJ21pcnJvcjpjcmVhdGVkJywgdGhpc1tvbk1pcnJvckNyZWF0ZWRdKS5vbignbWlycm9yOm1vdmUnLCB0aGlzW29uTWlycm9yTW92ZV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9mZignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9mZignbWlycm9yOm1vdmUnLCB0aGlzW29uTWlycm9yTW92ZV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBvcHRpb25zIHBhc3NlZCB0aHJvdWdoIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMubWlycm9yIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgW29uRHJhZ1N0YXJ0XShkcmFnRXZlbnQpIHtcclxuICAgIGlmIChkcmFnRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzW29uU2Nyb2xsXSwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0ID0ge1xyXG4gICAgICB4OiB3aW5kb3cuc2Nyb2xsWCxcclxuICAgICAgeTogd2luZG93LnNjcm9sbFlcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgeyBzb3VyY2UsIG9yaWdpbmFsU291cmNlLCBzb3VyY2VDb250YWluZXIsIHNlbnNvckV2ZW50IH0gPSBkcmFnRXZlbnQ7XHJcblxyXG4gICAgLy8gTGFzdCBzZW5zb3IgcG9zaXRpb24gb2YgbWlycm9yIG1vdmVcclxuICAgIHRoaXMubGFzdE1pcnJvck1vdmVkQ2xpZW50ID0ge1xyXG4gICAgICB4OiBzZW5zb3JFdmVudC5jbGllbnRYLFxyXG4gICAgICB5OiBzZW5zb3JFdmVudC5jbGllbnRZXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IG1pcnJvckNyZWF0ZUV2ZW50ID0gbmV3IF9NaXJyb3JFdmVudC5NaXJyb3JDcmVhdGVFdmVudCh7XHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIGRyYWdFdmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JDcmVhdGVFdmVudCk7XHJcblxyXG4gICAgaWYgKGlzTmF0aXZlRHJhZ0V2ZW50KHNlbnNvckV2ZW50KSB8fCBtaXJyb3JDcmVhdGVFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhcHBlbmRhYmxlQ29udGFpbmVyID0gdGhpc1tnZXRBcHBlbmRhYmxlQ29udGFpbmVyXShzb3VyY2UpIHx8IHNvdXJjZUNvbnRhaW5lcjtcclxuICAgIHRoaXMubWlycm9yID0gc291cmNlLmNsb25lTm9kZSh0cnVlKTtcclxuXHJcbiAgICBjb25zdCBtaXJyb3JDcmVhdGVkRXZlbnQgPSBuZXcgX01pcnJvckV2ZW50Lk1pcnJvckNyZWF0ZWRFdmVudCh7XHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIGRyYWdFdmVudCxcclxuICAgICAgbWlycm9yOiB0aGlzLm1pcnJvclxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbWlycm9yQXR0YWNoZWRFdmVudCA9IG5ldyBfTWlycm9yRXZlbnQuTWlycm9yQXR0YWNoZWRFdmVudCh7XHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIGRyYWdFdmVudCxcclxuICAgICAgbWlycm9yOiB0aGlzLm1pcnJvclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JDcmVhdGVkRXZlbnQpO1xyXG4gICAgYXBwZW5kYWJsZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1pcnJvcik7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckF0dGFjaGVkRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgW29uRHJhZ01vdmVdKGRyYWdFdmVudCkge1xyXG4gICAgaWYgKCF0aGlzLm1pcnJvciB8fCBkcmFnRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBzb3VyY2UsIG9yaWdpbmFsU291cmNlLCBzb3VyY2VDb250YWluZXIsIHNlbnNvckV2ZW50IH0gPSBkcmFnRXZlbnQ7XHJcblxyXG4gICAgbGV0IHBhc3NlZFRocmVzaFggPSB0cnVlO1xyXG4gICAgbGV0IHBhc3NlZFRocmVzaFkgPSB0cnVlO1xyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMudGhyZXNob2xkWCB8fCB0aGlzLm9wdGlvbnMudGhyZXNob2xkWSkge1xyXG4gICAgICBjb25zdCB7IHg6IGxhc3RYLCB5OiBsYXN0WSB9ID0gdGhpcy5sYXN0TWlycm9yTW92ZWRDbGllbnQ7XHJcblxyXG4gICAgICBpZiAoTWF0aC5hYnMobGFzdFggLSBzZW5zb3JFdmVudC5jbGllbnRYKSA8IHRoaXMub3B0aW9ucy50aHJlc2hvbGRYKSB7XHJcbiAgICAgICAgcGFzc2VkVGhyZXNoWCA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubGFzdE1pcnJvck1vdmVkQ2xpZW50LnggPSBzZW5zb3JFdmVudC5jbGllbnRYO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoTWF0aC5hYnMobGFzdFkgLSBzZW5zb3JFdmVudC5jbGllbnRZKSA8IHRoaXMub3B0aW9ucy50aHJlc2hvbGRZKSB7XHJcbiAgICAgICAgcGFzc2VkVGhyZXNoWSA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubGFzdE1pcnJvck1vdmVkQ2xpZW50LnkgPSBzZW5zb3JFdmVudC5jbGllbnRZO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXBhc3NlZFRocmVzaFggJiYgIXBhc3NlZFRocmVzaFkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtaXJyb3JNb3ZlRXZlbnQgPSBuZXcgX01pcnJvckV2ZW50Lk1pcnJvck1vdmVFdmVudCh7XHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIGRyYWdFdmVudCxcclxuICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcclxuICAgICAgcGFzc2VkVGhyZXNoWCxcclxuICAgICAgcGFzc2VkVGhyZXNoWVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JNb3ZlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgW29uRHJhZ1N0b3BdKGRyYWdFdmVudCkge1xyXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzW29uU2Nyb2xsXSwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgIGlmICghdGhpcy5taXJyb3IpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgc291cmNlLCBzb3VyY2VDb250YWluZXIsIHNlbnNvckV2ZW50IH0gPSBkcmFnRXZlbnQ7XHJcblxyXG4gICAgY29uc3QgbWlycm9yRGVzdHJveUV2ZW50ID0gbmV3IF9NaXJyb3JFdmVudC5NaXJyb3JEZXN0cm95RXZlbnQoe1xyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIGRyYWdFdmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JEZXN0cm95RXZlbnQpO1xyXG5cclxuICAgIGlmICghbWlycm9yRGVzdHJveUV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgdGhpcy5taXJyb3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm1pcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBbb25TY3JvbGxdKCkge1xyXG4gICAgdGhpcy5zY3JvbGxPZmZzZXQgPSB7XHJcbiAgICAgIHg6IHdpbmRvdy5zY3JvbGxYIC0gdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0LngsXHJcbiAgICAgIHk6IHdpbmRvdy5zY3JvbGxZIC0gdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0LnlcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNaXJyb3IgY3JlYXRlZCBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtNaXJyb3JDcmVhdGVkRXZlbnR9IG1pcnJvckV2ZW50XHJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbk1pcnJvckNyZWF0ZWRdKHsgbWlycm9yLCBzb3VyY2UsIHNlbnNvckV2ZW50IH0pIHtcclxuICAgIGNvbnN0IG1pcnJvckNsYXNzZXMgPSB0aGlzLmRyYWdnYWJsZS5nZXRDbGFzc05hbWVzRm9yKCdtaXJyb3InKTtcclxuXHJcbiAgICBjb25zdCBzZXRTdGF0ZSA9IChfcmVmKSA9PiB7XHJcbiAgICAgIGxldCB7IG1pcnJvck9mZnNldCwgaW5pdGlhbFgsIGluaXRpYWxZIH0gPSBfcmVmLFxyXG4gICAgICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ21pcnJvck9mZnNldCcsICdpbml0aWFsWCcsICdpbml0aWFsWSddKTtcclxuXHJcbiAgICAgIHRoaXMubWlycm9yT2Zmc2V0ID0gbWlycm9yT2Zmc2V0O1xyXG4gICAgICB0aGlzLmluaXRpYWxYID0gaW5pdGlhbFg7XHJcbiAgICAgIHRoaXMuaW5pdGlhbFkgPSBpbml0aWFsWTtcclxuICAgICAgdGhpcy5sYXN0TW92ZWRYID0gaW5pdGlhbFg7XHJcbiAgICAgIHRoaXMubGFzdE1vdmVkWSA9IGluaXRpYWxZO1xyXG4gICAgICByZXR1cm4gX2V4dGVuZHMoeyBtaXJyb3JPZmZzZXQsIGluaXRpYWxYLCBpbml0aWFsWSB9LCBhcmdzKTtcclxuICAgIH07XHJcblxyXG4gICAgbWlycm9yLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xyXG4gICAgICBtaXJyb3IsXHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIG1pcnJvckNsYXNzZXMsXHJcbiAgICAgIHNjcm9sbE9mZnNldDogdGhpcy5zY3JvbGxPZmZzZXQsXHJcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcclxuICAgICAgcGFzc2VkVGhyZXNoWDogdHJ1ZSxcclxuICAgICAgcGFzc2VkVGhyZXNoWTogdHJ1ZVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluaXRpYWxTdGF0ZSlcclxuICAgIC8vIEZpeCByZWZsb3cgaGVyZVxyXG4gICAgLnRoZW4oY29tcHV0ZU1pcnJvckRpbWVuc2lvbnMpLnRoZW4oY2FsY3VsYXRlTWlycm9yT2Zmc2V0KS50aGVuKHJlc2V0TWlycm9yKS50aGVuKGFkZE1pcnJvckNsYXNzZXMpLnRoZW4ocG9zaXRpb25NaXJyb3IoeyBpbml0aWFsOiB0cnVlIH0pKS50aGVuKHJlbW92ZU1pcnJvcklEKS50aGVuKHNldFN0YXRlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1pcnJvciBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge01pcnJvck1vdmVFdmVudH0gbWlycm9yRXZlbnRcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfG51bGx9XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25NaXJyb3JNb3ZlXShtaXJyb3JFdmVudCkge1xyXG4gICAgaWYgKG1pcnJvckV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2V0U3RhdGUgPSAoX3JlZjIpID0+IHtcclxuICAgICAgbGV0IHsgbGFzdE1vdmVkWCwgbGFzdE1vdmVkWSB9ID0gX3JlZjIsXHJcbiAgICAgICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2xhc3RNb3ZlZFgnLCAnbGFzdE1vdmVkWSddKTtcclxuXHJcbiAgICAgIHRoaXMubGFzdE1vdmVkWCA9IGxhc3RNb3ZlZFg7XHJcbiAgICAgIHRoaXMubGFzdE1vdmVkWSA9IGxhc3RNb3ZlZFk7XHJcblxyXG4gICAgICByZXR1cm4gX2V4dGVuZHMoeyBsYXN0TW92ZWRYLCBsYXN0TW92ZWRZIH0sIGFyZ3MpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSB7XHJcbiAgICAgIG1pcnJvcjogbWlycm9yRXZlbnQubWlycm9yLFxyXG4gICAgICBzZW5zb3JFdmVudDogbWlycm9yRXZlbnQuc2Vuc29yRXZlbnQsXHJcbiAgICAgIG1pcnJvck9mZnNldDogdGhpcy5taXJyb3JPZmZzZXQsXHJcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcclxuICAgICAgaW5pdGlhbFg6IHRoaXMuaW5pdGlhbFgsXHJcbiAgICAgIGluaXRpYWxZOiB0aGlzLmluaXRpYWxZLFxyXG4gICAgICBzY3JvbGxPZmZzZXQ6IHRoaXMuc2Nyb2xsT2Zmc2V0LFxyXG4gICAgICBwYXNzZWRUaHJlc2hYOiBtaXJyb3JFdmVudC5wYXNzZWRUaHJlc2hYLFxyXG4gICAgICBwYXNzZWRUaHJlc2hZOiBtaXJyb3JFdmVudC5wYXNzZWRUaHJlc2hZLFxyXG4gICAgICBsYXN0TW92ZWRYOiB0aGlzLmxhc3RNb3ZlZFgsXHJcbiAgICAgIGxhc3RNb3ZlZFk6IHRoaXMubGFzdE1vdmVkWVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluaXRpYWxTdGF0ZSkudGhlbihwb3NpdGlvbk1pcnJvcih7IHJhZjogdHJ1ZSB9KSkudGhlbihzZXRTdGF0ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFwcGVuZGFibGUgY29udGFpbmVyIGZvciBtaXJyb3IgYmFzZWQgb24gdGhlIGFwcGVuZFRvIG9wdGlvblxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25zLnNvdXJjZSAtIEN1cnJlbnQgc291cmNlXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAgICovXHJcbiAgW2dldEFwcGVuZGFibGVDb250YWluZXJdKHNvdXJjZSkge1xyXG4gICAgY29uc3QgYXBwZW5kVG8gPSB0aGlzLm9wdGlvbnMuYXBwZW5kVG87XHJcblxyXG4gICAgaWYgKHR5cGVvZiBhcHBlbmRUbyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXBwZW5kVG8pO1xyXG4gICAgfSBlbHNlIGlmIChhcHBlbmRUbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBhcHBlbmRUbztcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFwcGVuZFRvID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHJldHVybiBhcHBlbmRUbyhzb3VyY2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHNvdXJjZS5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gTWlycm9yOyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb21wdXRlcyBtaXJyb3IgZGltZW5zaW9ucyBiYXNlZCBvbiB0aGUgc291cmNlIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBBZGRzIHNvdXJjZVJlY3QgdG8gc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5zb3VyY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5mdW5jdGlvbiBjb21wdXRlTWlycm9yRGltZW5zaW9ucyhfcmVmMykge1xyXG4gIGxldCB7IHNvdXJjZSB9ID0gX3JlZjMsXHJcbiAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjMsIFsnc291cmNlJ10pO1xyXG5cclxuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBjb25zdCBzb3VyY2VSZWN0ID0gc291cmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgcmVzb2x2ZShfZXh0ZW5kcyh7IHNvdXJjZSwgc291cmNlUmVjdCB9LCBhcmdzKSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIG1pcnJvciBvZmZzZXRcclxuICogQWRkcyBtaXJyb3JPZmZzZXQgdG8gc3RhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAqIEBwYXJhbSB7U2Vuc29yRXZlbnR9IHN0YXRlLnNlbnNvckV2ZW50XHJcbiAqIEBwYXJhbSB7RE9NUmVjdH0gc3RhdGUuc291cmNlUmVjdFxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlTWlycm9yT2Zmc2V0KF9yZWY0KSB7XHJcbiAgbGV0IHsgc2Vuc29yRXZlbnQsIHNvdXJjZVJlY3QsIG9wdGlvbnMgfSA9IF9yZWY0LFxyXG4gICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY0LCBbJ3NlbnNvckV2ZW50JywgJ3NvdXJjZVJlY3QnLCAnb3B0aW9ucyddKTtcclxuXHJcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgY29uc3QgdG9wID0gb3B0aW9ucy5jdXJzb3JPZmZzZXRZID09PSBudWxsID8gc2Vuc29yRXZlbnQuY2xpZW50WSAtIHNvdXJjZVJlY3QudG9wIDogb3B0aW9ucy5jdXJzb3JPZmZzZXRZO1xyXG4gICAgY29uc3QgbGVmdCA9IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WCA9PT0gbnVsbCA/IHNlbnNvckV2ZW50LmNsaWVudFggLSBzb3VyY2VSZWN0LmxlZnQgOiBvcHRpb25zLmN1cnNvck9mZnNldFg7XHJcblxyXG4gICAgY29uc3QgbWlycm9yT2Zmc2V0ID0geyB0b3AsIGxlZnQgfTtcclxuXHJcbiAgICByZXNvbHZlKF9leHRlbmRzKHsgc2Vuc29yRXZlbnQsIHNvdXJjZVJlY3QsIG1pcnJvck9mZnNldCwgb3B0aW9ucyB9LCBhcmdzKSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBcHBseXMgbWlycm9yIHN0eWxlc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUubWlycm9yXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLnNvdXJjZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUub3B0aW9uc1xyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzZXRNaXJyb3IoX3JlZjUpIHtcclxuICBsZXQgeyBtaXJyb3IsIHNvdXJjZSwgb3B0aW9ucyB9ID0gX3JlZjUsXHJcbiAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjUsIFsnbWlycm9yJywgJ3NvdXJjZScsICdvcHRpb25zJ10pO1xyXG5cclxuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBsZXQgb2Zmc2V0SGVpZ2h0O1xyXG4gICAgbGV0IG9mZnNldFdpZHRoO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmNvbnN0cmFpbkRpbWVuc2lvbnMpIHtcclxuICAgICAgY29uc3QgY29tcHV0ZWRTb3VyY2VTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHNvdXJjZSk7XHJcbiAgICAgIG9mZnNldEhlaWdodCA9IGNvbXB1dGVkU291cmNlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpO1xyXG4gICAgICBvZmZzZXRXaWR0aCA9IGNvbXB1dGVkU291cmNlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJyk7XHJcbiAgICB9XHJcblxyXG4gICAgbWlycm9yLnN0eWxlLmRpc3BsYXkgPSBudWxsO1xyXG4gICAgbWlycm9yLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcclxuICAgIG1pcnJvci5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG4gICAgbWlycm9yLnN0eWxlLnRvcCA9IDA7XHJcbiAgICBtaXJyb3Iuc3R5bGUubGVmdCA9IDA7XHJcbiAgICBtaXJyb3Iuc3R5bGUubWFyZ2luID0gMDtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5jb25zdHJhaW5EaW1lbnNpb25zKSB7XHJcbiAgICAgIG1pcnJvci5zdHlsZS5oZWlnaHQgPSBvZmZzZXRIZWlnaHQ7XHJcbiAgICAgIG1pcnJvci5zdHlsZS53aWR0aCA9IG9mZnNldFdpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc29sdmUoX2V4dGVuZHMoeyBtaXJyb3IsIHNvdXJjZSwgb3B0aW9ucyB9LCBhcmdzKSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBcHBseXMgbWlycm9yIGNsYXNzIG9uIG1pcnJvciBlbGVtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5taXJyb3JcclxuICogQHBhcmFtIHtTdHJpbmdbXX0gc3RhdGUubWlycm9yQ2xhc3Nlc1xyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gYWRkTWlycm9yQ2xhc3NlcyhfcmVmNikge1xyXG4gIGxldCB7IG1pcnJvciwgbWlycm9yQ2xhc3NlcyB9ID0gX3JlZjYsXHJcbiAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjYsIFsnbWlycm9yJywgJ21pcnJvckNsYXNzZXMnXSk7XHJcblxyXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIG1pcnJvci5jbGFzc0xpc3QuYWRkKC4uLm1pcnJvckNsYXNzZXMpO1xyXG4gICAgcmVzb2x2ZShfZXh0ZW5kcyh7IG1pcnJvciwgbWlycm9yQ2xhc3NlcyB9LCBhcmdzKSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIHNvdXJjZSBJRCBmcm9tIGNsb25lZCBtaXJyb3IgZWxlbWVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUubWlycm9yXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmVNaXJyb3JJRChfcmVmNykge1xyXG4gIGxldCB7IG1pcnJvciB9ID0gX3JlZjcsXHJcbiAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjcsIFsnbWlycm9yJ10pO1xyXG5cclxuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBtaXJyb3IucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xyXG4gICAgZGVsZXRlIG1pcnJvci5pZDtcclxuICAgIHJlc29sdmUoX2V4dGVuZHMoeyBtaXJyb3IgfSwgYXJncykpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUG9zaXRpb25zIG1pcnJvciB3aXRoIHRyYW5zbGF0ZTNkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5taXJyb3JcclxuICogQHBhcmFtIHtTZW5zb3JFdmVudH0gc3RhdGUuc2Vuc29yRXZlbnRcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlLm1pcnJvck9mZnNldFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdGUuaW5pdGlhbFlcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXRlLmluaXRpYWxYXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZS5vcHRpb25zXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBwb3NpdGlvbk1pcnJvcih7IHdpdGhGcmFtZSA9IGZhbHNlLCBpbml0aWFsID0gZmFsc2UgfSA9IHt9KSB7XHJcbiAgcmV0dXJuIChfcmVmOCkgPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgbWlycm9yLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgbWlycm9yT2Zmc2V0LFxyXG4gICAgICBpbml0aWFsWSxcclxuICAgICAgaW5pdGlhbFgsXHJcbiAgICAgIHNjcm9sbE9mZnNldCxcclxuICAgICAgb3B0aW9ucyxcclxuICAgICAgcGFzc2VkVGhyZXNoWCxcclxuICAgICAgcGFzc2VkVGhyZXNoWSxcclxuICAgICAgbGFzdE1vdmVkWCxcclxuICAgICAgbGFzdE1vdmVkWVxyXG4gICAgfSA9IF9yZWY4LFxyXG4gICAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjgsIFsnbWlycm9yJywgJ3NlbnNvckV2ZW50JywgJ21pcnJvck9mZnNldCcsICdpbml0aWFsWScsICdpbml0aWFsWCcsICdzY3JvbGxPZmZzZXQnLCAnb3B0aW9ucycsICdwYXNzZWRUaHJlc2hYJywgJ3Bhc3NlZFRocmVzaFknLCAnbGFzdE1vdmVkWCcsICdsYXN0TW92ZWRZJ10pO1xyXG5cclxuICAgIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gX2V4dGVuZHMoe1xyXG4gICAgICAgIG1pcnJvcixcclxuICAgICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgICBtaXJyb3JPZmZzZXQsXHJcbiAgICAgICAgb3B0aW9uc1xyXG4gICAgICB9LCBhcmdzKTtcclxuXHJcbiAgICAgIGlmIChtaXJyb3JPZmZzZXQpIHtcclxuICAgICAgICBjb25zdCB4ID0gcGFzc2VkVGhyZXNoWCA/IE1hdGgucm91bmQoKHNlbnNvckV2ZW50LmNsaWVudFggLSBtaXJyb3JPZmZzZXQubGVmdCAtIHNjcm9sbE9mZnNldC54KSAvIChvcHRpb25zLnRocmVzaG9sZFggfHwgMSkpICogKG9wdGlvbnMudGhyZXNob2xkWCB8fCAxKSA6IE1hdGgucm91bmQobGFzdE1vdmVkWCk7XHJcbiAgICAgICAgY29uc3QgeSA9IHBhc3NlZFRocmVzaFkgPyBNYXRoLnJvdW5kKChzZW5zb3JFdmVudC5jbGllbnRZIC0gbWlycm9yT2Zmc2V0LnRvcCAtIHNjcm9sbE9mZnNldC55KSAvIChvcHRpb25zLnRocmVzaG9sZFkgfHwgMSkpICogKG9wdGlvbnMudGhyZXNob2xkWSB8fCAxKSA6IE1hdGgucm91bmQobGFzdE1vdmVkWSk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnhBeGlzICYmIG9wdGlvbnMueUF4aXMgfHwgaW5pdGlhbCkge1xyXG4gICAgICAgICAgbWlycm9yLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7eX1weCwgMClgO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy54QXhpcyAmJiAhb3B0aW9ucy55QXhpcykge1xyXG4gICAgICAgICAgbWlycm9yLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7aW5pdGlhbFl9cHgsIDApYDtcclxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMueUF4aXMgJiYgIW9wdGlvbnMueEF4aXMpIHtcclxuICAgICAgICAgIG1pcnJvci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtpbml0aWFsWH1weCwgJHt5fXB4LCAwKWA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaW5pdGlhbCkge1xyXG4gICAgICAgICAgcmVzdWx0LmluaXRpYWxYID0geDtcclxuICAgICAgICAgIHJlc3VsdC5pbml0aWFsWSA9IHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXN1bHQubGFzdE1vdmVkWCA9IHg7XHJcbiAgICAgICAgcmVzdWx0Lmxhc3RNb3ZlZFkgPSB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICB9LCB7IGZyYW1lOiB3aXRoRnJhbWUgfSk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdyYXBzIGZ1bmN0aW9ucyBpbiBwcm9taXNlIHdpdGggcG90ZW50aWFsIGFuaW1hdGlvbiBmcmFtZSBvcHRpb25cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnJhZlxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gd2l0aFByb21pc2UoY2FsbGJhY2ssIHsgcmFmID0gZmFsc2UgfSA9IHt9KSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGlmIChyYWYpIHtcclxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICBjYWxsYmFjayhyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNlbnNvciBldmVudCB3YXMgdHJpZ2dlcmVkIGJ5IGEgbmF0aXZlIGJyb3dzZXIgZHJhZyBldmVudFxyXG4gKiBAcGFyYW0ge1NlbnNvckV2ZW50fSBzZW5zb3JFdmVudFxyXG4gKi9cclxuZnVuY3Rpb24gaXNOYXRpdmVEcmFnRXZlbnQoc2Vuc29yRXZlbnQpIHtcclxuICByZXR1cm4gKC9eZHJhZy8udGVzdChzZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50LnR5cGUpXHJcbiAgKTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9NaXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcclxuXHJcbnZhciBfTWlycm9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01pcnJvcik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX01pcnJvcjIuZGVmYXVsdDtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IF9NaXJyb3IuZGVmYXVsdE9wdGlvbnM7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkluaXRpYWxpemUgPSBTeW1ib2woJ29uSW5pdGlhbGl6ZScpO1xyXG5jb25zdCBvbkRlc3Ryb3kgPSBTeW1ib2woJ29uRGVzdHJveScpO1xyXG5cclxuLyoqXHJcbiAqIEZvY3VzYWJsZSBkZWZhdWx0IG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEZvY3VzYWJsZSBwbHVnaW5cclxuICogQGNsYXNzIEZvY3VzYWJsZVxyXG4gKiBAbW9kdWxlIEZvY3VzYWJsZVxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgRm9jdXNhYmxlIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBGb2N1c2FibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgRm9jdXNhYmxlXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvY3VzYWJsZSBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XHJcblxyXG4gICAgdGhpc1tvbkluaXRpYWxpemVdID0gdGhpc1tvbkluaXRpYWxpemVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRGVzdHJveV0gPSB0aGlzW29uRGVzdHJveV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIGxpc3RlbmVycyB0byBkcmFnZ2FibGVcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZ2dhYmxlOmluaXRpYWxpemUnLCB0aGlzW29uSW5pdGlhbGl6ZV0pLm9uKCdkcmFnZ2FibGU6ZGVzdHJveScsIHRoaXNbb25EZXN0cm95XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBsaXN0ZW5lcnMgZnJvbSBkcmFnZ2FibGVcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWdnYWJsZTppbml0aWFsaXplJywgdGhpc1tvbkluaXRpYWxpemVdKS5vZmYoJ2RyYWdnYWJsZTpkZXN0cm95JywgdGhpc1tvbkRlc3Ryb3ldKTtcclxuXHJcbiAgICAvLyBSZW1vdmUgbW9kaWZpZWQgZWxlbWVudHMgd2hlbiBkZXRhY2hcclxuICAgIHRoaXNbb25EZXN0cm95XSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBvcHRpb25zIHBhc3NlZCB0aHJvdWdoIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuZm9jdXNhYmxlIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBkcmFnZ2FibGUgY29udGFpbmVycyBhbmQgZWxlbWVudHNcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudFtdfVxyXG4gICAqL1xyXG4gIGdldEVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIFsuLi50aGlzLmRyYWdnYWJsZS5jb250YWluZXJzLCAuLi50aGlzLmRyYWdnYWJsZS5nZXREcmFnZ2FibGVFbGVtZW50cygpXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGlhbGl6ZSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25Jbml0aWFsaXplXSgpIHtcclxuICAgIC8vIENhbiB3YWl0IHVudGlsIHRoZSBuZXh0IGJlc3QgZnJhbWUgaXMgYXZhaWxhYmxlXHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB0aGlzLmdldEVsZW1lbnRzKCkuZm9yRWFjaChlbGVtZW50ID0+IGRlY29yYXRlRWxlbWVudChlbGVtZW50KSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRGVzdHJveV0oKSB7XHJcbiAgICAvLyBDYW4gd2FpdCB1bnRpbCB0aGUgbmV4dCBiZXN0IGZyYW1lIGlzIGF2YWlsYWJsZVxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgdGhpcy5nZXRFbGVtZW50cygpLmZvckVhY2goZWxlbWVudCA9PiBzdHJpcEVsZW1lbnQoZWxlbWVudCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBGb2N1c2FibGU7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgbWlzc2luZyB0YWJpbmRleCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc28gdGhleSBjYW4gYmUgcmVzZXQgd2hlbiBkcmFnZ2FibGUgZ2V0cyBkZXN0cm95ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3Qge0hUTUxFbGVtZW50W119IGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuY29uc3QgZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4ID0gW107XHJcblxyXG4vKipcclxuICogRGVjb3JhdGVzIGVsZW1lbnQgd2l0aCB0YWJpbmRleCBhdHRyaWJ1dGVzXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQpIHtcclxuICBjb25zdCBoYXNNaXNzaW5nVGFiSW5kZXggPSBCb29sZWFuKCFlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSAmJiBlbGVtZW50LnRhYkluZGV4ID09PSAtMSk7XHJcblxyXG4gIGlmIChoYXNNaXNzaW5nVGFiSW5kZXgpIHtcclxuICAgIGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleC5wdXNoKGVsZW1lbnQpO1xyXG4gICAgZWxlbWVudC50YWJJbmRleCA9IDA7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBlbGVtZW50cyB0YWJpbmRleCBhdHRyaWJ1dGVzXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHN0cmlwRWxlbWVudChlbGVtZW50KSB7XHJcbiAgY29uc3QgdGFiSW5kZXhFbGVtZW50UG9zaXRpb24gPSBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXguaW5kZXhPZihlbGVtZW50KTtcclxuXHJcbiAgaWYgKHRhYkluZGV4RWxlbWVudFBvc2l0aW9uICE9PSAtMSkge1xyXG4gICAgZWxlbWVudC50YWJJbmRleCA9IC0xO1xyXG4gICAgZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4LnNwbGljZSh0YWJJbmRleEVsZW1lbnRQb3NpdGlvbiwgMSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0ZvY3VzYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xyXG5cclxudmFyIF9Gb2N1c2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRm9jdXNhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfRm9jdXNhYmxlMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG4vKipcclxuICogQWxsIGRyYWdnYWJsZSBwbHVnaW5zIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gKiBAYWJzdHJhY3RcclxuICogQGNsYXNzIEFic3RyYWN0UGx1Z2luXHJcbiAqIEBtb2R1bGUgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIEFic3RyYWN0UGx1Z2luIHtcclxuICAvKipcclxuICAgKiBBYnN0cmFjdFBsdWdpbiBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBBYnN0cmFjdFBsdWdpblxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICAgKiBAcHJvcGVydHkgZHJhZ2dhYmxlXHJcbiAgICAgKiBAdHlwZSB7RHJhZ2dhYmxlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYWdnYWJsZSA9IGRyYWdnYWJsZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRlIHRvIGFkZCBsaXN0ZW5lcnNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3ZlcnJpZGUgdG8gcmVtb3ZlIGxpc3RlbmVyc1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0UGx1Z2luO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Jbml0aWFsaXplID0gU3ltYm9sKCdvbkluaXRpYWxpemUnKTtcclxuY29uc3Qgb25EZXN0cm95ID0gU3ltYm9sKCdvbkRlc3Ryb3knKTtcclxuY29uc3QgYW5ub3VuY2VFdmVudCA9IFN5bWJvbCgnYW5ub3VuY2VFdmVudCcpO1xyXG5jb25zdCBhbm5vdW5jZU1lc3NhZ2UgPSBTeW1ib2woJ2Fubm91bmNlTWVzc2FnZScpO1xyXG5cclxuY29uc3QgQVJJQV9SRUxFVkFOVCA9ICdhcmlhLXJlbGV2YW50JztcclxuY29uc3QgQVJJQV9BVE9NSUMgPSAnYXJpYS1hdG9taWMnO1xyXG5jb25zdCBBUklBX0xJVkUgPSAnYXJpYS1saXZlJztcclxuY29uc3QgUk9MRSA9ICdyb2xlJztcclxuXHJcbi8qKlxyXG4gKiBBbm5vdW5jZW1lbnQgZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMuZXhwaXJlXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgZXhwaXJlOiA3MDAwXHJcbn07XHJcblxyXG4vKipcclxuICogQW5ub3VuY2VtZW50IHBsdWdpblxyXG4gKiBAY2xhc3MgQW5ub3VuY2VtZW50XHJcbiAqIEBtb2R1bGUgQW5ub3VuY2VtZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBBbm5vdW5jZW1lbnQgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIEFubm91bmNlbWVudCBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBBbm5vdW5jZW1lbnRcclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGx1Z2luIG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIHRoaXMuZ2V0T3B0aW9ucygpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9yaWdpbmFsIGRyYWdnYWJsZSB0cmlnZ2VyIG1ldGhvZC4gSGFjayB1bnRpbCB3ZSBoYXZlIG9uQWxsIG9yIG9uKCdhbGwnKVxyXG4gICAgICogQHByb3BlcnR5IG9yaWdpbmFsVHJpZ2dlck1ldGhvZFxyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9yaWdpbmFsVHJpZ2dlck1ldGhvZCA9IHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXI7XHJcblxyXG4gICAgdGhpc1tvbkluaXRpYWxpemVdID0gdGhpc1tvbkluaXRpYWxpemVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRGVzdHJveV0gPSB0aGlzW29uRGVzdHJveV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIGxpc3RlbmVycyB0byBkcmFnZ2FibGVcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZ2dhYmxlOmluaXRpYWxpemUnLCB0aGlzW29uSW5pdGlhbGl6ZV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgbGlzdGVuZXJzIGZyb20gZHJhZ2dhYmxlXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnZ2FibGU6ZGVzdHJveScsIHRoaXNbb25EZXN0cm95XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHBhc3NlZCBpbiBvcHRpb25zXHJcbiAgICovXHJcbiAgZ2V0T3B0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLmFubm91bmNlbWVudHMgfHwge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbm5vdW5jZXMgZXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RFdmVudH0gZXZlbnRcclxuICAgKi9cclxuICBbYW5ub3VuY2VFdmVudF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnNbZXZlbnQudHlwZV07XHJcblxyXG4gICAgaWYgKG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRoaXNbYW5ub3VuY2VNZXNzYWdlXShtZXNzYWdlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzW2Fubm91bmNlTWVzc2FnZV0obWVzc2FnZShldmVudCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW5ub3VuY2VzIG1lc3NhZ2UgdG8gc2NyZWVuIHJlYWRlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcclxuICAgKi9cclxuICBbYW5ub3VuY2VNZXNzYWdlXShtZXNzYWdlKSB7XHJcbiAgICBhbm5vdW5jZShtZXNzYWdlLCB7IGV4cGlyZTogdGhpcy5vcHRpb25zLmV4cGlyZSB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgaGFuZGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25Jbml0aWFsaXplXSgpIHtcclxuICAgIC8vIEhhY2sgdW50aWwgdGhlcmUgaXMgYW4gYXBpIGZvciBsaXN0ZW5pbmcgZm9yIGFsbCBldmVudHNcclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIgPSBldmVudCA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhpc1thbm5vdW5jZUV2ZW50XShldmVudCk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgb3JpZ2luYWwgdHJpZ2dlciBpcyBjYWxsZWRcclxuICAgICAgICB0aGlzLm9yaWdpbmFsVHJpZ2dlck1ldGhvZC5jYWxsKHRoaXMuZHJhZ2dhYmxlLCBldmVudCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IGhhbmRlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRGVzdHJveV0oKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyID0gdGhpcy5vcmlnaW5hbFRyaWdnZXJNZXRob2Q7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBBbm5vdW5jZW1lbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjb25zdCB7SFRNTEVsZW1lbnR9IGxpdmVSZWdpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmNvbnN0IGxpdmVSZWdpb24gPSBjcmVhdGVSZWdpb24oKTtcclxuXHJcbi8qKlxyXG4gKiBBbm5vdW5jZXMgbWVzc2FnZSB2aWEgbGl2ZSByZWdpb25cclxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZXhwaXJlXHJcbiAqL1xyXG5mdW5jdGlvbiBhbm5vdW5jZShtZXNzYWdlLCB7IGV4cGlyZSB9KSB7XHJcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICBlbGVtZW50LnRleHRDb250ZW50ID0gbWVzc2FnZTtcclxuICBsaXZlUmVnaW9uLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG5cclxuICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICBsaXZlUmVnaW9uLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xyXG4gIH0sIGV4cGlyZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIHJlZ2lvbiBlbGVtZW50XHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVnaW9uKCkge1xyXG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2RyYWdnYWJsZS1saXZlLXJlZ2lvbicpO1xyXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKEFSSUFfUkVMRVZBTlQsICdhZGRpdGlvbnMnKTtcclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZShBUklBX0FUT01JQywgJ3RydWUnKTtcclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZShBUklBX0xJVkUsICdhc3NlcnRpdmUnKTtcclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZShST0xFLCAnbG9nJyk7XHJcblxyXG4gIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xyXG4gIGVsZW1lbnQuc3R5bGUud2lkdGggPSAnMXB4JztcclxuICBlbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxcHgnO1xyXG4gIGVsZW1lbnQuc3R5bGUudG9wID0gJy0xcHgnO1xyXG4gIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuXHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn1cclxuXHJcbi8vIEFwcGVuZCBsaXZlIHJlZ2lvbiBlbGVtZW50IGFzIGVhcmx5IGFzIHBvc3NpYmxlXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XHJcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaXZlUmVnaW9uKTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fubm91bmNlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xyXG5cclxudmFyIF9Bbm5vdW5jZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQW5ub3VuY2VtZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfQW5ub3VuY2VtZW50Mi5kZWZhdWx0O1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gX0Fubm91bmNlbWVudC5kZWZhdWx0T3B0aW9ucztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5EcmFnZ2FibGVEZXN0cm95RXZlbnQgPSBleHBvcnRzLkRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQgPSBleHBvcnRzLkRyYWdnYWJsZUV2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKipcclxuICogQmFzZSBkcmFnZ2FibGUgZXZlbnRcclxuICogQGNsYXNzIERyYWdnYWJsZUV2ZW50XHJcbiAqIEBtb2R1bGUgRHJhZ2dhYmxlRXZlbnRcclxuICogQGV4dGVuZHMgQWJzdHJhY3RFdmVudFxyXG4gKi9cclxuY2xhc3MgRHJhZ2dhYmxlRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqIEBwcm9wZXJ0eSBkcmFnZ2FibGVcclxuICAgKiBAdHlwZSB7RHJhZ2dhYmxlfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkcmFnZ2FibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdnYWJsZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ2dhYmxlRXZlbnQgPSBEcmFnZ2FibGVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZ2dhYmxlIGluaXRpYWxpemVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnZ2FibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ2dhYmxlRXZlbnQudHlwZSA9ICdkcmFnZ2FibGUnO1xyXG5jbGFzcyBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50IGV4dGVuZHMgRHJhZ2dhYmxlRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCA9IERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnZ2FibGUgZGVzdG9yeSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdnYWJsZURlc3Ryb3lFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnZ2FibGVEZXN0cm95RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50LnR5cGUgPSAnZHJhZ2dhYmxlOmluaXRpYWxpemUnO1xyXG5jbGFzcyBEcmFnZ2FibGVEZXN0cm95RXZlbnQgZXh0ZW5kcyBEcmFnZ2FibGVFdmVudCB7fVxyXG5leHBvcnRzLkRyYWdnYWJsZURlc3Ryb3lFdmVudCA9IERyYWdnYWJsZURlc3Ryb3lFdmVudDtcclxuRHJhZ2dhYmxlRGVzdHJveUV2ZW50LnR5cGUgPSAnZHJhZ2dhYmxlOmRlc3Ryb3knO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkRyYWdTdG9wcGVkRXZlbnQgPSBleHBvcnRzLkRyYWdTdG9wRXZlbnQgPSBleHBvcnRzLkRyYWdQcmVzc3VyZUV2ZW50ID0gZXhwb3J0cy5EcmFnT3V0Q29udGFpbmVyRXZlbnQgPSBleHBvcnRzLkRyYWdPdmVyQ29udGFpbmVyRXZlbnQgPSBleHBvcnRzLkRyYWdPdXRFdmVudCA9IGV4cG9ydHMuRHJhZ092ZXJFdmVudCA9IGV4cG9ydHMuRHJhZ01vdmVFdmVudCA9IGV4cG9ydHMuRHJhZ1N0YXJ0RXZlbnQgPSBleHBvcnRzLkRyYWdFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgZHJhZyBldmVudFxyXG4gKiBAY2xhc3MgRHJhZ0V2ZW50XHJcbiAqIEBtb2R1bGUgRHJhZ0V2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIERyYWdFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBzb3VyY2UgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBzb3VyY2VcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNvdXJjZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBvcmlnaW5hbCBzb3VyY2UgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbFNvdXJjZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3JpZ2luYWxTb3VyY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9yaWdpbmFsU291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBtaXJyb3IgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG1pcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBzb3VyY2UgY29udGFpbmVyIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgc291cmNlQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzb3VyY2VDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZUNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbnNvciBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBzZW5zb3JFdmVudFxyXG4gICAqIEB0eXBlIHtTZW5zb3JFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc2Vuc29yRXZlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNlbnNvckV2ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgc2Vuc29yIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IG9yaWdpbmFsRXZlbnRcclxuICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9yaWdpbmFsRXZlbnQoKSB7XHJcbiAgICBpZiAodGhpcy5zZW5zb3JFdmVudCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnRXZlbnQgPSBEcmFnRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdGFydCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdTdGFydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdTdGFydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ0V2ZW50LnR5cGUgPSAnZHJhZyc7XHJcbmNsYXNzIERyYWdTdGFydEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdTdGFydEV2ZW50ID0gRHJhZ1N0YXJ0RXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgbW92ZSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnTW92ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnTW92ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnU3RhcnRFdmVudC50eXBlID0gJ2RyYWc6c3RhcnQnO1xyXG5EcmFnU3RhcnRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgRHJhZ01vdmVFdmVudCBleHRlbmRzIERyYWdFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5EcmFnTW92ZUV2ZW50ID0gRHJhZ01vdmVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgb3ZlciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ092ZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdPdmVyRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ01vdmVFdmVudC50eXBlID0gJ2RyYWc6bW92ZSc7XHJcbmNsYXNzIERyYWdPdmVyRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIHlvdSBhcmUgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGVsZW1lbnQgeW91IGFyZSBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXI7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdPdmVyRXZlbnQgPSBEcmFnT3ZlckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBvdXQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdPdXRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdPdXRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnT3ZlckV2ZW50LnR5cGUgPSAnZHJhZzpvdmVyJztcclxuRHJhZ092ZXJFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgRHJhZ091dEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciB5b3UgYXJlIG92ZXJcclxuICAgKiBAcHJvcGVydHkgb3ZlckNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBlbGVtZW50IHlvdSBsZWZ0XHJcbiAgICogQHByb3BlcnR5IG92ZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXI7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdPdXRFdmVudCA9IERyYWdPdXRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG92ZXIgY29udGFpbmVyIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ092ZXJDb250YWluZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnT3ZlckNvbnRhaW5lckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ091dEV2ZW50LnR5cGUgPSAnZHJhZzpvdXQnO1xyXG5jbGFzcyBEcmFnT3ZlckNvbnRhaW5lckV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciB5b3UgYXJlIG92ZXJcclxuICAgKiBAcHJvcGVydHkgb3ZlckNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ092ZXJDb250YWluZXJFdmVudCA9IERyYWdPdmVyQ29udGFpbmVyRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG91dCBjb250YWluZXIgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdPdXRDb250YWluZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdPdXRDb250YWluZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnT3ZlckNvbnRhaW5lckV2ZW50LnR5cGUgPSAnZHJhZzpvdmVyOmNvbnRhaW5lcic7XHJcbmNsYXNzIERyYWdPdXRDb250YWluZXJFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBjb250YWluZXIgeW91IGxlZnRcclxuICAgKiBAcHJvcGVydHkgb3ZlckNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ091dENvbnRhaW5lckV2ZW50ID0gRHJhZ091dENvbnRhaW5lckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgcHJlc3N1cmUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnUHJlc3N1cmVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnUHJlc3N1cmVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdPdXRDb250YWluZXJFdmVudC50eXBlID0gJ2RyYWc6b3V0OmNvbnRhaW5lcic7XHJcbmNsYXNzIERyYWdQcmVzc3VyZUV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogUHJlc3N1cmUgYXBwbGllZCBvbiBkcmFnZ2FibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBwcmVzc3VyZVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHByZXNzdXJlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wcmVzc3VyZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ1ByZXNzdXJlRXZlbnQgPSBEcmFnUHJlc3N1cmVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdG9wIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdQcmVzc3VyZUV2ZW50LnR5cGUgPSAnZHJhZzpwcmVzc3VyZSc7XHJcbmNsYXNzIERyYWdTdG9wRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ1N0b3BFdmVudCA9IERyYWdTdG9wRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHN0b3BwZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdTdG9wcGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnU3RvcHBlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdTdG9wRXZlbnQudHlwZSA9ICdkcmFnOnN0b3AnO1xyXG5jbGFzcyBEcmFnU3RvcHBlZEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XHJcbmV4cG9ydHMuRHJhZ1N0b3BwZWRFdmVudCA9IERyYWdTdG9wcGVkRXZlbnQ7XHJcbkRyYWdTdG9wcGVkRXZlbnQudHlwZSA9ICdkcmFnOnN0b3BwZWQnO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9EcmFnRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cclxuT2JqZWN0LmtleXMoX0RyYWdFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9EcmFnRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX0RyYWdnYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuXHJcbk9iamVjdC5rZXlzKF9EcmFnZ2FibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9EcmFnZ2FibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbnZhciBfUGx1Z2lucyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG5PYmplY3Qua2V5cyhfUGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9QbHVnaW5zW2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcbk9iamVjdC5rZXlzKF9TZW5zb3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1NlbnNvcnNba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX0RyYWdnYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5cclxudmFyIF9EcmFnZ2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ2dhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfRHJhZ2dhYmxlMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfRHJhZ2dhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XHJcblxyXG52YXIgX0RyYWdnYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnZ2FibGUpO1xyXG5cclxudmFyIF9Td2FwcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XHJcbmNvbnN0IG9uRHJhZ092ZXIgPSBTeW1ib2woJ29uRHJhZ092ZXInKTtcclxuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYW5ub3VuY2VtZW50IG1lc3NhZ2Ugd2hlbiB0aGUgRHJhZ2dhYmxlIGVsZW1lbnQgaXMgc3dhcHBlZCB3aXRoIGFub3RoZXIgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICogQHBhcmFtIHtTd2FwcGFibGVTd2FwcGVkRXZlbnR9IHN3YXBwYWJsZUV2ZW50XHJcbiAqIEByZXR1cm4ge1N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIG9uU3dhcHBhYmxlU3dhcHBlZERlZmF1bHRBbm5vdW5jZW1lbnQoeyBkcmFnRXZlbnQsIHN3YXBwZWRFbGVtZW50IH0pIHtcclxuICBjb25zdCBzb3VyY2VUZXh0ID0gZHJhZ0V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50LnNvdXJjZS5pZCB8fCAnc3dhcHBhYmxlIGVsZW1lbnQnO1xyXG4gIGNvbnN0IG92ZXJUZXh0ID0gc3dhcHBlZEVsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpIHx8IHN3YXBwZWRFbGVtZW50LmlkIHx8ICdzd2FwcGFibGUgZWxlbWVudCc7XHJcblxyXG4gIHJldHVybiBgU3dhcHBlZCAke3NvdXJjZVRleHR9IHdpdGggJHtvdmVyVGV4dH1gO1xyXG59XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtPYmplY3R9IGRlZmF1bHRBbm5vdW5jZW1lbnRzXHJcbiAqIEBjb25zdCB7RnVuY3Rpb259IGRlZmF1bHRBbm5vdW5jZW1lbnRzWydzd2FwcGFibGVkOnN3YXBwZWQnXVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdEFubm91bmNlbWVudHMgPSB7XHJcbiAgJ3N3YXBwYWJsZWQ6c3dhcHBlZCc6IG9uU3dhcHBhYmxlU3dhcHBlZERlZmF1bHRBbm5vdW5jZW1lbnRcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTd2FwcGFibGUgaXMgYnVpbHQgb24gdG9wIG9mIERyYWdnYWJsZSBhbmQgYWxsb3dzIHN3YXBwaW5nIG9mIGRyYWdnYWJsZSBlbGVtZW50cy5cclxuICogT3JkZXIgaXMgaXJyZWxldmFudCB0byBTd2FwcGFibGUuXHJcbiAqIEBjbGFzcyBTd2FwcGFibGVcclxuICogQG1vZHVsZSBTd2FwcGFibGVcclxuICogQGV4dGVuZHMgRHJhZ2dhYmxlXHJcbiAqL1xyXG5jbGFzcyBTd2FwcGFibGUgZXh0ZW5kcyBfRHJhZ2dhYmxlMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBTd2FwcGFibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgU3dhcHBhYmxlXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gU3dhcHBhYmxlIGNvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIFN3YXBwYWJsZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihjb250YWluZXJzLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xyXG4gICAgICBhbm5vdW5jZW1lbnRzOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdEFubm91bmNlbWVudHMsIG9wdGlvbnMuYW5ub3VuY2VtZW50cyB8fCB7fSlcclxuICAgIH0pKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExhc3QgZHJhZ2dhYmxlIGVsZW1lbnQgdGhhdCB3YXMgZHJhZ2dlZCBvdmVyXHJcbiAgICAgKiBAcHJvcGVydHkgbGFzdE92ZXJcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sYXN0T3ZlciA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzdHJveXMgU3dhcHBhYmxlIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBzdXBlci5kZXN0cm95KCk7XHJcblxyXG4gICAgdGhpcy5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCkub2ZmKCdkcmFnOm92ZXInLCB0aGlzLl9vbkRyYWdPdmVyKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXMuX29uRHJhZ1N0b3ApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdGFydCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdTdGFydEV2ZW50fSBldmVudCAtIERyYWcgc3RhcnQgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RhcnRdKGV2ZW50KSB7XHJcbiAgICBjb25zdCBzd2FwcGFibGVTdGFydEV2ZW50ID0gbmV3IF9Td2FwcGFibGVFdmVudC5Td2FwcGFibGVTdGFydEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHN3YXBwYWJsZVN0YXJ0RXZlbnQpO1xyXG5cclxuICAgIGlmIChzd2FwcGFibGVTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgZXZlbnQuY2FuY2VsKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG92ZXIgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnT3ZlckV2ZW50fSBldmVudCAtIERyYWcgb3ZlciBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdmVyXShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50Lm92ZXIgPT09IGV2ZW50Lm9yaWdpbmFsU291cmNlIHx8IGV2ZW50Lm92ZXIgPT09IGV2ZW50LnNvdXJjZSB8fCBldmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzd2FwcGFibGVTd2FwRXZlbnQgPSBuZXcgX1N3YXBwYWJsZUV2ZW50LlN3YXBwYWJsZVN3YXBFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIG92ZXI6IGV2ZW50Lm92ZXIsXHJcbiAgICAgIG92ZXJDb250YWluZXI6IGV2ZW50Lm92ZXJDb250YWluZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzd2FwcGFibGVTd2FwRXZlbnQpO1xyXG5cclxuICAgIGlmIChzd2FwcGFibGVTd2FwRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3dhcCBvcmlnaW5hbGx5IHN3YXBwZWQgZWxlbWVudCBiYWNrXHJcbiAgICBpZiAodGhpcy5sYXN0T3ZlciAmJiB0aGlzLmxhc3RPdmVyICE9PSBldmVudC5vdmVyKSB7XHJcbiAgICAgIHN3YXAodGhpcy5sYXN0T3ZlciwgZXZlbnQuc291cmNlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5sYXN0T3ZlciA9PT0gZXZlbnQub3Zlcikge1xyXG4gICAgICB0aGlzLmxhc3RPdmVyID0gbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubGFzdE92ZXIgPSBldmVudC5vdmVyO1xyXG4gICAgfVxyXG5cclxuICAgIHN3YXAoZXZlbnQuc291cmNlLCBldmVudC5vdmVyKTtcclxuXHJcbiAgICBjb25zdCBzd2FwcGFibGVTd2FwcGVkRXZlbnQgPSBuZXcgX1N3YXBwYWJsZUV2ZW50LlN3YXBwYWJsZVN3YXBwZWRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIHN3YXBwZWRFbGVtZW50OiBldmVudC5vdmVyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoc3dhcHBhYmxlU3dhcHBlZEV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RvcCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdTdG9wRXZlbnR9IGV2ZW50IC0gRHJhZyBzdG9wIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XHJcbiAgICBjb25zdCBzd2FwcGFibGVTdG9wRXZlbnQgPSBuZXcgX1N3YXBwYWJsZUV2ZW50LlN3YXBwYWJsZVN0b3BFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzd2FwcGFibGVTdG9wRXZlbnQpO1xyXG4gICAgdGhpcy5sYXN0T3ZlciA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBTd2FwcGFibGU7XHJcbmZ1bmN0aW9uIHdpdGhUZW1wRWxlbWVudChjYWxsYmFjaykge1xyXG4gIGNvbnN0IHRtcEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBjYWxsYmFjayh0bXBFbGVtZW50KTtcclxuICB0bXBFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG1wRWxlbWVudCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN3YXAoc291cmNlLCBvdmVyKSB7XHJcbiAgY29uc3Qgb3ZlclBhcmVudCA9IG92ZXIucGFyZW50Tm9kZTtcclxuICBjb25zdCBzb3VyY2VQYXJlbnQgPSBzb3VyY2UucGFyZW50Tm9kZTtcclxuXHJcbiAgd2l0aFRlbXBFbGVtZW50KHRtcEVsZW1lbnQgPT4ge1xyXG4gICAgc291cmNlUGFyZW50Lmluc2VydEJlZm9yZSh0bXBFbGVtZW50LCBzb3VyY2UpO1xyXG4gICAgb3ZlclBhcmVudC5pbnNlcnRCZWZvcmUoc291cmNlLCBvdmVyKTtcclxuICAgIHNvdXJjZVBhcmVudC5pbnNlcnRCZWZvcmUob3ZlciwgdG1wRWxlbWVudCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0NiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG5jb25zdCBjYW5jZWxlZCA9IFN5bWJvbCgnY2FuY2VsZWQnKTtcclxuXHJcbi8qKlxyXG4gKiBBbGwgZXZlbnRzIGZpcmVkIGJ5IGRyYWdnYWJsZSBpbmhlcml0IHRoaXMgY2xhc3MuIFlvdSBjYW4gY2FsbCBgY2FuY2VsKClgIHRvXHJcbiAqIGNhbmNlbCBhIHNwZWNpZmljIGV2ZW50IG9yIHlvdSBjYW4gY2hlY2sgaWYgYW4gZXZlbnQgaGFzIGJlZW4gY2FuY2VsZWQgYnlcclxuICogY2FsbGluZyBgY2FuY2VsZWQoKWAuXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAY2xhc3MgQWJzdHJhY3RFdmVudFxyXG4gKiBAbW9kdWxlIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIEFic3RyYWN0RXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBBYnN0cmFjdEV2ZW50IGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIEFic3RyYWN0RXZlbnRcclxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIEV2ZW50IGRhdGFcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogRXZlbnQgdHlwZVxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcHJvcGVydHkgdHlwZVxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZGF0YSkge1xyXG4gICAgdGhpc1tjYW5jZWxlZF0gPSBmYWxzZTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFkLW9ubHkgdHlwZVxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW50IGNhbmNlbGFibGVcclxuICAgKiBAc3RhdGljXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgdHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnR5cGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFkLW9ubHkgY2FuY2VsYWJsZVxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IGNhbmNlbGFibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jYW5jZWxhYmxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FuY2VscyB0aGUgZXZlbnQgaW5zdGFuY2VcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuICBjYW5jZWwoKSB7XHJcbiAgICB0aGlzW2NhbmNlbGVkXSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBldmVudCBoYXMgYmVlbiBjYW5jZWxlZFxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgY2FuY2VsZWQoKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzW2NhbmNlbGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG5ldyBldmVudCBpbnN0YW5jZSB3aXRoIGV4aXN0aW5nIGV2ZW50IGRhdGEuXHJcbiAgICogVGhpcyBtZXRob2QgYWxsb3dzIGZvciBvdmVycmlkaW5nIG9mIGV2ZW50IGRhdGEuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdEV2ZW50fVxyXG4gICAqL1xyXG4gIGNsb25lKGRhdGEpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihfZXh0ZW5kcyh7fSwgdGhpcy5kYXRhLCBkYXRhKSk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0RXZlbnQ7XHJcbkFic3RyYWN0RXZlbnQudHlwZSA9ICdldmVudCc7XHJcbkFic3RyYWN0RXZlbnQuY2FuY2VsYWJsZSA9IGZhbHNlO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLlN3YXBwYWJsZVN0b3BFdmVudCA9IGV4cG9ydHMuU3dhcHBhYmxlU3dhcHBlZEV2ZW50ID0gZXhwb3J0cy5Td2FwcGFibGVTd2FwRXZlbnQgPSBleHBvcnRzLlN3YXBwYWJsZVN0YXJ0RXZlbnQgPSBleHBvcnRzLlN3YXBwYWJsZUV2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKipcclxuICogQmFzZSBzd2FwcGFibGUgZXZlbnRcclxuICogQGNsYXNzIFN3YXBwYWJsZUV2ZW50XHJcbiAqIEBtb2R1bGUgU3dhcHBhYmxlRXZlbnRcclxuICogQGV4dGVuZHMgQWJzdHJhY3RFdmVudFxyXG4gKi9cclxuY2xhc3MgU3dhcHBhYmxlRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIE9yaWdpbmFsIGRyYWcgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBzd2FwcGFibGUgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgZHJhZ0V2ZW50XHJcbiAgICogQHR5cGUge0RyYWdFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ0V2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLlN3YXBwYWJsZUV2ZW50ID0gU3dhcHBhYmxlRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFN3YXBwYWJsZSBzdGFydCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTd2FwcGFibGVTdGFydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBTd2FwcGFibGVTdGFydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU3dhcHBhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblN3YXBwYWJsZUV2ZW50LnR5cGUgPSAnc3dhcHBhYmxlJztcclxuY2xhc3MgU3dhcHBhYmxlU3RhcnRFdmVudCBleHRlbmRzIFN3YXBwYWJsZUV2ZW50IHt9XHJcblxyXG5leHBvcnRzLlN3YXBwYWJsZVN0YXJ0RXZlbnQgPSBTd2FwcGFibGVTdGFydEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3dhcHBhYmxlIHN3YXAgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFN3YXBwYWJsZVN3YXBFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFN3YXBwYWJsZVN3YXBFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTd2FwcGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblN3YXBwYWJsZVN0YXJ0RXZlbnQudHlwZSA9ICdzd2FwcGFibGU6c3RhcnQnO1xyXG5Td2FwcGFibGVTdGFydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBTd2FwcGFibGVTd2FwRXZlbnQgZXh0ZW5kcyBTd2FwcGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBlbGVtZW50IHlvdSBhcmUgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciB5b3UgYXJlIG92ZXJcclxuICAgKiBAcHJvcGVydHkgb3ZlckNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuU3dhcHBhYmxlU3dhcEV2ZW50ID0gU3dhcHBhYmxlU3dhcEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFN3YXBwYWJsZSBzd2FwcGVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgU3dhcHBhYmxlU3dhcHBlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFN3YXBwYWJsZVN3YXBwZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU3dhcHBhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuU3dhcHBhYmxlU3dhcEV2ZW50LnR5cGUgPSAnc3dhcHBhYmxlOnN3YXAnO1xyXG5Td2FwcGFibGVTd2FwRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIFN3YXBwYWJsZVN3YXBwZWRFdmVudCBleHRlbmRzIFN3YXBwYWJsZUV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRyYWdnYWJsZSBlbGVtZW50IHRoYXQgeW91IHN3YXBwZWQgd2l0aFxyXG4gICAqIEBwcm9wZXJ0eSBzd2FwcGVkRWxlbWVudFxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc3dhcHBlZEVsZW1lbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN3YXBwZWRFbGVtZW50O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Td2FwcGFibGVTd2FwcGVkRXZlbnQgPSBTd2FwcGFibGVTd2FwcGVkRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3dhcHBhYmxlIHN0b3AgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTd2FwcGFibGVTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU3dhcHBhYmxlU3RvcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTd2FwcGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Td2FwcGFibGVTd2FwcGVkRXZlbnQudHlwZSA9ICdzd2FwcGFibGU6c3dhcHBlZCc7XHJcbmNsYXNzIFN3YXBwYWJsZVN0b3BFdmVudCBleHRlbmRzIFN3YXBwYWJsZUV2ZW50IHt9XHJcbmV4cG9ydHMuU3dhcHBhYmxlU3RvcEV2ZW50ID0gU3dhcHBhYmxlU3RvcEV2ZW50O1xyXG5Td2FwcGFibGVTdG9wRXZlbnQudHlwZSA9ICdzd2FwcGFibGU6c3RvcCc7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1N3YXBwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHJcbk9iamVjdC5rZXlzKF9Td2FwcGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9Td2FwcGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbnZhciBfU3dhcHBhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XHJcblxyXG52YXIgX1N3YXBwYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Td2FwcGFibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Td2FwcGFibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KVxyXG4vKioqKioqLyBdKTtcclxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@shopify/draggable/lib/swappable.js\n");

/***/ }),

/***/ "./resources/assets/core/plugins/custom/draggable/draggable.js":
/*!*********************************************************************!*\
  !*** ./resources/assets/core/plugins/custom/draggable/draggable.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// Draggable - a lightweight, responsive, modern drag & drop library: https://shopify.github.io/draggable/\n__webpack_require__(/*! @shopify/draggable/lib/draggable.bundle.js */ \"./node_modules/@shopify/draggable/lib/draggable.bundle.js\");\n\n__webpack_require__(/*! @shopify/draggable/lib/draggable.bundle.legacy.js */ \"./node_modules/@shopify/draggable/lib/draggable.bundle.legacy.js\");\n\n__webpack_require__(/*! @shopify/draggable/lib/draggable.js */ \"./node_modules/@shopify/draggable/lib/draggable.js\");\n\nwindow.Sortable = __webpack_require__(/*! @shopify/draggable/lib/sortable.js */ \"./node_modules/@shopify/draggable/lib/sortable.js\");\nwindow.Droppable = __webpack_require__(/*! @shopify/draggable/lib/droppable.js */ \"./node_modules/@shopify/draggable/lib/droppable.js\");\nwindow.Swappable = __webpack_require__(/*! @shopify/draggable/lib/swappable.js */ \"./node_modules/@shopify/draggable/lib/swappable.js\");\n\n__webpack_require__(/*! @shopify/draggable/lib/plugins.js */ \"./node_modules/@shopify/draggable/lib/plugins.js\");\n\n__webpack_require__(/*! @shopify/draggable/lib/plugins/collidable.js */ \"./node_modules/@shopify/draggable/lib/plugins/collidable.js\");\n\n__webpack_require__(/*! @shopify/draggable/lib/plugins/resize-mirror.js */ \"./node_modules/@shopify/draggable/lib/plugins/resize-mirror.js\");\n\n__webpack_require__(/*! @shopify/draggable/lib/plugins/snappable.js */ \"./node_modules/@shopify/draggable/lib/plugins/snappable.js\");\n\n__webpack_require__(/*! @shopify/draggable/lib/plugins/swap-animation.js */ \"./node_modules/@shopify/draggable/lib/plugins/swap-animation.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL2NvcmUvcGx1Z2lucy9jdXN0b20vZHJhZ2dhYmxlL2RyYWdnYWJsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxtQkFBTyxDQUFDLDZHQUFELENBQVA7O0FBQ0FBLG1CQUFPLENBQUMsMkhBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQywrRkFBRCxDQUFQOztBQUNBQyxNQUFNLENBQUNDLFFBQVAsR0FBa0JGLG1CQUFPLENBQUMsNkZBQUQsQ0FBekI7QUFDQUMsTUFBTSxDQUFDRSxTQUFQLEdBQW1CSCxtQkFBTyxDQUFDLCtGQUFELENBQTFCO0FBQ0FDLE1BQU0sQ0FBQ0csU0FBUCxHQUFtQkosbUJBQU8sQ0FBQywrRkFBRCxDQUExQjs7QUFDQUEsbUJBQU8sQ0FBQywyRkFBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLGlIQUFELENBQVA7O0FBQ0FBLG1CQUFPLENBQUMsdUhBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQywrR0FBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLHlIQUFELENBQVAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2NvcmUvcGx1Z2lucy9jdXN0b20vZHJhZ2dhYmxlL2RyYWdnYWJsZS5qcz9hMWRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIERyYWdnYWJsZSAtIGEgbGlnaHR3ZWlnaHQsIHJlc3BvbnNpdmUsIG1vZGVybiBkcmFnICYgZHJvcCBsaWJyYXJ5OiBodHRwczovL3Nob3BpZnkuZ2l0aHViLmlvL2RyYWdnYWJsZS9cclxuXHJcbnJlcXVpcmUoJ0BzaG9waWZ5L2RyYWdnYWJsZS9saWIvZHJhZ2dhYmxlLmJ1bmRsZS5qcycpO1xyXG5yZXF1aXJlKCdAc2hvcGlmeS9kcmFnZ2FibGUvbGliL2RyYWdnYWJsZS5idW5kbGUubGVnYWN5LmpzJyk7XHJcbnJlcXVpcmUoJ0BzaG9waWZ5L2RyYWdnYWJsZS9saWIvZHJhZ2dhYmxlLmpzJyk7XHJcbndpbmRvdy5Tb3J0YWJsZSA9IHJlcXVpcmUoJ0BzaG9waWZ5L2RyYWdnYWJsZS9saWIvc29ydGFibGUuanMnKTtcclxud2luZG93LkRyb3BwYWJsZSA9IHJlcXVpcmUoJ0BzaG9waWZ5L2RyYWdnYWJsZS9saWIvZHJvcHBhYmxlLmpzJyk7XHJcbndpbmRvdy5Td2FwcGFibGUgPSByZXF1aXJlKCdAc2hvcGlmeS9kcmFnZ2FibGUvbGliL3N3YXBwYWJsZS5qcycpO1xyXG5yZXF1aXJlKCdAc2hvcGlmeS9kcmFnZ2FibGUvbGliL3BsdWdpbnMuanMnKTtcclxucmVxdWlyZSgnQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9wbHVnaW5zL2NvbGxpZGFibGUuanMnKTtcclxucmVxdWlyZSgnQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9wbHVnaW5zL3Jlc2l6ZS1taXJyb3IuanMnKTtcclxucmVxdWlyZSgnQHNob3BpZnkvZHJhZ2dhYmxlL2xpYi9wbHVnaW5zL3NuYXBwYWJsZS5qcycpO1xyXG5yZXF1aXJlKCdAc2hvcGlmeS9kcmFnZ2FibGUvbGliL3BsdWdpbnMvc3dhcC1hbmltYXRpb24uanMnKTtcclxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJ3aW5kb3ciLCJTb3J0YWJsZSIsIkRyb3BwYWJsZSIsIlN3YXBwYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/core/plugins/custom/draggable/draggable.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/core/plugins/custom/draggable/draggable.js");
/******/ 	
/******/ })()
;