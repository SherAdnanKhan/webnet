/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/core/plugins/custom/cropper/cropper.js":
/*!*****************************************************************!*\
  !*** ./resources/assets/core/plugins/custom/cropper/cropper.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// Cropper -  A simple jQuery image cropping plugin: https://fengyuanchen.github.io/cropper/\nwindow.Cropper = __webpack_require__(/*! cropperjs/dist/cropper.js */ \"./node_modules/cropperjs/dist/cropper.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL2NvcmUvcGx1Z2lucy9jdXN0b20vY3JvcHBlci9jcm9wcGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkMsbUJBQU8sQ0FBQywyRUFBRCxDQUF4QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvY29yZS9wbHVnaW5zL2N1c3RvbS9jcm9wcGVyL2Nyb3BwZXIuanM/MjA0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDcm9wcGVyIC0gIEEgc2ltcGxlIGpRdWVyeSBpbWFnZSBjcm9wcGluZyBwbHVnaW46IGh0dHBzOi8vZmVuZ3l1YW5jaGVuLmdpdGh1Yi5pby9jcm9wcGVyL1xyXG5cclxud2luZG93LkNyb3BwZXIgPSByZXF1aXJlKCdjcm9wcGVyanMvZGlzdC9jcm9wcGVyLmpzJyk7XHJcbiJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJDcm9wcGVyIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/core/plugins/custom/cropper/cropper.js\n");

/***/ }),

/***/ "./node_modules/cropperjs/dist/cropper.js":
/*!************************************************!*\
  !*** ./node_modules/cropperjs/dist/cropper.js ***!
  \************************************************/
/***/ (function(module) {

eval("/*!\r\n * Cropper.js v1.5.12\r\n * https://fengyuanchen.github.io/cropperjs\r\n *\r\n * Copyright 2015-present Chen Fengyuan\r\n * Released under the MIT license\r\n *\r\n * Date: 2021-06-12T08:00:17.411Z\r\n */\r\n\r\n(function (global, factory) {\r\n   true ? module.exports = factory() :\r\n  0;\r\n}(this, (function () { 'use strict';\r\n\r\n  function ownKeys(object, enumerableOnly) {\r\n    var keys = Object.keys(object);\r\n\r\n    if (Object.getOwnPropertySymbols) {\r\n      var symbols = Object.getOwnPropertySymbols(object);\r\n\r\n      if (enumerableOnly) {\r\n        symbols = symbols.filter(function (sym) {\r\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\r\n        });\r\n      }\r\n\r\n      keys.push.apply(keys, symbols);\r\n    }\r\n\r\n    return keys;\r\n  }\r\n\r\n  function _objectSpread2(target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = arguments[i] != null ? arguments[i] : {};\r\n\r\n      if (i % 2) {\r\n        ownKeys(Object(source), true).forEach(function (key) {\r\n          _defineProperty(target, key, source[key]);\r\n        });\r\n      } else if (Object.getOwnPropertyDescriptors) {\r\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\r\n      } else {\r\n        ownKeys(Object(source)).forEach(function (key) {\r\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\r\n        });\r\n      }\r\n    }\r\n\r\n    return target;\r\n  }\r\n\r\n  function _typeof(obj) {\r\n    \"@babel/helpers - typeof\";\r\n\r\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\r\n      _typeof = function (obj) {\r\n        return typeof obj;\r\n      };\r\n    } else {\r\n      _typeof = function (obj) {\r\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\r\n      };\r\n    }\r\n\r\n    return _typeof(obj);\r\n  }\r\n\r\n  function _classCallCheck(instance, Constructor) {\r\n    if (!(instance instanceof Constructor)) {\r\n      throw new TypeError(\"Cannot call a class as a function\");\r\n    }\r\n  }\r\n\r\n  function _defineProperties(target, props) {\r\n    for (var i = 0; i < props.length; i++) {\r\n      var descriptor = props[i];\r\n      descriptor.enumerable = descriptor.enumerable || false;\r\n      descriptor.configurable = true;\r\n      if (\"value\" in descriptor) descriptor.writable = true;\r\n      Object.defineProperty(target, descriptor.key, descriptor);\r\n    }\r\n  }\r\n\r\n  function _createClass(Constructor, protoProps, staticProps) {\r\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n    if (staticProps) _defineProperties(Constructor, staticProps);\r\n    return Constructor;\r\n  }\r\n\r\n  function _defineProperty(obj, key, value) {\r\n    if (key in obj) {\r\n      Object.defineProperty(obj, key, {\r\n        value: value,\r\n        enumerable: true,\r\n        configurable: true,\r\n        writable: true\r\n      });\r\n    } else {\r\n      obj[key] = value;\r\n    }\r\n\r\n    return obj;\r\n  }\r\n\r\n  function _toConsumableArray(arr) {\r\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\r\n  }\r\n\r\n  function _arrayWithoutHoles(arr) {\r\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\r\n  }\r\n\r\n  function _iterableToArray(iter) {\r\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\r\n  }\r\n\r\n  function _unsupportedIterableToArray(o, minLen) {\r\n    if (!o) return;\r\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\r\n    var n = Object.prototype.toString.call(o).slice(8, -1);\r\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\r\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\r\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\r\n  }\r\n\r\n  function _arrayLikeToArray(arr, len) {\r\n    if (len == null || len > arr.length) len = arr.length;\r\n\r\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\r\n\r\n    return arr2;\r\n  }\r\n\r\n  function _nonIterableSpread() {\r\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\r\n  }\r\n\r\n  var IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';\r\n  var WINDOW = IS_BROWSER ? window : {};\r\n  var IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? 'ontouchstart' in WINDOW.document.documentElement : false;\r\n  var HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;\r\n  var NAMESPACE = 'cropper'; // Actions\r\n\r\n  var ACTION_ALL = 'all';\r\n  var ACTION_CROP = 'crop';\r\n  var ACTION_MOVE = 'move';\r\n  var ACTION_ZOOM = 'zoom';\r\n  var ACTION_EAST = 'e';\r\n  var ACTION_WEST = 'w';\r\n  var ACTION_SOUTH = 's';\r\n  var ACTION_NORTH = 'n';\r\n  var ACTION_NORTH_EAST = 'ne';\r\n  var ACTION_NORTH_WEST = 'nw';\r\n  var ACTION_SOUTH_EAST = 'se';\r\n  var ACTION_SOUTH_WEST = 'sw'; // Classes\r\n\r\n  var CLASS_CROP = \"\".concat(NAMESPACE, \"-crop\");\r\n  var CLASS_DISABLED = \"\".concat(NAMESPACE, \"-disabled\");\r\n  var CLASS_HIDDEN = \"\".concat(NAMESPACE, \"-hidden\");\r\n  var CLASS_HIDE = \"\".concat(NAMESPACE, \"-hide\");\r\n  var CLASS_INVISIBLE = \"\".concat(NAMESPACE, \"-invisible\");\r\n  var CLASS_MODAL = \"\".concat(NAMESPACE, \"-modal\");\r\n  var CLASS_MOVE = \"\".concat(NAMESPACE, \"-move\"); // Data keys\r\n\r\n  var DATA_ACTION = \"\".concat(NAMESPACE, \"Action\");\r\n  var DATA_PREVIEW = \"\".concat(NAMESPACE, \"Preview\"); // Drag modes\r\n\r\n  var DRAG_MODE_CROP = 'crop';\r\n  var DRAG_MODE_MOVE = 'move';\r\n  var DRAG_MODE_NONE = 'none'; // Events\r\n\r\n  var EVENT_CROP = 'crop';\r\n  var EVENT_CROP_END = 'cropend';\r\n  var EVENT_CROP_MOVE = 'cropmove';\r\n  var EVENT_CROP_START = 'cropstart';\r\n  var EVENT_DBLCLICK = 'dblclick';\r\n  var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';\r\n  var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';\r\n  var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';\r\n  var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;\r\n  var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;\r\n  var EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;\r\n  var EVENT_READY = 'ready';\r\n  var EVENT_RESIZE = 'resize';\r\n  var EVENT_WHEEL = 'wheel';\r\n  var EVENT_ZOOM = 'zoom'; // Mime types\r\n\r\n  var MIME_TYPE_JPEG = 'image/jpeg'; // RegExps\r\n\r\n  var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;\r\n  var REGEXP_DATA_URL = /^data:/;\r\n  var REGEXP_DATA_URL_JPEG = /^data:image\\/jpeg;base64,/;\r\n  var REGEXP_TAG_NAME = /^img|canvas$/i; // Misc\r\n  // Inspired by the default width and height of a canvas element.\r\n\r\n  var MIN_CONTAINER_WIDTH = 200;\r\n  var MIN_CONTAINER_HEIGHT = 100;\r\n\r\n  var DEFAULTS = {\r\n    // Define the view mode of the cropper\r\n    viewMode: 0,\r\n    // 0, 1, 2, 3\r\n    // Define the dragging mode of the cropper\r\n    dragMode: DRAG_MODE_CROP,\r\n    // 'crop', 'move' or 'none'\r\n    // Define the initial aspect ratio of the crop box\r\n    initialAspectRatio: NaN,\r\n    // Define the aspect ratio of the crop box\r\n    aspectRatio: NaN,\r\n    // An object with the previous cropping result data\r\n    data: null,\r\n    // A selector for adding extra containers to preview\r\n    preview: '',\r\n    // Re-render the cropper when resize the window\r\n    responsive: true,\r\n    // Restore the cropped area after resize the window\r\n    restore: true,\r\n    // Check if the current image is a cross-origin image\r\n    checkCrossOrigin: true,\r\n    // Check the current image's Exif Orientation information\r\n    checkOrientation: true,\r\n    // Show the black modal\r\n    modal: true,\r\n    // Show the dashed lines for guiding\r\n    guides: true,\r\n    // Show the center indicator for guiding\r\n    center: true,\r\n    // Show the white modal to highlight the crop box\r\n    highlight: true,\r\n    // Show the grid background\r\n    background: true,\r\n    // Enable to crop the image automatically when initialize\r\n    autoCrop: true,\r\n    // Define the percentage of automatic cropping area when initializes\r\n    autoCropArea: 0.8,\r\n    // Enable to move the image\r\n    movable: true,\r\n    // Enable to rotate the image\r\n    rotatable: true,\r\n    // Enable to scale the image\r\n    scalable: true,\r\n    // Enable to zoom the image\r\n    zoomable: true,\r\n    // Enable to zoom the image by dragging touch\r\n    zoomOnTouch: true,\r\n    // Enable to zoom the image by wheeling mouse\r\n    zoomOnWheel: true,\r\n    // Define zoom ratio when zoom the image by wheeling mouse\r\n    wheelZoomRatio: 0.1,\r\n    // Enable to move the crop box\r\n    cropBoxMovable: true,\r\n    // Enable to resize the crop box\r\n    cropBoxResizable: true,\r\n    // Toggle drag mode between \"crop\" and \"move\" when click twice on the cropper\r\n    toggleDragModeOnDblclick: true,\r\n    // Size limitation\r\n    minCanvasWidth: 0,\r\n    minCanvasHeight: 0,\r\n    minCropBoxWidth: 0,\r\n    minCropBoxHeight: 0,\r\n    minContainerWidth: MIN_CONTAINER_WIDTH,\r\n    minContainerHeight: MIN_CONTAINER_HEIGHT,\r\n    // Shortcuts of events\r\n    ready: null,\r\n    cropstart: null,\r\n    cropmove: null,\r\n    cropend: null,\r\n    crop: null,\r\n    zoom: null\r\n  };\r\n\r\n  var TEMPLATE = '<div class=\"cropper-container\" touch-action=\"none\">' + '<div class=\"cropper-wrap-box\">' + '<div class=\"cropper-canvas\"></div>' + '</div>' + '<div class=\"cropper-drag-box\"></div>' + '<div class=\"cropper-crop-box\">' + '<span class=\"cropper-view-box\"></span>' + '<span class=\"cropper-dashed dashed-h\"></span>' + '<span class=\"cropper-dashed dashed-v\"></span>' + '<span class=\"cropper-center\"></span>' + '<span class=\"cropper-face\"></span>' + '<span class=\"cropper-line line-e\" data-cropper-action=\"e\"></span>' + '<span class=\"cropper-line line-n\" data-cropper-action=\"n\"></span>' + '<span class=\"cropper-line line-w\" data-cropper-action=\"w\"></span>' + '<span class=\"cropper-line line-s\" data-cropper-action=\"s\"></span>' + '<span class=\"cropper-point point-e\" data-cropper-action=\"e\"></span>' + '<span class=\"cropper-point point-n\" data-cropper-action=\"n\"></span>' + '<span class=\"cropper-point point-w\" data-cropper-action=\"w\"></span>' + '<span class=\"cropper-point point-s\" data-cropper-action=\"s\"></span>' + '<span class=\"cropper-point point-ne\" data-cropper-action=\"ne\"></span>' + '<span class=\"cropper-point point-nw\" data-cropper-action=\"nw\"></span>' + '<span class=\"cropper-point point-sw\" data-cropper-action=\"sw\"></span>' + '<span class=\"cropper-point point-se\" data-cropper-action=\"se\"></span>' + '</div>' + '</div>';\r\n\r\n  /**\r\n   * Check if the given value is not a number.\r\n   */\r\n\r\n  var isNaN = Number.isNaN || WINDOW.isNaN;\r\n  /**\r\n   * Check if the given value is a number.\r\n   * @param {*} value - The value to check.\r\n   * @returns {boolean} Returns `true` if the given value is a number, else `false`.\r\n   */\r\n\r\n  function isNumber(value) {\r\n    return typeof value === 'number' && !isNaN(value);\r\n  }\r\n  /**\r\n   * Check if the given value is a positive number.\r\n   * @param {*} value - The value to check.\r\n   * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.\r\n   */\r\n\r\n  var isPositiveNumber = function isPositiveNumber(value) {\r\n    return value > 0 && value < Infinity;\r\n  };\r\n  /**\r\n   * Check if the given value is undefined.\r\n   * @param {*} value - The value to check.\r\n   * @returns {boolean} Returns `true` if the given value is undefined, else `false`.\r\n   */\r\n\r\n  function isUndefined(value) {\r\n    return typeof value === 'undefined';\r\n  }\r\n  /**\r\n   * Check if the given value is an object.\r\n   * @param {*} value - The value to check.\r\n   * @returns {boolean} Returns `true` if the given value is an object, else `false`.\r\n   */\r\n\r\n  function isObject(value) {\r\n    return _typeof(value) === 'object' && value !== null;\r\n  }\r\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n  /**\r\n   * Check if the given value is a plain object.\r\n   * @param {*} value - The value to check.\r\n   * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.\r\n   */\r\n\r\n  function isPlainObject(value) {\r\n    if (!isObject(value)) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      var _constructor = value.constructor;\r\n      var prototype = _constructor.prototype;\r\n      return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n  /**\r\n   * Check if the given value is a function.\r\n   * @param {*} value - The value to check.\r\n   * @returns {boolean} Returns `true` if the given value is a function, else `false`.\r\n   */\r\n\r\n  function isFunction(value) {\r\n    return typeof value === 'function';\r\n  }\r\n  var slice = Array.prototype.slice;\r\n  /**\r\n   * Convert array-like or iterable object to an array.\r\n   * @param {*} value - The value to convert.\r\n   * @returns {Array} Returns a new array.\r\n   */\r\n\r\n  function toArray(value) {\r\n    return Array.from ? Array.from(value) : slice.call(value);\r\n  }\r\n  /**\r\n   * Iterate the given data.\r\n   * @param {*} data - The data to iterate.\r\n   * @param {Function} callback - The process function for each element.\r\n   * @returns {*} The original data.\r\n   */\r\n\r\n  function forEach(data, callback) {\r\n    if (data && isFunction(callback)) {\r\n      if (Array.isArray(data) || isNumber(data.length)\r\n      /* array-like */\r\n      ) {\r\n          toArray(data).forEach(function (value, key) {\r\n            callback.call(data, value, key, data);\r\n          });\r\n        } else if (isObject(data)) {\r\n        Object.keys(data).forEach(function (key) {\r\n          callback.call(data, data[key], key, data);\r\n        });\r\n      }\r\n    }\r\n\r\n    return data;\r\n  }\r\n  /**\r\n   * Extend the given object.\r\n   * @param {*} target - The target object to extend.\r\n   * @param {*} args - The rest objects for merging to the target object.\r\n   * @returns {Object} The extended object.\r\n   */\r\n\r\n  var assign = Object.assign || function assign(target) {\r\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n      args[_key - 1] = arguments[_key];\r\n    }\r\n\r\n    if (isObject(target) && args.length > 0) {\r\n      args.forEach(function (arg) {\r\n        if (isObject(arg)) {\r\n          Object.keys(arg).forEach(function (key) {\r\n            target[key] = arg[key];\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    return target;\r\n  };\r\n  var REGEXP_DECIMALS = /\\.\\d*(?:0|9){12}\\d*$/;\r\n  /**\r\n   * Normalize decimal number.\r\n   * Check out {@link https://0.30000000000000004.com/}\r\n   * @param {number} value - The value to normalize.\r\n   * @param {number} [times=100000000000] - The times for normalizing.\r\n   * @returns {number} Returns the normalized number.\r\n   */\r\n\r\n  function normalizeDecimalNumber(value) {\r\n    var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;\r\n    return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;\r\n  }\r\n  var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;\r\n  /**\r\n   * Apply styles to the given element.\r\n   * @param {Element} element - The target element.\r\n   * @param {Object} styles - The styles for applying.\r\n   */\r\n\r\n  function setStyle(element, styles) {\r\n    var style = element.style;\r\n    forEach(styles, function (value, property) {\r\n      if (REGEXP_SUFFIX.test(property) && isNumber(value)) {\r\n        value = \"\".concat(value, \"px\");\r\n      }\r\n\r\n      style[property] = value;\r\n    });\r\n  }\r\n  /**\r\n   * Check if the given element has a special class.\r\n   * @param {Element} element - The element to check.\r\n   * @param {string} value - The class to search.\r\n   * @returns {boolean} Returns `true` if the special class was found.\r\n   */\r\n\r\n  function hasClass(element, value) {\r\n    return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;\r\n  }\r\n  /**\r\n   * Add classes to the given element.\r\n   * @param {Element} element - The target element.\r\n   * @param {string} value - The classes to be added.\r\n   */\r\n\r\n  function addClass(element, value) {\r\n    if (!value) {\r\n      return;\r\n    }\r\n\r\n    if (isNumber(element.length)) {\r\n      forEach(element, function (elem) {\r\n        addClass(elem, value);\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (element.classList) {\r\n      element.classList.add(value);\r\n      return;\r\n    }\r\n\r\n    var className = element.className.trim();\r\n\r\n    if (!className) {\r\n      element.className = value;\r\n    } else if (className.indexOf(value) < 0) {\r\n      element.className = \"\".concat(className, \" \").concat(value);\r\n    }\r\n  }\r\n  /**\r\n   * Remove classes from the given element.\r\n   * @param {Element} element - The target element.\r\n   * @param {string} value - The classes to be removed.\r\n   */\r\n\r\n  function removeClass(element, value) {\r\n    if (!value) {\r\n      return;\r\n    }\r\n\r\n    if (isNumber(element.length)) {\r\n      forEach(element, function (elem) {\r\n        removeClass(elem, value);\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (element.classList) {\r\n      element.classList.remove(value);\r\n      return;\r\n    }\r\n\r\n    if (element.className.indexOf(value) >= 0) {\r\n      element.className = element.className.replace(value, '');\r\n    }\r\n  }\r\n  /**\r\n   * Add or remove classes from the given element.\r\n   * @param {Element} element - The target element.\r\n   * @param {string} value - The classes to be toggled.\r\n   * @param {boolean} added - Add only.\r\n   */\r\n\r\n  function toggleClass(element, value, added) {\r\n    if (!value) {\r\n      return;\r\n    }\r\n\r\n    if (isNumber(element.length)) {\r\n      forEach(element, function (elem) {\r\n        toggleClass(elem, value, added);\r\n      });\r\n      return;\r\n    } // IE10-11 doesn't support the second parameter of `classList.toggle`\r\n\r\n\r\n    if (added) {\r\n      addClass(element, value);\r\n    } else {\r\n      removeClass(element, value);\r\n    }\r\n  }\r\n  var REGEXP_CAMEL_CASE = /([a-z\\d])([A-Z])/g;\r\n  /**\r\n   * Transform the given string from camelCase to kebab-case\r\n   * @param {string} value - The value to transform.\r\n   * @returns {string} The transformed value.\r\n   */\r\n\r\n  function toParamCase(value) {\r\n    return value.replace(REGEXP_CAMEL_CASE, '$1-$2').toLowerCase();\r\n  }\r\n  /**\r\n   * Get data from the given element.\r\n   * @param {Element} element - The target element.\r\n   * @param {string} name - The data key to get.\r\n   * @returns {string} The data value.\r\n   */\r\n\r\n  function getData(element, name) {\r\n    if (isObject(element[name])) {\r\n      return element[name];\r\n    }\r\n\r\n    if (element.dataset) {\r\n      return element.dataset[name];\r\n    }\r\n\r\n    return element.getAttribute(\"data-\".concat(toParamCase(name)));\r\n  }\r\n  /**\r\n   * Set data to the given element.\r\n   * @param {Element} element - The target element.\r\n   * @param {string} name - The data key to set.\r\n   * @param {string} data - The data value.\r\n   */\r\n\r\n  function setData(element, name, data) {\r\n    if (isObject(data)) {\r\n      element[name] = data;\r\n    } else if (element.dataset) {\r\n      element.dataset[name] = data;\r\n    } else {\r\n      element.setAttribute(\"data-\".concat(toParamCase(name)), data);\r\n    }\r\n  }\r\n  /**\r\n   * Remove data from the given element.\r\n   * @param {Element} element - The target element.\r\n   * @param {string} name - The data key to remove.\r\n   */\r\n\r\n  function removeData(element, name) {\r\n    if (isObject(element[name])) {\r\n      try {\r\n        delete element[name];\r\n      } catch (error) {\r\n        element[name] = undefined;\r\n      }\r\n    } else if (element.dataset) {\r\n      // #128 Safari not allows to delete dataset property\r\n      try {\r\n        delete element.dataset[name];\r\n      } catch (error) {\r\n        element.dataset[name] = undefined;\r\n      }\r\n    } else {\r\n      element.removeAttribute(\"data-\".concat(toParamCase(name)));\r\n    }\r\n  }\r\n  var REGEXP_SPACES = /\\s\\s*/;\r\n\r\n  var onceSupported = function () {\r\n    var supported = false;\r\n\r\n    if (IS_BROWSER) {\r\n      var once = false;\r\n\r\n      var listener = function listener() {};\r\n\r\n      var options = Object.defineProperty({}, 'once', {\r\n        get: function get() {\r\n          supported = true;\r\n          return once;\r\n        },\r\n\r\n        /**\r\n         * This setter can fix a `TypeError` in strict mode\r\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}\r\n         * @param {boolean} value - The value to set\r\n         */\r\n        set: function set(value) {\r\n          once = value;\r\n        }\r\n      });\r\n      WINDOW.addEventListener('test', listener, options);\r\n      WINDOW.removeEventListener('test', listener, options);\r\n    }\r\n\r\n    return supported;\r\n  }();\r\n  /**\r\n   * Remove event listener from the target element.\r\n   * @param {Element} element - The event target.\r\n   * @param {string} type - The event type(s).\r\n   * @param {Function} listener - The event listener.\r\n   * @param {Object} options - The event options.\r\n   */\r\n\r\n\r\n  function removeListener(element, type, listener) {\r\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\r\n    var handler = listener;\r\n    type.trim().split(REGEXP_SPACES).forEach(function (event) {\r\n      if (!onceSupported) {\r\n        var listeners = element.listeners;\r\n\r\n        if (listeners && listeners[event] && listeners[event][listener]) {\r\n          handler = listeners[event][listener];\r\n          delete listeners[event][listener];\r\n\r\n          if (Object.keys(listeners[event]).length === 0) {\r\n            delete listeners[event];\r\n          }\r\n\r\n          if (Object.keys(listeners).length === 0) {\r\n            delete element.listeners;\r\n          }\r\n        }\r\n      }\r\n\r\n      element.removeEventListener(event, handler, options);\r\n    });\r\n  }\r\n  /**\r\n   * Add event listener to the target element.\r\n   * @param {Element} element - The event target.\r\n   * @param {string} type - The event type(s).\r\n   * @param {Function} listener - The event listener.\r\n   * @param {Object} options - The event options.\r\n   */\r\n\r\n  function addListener(element, type, listener) {\r\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\r\n    var _handler = listener;\r\n    type.trim().split(REGEXP_SPACES).forEach(function (event) {\r\n      if (options.once && !onceSupported) {\r\n        var _element$listeners = element.listeners,\r\n            listeners = _element$listeners === void 0 ? {} : _element$listeners;\r\n\r\n        _handler = function handler() {\r\n          delete listeners[event][listener];\r\n          element.removeEventListener(event, _handler, options);\r\n\r\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\r\n            args[_key2] = arguments[_key2];\r\n          }\r\n\r\n          listener.apply(element, args);\r\n        };\r\n\r\n        if (!listeners[event]) {\r\n          listeners[event] = {};\r\n        }\r\n\r\n        if (listeners[event][listener]) {\r\n          element.removeEventListener(event, listeners[event][listener], options);\r\n        }\r\n\r\n        listeners[event][listener] = _handler;\r\n        element.listeners = listeners;\r\n      }\r\n\r\n      element.addEventListener(event, _handler, options);\r\n    });\r\n  }\r\n  /**\r\n   * Dispatch event on the target element.\r\n   * @param {Element} element - The event target.\r\n   * @param {string} type - The event type(s).\r\n   * @param {Object} data - The additional event data.\r\n   * @returns {boolean} Indicate if the event is default prevented or not.\r\n   */\r\n\r\n  function dispatchEvent(element, type, data) {\r\n    var event; // Event and CustomEvent on IE9-11 are global objects, not constructors\r\n\r\n    if (isFunction(Event) && isFunction(CustomEvent)) {\r\n      event = new CustomEvent(type, {\r\n        detail: data,\r\n        bubbles: true,\r\n        cancelable: true\r\n      });\r\n    } else {\r\n      event = document.createEvent('CustomEvent');\r\n      event.initCustomEvent(type, true, true, data);\r\n    }\r\n\r\n    return element.dispatchEvent(event);\r\n  }\r\n  /**\r\n   * Get the offset base on the document.\r\n   * @param {Element} element - The target element.\r\n   * @returns {Object} The offset data.\r\n   */\r\n\r\n  function getOffset(element) {\r\n    var box = element.getBoundingClientRect();\r\n    return {\r\n      left: box.left + (window.pageXOffset - document.documentElement.clientLeft),\r\n      top: box.top + (window.pageYOffset - document.documentElement.clientTop)\r\n    };\r\n  }\r\n  var location = WINDOW.location;\r\n  var REGEXP_ORIGINS = /^(\\w+:)\\/\\/([^:/?#]*):?(\\d*)/i;\r\n  /**\r\n   * Check if the given URL is a cross origin URL.\r\n   * @param {string} url - The target URL.\r\n   * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.\r\n   */\r\n\r\n  function isCrossOriginURL(url) {\r\n    var parts = url.match(REGEXP_ORIGINS);\r\n    return parts !== null && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);\r\n  }\r\n  /**\r\n   * Add timestamp to the given URL.\r\n   * @param {string} url - The target URL.\r\n   * @returns {string} The result URL.\r\n   */\r\n\r\n  function addTimestamp(url) {\r\n    var timestamp = \"timestamp=\".concat(new Date().getTime());\r\n    return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;\r\n  }\r\n  /**\r\n   * Get transforms base on the given object.\r\n   * @param {Object} obj - The target object.\r\n   * @returns {string} A string contains transform values.\r\n   */\r\n\r\n  function getTransforms(_ref) {\r\n    var rotate = _ref.rotate,\r\n        scaleX = _ref.scaleX,\r\n        scaleY = _ref.scaleY,\r\n        translateX = _ref.translateX,\r\n        translateY = _ref.translateY;\r\n    var values = [];\r\n\r\n    if (isNumber(translateX) && translateX !== 0) {\r\n      values.push(\"translateX(\".concat(translateX, \"px)\"));\r\n    }\r\n\r\n    if (isNumber(translateY) && translateY !== 0) {\r\n      values.push(\"translateY(\".concat(translateY, \"px)\"));\r\n    } // Rotate should come first before scale to match orientation transform\r\n\r\n\r\n    if (isNumber(rotate) && rotate !== 0) {\r\n      values.push(\"rotate(\".concat(rotate, \"deg)\"));\r\n    }\r\n\r\n    if (isNumber(scaleX) && scaleX !== 1) {\r\n      values.push(\"scaleX(\".concat(scaleX, \")\"));\r\n    }\r\n\r\n    if (isNumber(scaleY) && scaleY !== 1) {\r\n      values.push(\"scaleY(\".concat(scaleY, \")\"));\r\n    }\r\n\r\n    var transform = values.length ? values.join(' ') : 'none';\r\n    return {\r\n      WebkitTransform: transform,\r\n      msTransform: transform,\r\n      transform: transform\r\n    };\r\n  }\r\n  /**\r\n   * Get the max ratio of a group of pointers.\r\n   * @param {string} pointers - The target pointers.\r\n   * @returns {number} The result ratio.\r\n   */\r\n\r\n  function getMaxZoomRatio(pointers) {\r\n    var pointers2 = _objectSpread2({}, pointers);\r\n\r\n    var maxRatio = 0;\r\n    forEach(pointers, function (pointer, pointerId) {\r\n      delete pointers2[pointerId];\r\n      forEach(pointers2, function (pointer2) {\r\n        var x1 = Math.abs(pointer.startX - pointer2.startX);\r\n        var y1 = Math.abs(pointer.startY - pointer2.startY);\r\n        var x2 = Math.abs(pointer.endX - pointer2.endX);\r\n        var y2 = Math.abs(pointer.endY - pointer2.endY);\r\n        var z1 = Math.sqrt(x1 * x1 + y1 * y1);\r\n        var z2 = Math.sqrt(x2 * x2 + y2 * y2);\r\n        var ratio = (z2 - z1) / z1;\r\n\r\n        if (Math.abs(ratio) > Math.abs(maxRatio)) {\r\n          maxRatio = ratio;\r\n        }\r\n      });\r\n    });\r\n    return maxRatio;\r\n  }\r\n  /**\r\n   * Get a pointer from an event object.\r\n   * @param {Object} event - The target event object.\r\n   * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.\r\n   * @returns {Object} The result pointer contains start and/or end point coordinates.\r\n   */\r\n\r\n  function getPointer(_ref2, endOnly) {\r\n    var pageX = _ref2.pageX,\r\n        pageY = _ref2.pageY;\r\n    var end = {\r\n      endX: pageX,\r\n      endY: pageY\r\n    };\r\n    return endOnly ? end : _objectSpread2({\r\n      startX: pageX,\r\n      startY: pageY\r\n    }, end);\r\n  }\r\n  /**\r\n   * Get the center point coordinate of a group of pointers.\r\n   * @param {Object} pointers - The target pointers.\r\n   * @returns {Object} The center point coordinate.\r\n   */\r\n\r\n  function getPointersCenter(pointers) {\r\n    var pageX = 0;\r\n    var pageY = 0;\r\n    var count = 0;\r\n    forEach(pointers, function (_ref3) {\r\n      var startX = _ref3.startX,\r\n          startY = _ref3.startY;\r\n      pageX += startX;\r\n      pageY += startY;\r\n      count += 1;\r\n    });\r\n    pageX /= count;\r\n    pageY /= count;\r\n    return {\r\n      pageX: pageX,\r\n      pageY: pageY\r\n    };\r\n  }\r\n  /**\r\n   * Get the max sizes in a rectangle under the given aspect ratio.\r\n   * @param {Object} data - The original sizes.\r\n   * @param {string} [type='contain'] - The adjust type.\r\n   * @returns {Object} The result sizes.\r\n   */\r\n\r\n  function getAdjustedSizes(_ref4) // or 'cover'\r\n  {\r\n    var aspectRatio = _ref4.aspectRatio,\r\n        height = _ref4.height,\r\n        width = _ref4.width;\r\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'contain';\r\n    var isValidWidth = isPositiveNumber(width);\r\n    var isValidHeight = isPositiveNumber(height);\r\n\r\n    if (isValidWidth && isValidHeight) {\r\n      var adjustedWidth = height * aspectRatio;\r\n\r\n      if (type === 'contain' && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {\r\n        height = width / aspectRatio;\r\n      } else {\r\n        width = height * aspectRatio;\r\n      }\r\n    } else if (isValidWidth) {\r\n      height = width / aspectRatio;\r\n    } else if (isValidHeight) {\r\n      width = height * aspectRatio;\r\n    }\r\n\r\n    return {\r\n      width: width,\r\n      height: height\r\n    };\r\n  }\r\n  /**\r\n   * Get the new sizes of a rectangle after rotated.\r\n   * @param {Object} data - The original sizes.\r\n   * @returns {Object} The result sizes.\r\n   */\r\n\r\n  function getRotatedSizes(_ref5) {\r\n    var width = _ref5.width,\r\n        height = _ref5.height,\r\n        degree = _ref5.degree;\r\n    degree = Math.abs(degree) % 180;\r\n\r\n    if (degree === 90) {\r\n      return {\r\n        width: height,\r\n        height: width\r\n      };\r\n    }\r\n\r\n    var arc = degree % 90 * Math.PI / 180;\r\n    var sinArc = Math.sin(arc);\r\n    var cosArc = Math.cos(arc);\r\n    var newWidth = width * cosArc + height * sinArc;\r\n    var newHeight = width * sinArc + height * cosArc;\r\n    return degree > 90 ? {\r\n      width: newHeight,\r\n      height: newWidth\r\n    } : {\r\n      width: newWidth,\r\n      height: newHeight\r\n    };\r\n  }\r\n  /**\r\n   * Get a canvas which drew the given image.\r\n   * @param {HTMLImageElement} image - The image for drawing.\r\n   * @param {Object} imageData - The image data.\r\n   * @param {Object} canvasData - The canvas data.\r\n   * @param {Object} options - The options.\r\n   * @returns {HTMLCanvasElement} The result canvas.\r\n   */\r\n\r\n  function getSourceCanvas(image, _ref6, _ref7, _ref8) {\r\n    var imageAspectRatio = _ref6.aspectRatio,\r\n        imageNaturalWidth = _ref6.naturalWidth,\r\n        imageNaturalHeight = _ref6.naturalHeight,\r\n        _ref6$rotate = _ref6.rotate,\r\n        rotate = _ref6$rotate === void 0 ? 0 : _ref6$rotate,\r\n        _ref6$scaleX = _ref6.scaleX,\r\n        scaleX = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX,\r\n        _ref6$scaleY = _ref6.scaleY,\r\n        scaleY = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;\r\n    var aspectRatio = _ref7.aspectRatio,\r\n        naturalWidth = _ref7.naturalWidth,\r\n        naturalHeight = _ref7.naturalHeight;\r\n    var _ref8$fillColor = _ref8.fillColor,\r\n        fillColor = _ref8$fillColor === void 0 ? 'transparent' : _ref8$fillColor,\r\n        _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,\r\n        imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE,\r\n        _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,\r\n        imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? 'low' : _ref8$imageSmoothingQ,\r\n        _ref8$maxWidth = _ref8.maxWidth,\r\n        maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth,\r\n        _ref8$maxHeight = _ref8.maxHeight,\r\n        maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight,\r\n        _ref8$minWidth = _ref8.minWidth,\r\n        minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth,\r\n        _ref8$minHeight = _ref8.minHeight,\r\n        minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;\r\n    var canvas = document.createElement('canvas');\r\n    var context = canvas.getContext('2d');\r\n    var maxSizes = getAdjustedSizes({\r\n      aspectRatio: aspectRatio,\r\n      width: maxWidth,\r\n      height: maxHeight\r\n    });\r\n    var minSizes = getAdjustedSizes({\r\n      aspectRatio: aspectRatio,\r\n      width: minWidth,\r\n      height: minHeight\r\n    }, 'cover');\r\n    var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));\r\n    var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight)); // Note: should always use image's natural sizes for drawing as\r\n    // imageData.naturalWidth === canvasData.naturalHeight when rotate % 180 === 90\r\n\r\n    var destMaxSizes = getAdjustedSizes({\r\n      aspectRatio: imageAspectRatio,\r\n      width: maxWidth,\r\n      height: maxHeight\r\n    });\r\n    var destMinSizes = getAdjustedSizes({\r\n      aspectRatio: imageAspectRatio,\r\n      width: minWidth,\r\n      height: minHeight\r\n    }, 'cover');\r\n    var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));\r\n    var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));\r\n    var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];\r\n    canvas.width = normalizeDecimalNumber(width);\r\n    canvas.height = normalizeDecimalNumber(height);\r\n    context.fillStyle = fillColor;\r\n    context.fillRect(0, 0, width, height);\r\n    context.save();\r\n    context.translate(width / 2, height / 2);\r\n    context.rotate(rotate * Math.PI / 180);\r\n    context.scale(scaleX, scaleY);\r\n    context.imageSmoothingEnabled = imageSmoothingEnabled;\r\n    context.imageSmoothingQuality = imageSmoothingQuality;\r\n    context.drawImage.apply(context, [image].concat(_toConsumableArray(params.map(function (param) {\r\n      return Math.floor(normalizeDecimalNumber(param));\r\n    }))));\r\n    context.restore();\r\n    return canvas;\r\n  }\r\n  var fromCharCode = String.fromCharCode;\r\n  /**\r\n   * Get string from char code in data view.\r\n   * @param {DataView} dataView - The data view for read.\r\n   * @param {number} start - The start index.\r\n   * @param {number} length - The read length.\r\n   * @returns {string} The read result.\r\n   */\r\n\r\n  function getStringFromCharCode(dataView, start, length) {\r\n    var str = '';\r\n    length += start;\r\n\r\n    for (var i = start; i < length; i += 1) {\r\n      str += fromCharCode(dataView.getUint8(i));\r\n    }\r\n\r\n    return str;\r\n  }\r\n  var REGEXP_DATA_URL_HEAD = /^data:.*,/;\r\n  /**\r\n   * Transform Data URL to array buffer.\r\n   * @param {string} dataURL - The Data URL to transform.\r\n   * @returns {ArrayBuffer} The result array buffer.\r\n   */\r\n\r\n  function dataURLToArrayBuffer(dataURL) {\r\n    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');\r\n    var binary = atob(base64);\r\n    var arrayBuffer = new ArrayBuffer(binary.length);\r\n    var uint8 = new Uint8Array(arrayBuffer);\r\n    forEach(uint8, function (value, i) {\r\n      uint8[i] = binary.charCodeAt(i);\r\n    });\r\n    return arrayBuffer;\r\n  }\r\n  /**\r\n   * Transform array buffer to Data URL.\r\n   * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.\r\n   * @param {string} mimeType - The mime type of the Data URL.\r\n   * @returns {string} The result Data URL.\r\n   */\r\n\r\n  function arrayBufferToDataURL(arrayBuffer, mimeType) {\r\n    var chunks = []; // Chunk Typed Array for better performance (#435)\r\n\r\n    var chunkSize = 8192;\r\n    var uint8 = new Uint8Array(arrayBuffer);\r\n\r\n    while (uint8.length > 0) {\r\n      // XXX: Babel's `toConsumableArray` helper will throw error in IE or Safari 9\r\n      // eslint-disable-next-line prefer-spread\r\n      chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));\r\n      uint8 = uint8.subarray(chunkSize);\r\n    }\r\n\r\n    return \"data:\".concat(mimeType, \";base64,\").concat(btoa(chunks.join('')));\r\n  }\r\n  /**\r\n   * Get orientation value from given array buffer.\r\n   * @param {ArrayBuffer} arrayBuffer - The array buffer to read.\r\n   * @returns {number} The read orientation value.\r\n   */\r\n\r\n  function resetAndGetOrientation(arrayBuffer) {\r\n    var dataView = new DataView(arrayBuffer);\r\n    var orientation; // Ignores range error when the image does not have correct Exif information\r\n\r\n    try {\r\n      var littleEndian;\r\n      var app1Start;\r\n      var ifdStart; // Only handle JPEG image (start by 0xFFD8)\r\n\r\n      if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {\r\n        var length = dataView.byteLength;\r\n        var offset = 2;\r\n\r\n        while (offset + 1 < length) {\r\n          if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {\r\n            app1Start = offset;\r\n            break;\r\n          }\r\n\r\n          offset += 1;\r\n        }\r\n      }\r\n\r\n      if (app1Start) {\r\n        var exifIDCode = app1Start + 4;\r\n        var tiffOffset = app1Start + 10;\r\n\r\n        if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\r\n          var endianness = dataView.getUint16(tiffOffset);\r\n          littleEndian = endianness === 0x4949;\r\n\r\n          if (littleEndian || endianness === 0x4D4D\r\n          /* bigEndian */\r\n          ) {\r\n              if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {\r\n                var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\r\n\r\n                if (firstIFDOffset >= 0x00000008) {\r\n                  ifdStart = tiffOffset + firstIFDOffset;\r\n                }\r\n              }\r\n            }\r\n        }\r\n      }\r\n\r\n      if (ifdStart) {\r\n        var _length = dataView.getUint16(ifdStart, littleEndian);\r\n\r\n        var _offset;\r\n\r\n        var i;\r\n\r\n        for (i = 0; i < _length; i += 1) {\r\n          _offset = ifdStart + i * 12 + 2;\r\n\r\n          if (dataView.getUint16(_offset, littleEndian) === 0x0112\r\n          /* Orientation */\r\n          ) {\r\n              // 8 is the offset of the current tag's value\r\n              _offset += 8; // Get the original orientation value\r\n\r\n              orientation = dataView.getUint16(_offset, littleEndian); // Override the orientation with its default value\r\n\r\n              dataView.setUint16(_offset, 1, littleEndian);\r\n              break;\r\n            }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      orientation = 1;\r\n    }\r\n\r\n    return orientation;\r\n  }\r\n  /**\r\n   * Parse Exif Orientation value.\r\n   * @param {number} orientation - The orientation to parse.\r\n   * @returns {Object} The parsed result.\r\n   */\r\n\r\n  function parseOrientation(orientation) {\r\n    var rotate = 0;\r\n    var scaleX = 1;\r\n    var scaleY = 1;\r\n\r\n    switch (orientation) {\r\n      // Flip horizontal\r\n      case 2:\r\n        scaleX = -1;\r\n        break;\r\n      // Rotate left 180°\r\n\r\n      case 3:\r\n        rotate = -180;\r\n        break;\r\n      // Flip vertical\r\n\r\n      case 4:\r\n        scaleY = -1;\r\n        break;\r\n      // Flip vertical and rotate right 90°\r\n\r\n      case 5:\r\n        rotate = 90;\r\n        scaleY = -1;\r\n        break;\r\n      // Rotate right 90°\r\n\r\n      case 6:\r\n        rotate = 90;\r\n        break;\r\n      // Flip horizontal and rotate right 90°\r\n\r\n      case 7:\r\n        rotate = 90;\r\n        scaleX = -1;\r\n        break;\r\n      // Rotate left 90°\r\n\r\n      case 8:\r\n        rotate = -90;\r\n        break;\r\n    }\r\n\r\n    return {\r\n      rotate: rotate,\r\n      scaleX: scaleX,\r\n      scaleY: scaleY\r\n    };\r\n  }\r\n\r\n  var render = {\r\n    render: function render() {\r\n      this.initContainer();\r\n      this.initCanvas();\r\n      this.initCropBox();\r\n      this.renderCanvas();\r\n\r\n      if (this.cropped) {\r\n        this.renderCropBox();\r\n      }\r\n    },\r\n    initContainer: function initContainer() {\r\n      var element = this.element,\r\n          options = this.options,\r\n          container = this.container,\r\n          cropper = this.cropper;\r\n      var minWidth = Number(options.minContainerWidth);\r\n      var minHeight = Number(options.minContainerHeight);\r\n      addClass(cropper, CLASS_HIDDEN);\r\n      removeClass(element, CLASS_HIDDEN);\r\n      var containerData = {\r\n        width: Math.max(container.offsetWidth, minWidth >= 0 ? minWidth : MIN_CONTAINER_WIDTH),\r\n        height: Math.max(container.offsetHeight, minHeight >= 0 ? minHeight : MIN_CONTAINER_HEIGHT)\r\n      };\r\n      this.containerData = containerData;\r\n      setStyle(cropper, {\r\n        width: containerData.width,\r\n        height: containerData.height\r\n      });\r\n      addClass(element, CLASS_HIDDEN);\r\n      removeClass(cropper, CLASS_HIDDEN);\r\n    },\r\n    // Canvas (image wrapper)\r\n    initCanvas: function initCanvas() {\r\n      var containerData = this.containerData,\r\n          imageData = this.imageData;\r\n      var viewMode = this.options.viewMode;\r\n      var rotated = Math.abs(imageData.rotate) % 180 === 90;\r\n      var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;\r\n      var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;\r\n      var aspectRatio = naturalWidth / naturalHeight;\r\n      var canvasWidth = containerData.width;\r\n      var canvasHeight = containerData.height;\r\n\r\n      if (containerData.height * aspectRatio > containerData.width) {\r\n        if (viewMode === 3) {\r\n          canvasWidth = containerData.height * aspectRatio;\r\n        } else {\r\n          canvasHeight = containerData.width / aspectRatio;\r\n        }\r\n      } else if (viewMode === 3) {\r\n        canvasHeight = containerData.width / aspectRatio;\r\n      } else {\r\n        canvasWidth = containerData.height * aspectRatio;\r\n      }\r\n\r\n      var canvasData = {\r\n        aspectRatio: aspectRatio,\r\n        naturalWidth: naturalWidth,\r\n        naturalHeight: naturalHeight,\r\n        width: canvasWidth,\r\n        height: canvasHeight\r\n      };\r\n      this.canvasData = canvasData;\r\n      this.limited = viewMode === 1 || viewMode === 2;\r\n      this.limitCanvas(true, true);\r\n      canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);\r\n      canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);\r\n      canvasData.left = (containerData.width - canvasData.width) / 2;\r\n      canvasData.top = (containerData.height - canvasData.height) / 2;\r\n      canvasData.oldLeft = canvasData.left;\r\n      canvasData.oldTop = canvasData.top;\r\n      this.initialCanvasData = assign({}, canvasData);\r\n    },\r\n    limitCanvas: function limitCanvas(sizeLimited, positionLimited) {\r\n      var options = this.options,\r\n          containerData = this.containerData,\r\n          canvasData = this.canvasData,\r\n          cropBoxData = this.cropBoxData;\r\n      var viewMode = options.viewMode;\r\n      var aspectRatio = canvasData.aspectRatio;\r\n      var cropped = this.cropped && cropBoxData;\r\n\r\n      if (sizeLimited) {\r\n        var minCanvasWidth = Number(options.minCanvasWidth) || 0;\r\n        var minCanvasHeight = Number(options.minCanvasHeight) || 0;\r\n\r\n        if (viewMode > 1) {\r\n          minCanvasWidth = Math.max(minCanvasWidth, containerData.width);\r\n          minCanvasHeight = Math.max(minCanvasHeight, containerData.height);\r\n\r\n          if (viewMode === 3) {\r\n            if (minCanvasHeight * aspectRatio > minCanvasWidth) {\r\n              minCanvasWidth = minCanvasHeight * aspectRatio;\r\n            } else {\r\n              minCanvasHeight = minCanvasWidth / aspectRatio;\r\n            }\r\n          }\r\n        } else if (viewMode > 0) {\r\n          if (minCanvasWidth) {\r\n            minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);\r\n          } else if (minCanvasHeight) {\r\n            minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);\r\n          } else if (cropped) {\r\n            minCanvasWidth = cropBoxData.width;\r\n            minCanvasHeight = cropBoxData.height;\r\n\r\n            if (minCanvasHeight * aspectRatio > minCanvasWidth) {\r\n              minCanvasWidth = minCanvasHeight * aspectRatio;\r\n            } else {\r\n              minCanvasHeight = minCanvasWidth / aspectRatio;\r\n            }\r\n          }\r\n        }\r\n\r\n        var _getAdjustedSizes = getAdjustedSizes({\r\n          aspectRatio: aspectRatio,\r\n          width: minCanvasWidth,\r\n          height: minCanvasHeight\r\n        });\r\n\r\n        minCanvasWidth = _getAdjustedSizes.width;\r\n        minCanvasHeight = _getAdjustedSizes.height;\r\n        canvasData.minWidth = minCanvasWidth;\r\n        canvasData.minHeight = minCanvasHeight;\r\n        canvasData.maxWidth = Infinity;\r\n        canvasData.maxHeight = Infinity;\r\n      }\r\n\r\n      if (positionLimited) {\r\n        if (viewMode > (cropped ? 0 : 1)) {\r\n          var newCanvasLeft = containerData.width - canvasData.width;\r\n          var newCanvasTop = containerData.height - canvasData.height;\r\n          canvasData.minLeft = Math.min(0, newCanvasLeft);\r\n          canvasData.minTop = Math.min(0, newCanvasTop);\r\n          canvasData.maxLeft = Math.max(0, newCanvasLeft);\r\n          canvasData.maxTop = Math.max(0, newCanvasTop);\r\n\r\n          if (cropped && this.limited) {\r\n            canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));\r\n            canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));\r\n            canvasData.maxLeft = cropBoxData.left;\r\n            canvasData.maxTop = cropBoxData.top;\r\n\r\n            if (viewMode === 2) {\r\n              if (canvasData.width >= containerData.width) {\r\n                canvasData.minLeft = Math.min(0, newCanvasLeft);\r\n                canvasData.maxLeft = Math.max(0, newCanvasLeft);\r\n              }\r\n\r\n              if (canvasData.height >= containerData.height) {\r\n                canvasData.minTop = Math.min(0, newCanvasTop);\r\n                canvasData.maxTop = Math.max(0, newCanvasTop);\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          canvasData.minLeft = -canvasData.width;\r\n          canvasData.minTop = -canvasData.height;\r\n          canvasData.maxLeft = containerData.width;\r\n          canvasData.maxTop = containerData.height;\r\n        }\r\n      }\r\n    },\r\n    renderCanvas: function renderCanvas(changed, transformed) {\r\n      var canvasData = this.canvasData,\r\n          imageData = this.imageData;\r\n\r\n      if (transformed) {\r\n        var _getRotatedSizes = getRotatedSizes({\r\n          width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),\r\n          height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),\r\n          degree: imageData.rotate || 0\r\n        }),\r\n            naturalWidth = _getRotatedSizes.width,\r\n            naturalHeight = _getRotatedSizes.height;\r\n\r\n        var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);\r\n        var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);\r\n        canvasData.left -= (width - canvasData.width) / 2;\r\n        canvasData.top -= (height - canvasData.height) / 2;\r\n        canvasData.width = width;\r\n        canvasData.height = height;\r\n        canvasData.aspectRatio = naturalWidth / naturalHeight;\r\n        canvasData.naturalWidth = naturalWidth;\r\n        canvasData.naturalHeight = naturalHeight;\r\n        this.limitCanvas(true, false);\r\n      }\r\n\r\n      if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {\r\n        canvasData.left = canvasData.oldLeft;\r\n      }\r\n\r\n      if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {\r\n        canvasData.top = canvasData.oldTop;\r\n      }\r\n\r\n      canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);\r\n      canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);\r\n      this.limitCanvas(false, true);\r\n      canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);\r\n      canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);\r\n      canvasData.oldLeft = canvasData.left;\r\n      canvasData.oldTop = canvasData.top;\r\n      setStyle(this.canvas, assign({\r\n        width: canvasData.width,\r\n        height: canvasData.height\r\n      }, getTransforms({\r\n        translateX: canvasData.left,\r\n        translateY: canvasData.top\r\n      })));\r\n      this.renderImage(changed);\r\n\r\n      if (this.cropped && this.limited) {\r\n        this.limitCropBox(true, true);\r\n      }\r\n    },\r\n    renderImage: function renderImage(changed) {\r\n      var canvasData = this.canvasData,\r\n          imageData = this.imageData;\r\n      var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);\r\n      var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);\r\n      assign(imageData, {\r\n        width: width,\r\n        height: height,\r\n        left: (canvasData.width - width) / 2,\r\n        top: (canvasData.height - height) / 2\r\n      });\r\n      setStyle(this.image, assign({\r\n        width: imageData.width,\r\n        height: imageData.height\r\n      }, getTransforms(assign({\r\n        translateX: imageData.left,\r\n        translateY: imageData.top\r\n      }, imageData))));\r\n\r\n      if (changed) {\r\n        this.output();\r\n      }\r\n    },\r\n    initCropBox: function initCropBox() {\r\n      var options = this.options,\r\n          canvasData = this.canvasData;\r\n      var aspectRatio = options.aspectRatio || options.initialAspectRatio;\r\n      var autoCropArea = Number(options.autoCropArea) || 0.8;\r\n      var cropBoxData = {\r\n        width: canvasData.width,\r\n        height: canvasData.height\r\n      };\r\n\r\n      if (aspectRatio) {\r\n        if (canvasData.height * aspectRatio > canvasData.width) {\r\n          cropBoxData.height = cropBoxData.width / aspectRatio;\r\n        } else {\r\n          cropBoxData.width = cropBoxData.height * aspectRatio;\r\n        }\r\n      }\r\n\r\n      this.cropBoxData = cropBoxData;\r\n      this.limitCropBox(true, true); // Initialize auto crop area\r\n\r\n      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);\r\n      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight); // The width/height of auto crop area must large than \"minWidth/Height\"\r\n\r\n      cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);\r\n      cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);\r\n      cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;\r\n      cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;\r\n      cropBoxData.oldLeft = cropBoxData.left;\r\n      cropBoxData.oldTop = cropBoxData.top;\r\n      this.initialCropBoxData = assign({}, cropBoxData);\r\n    },\r\n    limitCropBox: function limitCropBox(sizeLimited, positionLimited) {\r\n      var options = this.options,\r\n          containerData = this.containerData,\r\n          canvasData = this.canvasData,\r\n          cropBoxData = this.cropBoxData,\r\n          limited = this.limited;\r\n      var aspectRatio = options.aspectRatio;\r\n\r\n      if (sizeLimited) {\r\n        var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;\r\n        var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;\r\n        var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;\r\n        var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height; // The min/maxCropBoxWidth/Height must be less than container's width/height\r\n\r\n        minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);\r\n        minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);\r\n\r\n        if (aspectRatio) {\r\n          if (minCropBoxWidth && minCropBoxHeight) {\r\n            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {\r\n              minCropBoxHeight = minCropBoxWidth / aspectRatio;\r\n            } else {\r\n              minCropBoxWidth = minCropBoxHeight * aspectRatio;\r\n            }\r\n          } else if (minCropBoxWidth) {\r\n            minCropBoxHeight = minCropBoxWidth / aspectRatio;\r\n          } else if (minCropBoxHeight) {\r\n            minCropBoxWidth = minCropBoxHeight * aspectRatio;\r\n          }\r\n\r\n          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {\r\n            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;\r\n          } else {\r\n            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;\r\n          }\r\n        } // The minWidth/Height must be less than maxWidth/Height\r\n\r\n\r\n        cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);\r\n        cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);\r\n        cropBoxData.maxWidth = maxCropBoxWidth;\r\n        cropBoxData.maxHeight = maxCropBoxHeight;\r\n      }\r\n\r\n      if (positionLimited) {\r\n        if (limited) {\r\n          cropBoxData.minLeft = Math.max(0, canvasData.left);\r\n          cropBoxData.minTop = Math.max(0, canvasData.top);\r\n          cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;\r\n          cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;\r\n        } else {\r\n          cropBoxData.minLeft = 0;\r\n          cropBoxData.minTop = 0;\r\n          cropBoxData.maxLeft = containerData.width - cropBoxData.width;\r\n          cropBoxData.maxTop = containerData.height - cropBoxData.height;\r\n        }\r\n      }\r\n    },\r\n    renderCropBox: function renderCropBox() {\r\n      var options = this.options,\r\n          containerData = this.containerData,\r\n          cropBoxData = this.cropBoxData;\r\n\r\n      if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {\r\n        cropBoxData.left = cropBoxData.oldLeft;\r\n      }\r\n\r\n      if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {\r\n        cropBoxData.top = cropBoxData.oldTop;\r\n      }\r\n\r\n      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);\r\n      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);\r\n      this.limitCropBox(false, true);\r\n      cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);\r\n      cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);\r\n      cropBoxData.oldLeft = cropBoxData.left;\r\n      cropBoxData.oldTop = cropBoxData.top;\r\n\r\n      if (options.movable && options.cropBoxMovable) {\r\n        // Turn to move the canvas when the crop box is equal to the container\r\n        setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);\r\n      }\r\n\r\n      setStyle(this.cropBox, assign({\r\n        width: cropBoxData.width,\r\n        height: cropBoxData.height\r\n      }, getTransforms({\r\n        translateX: cropBoxData.left,\r\n        translateY: cropBoxData.top\r\n      })));\r\n\r\n      if (this.cropped && this.limited) {\r\n        this.limitCanvas(true, true);\r\n      }\r\n\r\n      if (!this.disabled) {\r\n        this.output();\r\n      }\r\n    },\r\n    output: function output() {\r\n      this.preview();\r\n      dispatchEvent(this.element, EVENT_CROP, this.getData());\r\n    }\r\n  };\r\n\r\n  var preview = {\r\n    initPreview: function initPreview() {\r\n      var element = this.element,\r\n          crossOrigin = this.crossOrigin;\r\n      var preview = this.options.preview;\r\n      var url = crossOrigin ? this.crossOriginUrl : this.url;\r\n      var alt = element.alt || 'The image to preview';\r\n      var image = document.createElement('img');\r\n\r\n      if (crossOrigin) {\r\n        image.crossOrigin = crossOrigin;\r\n      }\r\n\r\n      image.src = url;\r\n      image.alt = alt;\r\n      this.viewBox.appendChild(image);\r\n      this.viewBoxImage = image;\r\n\r\n      if (!preview) {\r\n        return;\r\n      }\r\n\r\n      var previews = preview;\r\n\r\n      if (typeof preview === 'string') {\r\n        previews = element.ownerDocument.querySelectorAll(preview);\r\n      } else if (preview.querySelector) {\r\n        previews = [preview];\r\n      }\r\n\r\n      this.previews = previews;\r\n      forEach(previews, function (el) {\r\n        var img = document.createElement('img'); // Save the original size for recover\r\n\r\n        setData(el, DATA_PREVIEW, {\r\n          width: el.offsetWidth,\r\n          height: el.offsetHeight,\r\n          html: el.innerHTML\r\n        });\r\n\r\n        if (crossOrigin) {\r\n          img.crossOrigin = crossOrigin;\r\n        }\r\n\r\n        img.src = url;\r\n        img.alt = alt;\r\n        /**\r\n         * Override img element styles\r\n         * Add `display:block` to avoid margin top issue\r\n         * Add `height:auto` to override `height` attribute on IE8\r\n         * (Occur only when margin-top <= -height)\r\n         */\r\n\r\n        img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;\"';\r\n        el.innerHTML = '';\r\n        el.appendChild(img);\r\n      });\r\n    },\r\n    resetPreview: function resetPreview() {\r\n      forEach(this.previews, function (element) {\r\n        var data = getData(element, DATA_PREVIEW);\r\n        setStyle(element, {\r\n          width: data.width,\r\n          height: data.height\r\n        });\r\n        element.innerHTML = data.html;\r\n        removeData(element, DATA_PREVIEW);\r\n      });\r\n    },\r\n    preview: function preview() {\r\n      var imageData = this.imageData,\r\n          canvasData = this.canvasData,\r\n          cropBoxData = this.cropBoxData;\r\n      var cropBoxWidth = cropBoxData.width,\r\n          cropBoxHeight = cropBoxData.height;\r\n      var width = imageData.width,\r\n          height = imageData.height;\r\n      var left = cropBoxData.left - canvasData.left - imageData.left;\r\n      var top = cropBoxData.top - canvasData.top - imageData.top;\r\n\r\n      if (!this.cropped || this.disabled) {\r\n        return;\r\n      }\r\n\r\n      setStyle(this.viewBoxImage, assign({\r\n        width: width,\r\n        height: height\r\n      }, getTransforms(assign({\r\n        translateX: -left,\r\n        translateY: -top\r\n      }, imageData))));\r\n      forEach(this.previews, function (element) {\r\n        var data = getData(element, DATA_PREVIEW);\r\n        var originalWidth = data.width;\r\n        var originalHeight = data.height;\r\n        var newWidth = originalWidth;\r\n        var newHeight = originalHeight;\r\n        var ratio = 1;\r\n\r\n        if (cropBoxWidth) {\r\n          ratio = originalWidth / cropBoxWidth;\r\n          newHeight = cropBoxHeight * ratio;\r\n        }\r\n\r\n        if (cropBoxHeight && newHeight > originalHeight) {\r\n          ratio = originalHeight / cropBoxHeight;\r\n          newWidth = cropBoxWidth * ratio;\r\n          newHeight = originalHeight;\r\n        }\r\n\r\n        setStyle(element, {\r\n          width: newWidth,\r\n          height: newHeight\r\n        });\r\n        setStyle(element.getElementsByTagName('img')[0], assign({\r\n          width: width * ratio,\r\n          height: height * ratio\r\n        }, getTransforms(assign({\r\n          translateX: -left * ratio,\r\n          translateY: -top * ratio\r\n        }, imageData))));\r\n      });\r\n    }\r\n  };\r\n\r\n  var events = {\r\n    bind: function bind() {\r\n      var element = this.element,\r\n          options = this.options,\r\n          cropper = this.cropper;\r\n\r\n      if (isFunction(options.cropstart)) {\r\n        addListener(element, EVENT_CROP_START, options.cropstart);\r\n      }\r\n\r\n      if (isFunction(options.cropmove)) {\r\n        addListener(element, EVENT_CROP_MOVE, options.cropmove);\r\n      }\r\n\r\n      if (isFunction(options.cropend)) {\r\n        addListener(element, EVENT_CROP_END, options.cropend);\r\n      }\r\n\r\n      if (isFunction(options.crop)) {\r\n        addListener(element, EVENT_CROP, options.crop);\r\n      }\r\n\r\n      if (isFunction(options.zoom)) {\r\n        addListener(element, EVENT_ZOOM, options.zoom);\r\n      }\r\n\r\n      addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));\r\n\r\n      if (options.zoomable && options.zoomOnWheel) {\r\n        addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {\r\n          passive: false,\r\n          capture: true\r\n        });\r\n      }\r\n\r\n      if (options.toggleDragModeOnDblclick) {\r\n        addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));\r\n      }\r\n\r\n      addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));\r\n      addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));\r\n\r\n      if (options.responsive) {\r\n        addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));\r\n      }\r\n    },\r\n    unbind: function unbind() {\r\n      var element = this.element,\r\n          options = this.options,\r\n          cropper = this.cropper;\r\n\r\n      if (isFunction(options.cropstart)) {\r\n        removeListener(element, EVENT_CROP_START, options.cropstart);\r\n      }\r\n\r\n      if (isFunction(options.cropmove)) {\r\n        removeListener(element, EVENT_CROP_MOVE, options.cropmove);\r\n      }\r\n\r\n      if (isFunction(options.cropend)) {\r\n        removeListener(element, EVENT_CROP_END, options.cropend);\r\n      }\r\n\r\n      if (isFunction(options.crop)) {\r\n        removeListener(element, EVENT_CROP, options.crop);\r\n      }\r\n\r\n      if (isFunction(options.zoom)) {\r\n        removeListener(element, EVENT_ZOOM, options.zoom);\r\n      }\r\n\r\n      removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);\r\n\r\n      if (options.zoomable && options.zoomOnWheel) {\r\n        removeListener(cropper, EVENT_WHEEL, this.onWheel, {\r\n          passive: false,\r\n          capture: true\r\n        });\r\n      }\r\n\r\n      if (options.toggleDragModeOnDblclick) {\r\n        removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);\r\n      }\r\n\r\n      removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);\r\n      removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);\r\n\r\n      if (options.responsive) {\r\n        removeListener(window, EVENT_RESIZE, this.onResize);\r\n      }\r\n    }\r\n  };\r\n\r\n  var handlers = {\r\n    resize: function resize() {\r\n      if (this.disabled) {\r\n        return;\r\n      }\r\n\r\n      var options = this.options,\r\n          container = this.container,\r\n          containerData = this.containerData;\r\n      var ratioX = container.offsetWidth / containerData.width;\r\n      var ratioY = container.offsetHeight / containerData.height;\r\n      var ratio = Math.abs(ratioX - 1) > Math.abs(ratioY - 1) ? ratioX : ratioY; // Resize when width changed or height changed\r\n\r\n      if (ratio !== 1) {\r\n        var canvasData;\r\n        var cropBoxData;\r\n\r\n        if (options.restore) {\r\n          canvasData = this.getCanvasData();\r\n          cropBoxData = this.getCropBoxData();\r\n        }\r\n\r\n        this.render();\r\n\r\n        if (options.restore) {\r\n          this.setCanvasData(forEach(canvasData, function (n, i) {\r\n            canvasData[i] = n * ratio;\r\n          }));\r\n          this.setCropBoxData(forEach(cropBoxData, function (n, i) {\r\n            cropBoxData[i] = n * ratio;\r\n          }));\r\n        }\r\n      }\r\n    },\r\n    dblclick: function dblclick() {\r\n      if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {\r\n        return;\r\n      }\r\n\r\n      this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);\r\n    },\r\n    wheel: function wheel(event) {\r\n      var _this = this;\r\n\r\n      var ratio = Number(this.options.wheelZoomRatio) || 0.1;\r\n      var delta = 1;\r\n\r\n      if (this.disabled) {\r\n        return;\r\n      }\r\n\r\n      event.preventDefault(); // Limit wheel speed to prevent zoom too fast (#21)\r\n\r\n      if (this.wheeling) {\r\n        return;\r\n      }\r\n\r\n      this.wheeling = true;\r\n      setTimeout(function () {\r\n        _this.wheeling = false;\r\n      }, 50);\r\n\r\n      if (event.deltaY) {\r\n        delta = event.deltaY > 0 ? 1 : -1;\r\n      } else if (event.wheelDelta) {\r\n        delta = -event.wheelDelta / 120;\r\n      } else if (event.detail) {\r\n        delta = event.detail > 0 ? 1 : -1;\r\n      }\r\n\r\n      this.zoom(-delta * ratio, event);\r\n    },\r\n    cropStart: function cropStart(event) {\r\n      var buttons = event.buttons,\r\n          button = event.button;\r\n\r\n      if (this.disabled // Handle mouse event and pointer event and ignore touch event\r\n      || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && ( // No primary button (Usually the left button)\r\n      isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 // Open context menu\r\n      || event.ctrlKey)) {\r\n        return;\r\n      }\r\n\r\n      var options = this.options,\r\n          pointers = this.pointers;\r\n      var action;\r\n\r\n      if (event.changedTouches) {\r\n        // Handle touch event\r\n        forEach(event.changedTouches, function (touch) {\r\n          pointers[touch.identifier] = getPointer(touch);\r\n        });\r\n      } else {\r\n        // Handle mouse event and pointer event\r\n        pointers[event.pointerId || 0] = getPointer(event);\r\n      }\r\n\r\n      if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {\r\n        action = ACTION_ZOOM;\r\n      } else {\r\n        action = getData(event.target, DATA_ACTION);\r\n      }\r\n\r\n      if (!REGEXP_ACTIONS.test(action)) {\r\n        return;\r\n      }\r\n\r\n      if (dispatchEvent(this.element, EVENT_CROP_START, {\r\n        originalEvent: event,\r\n        action: action\r\n      }) === false) {\r\n        return;\r\n      } // This line is required for preventing page zooming in iOS browsers\r\n\r\n\r\n      event.preventDefault();\r\n      this.action = action;\r\n      this.cropping = false;\r\n\r\n      if (action === ACTION_CROP) {\r\n        this.cropping = true;\r\n        addClass(this.dragBox, CLASS_MODAL);\r\n      }\r\n    },\r\n    cropMove: function cropMove(event) {\r\n      var action = this.action;\r\n\r\n      if (this.disabled || !action) {\r\n        return;\r\n      }\r\n\r\n      var pointers = this.pointers;\r\n      event.preventDefault();\r\n\r\n      if (dispatchEvent(this.element, EVENT_CROP_MOVE, {\r\n        originalEvent: event,\r\n        action: action\r\n      }) === false) {\r\n        return;\r\n      }\r\n\r\n      if (event.changedTouches) {\r\n        forEach(event.changedTouches, function (touch) {\r\n          // The first parameter should not be undefined (#432)\r\n          assign(pointers[touch.identifier] || {}, getPointer(touch, true));\r\n        });\r\n      } else {\r\n        assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));\r\n      }\r\n\r\n      this.change(event);\r\n    },\r\n    cropEnd: function cropEnd(event) {\r\n      if (this.disabled) {\r\n        return;\r\n      }\r\n\r\n      var action = this.action,\r\n          pointers = this.pointers;\r\n\r\n      if (event.changedTouches) {\r\n        forEach(event.changedTouches, function (touch) {\r\n          delete pointers[touch.identifier];\r\n        });\r\n      } else {\r\n        delete pointers[event.pointerId || 0];\r\n      }\r\n\r\n      if (!action) {\r\n        return;\r\n      }\r\n\r\n      event.preventDefault();\r\n\r\n      if (!Object.keys(pointers).length) {\r\n        this.action = '';\r\n      }\r\n\r\n      if (this.cropping) {\r\n        this.cropping = false;\r\n        toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);\r\n      }\r\n\r\n      dispatchEvent(this.element, EVENT_CROP_END, {\r\n        originalEvent: event,\r\n        action: action\r\n      });\r\n    }\r\n  };\r\n\r\n  var change = {\r\n    change: function change(event) {\r\n      var options = this.options,\r\n          canvasData = this.canvasData,\r\n          containerData = this.containerData,\r\n          cropBoxData = this.cropBoxData,\r\n          pointers = this.pointers;\r\n      var action = this.action;\r\n      var aspectRatio = options.aspectRatio;\r\n      var left = cropBoxData.left,\r\n          top = cropBoxData.top,\r\n          width = cropBoxData.width,\r\n          height = cropBoxData.height;\r\n      var right = left + width;\r\n      var bottom = top + height;\r\n      var minLeft = 0;\r\n      var minTop = 0;\r\n      var maxWidth = containerData.width;\r\n      var maxHeight = containerData.height;\r\n      var renderable = true;\r\n      var offset; // Locking aspect ratio in \"free mode\" by holding shift key\r\n\r\n      if (!aspectRatio && event.shiftKey) {\r\n        aspectRatio = width && height ? width / height : 1;\r\n      }\r\n\r\n      if (this.limited) {\r\n        minLeft = cropBoxData.minLeft;\r\n        minTop = cropBoxData.minTop;\r\n        maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);\r\n        maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);\r\n      }\r\n\r\n      var pointer = pointers[Object.keys(pointers)[0]];\r\n      var range = {\r\n        x: pointer.endX - pointer.startX,\r\n        y: pointer.endY - pointer.startY\r\n      };\r\n\r\n      var check = function check(side) {\r\n        switch (side) {\r\n          case ACTION_EAST:\r\n            if (right + range.x > maxWidth) {\r\n              range.x = maxWidth - right;\r\n            }\r\n\r\n            break;\r\n\r\n          case ACTION_WEST:\r\n            if (left + range.x < minLeft) {\r\n              range.x = minLeft - left;\r\n            }\r\n\r\n            break;\r\n\r\n          case ACTION_NORTH:\r\n            if (top + range.y < minTop) {\r\n              range.y = minTop - top;\r\n            }\r\n\r\n            break;\r\n\r\n          case ACTION_SOUTH:\r\n            if (bottom + range.y > maxHeight) {\r\n              range.y = maxHeight - bottom;\r\n            }\r\n\r\n            break;\r\n        }\r\n      };\r\n\r\n      switch (action) {\r\n        // Move crop box\r\n        case ACTION_ALL:\r\n          left += range.x;\r\n          top += range.y;\r\n          break;\r\n        // Resize crop box\r\n\r\n        case ACTION_EAST:\r\n          if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {\r\n            renderable = false;\r\n            break;\r\n          }\r\n\r\n          check(ACTION_EAST);\r\n          width += range.x;\r\n\r\n          if (width < 0) {\r\n            action = ACTION_WEST;\r\n            width = -width;\r\n            left -= width;\r\n          }\r\n\r\n          if (aspectRatio) {\r\n            height = width / aspectRatio;\r\n            top += (cropBoxData.height - height) / 2;\r\n          }\r\n\r\n          break;\r\n\r\n        case ACTION_NORTH:\r\n          if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {\r\n            renderable = false;\r\n            break;\r\n          }\r\n\r\n          check(ACTION_NORTH);\r\n          height -= range.y;\r\n          top += range.y;\r\n\r\n          if (height < 0) {\r\n            action = ACTION_SOUTH;\r\n            height = -height;\r\n            top -= height;\r\n          }\r\n\r\n          if (aspectRatio) {\r\n            width = height * aspectRatio;\r\n            left += (cropBoxData.width - width) / 2;\r\n          }\r\n\r\n          break;\r\n\r\n        case ACTION_WEST:\r\n          if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {\r\n            renderable = false;\r\n            break;\r\n          }\r\n\r\n          check(ACTION_WEST);\r\n          width -= range.x;\r\n          left += range.x;\r\n\r\n          if (width < 0) {\r\n            action = ACTION_EAST;\r\n            width = -width;\r\n            left -= width;\r\n          }\r\n\r\n          if (aspectRatio) {\r\n            height = width / aspectRatio;\r\n            top += (cropBoxData.height - height) / 2;\r\n          }\r\n\r\n          break;\r\n\r\n        case ACTION_SOUTH:\r\n          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {\r\n            renderable = false;\r\n            break;\r\n          }\r\n\r\n          check(ACTION_SOUTH);\r\n          height += range.y;\r\n\r\n          if (height < 0) {\r\n            action = ACTION_NORTH;\r\n            height = -height;\r\n            top -= height;\r\n          }\r\n\r\n          if (aspectRatio) {\r\n            width = height * aspectRatio;\r\n            left += (cropBoxData.width - width) / 2;\r\n          }\r\n\r\n          break;\r\n\r\n        case ACTION_NORTH_EAST:\r\n          if (aspectRatio) {\r\n            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {\r\n              renderable = false;\r\n              break;\r\n            }\r\n\r\n            check(ACTION_NORTH);\r\n            height -= range.y;\r\n            top += range.y;\r\n            width = height * aspectRatio;\r\n          } else {\r\n            check(ACTION_NORTH);\r\n            check(ACTION_EAST);\r\n\r\n            if (range.x >= 0) {\r\n              if (right < maxWidth) {\r\n                width += range.x;\r\n              } else if (range.y <= 0 && top <= minTop) {\r\n                renderable = false;\r\n              }\r\n            } else {\r\n              width += range.x;\r\n            }\r\n\r\n            if (range.y <= 0) {\r\n              if (top > minTop) {\r\n                height -= range.y;\r\n                top += range.y;\r\n              }\r\n            } else {\r\n              height -= range.y;\r\n              top += range.y;\r\n            }\r\n          }\r\n\r\n          if (width < 0 && height < 0) {\r\n            action = ACTION_SOUTH_WEST;\r\n            height = -height;\r\n            width = -width;\r\n            top -= height;\r\n            left -= width;\r\n          } else if (width < 0) {\r\n            action = ACTION_NORTH_WEST;\r\n            width = -width;\r\n            left -= width;\r\n          } else if (height < 0) {\r\n            action = ACTION_SOUTH_EAST;\r\n            height = -height;\r\n            top -= height;\r\n          }\r\n\r\n          break;\r\n\r\n        case ACTION_NORTH_WEST:\r\n          if (aspectRatio) {\r\n            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {\r\n              renderable = false;\r\n              break;\r\n            }\r\n\r\n            check(ACTION_NORTH);\r\n            height -= range.y;\r\n            top += range.y;\r\n            width = height * aspectRatio;\r\n            left += cropBoxData.width - width;\r\n          } else {\r\n            check(ACTION_NORTH);\r\n            check(ACTION_WEST);\r\n\r\n            if (range.x <= 0) {\r\n              if (left > minLeft) {\r\n                width -= range.x;\r\n                left += range.x;\r\n              } else if (range.y <= 0 && top <= minTop) {\r\n                renderable = false;\r\n              }\r\n            } else {\r\n              width -= range.x;\r\n              left += range.x;\r\n            }\r\n\r\n            if (range.y <= 0) {\r\n              if (top > minTop) {\r\n                height -= range.y;\r\n                top += range.y;\r\n              }\r\n            } else {\r\n              height -= range.y;\r\n              top += range.y;\r\n            }\r\n          }\r\n\r\n          if (width < 0 && height < 0) {\r\n            action = ACTION_SOUTH_EAST;\r\n            height = -height;\r\n            width = -width;\r\n            top -= height;\r\n            left -= width;\r\n          } else if (width < 0) {\r\n            action = ACTION_NORTH_EAST;\r\n            width = -width;\r\n            left -= width;\r\n          } else if (height < 0) {\r\n            action = ACTION_SOUTH_WEST;\r\n            height = -height;\r\n            top -= height;\r\n          }\r\n\r\n          break;\r\n\r\n        case ACTION_SOUTH_WEST:\r\n          if (aspectRatio) {\r\n            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {\r\n              renderable = false;\r\n              break;\r\n            }\r\n\r\n            check(ACTION_WEST);\r\n            width -= range.x;\r\n            left += range.x;\r\n            height = width / aspectRatio;\r\n          } else {\r\n            check(ACTION_SOUTH);\r\n            check(ACTION_WEST);\r\n\r\n            if (range.x <= 0) {\r\n              if (left > minLeft) {\r\n                width -= range.x;\r\n                left += range.x;\r\n              } else if (range.y >= 0 && bottom >= maxHeight) {\r\n                renderable = false;\r\n              }\r\n            } else {\r\n              width -= range.x;\r\n              left += range.x;\r\n            }\r\n\r\n            if (range.y >= 0) {\r\n              if (bottom < maxHeight) {\r\n                height += range.y;\r\n              }\r\n            } else {\r\n              height += range.y;\r\n            }\r\n          }\r\n\r\n          if (width < 0 && height < 0) {\r\n            action = ACTION_NORTH_EAST;\r\n            height = -height;\r\n            width = -width;\r\n            top -= height;\r\n            left -= width;\r\n          } else if (width < 0) {\r\n            action = ACTION_SOUTH_EAST;\r\n            width = -width;\r\n            left -= width;\r\n          } else if (height < 0) {\r\n            action = ACTION_NORTH_WEST;\r\n            height = -height;\r\n            top -= height;\r\n          }\r\n\r\n          break;\r\n\r\n        case ACTION_SOUTH_EAST:\r\n          if (aspectRatio) {\r\n            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {\r\n              renderable = false;\r\n              break;\r\n            }\r\n\r\n            check(ACTION_EAST);\r\n            width += range.x;\r\n            height = width / aspectRatio;\r\n          } else {\r\n            check(ACTION_SOUTH);\r\n            check(ACTION_EAST);\r\n\r\n            if (range.x >= 0) {\r\n              if (right < maxWidth) {\r\n                width += range.x;\r\n              } else if (range.y >= 0 && bottom >= maxHeight) {\r\n                renderable = false;\r\n              }\r\n            } else {\r\n              width += range.x;\r\n            }\r\n\r\n            if (range.y >= 0) {\r\n              if (bottom < maxHeight) {\r\n                height += range.y;\r\n              }\r\n            } else {\r\n              height += range.y;\r\n            }\r\n          }\r\n\r\n          if (width < 0 && height < 0) {\r\n            action = ACTION_NORTH_WEST;\r\n            height = -height;\r\n            width = -width;\r\n            top -= height;\r\n            left -= width;\r\n          } else if (width < 0) {\r\n            action = ACTION_SOUTH_WEST;\r\n            width = -width;\r\n            left -= width;\r\n          } else if (height < 0) {\r\n            action = ACTION_NORTH_EAST;\r\n            height = -height;\r\n            top -= height;\r\n          }\r\n\r\n          break;\r\n        // Move canvas\r\n\r\n        case ACTION_MOVE:\r\n          this.move(range.x, range.y);\r\n          renderable = false;\r\n          break;\r\n        // Zoom canvas\r\n\r\n        case ACTION_ZOOM:\r\n          this.zoom(getMaxZoomRatio(pointers), event);\r\n          renderable = false;\r\n          break;\r\n        // Create crop box\r\n\r\n        case ACTION_CROP:\r\n          if (!range.x || !range.y) {\r\n            renderable = false;\r\n            break;\r\n          }\r\n\r\n          offset = getOffset(this.cropper);\r\n          left = pointer.startX - offset.left;\r\n          top = pointer.startY - offset.top;\r\n          width = cropBoxData.minWidth;\r\n          height = cropBoxData.minHeight;\r\n\r\n          if (range.x > 0) {\r\n            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;\r\n          } else if (range.x < 0) {\r\n            left -= width;\r\n            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;\r\n          }\r\n\r\n          if (range.y < 0) {\r\n            top -= height;\r\n          } // Show the crop box if is hidden\r\n\r\n\r\n          if (!this.cropped) {\r\n            removeClass(this.cropBox, CLASS_HIDDEN);\r\n            this.cropped = true;\r\n\r\n            if (this.limited) {\r\n              this.limitCropBox(true, true);\r\n            }\r\n          }\r\n\r\n          break;\r\n      }\r\n\r\n      if (renderable) {\r\n        cropBoxData.width = width;\r\n        cropBoxData.height = height;\r\n        cropBoxData.left = left;\r\n        cropBoxData.top = top;\r\n        this.action = action;\r\n        this.renderCropBox();\r\n      } // Override\r\n\r\n\r\n      forEach(pointers, function (p) {\r\n        p.startX = p.endX;\r\n        p.startY = p.endY;\r\n      });\r\n    }\r\n  };\r\n\r\n  var methods = {\r\n    // Show the crop box manually\r\n    crop: function crop() {\r\n      if (this.ready && !this.cropped && !this.disabled) {\r\n        this.cropped = true;\r\n        this.limitCropBox(true, true);\r\n\r\n        if (this.options.modal) {\r\n          addClass(this.dragBox, CLASS_MODAL);\r\n        }\r\n\r\n        removeClass(this.cropBox, CLASS_HIDDEN);\r\n        this.setCropBoxData(this.initialCropBoxData);\r\n      }\r\n\r\n      return this;\r\n    },\r\n    // Reset the image and crop box to their initial states\r\n    reset: function reset() {\r\n      if (this.ready && !this.disabled) {\r\n        this.imageData = assign({}, this.initialImageData);\r\n        this.canvasData = assign({}, this.initialCanvasData);\r\n        this.cropBoxData = assign({}, this.initialCropBoxData);\r\n        this.renderCanvas();\r\n\r\n        if (this.cropped) {\r\n          this.renderCropBox();\r\n        }\r\n      }\r\n\r\n      return this;\r\n    },\r\n    // Clear the crop box\r\n    clear: function clear() {\r\n      if (this.cropped && !this.disabled) {\r\n        assign(this.cropBoxData, {\r\n          left: 0,\r\n          top: 0,\r\n          width: 0,\r\n          height: 0\r\n        });\r\n        this.cropped = false;\r\n        this.renderCropBox();\r\n        this.limitCanvas(true, true); // Render canvas after crop box rendered\r\n\r\n        this.renderCanvas();\r\n        removeClass(this.dragBox, CLASS_MODAL);\r\n        addClass(this.cropBox, CLASS_HIDDEN);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Replace the image's src and rebuild the cropper\r\n     * @param {string} url - The new URL.\r\n     * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.\r\n     * @returns {Cropper} this\r\n     */\r\n    replace: function replace(url) {\r\n      var hasSameSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n\r\n      if (!this.disabled && url) {\r\n        if (this.isImg) {\r\n          this.element.src = url;\r\n        }\r\n\r\n        if (hasSameSize) {\r\n          this.url = url;\r\n          this.image.src = url;\r\n\r\n          if (this.ready) {\r\n            this.viewBoxImage.src = url;\r\n            forEach(this.previews, function (element) {\r\n              element.getElementsByTagName('img')[0].src = url;\r\n            });\r\n          }\r\n        } else {\r\n          if (this.isImg) {\r\n            this.replaced = true;\r\n          }\r\n\r\n          this.options.data = null;\r\n          this.uncreate();\r\n          this.load(url);\r\n        }\r\n      }\r\n\r\n      return this;\r\n    },\r\n    // Enable (unfreeze) the cropper\r\n    enable: function enable() {\r\n      if (this.ready && this.disabled) {\r\n        this.disabled = false;\r\n        removeClass(this.cropper, CLASS_DISABLED);\r\n      }\r\n\r\n      return this;\r\n    },\r\n    // Disable (freeze) the cropper\r\n    disable: function disable() {\r\n      if (this.ready && !this.disabled) {\r\n        this.disabled = true;\r\n        addClass(this.cropper, CLASS_DISABLED);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy the cropper and remove the instance from the image\r\n     * @returns {Cropper} this\r\n     */\r\n    destroy: function destroy() {\r\n      var element = this.element;\r\n\r\n      if (!element[NAMESPACE]) {\r\n        return this;\r\n      }\r\n\r\n      element[NAMESPACE] = undefined;\r\n\r\n      if (this.isImg && this.replaced) {\r\n        element.src = this.originalUrl;\r\n      }\r\n\r\n      this.uncreate();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Move the canvas with relative offsets\r\n     * @param {number} offsetX - The relative offset distance on the x-axis.\r\n     * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.\r\n     * @returns {Cropper} this\r\n     */\r\n    move: function move(offsetX) {\r\n      var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : offsetX;\r\n      var _this$canvasData = this.canvasData,\r\n          left = _this$canvasData.left,\r\n          top = _this$canvasData.top;\r\n      return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));\r\n    },\r\n\r\n    /**\r\n     * Move the canvas to an absolute point\r\n     * @param {number} x - The x-axis coordinate.\r\n     * @param {number} [y=x] - The y-axis coordinate.\r\n     * @returns {Cropper} this\r\n     */\r\n    moveTo: function moveTo(x) {\r\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\r\n      var canvasData = this.canvasData;\r\n      var changed = false;\r\n      x = Number(x);\r\n      y = Number(y);\r\n\r\n      if (this.ready && !this.disabled && this.options.movable) {\r\n        if (isNumber(x)) {\r\n          canvasData.left = x;\r\n          changed = true;\r\n        }\r\n\r\n        if (isNumber(y)) {\r\n          canvasData.top = y;\r\n          changed = true;\r\n        }\r\n\r\n        if (changed) {\r\n          this.renderCanvas(true);\r\n        }\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Zoom the canvas with a relative ratio\r\n     * @param {number} ratio - The target ratio.\r\n     * @param {Event} _originalEvent - The original event if any.\r\n     * @returns {Cropper} this\r\n     */\r\n    zoom: function zoom(ratio, _originalEvent) {\r\n      var canvasData = this.canvasData;\r\n      ratio = Number(ratio);\r\n\r\n      if (ratio < 0) {\r\n        ratio = 1 / (1 - ratio);\r\n      } else {\r\n        ratio = 1 + ratio;\r\n      }\r\n\r\n      return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);\r\n    },\r\n\r\n    /**\r\n     * Zoom the canvas to an absolute ratio\r\n     * @param {number} ratio - The target ratio.\r\n     * @param {Object} pivot - The zoom pivot point coordinate.\r\n     * @param {Event} _originalEvent - The original event if any.\r\n     * @returns {Cropper} this\r\n     */\r\n    zoomTo: function zoomTo(ratio, pivot, _originalEvent) {\r\n      var options = this.options,\r\n          canvasData = this.canvasData;\r\n      var width = canvasData.width,\r\n          height = canvasData.height,\r\n          naturalWidth = canvasData.naturalWidth,\r\n          naturalHeight = canvasData.naturalHeight;\r\n      ratio = Number(ratio);\r\n\r\n      if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {\r\n        var newWidth = naturalWidth * ratio;\r\n        var newHeight = naturalHeight * ratio;\r\n\r\n        if (dispatchEvent(this.element, EVENT_ZOOM, {\r\n          ratio: ratio,\r\n          oldRatio: width / naturalWidth,\r\n          originalEvent: _originalEvent\r\n        }) === false) {\r\n          return this;\r\n        }\r\n\r\n        if (_originalEvent) {\r\n          var pointers = this.pointers;\r\n          var offset = getOffset(this.cropper);\r\n          var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {\r\n            pageX: _originalEvent.pageX,\r\n            pageY: _originalEvent.pageY\r\n          }; // Zoom from the triggering point of the event\r\n\r\n          canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);\r\n          canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);\r\n        } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {\r\n          canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);\r\n          canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);\r\n        } else {\r\n          // Zoom from the center of the canvas\r\n          canvasData.left -= (newWidth - width) / 2;\r\n          canvasData.top -= (newHeight - height) / 2;\r\n        }\r\n\r\n        canvasData.width = newWidth;\r\n        canvasData.height = newHeight;\r\n        this.renderCanvas(true);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate the canvas with a relative degree\r\n     * @param {number} degree - The rotate degree.\r\n     * @returns {Cropper} this\r\n     */\r\n    rotate: function rotate(degree) {\r\n      return this.rotateTo((this.imageData.rotate || 0) + Number(degree));\r\n    },\r\n\r\n    /**\r\n     * Rotate the canvas to an absolute degree\r\n     * @param {number} degree - The rotate degree.\r\n     * @returns {Cropper} this\r\n     */\r\n    rotateTo: function rotateTo(degree) {\r\n      degree = Number(degree);\r\n\r\n      if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {\r\n        this.imageData.rotate = degree % 360;\r\n        this.renderCanvas(true, true);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Scale the image on the x-axis.\r\n     * @param {number} scaleX - The scale ratio on the x-axis.\r\n     * @returns {Cropper} this\r\n     */\r\n    scaleX: function scaleX(_scaleX) {\r\n      var scaleY = this.imageData.scaleY;\r\n      return this.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);\r\n    },\r\n\r\n    /**\r\n     * Scale the image on the y-axis.\r\n     * @param {number} scaleY - The scale ratio on the y-axis.\r\n     * @returns {Cropper} this\r\n     */\r\n    scaleY: function scaleY(_scaleY) {\r\n      var scaleX = this.imageData.scaleX;\r\n      return this.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);\r\n    },\r\n\r\n    /**\r\n     * Scale the image\r\n     * @param {number} scaleX - The scale ratio on the x-axis.\r\n     * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.\r\n     * @returns {Cropper} this\r\n     */\r\n    scale: function scale(scaleX) {\r\n      var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;\r\n      var imageData = this.imageData;\r\n      var transformed = false;\r\n      scaleX = Number(scaleX);\r\n      scaleY = Number(scaleY);\r\n\r\n      if (this.ready && !this.disabled && this.options.scalable) {\r\n        if (isNumber(scaleX)) {\r\n          imageData.scaleX = scaleX;\r\n          transformed = true;\r\n        }\r\n\r\n        if (isNumber(scaleY)) {\r\n          imageData.scaleY = scaleY;\r\n          transformed = true;\r\n        }\r\n\r\n        if (transformed) {\r\n          this.renderCanvas(true, true);\r\n        }\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Get the cropped area position and size data (base on the original image)\r\n     * @param {boolean} [rounded=false] - Indicate if round the data values or not.\r\n     * @returns {Object} The result cropped data.\r\n     */\r\n    getData: function getData() {\r\n      var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n      var options = this.options,\r\n          imageData = this.imageData,\r\n          canvasData = this.canvasData,\r\n          cropBoxData = this.cropBoxData;\r\n      var data;\r\n\r\n      if (this.ready && this.cropped) {\r\n        data = {\r\n          x: cropBoxData.left - canvasData.left,\r\n          y: cropBoxData.top - canvasData.top,\r\n          width: cropBoxData.width,\r\n          height: cropBoxData.height\r\n        };\r\n        var ratio = imageData.width / imageData.naturalWidth;\r\n        forEach(data, function (n, i) {\r\n          data[i] = n / ratio;\r\n        });\r\n\r\n        if (rounded) {\r\n          // In case rounding off leads to extra 1px in right or bottom border\r\n          // we should round the top-left corner and the dimension (#343).\r\n          var bottom = Math.round(data.y + data.height);\r\n          var right = Math.round(data.x + data.width);\r\n          data.x = Math.round(data.x);\r\n          data.y = Math.round(data.y);\r\n          data.width = right - data.x;\r\n          data.height = bottom - data.y;\r\n        }\r\n      } else {\r\n        data = {\r\n          x: 0,\r\n          y: 0,\r\n          width: 0,\r\n          height: 0\r\n        };\r\n      }\r\n\r\n      if (options.rotatable) {\r\n        data.rotate = imageData.rotate || 0;\r\n      }\r\n\r\n      if (options.scalable) {\r\n        data.scaleX = imageData.scaleX || 1;\r\n        data.scaleY = imageData.scaleY || 1;\r\n      }\r\n\r\n      return data;\r\n    },\r\n\r\n    /**\r\n     * Set the cropped area position and size with new data\r\n     * @param {Object} data - The new data.\r\n     * @returns {Cropper} this\r\n     */\r\n    setData: function setData(data) {\r\n      var options = this.options,\r\n          imageData = this.imageData,\r\n          canvasData = this.canvasData;\r\n      var cropBoxData = {};\r\n\r\n      if (this.ready && !this.disabled && isPlainObject(data)) {\r\n        var transformed = false;\r\n\r\n        if (options.rotatable) {\r\n          if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {\r\n            imageData.rotate = data.rotate;\r\n            transformed = true;\r\n          }\r\n        }\r\n\r\n        if (options.scalable) {\r\n          if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {\r\n            imageData.scaleX = data.scaleX;\r\n            transformed = true;\r\n          }\r\n\r\n          if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {\r\n            imageData.scaleY = data.scaleY;\r\n            transformed = true;\r\n          }\r\n        }\r\n\r\n        if (transformed) {\r\n          this.renderCanvas(true, true);\r\n        }\r\n\r\n        var ratio = imageData.width / imageData.naturalWidth;\r\n\r\n        if (isNumber(data.x)) {\r\n          cropBoxData.left = data.x * ratio + canvasData.left;\r\n        }\r\n\r\n        if (isNumber(data.y)) {\r\n          cropBoxData.top = data.y * ratio + canvasData.top;\r\n        }\r\n\r\n        if (isNumber(data.width)) {\r\n          cropBoxData.width = data.width * ratio;\r\n        }\r\n\r\n        if (isNumber(data.height)) {\r\n          cropBoxData.height = data.height * ratio;\r\n        }\r\n\r\n        this.setCropBoxData(cropBoxData);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Get the container size data.\r\n     * @returns {Object} The result container data.\r\n     */\r\n    getContainerData: function getContainerData() {\r\n      return this.ready ? assign({}, this.containerData) : {};\r\n    },\r\n\r\n    /**\r\n     * Get the image position and size data.\r\n     * @returns {Object} The result image data.\r\n     */\r\n    getImageData: function getImageData() {\r\n      return this.sized ? assign({}, this.imageData) : {};\r\n    },\r\n\r\n    /**\r\n     * Get the canvas position and size data.\r\n     * @returns {Object} The result canvas data.\r\n     */\r\n    getCanvasData: function getCanvasData() {\r\n      var canvasData = this.canvasData;\r\n      var data = {};\r\n\r\n      if (this.ready) {\r\n        forEach(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (n) {\r\n          data[n] = canvasData[n];\r\n        });\r\n      }\r\n\r\n      return data;\r\n    },\r\n\r\n    /**\r\n     * Set the canvas position and size with new data.\r\n     * @param {Object} data - The new canvas data.\r\n     * @returns {Cropper} this\r\n     */\r\n    setCanvasData: function setCanvasData(data) {\r\n      var canvasData = this.canvasData;\r\n      var aspectRatio = canvasData.aspectRatio;\r\n\r\n      if (this.ready && !this.disabled && isPlainObject(data)) {\r\n        if (isNumber(data.left)) {\r\n          canvasData.left = data.left;\r\n        }\r\n\r\n        if (isNumber(data.top)) {\r\n          canvasData.top = data.top;\r\n        }\r\n\r\n        if (isNumber(data.width)) {\r\n          canvasData.width = data.width;\r\n          canvasData.height = data.width / aspectRatio;\r\n        } else if (isNumber(data.height)) {\r\n          canvasData.height = data.height;\r\n          canvasData.width = data.height * aspectRatio;\r\n        }\r\n\r\n        this.renderCanvas(true);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Get the crop box position and size data.\r\n     * @returns {Object} The result crop box data.\r\n     */\r\n    getCropBoxData: function getCropBoxData() {\r\n      var cropBoxData = this.cropBoxData;\r\n      var data;\r\n\r\n      if (this.ready && this.cropped) {\r\n        data = {\r\n          left: cropBoxData.left,\r\n          top: cropBoxData.top,\r\n          width: cropBoxData.width,\r\n          height: cropBoxData.height\r\n        };\r\n      }\r\n\r\n      return data || {};\r\n    },\r\n\r\n    /**\r\n     * Set the crop box position and size with new data.\r\n     * @param {Object} data - The new crop box data.\r\n     * @returns {Cropper} this\r\n     */\r\n    setCropBoxData: function setCropBoxData(data) {\r\n      var cropBoxData = this.cropBoxData;\r\n      var aspectRatio = this.options.aspectRatio;\r\n      var widthChanged;\r\n      var heightChanged;\r\n\r\n      if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {\r\n        if (isNumber(data.left)) {\r\n          cropBoxData.left = data.left;\r\n        }\r\n\r\n        if (isNumber(data.top)) {\r\n          cropBoxData.top = data.top;\r\n        }\r\n\r\n        if (isNumber(data.width) && data.width !== cropBoxData.width) {\r\n          widthChanged = true;\r\n          cropBoxData.width = data.width;\r\n        }\r\n\r\n        if (isNumber(data.height) && data.height !== cropBoxData.height) {\r\n          heightChanged = true;\r\n          cropBoxData.height = data.height;\r\n        }\r\n\r\n        if (aspectRatio) {\r\n          if (widthChanged) {\r\n            cropBoxData.height = cropBoxData.width / aspectRatio;\r\n          } else if (heightChanged) {\r\n            cropBoxData.width = cropBoxData.height * aspectRatio;\r\n          }\r\n        }\r\n\r\n        this.renderCropBox();\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Get a canvas drawn the cropped image.\r\n     * @param {Object} [options={}] - The config options.\r\n     * @returns {HTMLCanvasElement} - The result canvas.\r\n     */\r\n    getCroppedCanvas: function getCroppedCanvas() {\r\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n\r\n      if (!this.ready || !window.HTMLCanvasElement) {\r\n        return null;\r\n      }\r\n\r\n      var canvasData = this.canvasData;\r\n      var source = getSourceCanvas(this.image, this.imageData, canvasData, options); // Returns the source canvas if it is not cropped.\r\n\r\n      if (!this.cropped) {\r\n        return source;\r\n      }\r\n\r\n      var _this$getData = this.getData(),\r\n          initialX = _this$getData.x,\r\n          initialY = _this$getData.y,\r\n          initialWidth = _this$getData.width,\r\n          initialHeight = _this$getData.height;\r\n\r\n      var ratio = source.width / Math.floor(canvasData.naturalWidth);\r\n\r\n      if (ratio !== 1) {\r\n        initialX *= ratio;\r\n        initialY *= ratio;\r\n        initialWidth *= ratio;\r\n        initialHeight *= ratio;\r\n      }\r\n\r\n      var aspectRatio = initialWidth / initialHeight;\r\n      var maxSizes = getAdjustedSizes({\r\n        aspectRatio: aspectRatio,\r\n        width: options.maxWidth || Infinity,\r\n        height: options.maxHeight || Infinity\r\n      });\r\n      var minSizes = getAdjustedSizes({\r\n        aspectRatio: aspectRatio,\r\n        width: options.minWidth || 0,\r\n        height: options.minHeight || 0\r\n      }, 'cover');\r\n\r\n      var _getAdjustedSizes = getAdjustedSizes({\r\n        aspectRatio: aspectRatio,\r\n        width: options.width || (ratio !== 1 ? source.width : initialWidth),\r\n        height: options.height || (ratio !== 1 ? source.height : initialHeight)\r\n      }),\r\n          width = _getAdjustedSizes.width,\r\n          height = _getAdjustedSizes.height;\r\n\r\n      width = Math.min(maxSizes.width, Math.max(minSizes.width, width));\r\n      height = Math.min(maxSizes.height, Math.max(minSizes.height, height));\r\n      var canvas = document.createElement('canvas');\r\n      var context = canvas.getContext('2d');\r\n      canvas.width = normalizeDecimalNumber(width);\r\n      canvas.height = normalizeDecimalNumber(height);\r\n      context.fillStyle = options.fillColor || 'transparent';\r\n      context.fillRect(0, 0, width, height);\r\n      var _options$imageSmoothi = options.imageSmoothingEnabled,\r\n          imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi,\r\n          imageSmoothingQuality = options.imageSmoothingQuality;\r\n      context.imageSmoothingEnabled = imageSmoothingEnabled;\r\n\r\n      if (imageSmoothingQuality) {\r\n        context.imageSmoothingQuality = imageSmoothingQuality;\r\n      } // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage\r\n\r\n\r\n      var sourceWidth = source.width;\r\n      var sourceHeight = source.height; // Source canvas parameters\r\n\r\n      var srcX = initialX;\r\n      var srcY = initialY;\r\n      var srcWidth;\r\n      var srcHeight; // Destination canvas parameters\r\n\r\n      var dstX;\r\n      var dstY;\r\n      var dstWidth;\r\n      var dstHeight;\r\n\r\n      if (srcX <= -initialWidth || srcX > sourceWidth) {\r\n        srcX = 0;\r\n        srcWidth = 0;\r\n        dstX = 0;\r\n        dstWidth = 0;\r\n      } else if (srcX <= 0) {\r\n        dstX = -srcX;\r\n        srcX = 0;\r\n        srcWidth = Math.min(sourceWidth, initialWidth + srcX);\r\n        dstWidth = srcWidth;\r\n      } else if (srcX <= sourceWidth) {\r\n        dstX = 0;\r\n        srcWidth = Math.min(initialWidth, sourceWidth - srcX);\r\n        dstWidth = srcWidth;\r\n      }\r\n\r\n      if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {\r\n        srcY = 0;\r\n        srcHeight = 0;\r\n        dstY = 0;\r\n        dstHeight = 0;\r\n      } else if (srcY <= 0) {\r\n        dstY = -srcY;\r\n        srcY = 0;\r\n        srcHeight = Math.min(sourceHeight, initialHeight + srcY);\r\n        dstHeight = srcHeight;\r\n      } else if (srcY <= sourceHeight) {\r\n        dstY = 0;\r\n        srcHeight = Math.min(initialHeight, sourceHeight - srcY);\r\n        dstHeight = srcHeight;\r\n      }\r\n\r\n      var params = [srcX, srcY, srcWidth, srcHeight]; // Avoid \"IndexSizeError\"\r\n\r\n      if (dstWidth > 0 && dstHeight > 0) {\r\n        var scale = width / initialWidth;\r\n        params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);\r\n      } // All the numerical parameters should be integer for `drawImage`\r\n      // https://github.com/fengyuanchen/cropper/issues/476\r\n\r\n\r\n      context.drawImage.apply(context, [source].concat(_toConsumableArray(params.map(function (param) {\r\n        return Math.floor(normalizeDecimalNumber(param));\r\n      }))));\r\n      return canvas;\r\n    },\r\n\r\n    /**\r\n     * Change the aspect ratio of the crop box.\r\n     * @param {number} aspectRatio - The new aspect ratio.\r\n     * @returns {Cropper} this\r\n     */\r\n    setAspectRatio: function setAspectRatio(aspectRatio) {\r\n      var options = this.options;\r\n\r\n      if (!this.disabled && !isUndefined(aspectRatio)) {\r\n        // 0 -> NaN\r\n        options.aspectRatio = Math.max(0, aspectRatio) || NaN;\r\n\r\n        if (this.ready) {\r\n          this.initCropBox();\r\n\r\n          if (this.cropped) {\r\n            this.renderCropBox();\r\n          }\r\n        }\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Change the drag mode.\r\n     * @param {string} mode - The new drag mode.\r\n     * @returns {Cropper} this\r\n     */\r\n    setDragMode: function setDragMode(mode) {\r\n      var options = this.options,\r\n          dragBox = this.dragBox,\r\n          face = this.face;\r\n\r\n      if (this.ready && !this.disabled) {\r\n        var croppable = mode === DRAG_MODE_CROP;\r\n        var movable = options.movable && mode === DRAG_MODE_MOVE;\r\n        mode = croppable || movable ? mode : DRAG_MODE_NONE;\r\n        options.dragMode = mode;\r\n        setData(dragBox, DATA_ACTION, mode);\r\n        toggleClass(dragBox, CLASS_CROP, croppable);\r\n        toggleClass(dragBox, CLASS_MOVE, movable);\r\n\r\n        if (!options.cropBoxMovable) {\r\n          // Sync drag mode to crop box when it is not movable\r\n          setData(face, DATA_ACTION, mode);\r\n          toggleClass(face, CLASS_CROP, croppable);\r\n          toggleClass(face, CLASS_MOVE, movable);\r\n        }\r\n      }\r\n\r\n      return this;\r\n    }\r\n  };\r\n\r\n  var AnotherCropper = WINDOW.Cropper;\r\n\r\n  var Cropper = /*#__PURE__*/function () {\r\n    /**\r\n     * Create a new Cropper.\r\n     * @param {Element} element - The target element for cropping.\r\n     * @param {Object} [options={}] - The configuration options.\r\n     */\r\n    function Cropper(element) {\r\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n\r\n      _classCallCheck(this, Cropper);\r\n\r\n      if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {\r\n        throw new Error('The first argument is required and must be an <img> or <canvas> element.');\r\n      }\r\n\r\n      this.element = element;\r\n      this.options = assign({}, DEFAULTS, isPlainObject(options) && options);\r\n      this.cropped = false;\r\n      this.disabled = false;\r\n      this.pointers = {};\r\n      this.ready = false;\r\n      this.reloading = false;\r\n      this.replaced = false;\r\n      this.sized = false;\r\n      this.sizing = false;\r\n      this.init();\r\n    }\r\n\r\n    _createClass(Cropper, [{\r\n      key: \"init\",\r\n      value: function init() {\r\n        var element = this.element;\r\n        var tagName = element.tagName.toLowerCase();\r\n        var url;\r\n\r\n        if (element[NAMESPACE]) {\r\n          return;\r\n        }\r\n\r\n        element[NAMESPACE] = this;\r\n\r\n        if (tagName === 'img') {\r\n          this.isImg = true; // e.g.: \"img/picture.jpg\"\r\n\r\n          url = element.getAttribute('src') || '';\r\n          this.originalUrl = url; // Stop when it's a blank image\r\n\r\n          if (!url) {\r\n            return;\r\n          } // e.g.: \"https://example.com/img/picture.jpg\"\r\n\r\n\r\n          url = element.src;\r\n        } else if (tagName === 'canvas' && window.HTMLCanvasElement) {\r\n          url = element.toDataURL();\r\n        }\r\n\r\n        this.load(url);\r\n      }\r\n    }, {\r\n      key: \"load\",\r\n      value: function load(url) {\r\n        var _this = this;\r\n\r\n        if (!url) {\r\n          return;\r\n        }\r\n\r\n        this.url = url;\r\n        this.imageData = {};\r\n        var element = this.element,\r\n            options = this.options;\r\n\r\n        if (!options.rotatable && !options.scalable) {\r\n          options.checkOrientation = false;\r\n        } // Only IE10+ supports Typed Arrays\r\n\r\n\r\n        if (!options.checkOrientation || !window.ArrayBuffer) {\r\n          this.clone();\r\n          return;\r\n        } // Detect the mime type of the image directly if it is a Data URL\r\n\r\n\r\n        if (REGEXP_DATA_URL.test(url)) {\r\n          // Read ArrayBuffer from Data URL of JPEG images directly for better performance\r\n          if (REGEXP_DATA_URL_JPEG.test(url)) {\r\n            this.read(dataURLToArrayBuffer(url));\r\n          } else {\r\n            // Only a JPEG image may contains Exif Orientation information,\r\n            // the rest types of Data URLs are not necessary to check orientation at all.\r\n            this.clone();\r\n          }\r\n\r\n          return;\r\n        } // 1. Detect the mime type of the image by a XMLHttpRequest.\r\n        // 2. Load the image as ArrayBuffer for reading orientation if its a JPEG image.\r\n\r\n\r\n        var xhr = new XMLHttpRequest();\r\n        var clone = this.clone.bind(this);\r\n        this.reloading = true;\r\n        this.xhr = xhr; // 1. Cross origin requests are only supported for protocol schemes:\r\n        // http, https, data, chrome, chrome-extension.\r\n        // 2. Access to XMLHttpRequest from a Data URL will be blocked by CORS policy\r\n        // in some browsers as IE11 and Safari.\r\n\r\n        xhr.onabort = clone;\r\n        xhr.onerror = clone;\r\n        xhr.ontimeout = clone;\r\n\r\n        xhr.onprogress = function () {\r\n          // Abort the request directly if it not a JPEG image for better performance\r\n          if (xhr.getResponseHeader('content-type') !== MIME_TYPE_JPEG) {\r\n            xhr.abort();\r\n          }\r\n        };\r\n\r\n        xhr.onload = function () {\r\n          _this.read(xhr.response);\r\n        };\r\n\r\n        xhr.onloadend = function () {\r\n          _this.reloading = false;\r\n          _this.xhr = null;\r\n        }; // Bust cache when there is a \"crossOrigin\" property to avoid browser cache error\r\n\r\n\r\n        if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {\r\n          url = addTimestamp(url);\r\n        } // The third parameter is required for avoiding side-effect (#682)\r\n\r\n\r\n        xhr.open('GET', url, true);\r\n        xhr.responseType = 'arraybuffer';\r\n        xhr.withCredentials = element.crossOrigin === 'use-credentials';\r\n        xhr.send();\r\n      }\r\n    }, {\r\n      key: \"read\",\r\n      value: function read(arrayBuffer) {\r\n        var options = this.options,\r\n            imageData = this.imageData; // Reset the orientation value to its default value 1\r\n        // as some iOS browsers will render image with its orientation\r\n\r\n        var orientation = resetAndGetOrientation(arrayBuffer);\r\n        var rotate = 0;\r\n        var scaleX = 1;\r\n        var scaleY = 1;\r\n\r\n        if (orientation > 1) {\r\n          // Generate a new URL which has the default orientation value\r\n          this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);\r\n\r\n          var _parseOrientation = parseOrientation(orientation);\r\n\r\n          rotate = _parseOrientation.rotate;\r\n          scaleX = _parseOrientation.scaleX;\r\n          scaleY = _parseOrientation.scaleY;\r\n        }\r\n\r\n        if (options.rotatable) {\r\n          imageData.rotate = rotate;\r\n        }\r\n\r\n        if (options.scalable) {\r\n          imageData.scaleX = scaleX;\r\n          imageData.scaleY = scaleY;\r\n        }\r\n\r\n        this.clone();\r\n      }\r\n    }, {\r\n      key: \"clone\",\r\n      value: function clone() {\r\n        var element = this.element,\r\n            url = this.url;\r\n        var crossOrigin = element.crossOrigin;\r\n        var crossOriginUrl = url;\r\n\r\n        if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {\r\n          if (!crossOrigin) {\r\n            crossOrigin = 'anonymous';\r\n          } // Bust cache when there is not a \"crossOrigin\" property (#519)\r\n\r\n\r\n          crossOriginUrl = addTimestamp(url);\r\n        }\r\n\r\n        this.crossOrigin = crossOrigin;\r\n        this.crossOriginUrl = crossOriginUrl;\r\n        var image = document.createElement('img');\r\n\r\n        if (crossOrigin) {\r\n          image.crossOrigin = crossOrigin;\r\n        }\r\n\r\n        image.src = crossOriginUrl || url;\r\n        image.alt = element.alt || 'The image to crop';\r\n        this.image = image;\r\n        image.onload = this.start.bind(this);\r\n        image.onerror = this.stop.bind(this);\r\n        addClass(image, CLASS_HIDE);\r\n        element.parentNode.insertBefore(image, element.nextSibling);\r\n      }\r\n    }, {\r\n      key: \"start\",\r\n      value: function start() {\r\n        var _this2 = this;\r\n\r\n        var image = this.image;\r\n        image.onload = null;\r\n        image.onerror = null;\r\n        this.sizing = true; // Match all browsers that use WebKit as the layout engine in iOS devices,\r\n        // such as Safari for iOS, Chrome for iOS, and in-app browsers.\r\n\r\n        var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);\r\n\r\n        var done = function done(naturalWidth, naturalHeight) {\r\n          assign(_this2.imageData, {\r\n            naturalWidth: naturalWidth,\r\n            naturalHeight: naturalHeight,\r\n            aspectRatio: naturalWidth / naturalHeight\r\n          });\r\n          _this2.initialImageData = assign({}, _this2.imageData);\r\n          _this2.sizing = false;\r\n          _this2.sized = true;\r\n\r\n          _this2.build();\r\n        }; // Most modern browsers (excepts iOS WebKit)\r\n\r\n\r\n        if (image.naturalWidth && !isIOSWebKit) {\r\n          done(image.naturalWidth, image.naturalHeight);\r\n          return;\r\n        }\r\n\r\n        var sizingImage = document.createElement('img');\r\n        var body = document.body || document.documentElement;\r\n        this.sizingImage = sizingImage;\r\n\r\n        sizingImage.onload = function () {\r\n          done(sizingImage.width, sizingImage.height);\r\n\r\n          if (!isIOSWebKit) {\r\n            body.removeChild(sizingImage);\r\n          }\r\n        };\r\n\r\n        sizingImage.src = image.src; // iOS WebKit will convert the image automatically\r\n        // with its orientation once append it into DOM (#279)\r\n\r\n        if (!isIOSWebKit) {\r\n          sizingImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';\r\n          body.appendChild(sizingImage);\r\n        }\r\n      }\r\n    }, {\r\n      key: \"stop\",\r\n      value: function stop() {\r\n        var image = this.image;\r\n        image.onload = null;\r\n        image.onerror = null;\r\n        image.parentNode.removeChild(image);\r\n        this.image = null;\r\n      }\r\n    }, {\r\n      key: \"build\",\r\n      value: function build() {\r\n        if (!this.sized || this.ready) {\r\n          return;\r\n        }\r\n\r\n        var element = this.element,\r\n            options = this.options,\r\n            image = this.image; // Create cropper elements\r\n\r\n        var container = element.parentNode;\r\n        var template = document.createElement('div');\r\n        template.innerHTML = TEMPLATE;\r\n        var cropper = template.querySelector(\".\".concat(NAMESPACE, \"-container\"));\r\n        var canvas = cropper.querySelector(\".\".concat(NAMESPACE, \"-canvas\"));\r\n        var dragBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-drag-box\"));\r\n        var cropBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-crop-box\"));\r\n        var face = cropBox.querySelector(\".\".concat(NAMESPACE, \"-face\"));\r\n        this.container = container;\r\n        this.cropper = cropper;\r\n        this.canvas = canvas;\r\n        this.dragBox = dragBox;\r\n        this.cropBox = cropBox;\r\n        this.viewBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-view-box\"));\r\n        this.face = face;\r\n        canvas.appendChild(image); // Hide the original image\r\n\r\n        addClass(element, CLASS_HIDDEN); // Inserts the cropper after to the current image\r\n\r\n        container.insertBefore(cropper, element.nextSibling); // Show the image if is hidden\r\n\r\n        if (!this.isImg) {\r\n          removeClass(image, CLASS_HIDE);\r\n        }\r\n\r\n        this.initPreview();\r\n        this.bind();\r\n        options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;\r\n        options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;\r\n        options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;\r\n        addClass(cropBox, CLASS_HIDDEN);\r\n\r\n        if (!options.guides) {\r\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-dashed\")), CLASS_HIDDEN);\r\n        }\r\n\r\n        if (!options.center) {\r\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-center\")), CLASS_HIDDEN);\r\n        }\r\n\r\n        if (options.background) {\r\n          addClass(cropper, \"\".concat(NAMESPACE, \"-bg\"));\r\n        }\r\n\r\n        if (!options.highlight) {\r\n          addClass(face, CLASS_INVISIBLE);\r\n        }\r\n\r\n        if (options.cropBoxMovable) {\r\n          addClass(face, CLASS_MOVE);\r\n          setData(face, DATA_ACTION, ACTION_ALL);\r\n        }\r\n\r\n        if (!options.cropBoxResizable) {\r\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-line\")), CLASS_HIDDEN);\r\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-point\")), CLASS_HIDDEN);\r\n        }\r\n\r\n        this.render();\r\n        this.ready = true;\r\n        this.setDragMode(options.dragMode);\r\n\r\n        if (options.autoCrop) {\r\n          this.crop();\r\n        }\r\n\r\n        this.setData(options.data);\r\n\r\n        if (isFunction(options.ready)) {\r\n          addListener(element, EVENT_READY, options.ready, {\r\n            once: true\r\n          });\r\n        }\r\n\r\n        dispatchEvent(element, EVENT_READY);\r\n      }\r\n    }, {\r\n      key: \"unbuild\",\r\n      value: function unbuild() {\r\n        if (!this.ready) {\r\n          return;\r\n        }\r\n\r\n        this.ready = false;\r\n        this.unbind();\r\n        this.resetPreview();\r\n        this.cropper.parentNode.removeChild(this.cropper);\r\n        removeClass(this.element, CLASS_HIDDEN);\r\n      }\r\n    }, {\r\n      key: \"uncreate\",\r\n      value: function uncreate() {\r\n        if (this.ready) {\r\n          this.unbuild();\r\n          this.ready = false;\r\n          this.cropped = false;\r\n        } else if (this.sizing) {\r\n          this.sizingImage.onload = null;\r\n          this.sizing = false;\r\n          this.sized = false;\r\n        } else if (this.reloading) {\r\n          this.xhr.onabort = null;\r\n          this.xhr.abort();\r\n        } else if (this.image) {\r\n          this.stop();\r\n        }\r\n      }\r\n      /**\r\n       * Get the no conflict cropper class.\r\n       * @returns {Cropper} The cropper class.\r\n       */\r\n\r\n    }], [{\r\n      key: \"noConflict\",\r\n      value: function noConflict() {\r\n        window.Cropper = AnotherCropper;\r\n        return Cropper;\r\n      }\r\n      /**\r\n       * Change the default options.\r\n       * @param {Object} options - The new default options.\r\n       */\r\n\r\n    }, {\r\n      key: \"setDefaults\",\r\n      value: function setDefaults(options) {\r\n        assign(DEFAULTS, isPlainObject(options) && options);\r\n      }\r\n    }]);\r\n\r\n    return Cropper;\r\n  }();\r\n\r\n  assign(Cropper.prototype, render, preview, events, handlers, change, methods);\r\n\r\n  return Cropper;\r\n\r\n})));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLENBQ3NHO0FBQ3hHLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxTQUFTO0FBQ1QsUUFBUTtBQUNSLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlC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VUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywrQkFBK0IsOEJBQThCLDRCQUE0QiwyQkFBMkIsZUFBZSx1QkFBdUIsV0FBVyxnQkFBZ0I7QUFDbk87QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLHlDQUF5QztBQUN6QztBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcm9wcGVyanMvZGlzdC9jcm9wcGVyLmpzP2Q4ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXHJcbiAqIENyb3BwZXIuanMgdjEuNS4xMlxyXG4gKiBodHRwczovL2Zlbmd5dWFuY2hlbi5naXRodWIuaW8vY3JvcHBlcmpzXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQgQ2hlbiBGZW5neXVhblxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICpcclxuICogRGF0ZTogMjAyMS0wNi0xMlQwODowMDoxNy40MTFaXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XHJcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcclxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuQ3JvcHBlciA9IGZhY3RvcnkoKSk7XHJcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcclxuXHJcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xyXG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcclxuXHJcbiAgICAgIGlmIChlbnVtZXJhYmxlT25seSkge1xyXG4gICAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XHJcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBrZXlzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcclxuXHJcbiAgICAgIGlmIChpICUgMikge1xyXG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcclxuICAgIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcclxuXHJcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcclxuICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcclxuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XHJcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcclxuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xyXG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XHJcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcclxuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcclxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcclxuICAgIGlmIChrZXkgaW4gb2JqKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xyXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9iajtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcclxuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xyXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XHJcbiAgICBpZiAoIW8pIHJldHVybjtcclxuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XHJcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XHJcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XHJcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xyXG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xyXG5cclxuICAgIHJldHVybiBhcnIyO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XHJcbiAgfVxyXG5cclxuICB2YXIgSVNfQlJPV1NFUiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xyXG4gIHZhciBXSU5ET1cgPSBJU19CUk9XU0VSID8gd2luZG93IDoge307XHJcbiAgdmFyIElTX1RPVUNIX0RFVklDRSA9IElTX0JST1dTRVIgJiYgV0lORE9XLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICdvbnRvdWNoc3RhcnQnIGluIFdJTkRPVy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBmYWxzZTtcclxuICB2YXIgSEFTX1BPSU5URVJfRVZFTlQgPSBJU19CUk9XU0VSID8gJ1BvaW50ZXJFdmVudCcgaW4gV0lORE9XIDogZmFsc2U7XHJcbiAgdmFyIE5BTUVTUEFDRSA9ICdjcm9wcGVyJzsgLy8gQWN0aW9uc1xyXG5cclxuICB2YXIgQUNUSU9OX0FMTCA9ICdhbGwnO1xyXG4gIHZhciBBQ1RJT05fQ1JPUCA9ICdjcm9wJztcclxuICB2YXIgQUNUSU9OX01PVkUgPSAnbW92ZSc7XHJcbiAgdmFyIEFDVElPTl9aT09NID0gJ3pvb20nO1xyXG4gIHZhciBBQ1RJT05fRUFTVCA9ICdlJztcclxuICB2YXIgQUNUSU9OX1dFU1QgPSAndyc7XHJcbiAgdmFyIEFDVElPTl9TT1VUSCA9ICdzJztcclxuICB2YXIgQUNUSU9OX05PUlRIID0gJ24nO1xyXG4gIHZhciBBQ1RJT05fTk9SVEhfRUFTVCA9ICduZSc7XHJcbiAgdmFyIEFDVElPTl9OT1JUSF9XRVNUID0gJ253JztcclxuICB2YXIgQUNUSU9OX1NPVVRIX0VBU1QgPSAnc2UnO1xyXG4gIHZhciBBQ1RJT05fU09VVEhfV0VTVCA9ICdzdyc7IC8vIENsYXNzZXNcclxuXHJcbiAgdmFyIENMQVNTX0NST1AgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWNyb3BcIik7XHJcbiAgdmFyIENMQVNTX0RJU0FCTEVEID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1kaXNhYmxlZFwiKTtcclxuICB2YXIgQ0xBU1NfSElEREVOID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1oaWRkZW5cIik7XHJcbiAgdmFyIENMQVNTX0hJREUgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWhpZGVcIik7XHJcbiAgdmFyIENMQVNTX0lOVklTSUJMRSA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItaW52aXNpYmxlXCIpO1xyXG4gIHZhciBDTEFTU19NT0RBTCA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItbW9kYWxcIik7XHJcbiAgdmFyIENMQVNTX01PVkUgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLW1vdmVcIik7IC8vIERhdGEga2V5c1xyXG5cclxuICB2YXIgREFUQV9BQ1RJT04gPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiQWN0aW9uXCIpO1xyXG4gIHZhciBEQVRBX1BSRVZJRVcgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiUHJldmlld1wiKTsgLy8gRHJhZyBtb2Rlc1xyXG5cclxuICB2YXIgRFJBR19NT0RFX0NST1AgPSAnY3JvcCc7XHJcbiAgdmFyIERSQUdfTU9ERV9NT1ZFID0gJ21vdmUnO1xyXG4gIHZhciBEUkFHX01PREVfTk9ORSA9ICdub25lJzsgLy8gRXZlbnRzXHJcblxyXG4gIHZhciBFVkVOVF9DUk9QID0gJ2Nyb3AnO1xyXG4gIHZhciBFVkVOVF9DUk9QX0VORCA9ICdjcm9wZW5kJztcclxuICB2YXIgRVZFTlRfQ1JPUF9NT1ZFID0gJ2Nyb3Btb3ZlJztcclxuICB2YXIgRVZFTlRfQ1JPUF9TVEFSVCA9ICdjcm9wc3RhcnQnO1xyXG4gIHZhciBFVkVOVF9EQkxDTElDSyA9ICdkYmxjbGljayc7XHJcbiAgdmFyIEVWRU5UX1RPVUNIX1NUQVJUID0gSVNfVE9VQ0hfREVWSUNFID8gJ3RvdWNoc3RhcnQnIDogJ21vdXNlZG93bic7XHJcbiAgdmFyIEVWRU5UX1RPVUNIX01PVkUgPSBJU19UT1VDSF9ERVZJQ0UgPyAndG91Y2htb3ZlJyA6ICdtb3VzZW1vdmUnO1xyXG4gIHZhciBFVkVOVF9UT1VDSF9FTkQgPSBJU19UT1VDSF9ERVZJQ0UgPyAndG91Y2hlbmQgdG91Y2hjYW5jZWwnIDogJ21vdXNldXAnO1xyXG4gIHZhciBFVkVOVF9QT0lOVEVSX0RPV04gPSBIQVNfUE9JTlRFUl9FVkVOVCA/ICdwb2ludGVyZG93bicgOiBFVkVOVF9UT1VDSF9TVEFSVDtcclxuICB2YXIgRVZFTlRfUE9JTlRFUl9NT1ZFID0gSEFTX1BPSU5URVJfRVZFTlQgPyAncG9pbnRlcm1vdmUnIDogRVZFTlRfVE9VQ0hfTU9WRTtcclxuICB2YXIgRVZFTlRfUE9JTlRFUl9VUCA9IEhBU19QT0lOVEVSX0VWRU5UID8gJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJyA6IEVWRU5UX1RPVUNIX0VORDtcclxuICB2YXIgRVZFTlRfUkVBRFkgPSAncmVhZHknO1xyXG4gIHZhciBFVkVOVF9SRVNJWkUgPSAncmVzaXplJztcclxuICB2YXIgRVZFTlRfV0hFRUwgPSAnd2hlZWwnO1xyXG4gIHZhciBFVkVOVF9aT09NID0gJ3pvb20nOyAvLyBNaW1lIHR5cGVzXHJcblxyXG4gIHZhciBNSU1FX1RZUEVfSlBFRyA9ICdpbWFnZS9qcGVnJzsgLy8gUmVnRXhwc1xyXG5cclxuICB2YXIgUkVHRVhQX0FDVElPTlMgPSAvXmV8d3xzfG58c2V8c3d8bmV8bnd8YWxsfGNyb3B8bW92ZXx6b29tJC87XHJcbiAgdmFyIFJFR0VYUF9EQVRBX1VSTCA9IC9eZGF0YTovO1xyXG4gIHZhciBSRUdFWFBfREFUQV9VUkxfSlBFRyA9IC9eZGF0YTppbWFnZVxcL2pwZWc7YmFzZTY0LC87XHJcbiAgdmFyIFJFR0VYUF9UQUdfTkFNRSA9IC9eaW1nfGNhbnZhcyQvaTsgLy8gTWlzY1xyXG4gIC8vIEluc3BpcmVkIGJ5IHRoZSBkZWZhdWx0IHdpZHRoIGFuZCBoZWlnaHQgb2YgYSBjYW52YXMgZWxlbWVudC5cclxuXHJcbiAgdmFyIE1JTl9DT05UQUlORVJfV0lEVEggPSAyMDA7XHJcbiAgdmFyIE1JTl9DT05UQUlORVJfSEVJR0hUID0gMTAwO1xyXG5cclxuICB2YXIgREVGQVVMVFMgPSB7XHJcbiAgICAvLyBEZWZpbmUgdGhlIHZpZXcgbW9kZSBvZiB0aGUgY3JvcHBlclxyXG4gICAgdmlld01vZGU6IDAsXHJcbiAgICAvLyAwLCAxLCAyLCAzXHJcbiAgICAvLyBEZWZpbmUgdGhlIGRyYWdnaW5nIG1vZGUgb2YgdGhlIGNyb3BwZXJcclxuICAgIGRyYWdNb2RlOiBEUkFHX01PREVfQ1JPUCxcclxuICAgIC8vICdjcm9wJywgJ21vdmUnIG9yICdub25lJ1xyXG4gICAgLy8gRGVmaW5lIHRoZSBpbml0aWFsIGFzcGVjdCByYXRpbyBvZiB0aGUgY3JvcCBib3hcclxuICAgIGluaXRpYWxBc3BlY3RSYXRpbzogTmFOLFxyXG4gICAgLy8gRGVmaW5lIHRoZSBhc3BlY3QgcmF0aW8gb2YgdGhlIGNyb3AgYm94XHJcbiAgICBhc3BlY3RSYXRpbzogTmFOLFxyXG4gICAgLy8gQW4gb2JqZWN0IHdpdGggdGhlIHByZXZpb3VzIGNyb3BwaW5nIHJlc3VsdCBkYXRhXHJcbiAgICBkYXRhOiBudWxsLFxyXG4gICAgLy8gQSBzZWxlY3RvciBmb3IgYWRkaW5nIGV4dHJhIGNvbnRhaW5lcnMgdG8gcHJldmlld1xyXG4gICAgcHJldmlldzogJycsXHJcbiAgICAvLyBSZS1yZW5kZXIgdGhlIGNyb3BwZXIgd2hlbiByZXNpemUgdGhlIHdpbmRvd1xyXG4gICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuICAgIC8vIFJlc3RvcmUgdGhlIGNyb3BwZWQgYXJlYSBhZnRlciByZXNpemUgdGhlIHdpbmRvd1xyXG4gICAgcmVzdG9yZTogdHJ1ZSxcclxuICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGltYWdlIGlzIGEgY3Jvc3Mtb3JpZ2luIGltYWdlXHJcbiAgICBjaGVja0Nyb3NzT3JpZ2luOiB0cnVlLFxyXG4gICAgLy8gQ2hlY2sgdGhlIGN1cnJlbnQgaW1hZ2UncyBFeGlmIE9yaWVudGF0aW9uIGluZm9ybWF0aW9uXHJcbiAgICBjaGVja09yaWVudGF0aW9uOiB0cnVlLFxyXG4gICAgLy8gU2hvdyB0aGUgYmxhY2sgbW9kYWxcclxuICAgIG1vZGFsOiB0cnVlLFxyXG4gICAgLy8gU2hvdyB0aGUgZGFzaGVkIGxpbmVzIGZvciBndWlkaW5nXHJcbiAgICBndWlkZXM6IHRydWUsXHJcbiAgICAvLyBTaG93IHRoZSBjZW50ZXIgaW5kaWNhdG9yIGZvciBndWlkaW5nXHJcbiAgICBjZW50ZXI6IHRydWUsXHJcbiAgICAvLyBTaG93IHRoZSB3aGl0ZSBtb2RhbCB0byBoaWdobGlnaHQgdGhlIGNyb3AgYm94XHJcbiAgICBoaWdobGlnaHQ6IHRydWUsXHJcbiAgICAvLyBTaG93IHRoZSBncmlkIGJhY2tncm91bmRcclxuICAgIGJhY2tncm91bmQ6IHRydWUsXHJcbiAgICAvLyBFbmFibGUgdG8gY3JvcCB0aGUgaW1hZ2UgYXV0b21hdGljYWxseSB3aGVuIGluaXRpYWxpemVcclxuICAgIGF1dG9Dcm9wOiB0cnVlLFxyXG4gICAgLy8gRGVmaW5lIHRoZSBwZXJjZW50YWdlIG9mIGF1dG9tYXRpYyBjcm9wcGluZyBhcmVhIHdoZW4gaW5pdGlhbGl6ZXNcclxuICAgIGF1dG9Dcm9wQXJlYTogMC44LFxyXG4gICAgLy8gRW5hYmxlIHRvIG1vdmUgdGhlIGltYWdlXHJcbiAgICBtb3ZhYmxlOiB0cnVlLFxyXG4gICAgLy8gRW5hYmxlIHRvIHJvdGF0ZSB0aGUgaW1hZ2VcclxuICAgIHJvdGF0YWJsZTogdHJ1ZSxcclxuICAgIC8vIEVuYWJsZSB0byBzY2FsZSB0aGUgaW1hZ2VcclxuICAgIHNjYWxhYmxlOiB0cnVlLFxyXG4gICAgLy8gRW5hYmxlIHRvIHpvb20gdGhlIGltYWdlXHJcbiAgICB6b29tYWJsZTogdHJ1ZSxcclxuICAgIC8vIEVuYWJsZSB0byB6b29tIHRoZSBpbWFnZSBieSBkcmFnZ2luZyB0b3VjaFxyXG4gICAgem9vbU9uVG91Y2g6IHRydWUsXHJcbiAgICAvLyBFbmFibGUgdG8gem9vbSB0aGUgaW1hZ2UgYnkgd2hlZWxpbmcgbW91c2VcclxuICAgIHpvb21PbldoZWVsOiB0cnVlLFxyXG4gICAgLy8gRGVmaW5lIHpvb20gcmF0aW8gd2hlbiB6b29tIHRoZSBpbWFnZSBieSB3aGVlbGluZyBtb3VzZVxyXG4gICAgd2hlZWxab29tUmF0aW86IDAuMSxcclxuICAgIC8vIEVuYWJsZSB0byBtb3ZlIHRoZSBjcm9wIGJveFxyXG4gICAgY3JvcEJveE1vdmFibGU6IHRydWUsXHJcbiAgICAvLyBFbmFibGUgdG8gcmVzaXplIHRoZSBjcm9wIGJveFxyXG4gICAgY3JvcEJveFJlc2l6YWJsZTogdHJ1ZSxcclxuICAgIC8vIFRvZ2dsZSBkcmFnIG1vZGUgYmV0d2VlbiBcImNyb3BcIiBhbmQgXCJtb3ZlXCIgd2hlbiBjbGljayB0d2ljZSBvbiB0aGUgY3JvcHBlclxyXG4gICAgdG9nZ2xlRHJhZ01vZGVPbkRibGNsaWNrOiB0cnVlLFxyXG4gICAgLy8gU2l6ZSBsaW1pdGF0aW9uXHJcbiAgICBtaW5DYW52YXNXaWR0aDogMCxcclxuICAgIG1pbkNhbnZhc0hlaWdodDogMCxcclxuICAgIG1pbkNyb3BCb3hXaWR0aDogMCxcclxuICAgIG1pbkNyb3BCb3hIZWlnaHQ6IDAsXHJcbiAgICBtaW5Db250YWluZXJXaWR0aDogTUlOX0NPTlRBSU5FUl9XSURUSCxcclxuICAgIG1pbkNvbnRhaW5lckhlaWdodDogTUlOX0NPTlRBSU5FUl9IRUlHSFQsXHJcbiAgICAvLyBTaG9ydGN1dHMgb2YgZXZlbnRzXHJcbiAgICByZWFkeTogbnVsbCxcclxuICAgIGNyb3BzdGFydDogbnVsbCxcclxuICAgIGNyb3Btb3ZlOiBudWxsLFxyXG4gICAgY3JvcGVuZDogbnVsbCxcclxuICAgIGNyb3A6IG51bGwsXHJcbiAgICB6b29tOiBudWxsXHJcbiAgfTtcclxuXHJcbiAgdmFyIFRFTVBMQVRFID0gJzxkaXYgY2xhc3M9XCJjcm9wcGVyLWNvbnRhaW5lclwiIHRvdWNoLWFjdGlvbj1cIm5vbmVcIj4nICsgJzxkaXYgY2xhc3M9XCJjcm9wcGVyLXdyYXAtYm94XCI+JyArICc8ZGl2IGNsYXNzPVwiY3JvcHBlci1jYW52YXNcIj48L2Rpdj4nICsgJzwvZGl2PicgKyAnPGRpdiBjbGFzcz1cImNyb3BwZXItZHJhZy1ib3hcIj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJjcm9wcGVyLWNyb3AtYm94XCI+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItdmlldy1ib3hcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItZGFzaGVkIGRhc2hlZC1oXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLWRhc2hlZCBkYXNoZWQtdlwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1jZW50ZXJcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItZmFjZVwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1saW5lIGxpbmUtZVwiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJlXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLWxpbmUgbGluZS1uXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cIm5cIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItbGluZSBsaW5lLXdcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwid1wiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1saW5lIGxpbmUtc1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJzXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LWVcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwiZVwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1uXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cIm5cIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtd1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJ3XCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LXNcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwic1wiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1uZVwiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJuZVwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1ud1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJud1wiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1zd1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJzd1wiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1zZVwiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJzZVwiPjwvc3Bhbj4nICsgJzwvZGl2PicgKyAnPC9kaXY+JztcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlci5cclxuICAgKi9cclxuXHJcbiAgdmFyIGlzTmFOID0gTnVtYmVyLmlzTmFOIHx8IFdJTkRPVy5pc05hTjtcclxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBudW1iZXIuXHJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBwb3NpdGl2ZSBudW1iZXIuXHJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgcG9zaXRpdmUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXHJcbiAgICovXHJcblxyXG4gIHZhciBpc1Bvc2l0aXZlTnVtYmVyID0gZnVuY3Rpb24gaXNQb3NpdGl2ZU51bWJlcih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID4gMCAmJiB2YWx1ZSA8IEluZmluaXR5O1xyXG4gIH07XHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHVuZGVmaW5lZC5cclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdW5kZWZpbmVkLCBlbHNlIGBmYWxzZWAuXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdC5cclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gX3R5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xyXG4gIH1cclxuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xyXG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHZhciBfY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcjtcclxuICAgICAgdmFyIHByb3RvdHlwZSA9IF9jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XHJcbiAgICAgIHJldHVybiBfY29uc3RydWN0b3IgJiYgcHJvdG90eXBlICYmIGhhc093blByb3BlcnR5LmNhbGwocHJvdG90eXBlLCAnaXNQcm90b3R5cGVPZicpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbi5cclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xyXG4gIH1cclxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcbiAgLyoqXHJcbiAgICogQ29udmVydCBhcnJheS1saWtlIG9yIGl0ZXJhYmxlIG9iamVjdCB0byBhbiBhcnJheS5cclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQuXHJcbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5LlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbSA/IEFycmF5LmZyb20odmFsdWUpIDogc2xpY2UuY2FsbCh2YWx1ZSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEl0ZXJhdGUgdGhlIGdpdmVuIGRhdGEuXHJcbiAgICogQHBhcmFtIHsqfSBkYXRhIC0gVGhlIGRhdGEgdG8gaXRlcmF0ZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBwcm9jZXNzIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQuXHJcbiAgICogQHJldHVybnMgeyp9IFRoZSBvcmlnaW5hbCBkYXRhLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBmb3JFYWNoKGRhdGEsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoZGF0YSAmJiBpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc051bWJlcihkYXRhLmxlbmd0aClcclxuICAgICAgLyogYXJyYXktbGlrZSAqL1xyXG4gICAgICApIHtcclxuICAgICAgICAgIHRvQXJyYXkoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKGRhdGEsIHZhbHVlLCBrZXksIGRhdGEpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhKSkge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgY2FsbGJhY2suY2FsbChkYXRhLCBkYXRhW2tleV0sIGtleSwgZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogRXh0ZW5kIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCB0byBleHRlbmQuXHJcbiAgICogQHBhcmFtIHsqfSBhcmdzIC0gVGhlIHJlc3Qgb2JqZWN0cyBmb3IgbWVyZ2luZyB0byB0aGUgdGFyZ2V0IG9iamVjdC5cclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZXh0ZW5kZWQgb2JqZWN0LlxyXG4gICAqL1xyXG5cclxuICB2YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XHJcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc09iamVjdCh0YXJnZXQpICYmIGFyZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xyXG4gICAgICAgIGlmIChpc09iamVjdChhcmcpKSB7XHJcbiAgICAgICAgICBPYmplY3Qua2V5cyhhcmcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IGFyZ1trZXldO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH07XHJcbiAgdmFyIFJFR0VYUF9ERUNJTUFMUyA9IC9cXC5cXGQqKD86MHw5KXsxMn1cXGQqJC87XHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplIGRlY2ltYWwgbnVtYmVyLlxyXG4gICAqIENoZWNrIG91dCB7QGxpbmsgaHR0cHM6Ly8wLjMwMDAwMDAwMDAwMDAwMDA0LmNvbS99XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIG5vcm1hbGl6ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVzPTEwMDAwMDAwMDAwMF0gLSBUaGUgdGltZXMgZm9yIG5vcm1hbGl6aW5nLlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgbnVtYmVyLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBub3JtYWxpemVEZWNpbWFsTnVtYmVyKHZhbHVlKSB7XHJcbiAgICB2YXIgdGltZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEwMDAwMDAwMDAwMDtcclxuICAgIHJldHVybiBSRUdFWFBfREVDSU1BTFMudGVzdCh2YWx1ZSkgPyBNYXRoLnJvdW5kKHZhbHVlICogdGltZXMpIC8gdGltZXMgOiB2YWx1ZTtcclxuICB9XHJcbiAgdmFyIFJFR0VYUF9TVUZGSVggPSAvXndpZHRofGhlaWdodHxsZWZ0fHRvcHxtYXJnaW5MZWZ0fG1hcmdpblRvcCQvO1xyXG4gIC8qKlxyXG4gICAqIEFwcGx5IHN0eWxlcyB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyAtIFRoZSBzdHlsZXMgZm9yIGFwcGx5aW5nLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBzdHlsZXMpIHtcclxuICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XHJcbiAgICBmb3JFYWNoKHN0eWxlcywgZnVuY3Rpb24gKHZhbHVlLCBwcm9wZXJ0eSkge1xyXG4gICAgICBpZiAoUkVHRVhQX1NVRkZJWC50ZXN0KHByb3BlcnR5KSAmJiBpc051bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZSA9IFwiXCIuY29uY2F0KHZhbHVlLCBcInB4XCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBoYXMgYSBzcGVjaWFsIGNsYXNzLlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIGNoZWNrLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjbGFzcyB0byBzZWFyY2guXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWFsIGNsYXNzIHdhcyBmb3VuZC5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgdmFsdWUpIHtcclxuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdCA/IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHZhbHVlKSA6IGVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YodmFsdWUpID4gLTE7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEFkZCBjbGFzc2VzIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgY2xhc3NlcyB0byBiZSBhZGRlZC5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgdmFsdWUpIHtcclxuICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc051bWJlcihlbGVtZW50Lmxlbmd0aCkpIHtcclxuICAgICAgZm9yRWFjaChlbGVtZW50LCBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgIGFkZENsYXNzKGVsZW0sIHZhbHVlKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcclxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKHZhbHVlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS50cmltKCk7XHJcblxyXG4gICAgaWYgKCFjbGFzc05hbWUpIHtcclxuICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSB2YWx1ZTtcclxuICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lLmluZGV4T2YodmFsdWUpIDwgMCkge1xyXG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFwiXCIuY29uY2F0KGNsYXNzTmFtZSwgXCIgXCIpLmNvbmNhdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBjbGFzc2VzIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjbGFzc2VzIHRvIGJlIHJlbW92ZWQuXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNOdW1iZXIoZWxlbWVudC5sZW5ndGgpKSB7XHJcbiAgICAgIGZvckVhY2goZWxlbWVudCwgZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICByZW1vdmVDbGFzcyhlbGVtLCB2YWx1ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XHJcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh2YWx1ZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZih2YWx1ZSkgPj0gMCkge1xyXG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UodmFsdWUsICcnKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogQWRkIG9yIHJlbW92ZSBjbGFzc2VzIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjbGFzc2VzIHRvIGJlIHRvZ2dsZWQuXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBhZGRlZCAtIEFkZCBvbmx5LlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCB2YWx1ZSwgYWRkZWQpIHtcclxuICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc051bWJlcihlbGVtZW50Lmxlbmd0aCkpIHtcclxuICAgICAgZm9yRWFjaChlbGVtZW50LCBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsZW0sIHZhbHVlLCBhZGRlZCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9IC8vIElFMTAtMTEgZG9lc24ndCBzdXBwb3J0IHRoZSBzZWNvbmQgcGFyYW1ldGVyIG9mIGBjbGFzc0xpc3QudG9nZ2xlYFxyXG5cclxuXHJcbiAgICBpZiAoYWRkZWQpIHtcclxuICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgdmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuICB2YXIgUkVHRVhQX0NBTUVMX0NBU0UgPSAvKFthLXpcXGRdKShbQS1aXSkvZztcclxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIGdpdmVuIHN0cmluZyBmcm9tIGNhbWVsQ2FzZSB0byBrZWJhYi1jYXNlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRyYW5zZm9ybS5cclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHJhbnNmb3JtZWQgdmFsdWUuXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIHRvUGFyYW1DYXNlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZShSRUdFWFBfQ0FNRUxfQ0FTRSwgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogR2V0IGRhdGEgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgZGF0YSBrZXkgdG8gZ2V0LlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkYXRhIHZhbHVlLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBnZXREYXRhKGVsZW1lbnQsIG5hbWUpIHtcclxuICAgIGlmIChpc09iamVjdChlbGVtZW50W25hbWVdKSkge1xyXG4gICAgICByZXR1cm4gZWxlbWVudFtuYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZWxlbWVudC5kYXRhc2V0KSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50LmRhdGFzZXRbbmFtZV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1cIi5jb25jYXQodG9QYXJhbUNhc2UobmFtZSkpKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU2V0IGRhdGEgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRhdGEga2V5IHRvIHNldC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIFRoZSBkYXRhIHZhbHVlLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBzZXREYXRhKGVsZW1lbnQsIG5hbWUsIGRhdGEpIHtcclxuICAgIGlmIChpc09iamVjdChkYXRhKSkge1xyXG4gICAgICBlbGVtZW50W25hbWVdID0gZGF0YTtcclxuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5kYXRhc2V0KSB7XHJcbiAgICAgIGVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IGRhdGE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtXCIuY29uY2F0KHRvUGFyYW1DYXNlKG5hbWUpKSwgZGF0YSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBkYXRhIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRhdGEga2V5IHRvIHJlbW92ZS5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlRGF0YShlbGVtZW50LCBuYW1lKSB7XHJcbiAgICBpZiAoaXNPYmplY3QoZWxlbWVudFtuYW1lXSkpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBkZWxldGUgZWxlbWVudFtuYW1lXTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBlbGVtZW50W25hbWVdID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQuZGF0YXNldCkge1xyXG4gICAgICAvLyAjMTI4IFNhZmFyaSBub3QgYWxsb3dzIHRvIGRlbGV0ZSBkYXRhc2V0IHByb3BlcnR5XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZGVsZXRlIGVsZW1lbnQuZGF0YXNldFtuYW1lXTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBlbGVtZW50LmRhdGFzZXRbbmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1cIi5jb25jYXQodG9QYXJhbUNhc2UobmFtZSkpKTtcclxuICAgIH1cclxuICB9XHJcbiAgdmFyIFJFR0VYUF9TUEFDRVMgPSAvXFxzXFxzKi87XHJcblxyXG4gIHZhciBvbmNlU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHN1cHBvcnRlZCA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChJU19CUk9XU0VSKSB7XHJcbiAgICAgIHZhciBvbmNlID0gZmFsc2U7XHJcblxyXG4gICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHt9O1xyXG5cclxuICAgICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdvbmNlJywge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHJldHVybiBvbmNlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgc2V0dGVyIGNhbiBmaXggYSBgVHlwZUVycm9yYCBpbiBzdHJpY3QgbW9kZVxyXG4gICAgICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9FcnJvcnMvR2V0dGVyX29ubHl9XHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXRcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xyXG4gICAgICAgICAgb25jZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIFdJTkRPVy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbGlzdGVuZXIsIG9wdGlvbnMpO1xyXG4gICAgICBXSU5ET1cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIGxpc3RlbmVyLCBvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xyXG4gIH0oKTtcclxuICAvKipcclxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGUgdGFyZ2V0IGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIGV2ZW50IHRhcmdldC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlKHMpLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGV2ZW50IG9wdGlvbnMuXHJcbiAgICovXHJcblxyXG5cclxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xyXG4gICAgdmFyIGhhbmRsZXIgPSBsaXN0ZW5lcjtcclxuICAgIHR5cGUudHJpbSgpLnNwbGl0KFJFR0VYUF9TUEFDRVMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgIGlmICghb25jZVN1cHBvcnRlZCkge1xyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBlbGVtZW50Lmxpc3RlbmVycztcclxuXHJcbiAgICAgICAgaWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnNbZXZlbnRdICYmIGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdKSB7XHJcbiAgICAgICAgICBoYW5kbGVyID0gbGlzdGVuZXJzW2V2ZW50XVtsaXN0ZW5lcl07XHJcbiAgICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2V2ZW50XVtsaXN0ZW5lcl07XHJcblxyXG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGxpc3RlbmVyc1tldmVudF0pLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2V2ZW50XTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobGlzdGVuZXJzKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQubGlzdGVuZXJzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBZGQgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHRhcmdldCBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCB0YXJnZXQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZXZlbnQgdHlwZShzKS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBldmVudCBsaXN0ZW5lci5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBldmVudCBvcHRpb25zLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBhZGRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xyXG4gICAgdmFyIF9oYW5kbGVyID0gbGlzdGVuZXI7XHJcbiAgICB0eXBlLnRyaW0oKS5zcGxpdChSRUdFWFBfU1BBQ0VTKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICBpZiAob3B0aW9ucy5vbmNlICYmICFvbmNlU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgdmFyIF9lbGVtZW50JGxpc3RlbmVycyA9IGVsZW1lbnQubGlzdGVuZXJzLFxyXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBfZWxlbWVudCRsaXN0ZW5lcnMgPT09IHZvaWQgMCA/IHt9IDogX2VsZW1lbnQkbGlzdGVuZXJzO1xyXG5cclxuICAgICAgICBfaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XHJcbiAgICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2V2ZW50XVtsaXN0ZW5lcl07XHJcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIF9oYW5kbGVyLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KGVsZW1lbnQsIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICghbGlzdGVuZXJzW2V2ZW50XSkge1xyXG4gICAgICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IHt9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdKSB7XHJcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdID0gX2hhbmRsZXI7XHJcbiAgICAgICAgZWxlbWVudC5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgX2hhbmRsZXIsIG9wdGlvbnMpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoIGV2ZW50IG9uIHRoZSB0YXJnZXQgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZXZlbnQgdGFyZ2V0LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIGV2ZW50IHR5cGUocykuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgYWRkaXRpb25hbCBldmVudCBkYXRhLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBJbmRpY2F0ZSBpZiB0aGUgZXZlbnQgaXMgZGVmYXVsdCBwcmV2ZW50ZWQgb3Igbm90LlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIHR5cGUsIGRhdGEpIHtcclxuICAgIHZhciBldmVudDsgLy8gRXZlbnQgYW5kIEN1c3RvbUV2ZW50IG9uIElFOS0xMSBhcmUgZ2xvYmFsIG9iamVjdHMsIG5vdCBjb25zdHJ1Y3RvcnNcclxuXHJcbiAgICBpZiAoaXNGdW5jdGlvbihFdmVudCkgJiYgaXNGdW5jdGlvbihDdXN0b21FdmVudCkpIHtcclxuICAgICAgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQodHlwZSwge1xyXG4gICAgICAgIGRldGFpbDogZGF0YSxcclxuICAgICAgICBidWJibGVzOiB0cnVlLFxyXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xyXG4gICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSwgZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgb2Zmc2V0IGJhc2Ugb24gdGhlIGRvY3VtZW50LlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudC5cclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgb2Zmc2V0IGRhdGEuXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIGdldE9mZnNldChlbGVtZW50KSB7XHJcbiAgICB2YXIgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxlZnQ6IGJveC5sZWZ0ICsgKHdpbmRvdy5wYWdlWE9mZnNldCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRMZWZ0KSxcclxuICAgICAgdG9wOiBib3gudG9wICsgKHdpbmRvdy5wYWdlWU9mZnNldCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRUb3ApXHJcbiAgICB9O1xyXG4gIH1cclxuICB2YXIgbG9jYXRpb24gPSBXSU5ET1cubG9jYXRpb247XHJcbiAgdmFyIFJFR0VYUF9PUklHSU5TID0gL14oXFx3KzopXFwvXFwvKFteOi8/I10qKTo/KFxcZCopL2k7XHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIFVSTCBpcyBhIGNyb3NzIG9yaWdpbiBVUkwuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSB0YXJnZXQgVVJMLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gVVJMIGlzIGEgY3Jvc3Mgb3JpZ2luIFVSTCwgZWxzZSBgZmFsc2VgLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBpc0Nyb3NzT3JpZ2luVVJMKHVybCkge1xyXG4gICAgdmFyIHBhcnRzID0gdXJsLm1hdGNoKFJFR0VYUF9PUklHSU5TKTtcclxuICAgIHJldHVybiBwYXJ0cyAhPT0gbnVsbCAmJiAocGFydHNbMV0gIT09IGxvY2F0aW9uLnByb3RvY29sIHx8IHBhcnRzWzJdICE9PSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwYXJ0c1szXSAhPT0gbG9jYXRpb24ucG9ydCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEFkZCB0aW1lc3RhbXAgdG8gdGhlIGdpdmVuIFVSTC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHRhcmdldCBVUkwuXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHJlc3VsdCBVUkwuXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIGFkZFRpbWVzdGFtcCh1cmwpIHtcclxuICAgIHZhciB0aW1lc3RhbXAgPSBcInRpbWVzdGFtcD1cIi5jb25jYXQobmV3IERhdGUoKS5nZXRUaW1lKCkpO1xyXG4gICAgcmV0dXJuIHVybCArICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyB0aW1lc3RhbXA7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEdldCB0cmFuc2Zvcm1zIGJhc2Ugb24gdGhlIGdpdmVuIG9iamVjdC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIHRhcmdldCBvYmplY3QuXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgY29udGFpbnMgdHJhbnNmb3JtIHZhbHVlcy5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtcyhfcmVmKSB7XHJcbiAgICB2YXIgcm90YXRlID0gX3JlZi5yb3RhdGUsXHJcbiAgICAgICAgc2NhbGVYID0gX3JlZi5zY2FsZVgsXHJcbiAgICAgICAgc2NhbGVZID0gX3JlZi5zY2FsZVksXHJcbiAgICAgICAgdHJhbnNsYXRlWCA9IF9yZWYudHJhbnNsYXRlWCxcclxuICAgICAgICB0cmFuc2xhdGVZID0gX3JlZi50cmFuc2xhdGVZO1xyXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuICAgIGlmIChpc051bWJlcih0cmFuc2xhdGVYKSAmJiB0cmFuc2xhdGVYICE9PSAwKSB7XHJcbiAgICAgIHZhbHVlcy5wdXNoKFwidHJhbnNsYXRlWChcIi5jb25jYXQodHJhbnNsYXRlWCwgXCJweClcIikpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc051bWJlcih0cmFuc2xhdGVZKSAmJiB0cmFuc2xhdGVZICE9PSAwKSB7XHJcbiAgICAgIHZhbHVlcy5wdXNoKFwidHJhbnNsYXRlWShcIi5jb25jYXQodHJhbnNsYXRlWSwgXCJweClcIikpO1xyXG4gICAgfSAvLyBSb3RhdGUgc2hvdWxkIGNvbWUgZmlyc3QgYmVmb3JlIHNjYWxlIHRvIG1hdGNoIG9yaWVudGF0aW9uIHRyYW5zZm9ybVxyXG5cclxuXHJcbiAgICBpZiAoaXNOdW1iZXIocm90YXRlKSAmJiByb3RhdGUgIT09IDApIHtcclxuICAgICAgdmFsdWVzLnB1c2goXCJyb3RhdGUoXCIuY29uY2F0KHJvdGF0ZSwgXCJkZWcpXCIpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNOdW1iZXIoc2NhbGVYKSAmJiBzY2FsZVggIT09IDEpIHtcclxuICAgICAgdmFsdWVzLnB1c2goXCJzY2FsZVgoXCIuY29uY2F0KHNjYWxlWCwgXCIpXCIpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNOdW1iZXIoc2NhbGVZKSAmJiBzY2FsZVkgIT09IDEpIHtcclxuICAgICAgdmFsdWVzLnB1c2goXCJzY2FsZVkoXCIuY29uY2F0KHNjYWxlWSwgXCIpXCIpKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdHJhbnNmb3JtID0gdmFsdWVzLmxlbmd0aCA/IHZhbHVlcy5qb2luKCcgJykgOiAnbm9uZSc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBXZWJraXRUcmFuc2Zvcm06IHRyYW5zZm9ybSxcclxuICAgICAgbXNUcmFuc2Zvcm06IHRyYW5zZm9ybSxcclxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1cclxuICAgIH07XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWF4IHJhdGlvIG9mIGEgZ3JvdXAgb2YgcG9pbnRlcnMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvaW50ZXJzIC0gVGhlIHRhcmdldCBwb2ludGVycy5cclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVzdWx0IHJhdGlvLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBnZXRNYXhab29tUmF0aW8ocG9pbnRlcnMpIHtcclxuICAgIHZhciBwb2ludGVyczIgPSBfb2JqZWN0U3ByZWFkMih7fSwgcG9pbnRlcnMpO1xyXG5cclxuICAgIHZhciBtYXhSYXRpbyA9IDA7XHJcbiAgICBmb3JFYWNoKHBvaW50ZXJzLCBmdW5jdGlvbiAocG9pbnRlciwgcG9pbnRlcklkKSB7XHJcbiAgICAgIGRlbGV0ZSBwb2ludGVyczJbcG9pbnRlcklkXTtcclxuICAgICAgZm9yRWFjaChwb2ludGVyczIsIGZ1bmN0aW9uIChwb2ludGVyMikge1xyXG4gICAgICAgIHZhciB4MSA9IE1hdGguYWJzKHBvaW50ZXIuc3RhcnRYIC0gcG9pbnRlcjIuc3RhcnRYKTtcclxuICAgICAgICB2YXIgeTEgPSBNYXRoLmFicyhwb2ludGVyLnN0YXJ0WSAtIHBvaW50ZXIyLnN0YXJ0WSk7XHJcbiAgICAgICAgdmFyIHgyID0gTWF0aC5hYnMocG9pbnRlci5lbmRYIC0gcG9pbnRlcjIuZW5kWCk7XHJcbiAgICAgICAgdmFyIHkyID0gTWF0aC5hYnMocG9pbnRlci5lbmRZIC0gcG9pbnRlcjIuZW5kWSk7XHJcbiAgICAgICAgdmFyIHoxID0gTWF0aC5zcXJ0KHgxICogeDEgKyB5MSAqIHkxKTtcclxuICAgICAgICB2YXIgejIgPSBNYXRoLnNxcnQoeDIgKiB4MiArIHkyICogeTIpO1xyXG4gICAgICAgIHZhciByYXRpbyA9ICh6MiAtIHoxKSAvIHoxO1xyXG5cclxuICAgICAgICBpZiAoTWF0aC5hYnMocmF0aW8pID4gTWF0aC5hYnMobWF4UmF0aW8pKSB7XHJcbiAgICAgICAgICBtYXhSYXRpbyA9IHJhdGlvO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBtYXhSYXRpbztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogR2V0IGEgcG9pbnRlciBmcm9tIGFuIGV2ZW50IG9iamVjdC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgdGFyZ2V0IGV2ZW50IG9iamVjdC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuZE9ubHkgLSBJbmRpY2F0ZXMgaWYgb25seSByZXR1cm5zIHRoZSBlbmQgcG9pbnQgY29vcmRpbmF0ZSBvciBub3QuXHJcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdCBwb2ludGVyIGNvbnRhaW5zIHN0YXJ0IGFuZC9vciBlbmQgcG9pbnQgY29vcmRpbmF0ZXMuXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIGdldFBvaW50ZXIoX3JlZjIsIGVuZE9ubHkpIHtcclxuICAgIHZhciBwYWdlWCA9IF9yZWYyLnBhZ2VYLFxyXG4gICAgICAgIHBhZ2VZID0gX3JlZjIucGFnZVk7XHJcbiAgICB2YXIgZW5kID0ge1xyXG4gICAgICBlbmRYOiBwYWdlWCxcclxuICAgICAgZW5kWTogcGFnZVlcclxuICAgIH07XHJcbiAgICByZXR1cm4gZW5kT25seSA/IGVuZCA6IF9vYmplY3RTcHJlYWQyKHtcclxuICAgICAgc3RhcnRYOiBwYWdlWCxcclxuICAgICAgc3RhcnRZOiBwYWdlWVxyXG4gICAgfSwgZW5kKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjZW50ZXIgcG9pbnQgY29vcmRpbmF0ZSBvZiBhIGdyb3VwIG9mIHBvaW50ZXJzLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVycyAtIFRoZSB0YXJnZXQgcG9pbnRlcnMuXHJcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGNlbnRlciBwb2ludCBjb29yZGluYXRlLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBnZXRQb2ludGVyc0NlbnRlcihwb2ludGVycykge1xyXG4gICAgdmFyIHBhZ2VYID0gMDtcclxuICAgIHZhciBwYWdlWSA9IDA7XHJcbiAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgZm9yRWFjaChwb2ludGVycywgZnVuY3Rpb24gKF9yZWYzKSB7XHJcbiAgICAgIHZhciBzdGFydFggPSBfcmVmMy5zdGFydFgsXHJcbiAgICAgICAgICBzdGFydFkgPSBfcmVmMy5zdGFydFk7XHJcbiAgICAgIHBhZ2VYICs9IHN0YXJ0WDtcclxuICAgICAgcGFnZVkgKz0gc3RhcnRZO1xyXG4gICAgICBjb3VudCArPSAxO1xyXG4gICAgfSk7XHJcbiAgICBwYWdlWCAvPSBjb3VudDtcclxuICAgIHBhZ2VZIC89IGNvdW50O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGFnZVg6IHBhZ2VYLFxyXG4gICAgICBwYWdlWTogcGFnZVlcclxuICAgIH07XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWF4IHNpemVzIGluIGEgcmVjdGFuZ2xlIHVuZGVyIHRoZSBnaXZlbiBhc3BlY3QgcmF0aW8uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgb3JpZ2luYWwgc2l6ZXMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlPSdjb250YWluJ10gLSBUaGUgYWRqdXN0IHR5cGUuXHJcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdCBzaXplcy5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gZ2V0QWRqdXN0ZWRTaXplcyhfcmVmNCkgLy8gb3IgJ2NvdmVyJ1xyXG4gIHtcclxuICAgIHZhciBhc3BlY3RSYXRpbyA9IF9yZWY0LmFzcGVjdFJhdGlvLFxyXG4gICAgICAgIGhlaWdodCA9IF9yZWY0LmhlaWdodCxcclxuICAgICAgICB3aWR0aCA9IF9yZWY0LndpZHRoO1xyXG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdjb250YWluJztcclxuICAgIHZhciBpc1ZhbGlkV2lkdGggPSBpc1Bvc2l0aXZlTnVtYmVyKHdpZHRoKTtcclxuICAgIHZhciBpc1ZhbGlkSGVpZ2h0ID0gaXNQb3NpdGl2ZU51bWJlcihoZWlnaHQpO1xyXG5cclxuICAgIGlmIChpc1ZhbGlkV2lkdGggJiYgaXNWYWxpZEhlaWdodCkge1xyXG4gICAgICB2YXIgYWRqdXN0ZWRXaWR0aCA9IGhlaWdodCAqIGFzcGVjdFJhdGlvO1xyXG5cclxuICAgICAgaWYgKHR5cGUgPT09ICdjb250YWluJyAmJiBhZGp1c3RlZFdpZHRoID4gd2lkdGggfHwgdHlwZSA9PT0gJ2NvdmVyJyAmJiBhZGp1c3RlZFdpZHRoIDwgd2lkdGgpIHtcclxuICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZFdpZHRoKSB7XHJcbiAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0UmF0aW87XHJcbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRIZWlnaHQpIHtcclxuICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICB9O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBHZXQgdGhlIG5ldyBzaXplcyBvZiBhIHJlY3RhbmdsZSBhZnRlciByb3RhdGVkLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIG9yaWdpbmFsIHNpemVzLlxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgc2l6ZXMuXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIGdldFJvdGF0ZWRTaXplcyhfcmVmNSkge1xyXG4gICAgdmFyIHdpZHRoID0gX3JlZjUud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjUuaGVpZ2h0LFxyXG4gICAgICAgIGRlZ3JlZSA9IF9yZWY1LmRlZ3JlZTtcclxuICAgIGRlZ3JlZSA9IE1hdGguYWJzKGRlZ3JlZSkgJSAxODA7XHJcblxyXG4gICAgaWYgKGRlZ3JlZSA9PT0gOTApIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aDogaGVpZ2h0LFxyXG4gICAgICAgIGhlaWdodDogd2lkdGhcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYXJjID0gZGVncmVlICUgOTAgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgdmFyIHNpbkFyYyA9IE1hdGguc2luKGFyYyk7XHJcbiAgICB2YXIgY29zQXJjID0gTWF0aC5jb3MoYXJjKTtcclxuICAgIHZhciBuZXdXaWR0aCA9IHdpZHRoICogY29zQXJjICsgaGVpZ2h0ICogc2luQXJjO1xyXG4gICAgdmFyIG5ld0hlaWdodCA9IHdpZHRoICogc2luQXJjICsgaGVpZ2h0ICogY29zQXJjO1xyXG4gICAgcmV0dXJuIGRlZ3JlZSA+IDkwID8ge1xyXG4gICAgICB3aWR0aDogbmV3SGVpZ2h0LFxyXG4gICAgICBoZWlnaHQ6IG5ld1dpZHRoXHJcbiAgICB9IDoge1xyXG4gICAgICB3aWR0aDogbmV3V2lkdGgsXHJcbiAgICAgIGhlaWdodDogbmV3SGVpZ2h0XHJcbiAgICB9O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBHZXQgYSBjYW52YXMgd2hpY2ggZHJldyB0aGUgZ2l2ZW4gaW1hZ2UuXHJcbiAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWFnZSAtIFRoZSBpbWFnZSBmb3IgZHJhd2luZy5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhIC0gVGhlIGltYWdlIGRhdGEuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0RhdGEgLSBUaGUgY2FudmFzIGRhdGEuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucy5cclxuICAgKiBAcmV0dXJucyB7SFRNTENhbnZhc0VsZW1lbnR9IFRoZSByZXN1bHQgY2FudmFzLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBnZXRTb3VyY2VDYW52YXMoaW1hZ2UsIF9yZWY2LCBfcmVmNywgX3JlZjgpIHtcclxuICAgIHZhciBpbWFnZUFzcGVjdFJhdGlvID0gX3JlZjYuYXNwZWN0UmF0aW8sXHJcbiAgICAgICAgaW1hZ2VOYXR1cmFsV2lkdGggPSBfcmVmNi5uYXR1cmFsV2lkdGgsXHJcbiAgICAgICAgaW1hZ2VOYXR1cmFsSGVpZ2h0ID0gX3JlZjYubmF0dXJhbEhlaWdodCxcclxuICAgICAgICBfcmVmNiRyb3RhdGUgPSBfcmVmNi5yb3RhdGUsXHJcbiAgICAgICAgcm90YXRlID0gX3JlZjYkcm90YXRlID09PSB2b2lkIDAgPyAwIDogX3JlZjYkcm90YXRlLFxyXG4gICAgICAgIF9yZWY2JHNjYWxlWCA9IF9yZWY2LnNjYWxlWCxcclxuICAgICAgICBzY2FsZVggPSBfcmVmNiRzY2FsZVggPT09IHZvaWQgMCA/IDEgOiBfcmVmNiRzY2FsZVgsXHJcbiAgICAgICAgX3JlZjYkc2NhbGVZID0gX3JlZjYuc2NhbGVZLFxyXG4gICAgICAgIHNjYWxlWSA9IF9yZWY2JHNjYWxlWSA9PT0gdm9pZCAwID8gMSA6IF9yZWY2JHNjYWxlWTtcclxuICAgIHZhciBhc3BlY3RSYXRpbyA9IF9yZWY3LmFzcGVjdFJhdGlvLFxyXG4gICAgICAgIG5hdHVyYWxXaWR0aCA9IF9yZWY3Lm5hdHVyYWxXaWR0aCxcclxuICAgICAgICBuYXR1cmFsSGVpZ2h0ID0gX3JlZjcubmF0dXJhbEhlaWdodDtcclxuICAgIHZhciBfcmVmOCRmaWxsQ29sb3IgPSBfcmVmOC5maWxsQ29sb3IsXHJcbiAgICAgICAgZmlsbENvbG9yID0gX3JlZjgkZmlsbENvbG9yID09PSB2b2lkIDAgPyAndHJhbnNwYXJlbnQnIDogX3JlZjgkZmlsbENvbG9yLFxyXG4gICAgICAgIF9yZWY4JGltYWdlU21vb3RoaW5nRSA9IF9yZWY4LmltYWdlU21vb3RoaW5nRW5hYmxlZCxcclxuICAgICAgICBpbWFnZVNtb290aGluZ0VuYWJsZWQgPSBfcmVmOCRpbWFnZVNtb290aGluZ0UgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmOCRpbWFnZVNtb290aGluZ0UsXHJcbiAgICAgICAgX3JlZjgkaW1hZ2VTbW9vdGhpbmdRID0gX3JlZjguaW1hZ2VTbW9vdGhpbmdRdWFsaXR5LFxyXG4gICAgICAgIGltYWdlU21vb3RoaW5nUXVhbGl0eSA9IF9yZWY4JGltYWdlU21vb3RoaW5nUSA9PT0gdm9pZCAwID8gJ2xvdycgOiBfcmVmOCRpbWFnZVNtb290aGluZ1EsXHJcbiAgICAgICAgX3JlZjgkbWF4V2lkdGggPSBfcmVmOC5tYXhXaWR0aCxcclxuICAgICAgICBtYXhXaWR0aCA9IF9yZWY4JG1heFdpZHRoID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9yZWY4JG1heFdpZHRoLFxyXG4gICAgICAgIF9yZWY4JG1heEhlaWdodCA9IF9yZWY4Lm1heEhlaWdodCxcclxuICAgICAgICBtYXhIZWlnaHQgPSBfcmVmOCRtYXhIZWlnaHQgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX3JlZjgkbWF4SGVpZ2h0LFxyXG4gICAgICAgIF9yZWY4JG1pbldpZHRoID0gX3JlZjgubWluV2lkdGgsXHJcbiAgICAgICAgbWluV2lkdGggPSBfcmVmOCRtaW5XaWR0aCA9PT0gdm9pZCAwID8gMCA6IF9yZWY4JG1pbldpZHRoLFxyXG4gICAgICAgIF9yZWY4JG1pbkhlaWdodCA9IF9yZWY4Lm1pbkhlaWdodCxcclxuICAgICAgICBtaW5IZWlnaHQgPSBfcmVmOCRtaW5IZWlnaHQgPT09IHZvaWQgMCA/IDAgOiBfcmVmOCRtaW5IZWlnaHQ7XHJcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgdmFyIG1heFNpemVzID0gZ2V0QWRqdXN0ZWRTaXplcyh7XHJcbiAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcclxuICAgICAgd2lkdGg6IG1heFdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IG1heEhlaWdodFxyXG4gICAgfSk7XHJcbiAgICB2YXIgbWluU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcclxuICAgICAgYXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvLFxyXG4gICAgICB3aWR0aDogbWluV2lkdGgsXHJcbiAgICAgIGhlaWdodDogbWluSGVpZ2h0XHJcbiAgICB9LCAnY292ZXInKTtcclxuICAgIHZhciB3aWR0aCA9IE1hdGgubWluKG1heFNpemVzLndpZHRoLCBNYXRoLm1heChtaW5TaXplcy53aWR0aCwgbmF0dXJhbFdpZHRoKSk7XHJcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5taW4obWF4U2l6ZXMuaGVpZ2h0LCBNYXRoLm1heChtaW5TaXplcy5oZWlnaHQsIG5hdHVyYWxIZWlnaHQpKTsgLy8gTm90ZTogc2hvdWxkIGFsd2F5cyB1c2UgaW1hZ2UncyBuYXR1cmFsIHNpemVzIGZvciBkcmF3aW5nIGFzXHJcbiAgICAvLyBpbWFnZURhdGEubmF0dXJhbFdpZHRoID09PSBjYW52YXNEYXRhLm5hdHVyYWxIZWlnaHQgd2hlbiByb3RhdGUgJSAxODAgPT09IDkwXHJcblxyXG4gICAgdmFyIGRlc3RNYXhTaXplcyA9IGdldEFkanVzdGVkU2l6ZXMoe1xyXG4gICAgICBhc3BlY3RSYXRpbzogaW1hZ2VBc3BlY3RSYXRpbyxcclxuICAgICAgd2lkdGg6IG1heFdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IG1heEhlaWdodFxyXG4gICAgfSk7XHJcbiAgICB2YXIgZGVzdE1pblNpemVzID0gZ2V0QWRqdXN0ZWRTaXplcyh7XHJcbiAgICAgIGFzcGVjdFJhdGlvOiBpbWFnZUFzcGVjdFJhdGlvLFxyXG4gICAgICB3aWR0aDogbWluV2lkdGgsXHJcbiAgICAgIGhlaWdodDogbWluSGVpZ2h0XHJcbiAgICB9LCAnY292ZXInKTtcclxuICAgIHZhciBkZXN0V2lkdGggPSBNYXRoLm1pbihkZXN0TWF4U2l6ZXMud2lkdGgsIE1hdGgubWF4KGRlc3RNaW5TaXplcy53aWR0aCwgaW1hZ2VOYXR1cmFsV2lkdGgpKTtcclxuICAgIHZhciBkZXN0SGVpZ2h0ID0gTWF0aC5taW4oZGVzdE1heFNpemVzLmhlaWdodCwgTWF0aC5tYXgoZGVzdE1pblNpemVzLmhlaWdodCwgaW1hZ2VOYXR1cmFsSGVpZ2h0KSk7XHJcbiAgICB2YXIgcGFyYW1zID0gWy1kZXN0V2lkdGggLyAyLCAtZGVzdEhlaWdodCAvIDIsIGRlc3RXaWR0aCwgZGVzdEhlaWdodF07XHJcbiAgICBjYW52YXMud2lkdGggPSBub3JtYWxpemVEZWNpbWFsTnVtYmVyKHdpZHRoKTtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBub3JtYWxpemVEZWNpbWFsTnVtYmVyKGhlaWdodCk7XHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxDb2xvcjtcclxuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICBjb250ZXh0LnNhdmUoKTtcclxuICAgIGNvbnRleHQudHJhbnNsYXRlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XHJcbiAgICBjb250ZXh0LnJvdGF0ZShyb3RhdGUgKiBNYXRoLlBJIC8gMTgwKTtcclxuICAgIGNvbnRleHQuc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xyXG4gICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBpbWFnZVNtb290aGluZ0VuYWJsZWQ7XHJcbiAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nUXVhbGl0eSA9IGltYWdlU21vb3RoaW5nUXVhbGl0eTtcclxuICAgIGNvbnRleHQuZHJhd0ltYWdlLmFwcGx5KGNvbnRleHQsIFtpbWFnZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihub3JtYWxpemVEZWNpbWFsTnVtYmVyKHBhcmFtKSk7XHJcbiAgICB9KSkpKTtcclxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgcmV0dXJuIGNhbnZhcztcclxuICB9XHJcbiAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XHJcbiAgLyoqXHJcbiAgICogR2V0IHN0cmluZyBmcm9tIGNoYXIgY29kZSBpbiBkYXRhIHZpZXcuXHJcbiAgICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXcgLSBUaGUgZGF0YSB2aWV3IGZvciByZWFkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFRoZSBzdGFydCBpbmRleC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIC0gVGhlIHJlYWQgbGVuZ3RoLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByZWFkIHJlc3VsdC5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbUNoYXJDb2RlKGRhdGFWaWV3LCBzdGFydCwgbGVuZ3RoKSB7XHJcbiAgICB2YXIgc3RyID0gJyc7XHJcbiAgICBsZW5ndGggKz0gc3RhcnQ7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgc3RyICs9IGZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcbiAgdmFyIFJFR0VYUF9EQVRBX1VSTF9IRUFEID0gL15kYXRhOi4qLC87XHJcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIERhdGEgVVJMIHRvIGFycmF5IGJ1ZmZlci5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVSTCAtIFRoZSBEYXRhIFVSTCB0byB0cmFuc2Zvcm0uXHJcbiAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBUaGUgcmVzdWx0IGFycmF5IGJ1ZmZlci5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gZGF0YVVSTFRvQXJyYXlCdWZmZXIoZGF0YVVSTCkge1xyXG4gICAgdmFyIGJhc2U2NCA9IGRhdGFVUkwucmVwbGFjZShSRUdFWFBfREFUQV9VUkxfSEVBRCwgJycpO1xyXG4gICAgdmFyIGJpbmFyeSA9IGF0b2IoYmFzZTY0KTtcclxuICAgIHZhciBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihiaW5hcnkubGVuZ3RoKTtcclxuICAgIHZhciB1aW50OCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcclxuICAgIGZvckVhY2godWludDgsIGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xyXG4gICAgICB1aW50OFtpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYXJyYXlCdWZmZXI7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhcnJheSBidWZmZXIgdG8gRGF0YSBVUkwuXHJcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgLSBUaGUgYXJyYXkgYnVmZmVyIHRvIHRyYW5zZm9ybS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWltZVR5cGUgLSBUaGUgbWltZSB0eXBlIG9mIHRoZSBEYXRhIFVSTC5cclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcmVzdWx0IERhdGEgVVJMLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBhcnJheUJ1ZmZlclRvRGF0YVVSTChhcnJheUJ1ZmZlciwgbWltZVR5cGUpIHtcclxuICAgIHZhciBjaHVua3MgPSBbXTsgLy8gQ2h1bmsgVHlwZWQgQXJyYXkgZm9yIGJldHRlciBwZXJmb3JtYW5jZSAoIzQzNSlcclxuXHJcbiAgICB2YXIgY2h1bmtTaXplID0gODE5MjtcclxuICAgIHZhciB1aW50OCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcclxuXHJcbiAgICB3aGlsZSAodWludDgubGVuZ3RoID4gMCkge1xyXG4gICAgICAvLyBYWFg6IEJhYmVsJ3MgYHRvQ29uc3VtYWJsZUFycmF5YCBoZWxwZXIgd2lsbCB0aHJvdyBlcnJvciBpbiBJRSBvciBTYWZhcmkgOVxyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxyXG4gICAgICBjaHVua3MucHVzaChmcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdG9BcnJheSh1aW50OC5zdWJhcnJheSgwLCBjaHVua1NpemUpKSkpO1xyXG4gICAgICB1aW50OCA9IHVpbnQ4LnN1YmFycmF5KGNodW5rU2l6ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFwiZGF0YTpcIi5jb25jYXQobWltZVR5cGUsIFwiO2Jhc2U2NCxcIikuY29uY2F0KGJ0b2EoY2h1bmtzLmpvaW4oJycpKSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEdldCBvcmllbnRhdGlvbiB2YWx1ZSBmcm9tIGdpdmVuIGFycmF5IGJ1ZmZlci5cclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciAtIFRoZSBhcnJheSBidWZmZXIgdG8gcmVhZC5cclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVhZCBvcmllbnRhdGlvbiB2YWx1ZS5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gcmVzZXRBbmRHZXRPcmllbnRhdGlvbihhcnJheUJ1ZmZlcikge1xyXG4gICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcclxuICAgIHZhciBvcmllbnRhdGlvbjsgLy8gSWdub3JlcyByYW5nZSBlcnJvciB3aGVuIHRoZSBpbWFnZSBkb2VzIG5vdCBoYXZlIGNvcnJlY3QgRXhpZiBpbmZvcm1hdGlvblxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHZhciBsaXR0bGVFbmRpYW47XHJcbiAgICAgIHZhciBhcHAxU3RhcnQ7XHJcbiAgICAgIHZhciBpZmRTdGFydDsgLy8gT25seSBoYW5kbGUgSlBFRyBpbWFnZSAoc3RhcnQgYnkgMHhGRkQ4KVxyXG5cclxuICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KDApID09PSAweEZGICYmIGRhdGFWaWV3LmdldFVpbnQ4KDEpID09PSAweEQ4KSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGFWaWV3LmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IDI7XHJcblxyXG4gICAgICAgIHdoaWxlIChvZmZzZXQgKyAxIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSA9PT0gMHhGRiAmJiBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyAxKSA9PT0gMHhFMSkge1xyXG4gICAgICAgICAgICBhcHAxU3RhcnQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIG9mZnNldCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGFwcDFTdGFydCkge1xyXG4gICAgICAgIHZhciBleGlmSURDb2RlID0gYXBwMVN0YXJ0ICsgNDtcclxuICAgICAgICB2YXIgdGlmZk9mZnNldCA9IGFwcDFTdGFydCArIDEwO1xyXG5cclxuICAgICAgICBpZiAoZ2V0U3RyaW5nRnJvbUNoYXJDb2RlKGRhdGFWaWV3LCBleGlmSURDb2RlLCA0KSA9PT0gJ0V4aWYnKSB7XHJcbiAgICAgICAgICB2YXIgZW5kaWFubmVzcyA9IGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0KTtcclxuICAgICAgICAgIGxpdHRsZUVuZGlhbiA9IGVuZGlhbm5lc3MgPT09IDB4NDk0OTtcclxuXHJcbiAgICAgICAgICBpZiAobGl0dGxlRW5kaWFuIHx8IGVuZGlhbm5lc3MgPT09IDB4NEQ0RFxyXG4gICAgICAgICAgLyogYmlnRW5kaWFuICovXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQgKyAyLCBsaXR0bGVFbmRpYW4pID09PSAweDAwMkEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdElGRE9mZnNldCA9IGRhdGFWaWV3LmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgbGl0dGxlRW5kaWFuKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RJRkRPZmZzZXQgPj0gMHgwMDAwMDAwOCkge1xyXG4gICAgICAgICAgICAgICAgICBpZmRTdGFydCA9IHRpZmZPZmZzZXQgKyBmaXJzdElGRE9mZnNldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpZmRTdGFydCkge1xyXG4gICAgICAgIHZhciBfbGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDE2KGlmZFN0YXJ0LCBsaXR0bGVFbmRpYW4pO1xyXG5cclxuICAgICAgICB2YXIgX29mZnNldDtcclxuXHJcbiAgICAgICAgdmFyIGk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBfbGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgIF9vZmZzZXQgPSBpZmRTdGFydCArIGkgKiAxMiArIDI7XHJcblxyXG4gICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNihfb2Zmc2V0LCBsaXR0bGVFbmRpYW4pID09PSAweDAxMTJcclxuICAgICAgICAgIC8qIE9yaWVudGF0aW9uICovXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAvLyA4IGlzIHRoZSBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgdGFnJ3MgdmFsdWVcclxuICAgICAgICAgICAgICBfb2Zmc2V0ICs9IDg7IC8vIEdldCB0aGUgb3JpZ2luYWwgb3JpZW50YXRpb24gdmFsdWVcclxuXHJcbiAgICAgICAgICAgICAgb3JpZW50YXRpb24gPSBkYXRhVmlldy5nZXRVaW50MTYoX29mZnNldCwgbGl0dGxlRW5kaWFuKTsgLy8gT3ZlcnJpZGUgdGhlIG9yaWVudGF0aW9uIHdpdGggaXRzIGRlZmF1bHQgdmFsdWVcclxuXHJcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KF9vZmZzZXQsIDEsIGxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIG9yaWVudGF0aW9uID0gMTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3JpZW50YXRpb247XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFBhcnNlIEV4aWYgT3JpZW50YXRpb24gdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yaWVudGF0aW9uIC0gVGhlIG9yaWVudGF0aW9uIHRvIHBhcnNlLlxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwYXJzZWQgcmVzdWx0LlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBwYXJzZU9yaWVudGF0aW9uKG9yaWVudGF0aW9uKSB7XHJcbiAgICB2YXIgcm90YXRlID0gMDtcclxuICAgIHZhciBzY2FsZVggPSAxO1xyXG4gICAgdmFyIHNjYWxlWSA9IDE7XHJcblxyXG4gICAgc3dpdGNoIChvcmllbnRhdGlvbikge1xyXG4gICAgICAvLyBGbGlwIGhvcml6b250YWxcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIHNjYWxlWCA9IC0xO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAvLyBSb3RhdGUgbGVmdCAxODDCsFxyXG5cclxuICAgICAgY2FzZSAzOlxyXG4gICAgICAgIHJvdGF0ZSA9IC0xODA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIC8vIEZsaXAgdmVydGljYWxcclxuXHJcbiAgICAgIGNhc2UgNDpcclxuICAgICAgICBzY2FsZVkgPSAtMTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgLy8gRmxpcCB2ZXJ0aWNhbCBhbmQgcm90YXRlIHJpZ2h0IDkwwrBcclxuXHJcbiAgICAgIGNhc2UgNTpcclxuICAgICAgICByb3RhdGUgPSA5MDtcclxuICAgICAgICBzY2FsZVkgPSAtMTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgLy8gUm90YXRlIHJpZ2h0IDkwwrBcclxuXHJcbiAgICAgIGNhc2UgNjpcclxuICAgICAgICByb3RhdGUgPSA5MDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgLy8gRmxpcCBob3Jpem9udGFsIGFuZCByb3RhdGUgcmlnaHQgOTDCsFxyXG5cclxuICAgICAgY2FzZSA3OlxyXG4gICAgICAgIHJvdGF0ZSA9IDkwO1xyXG4gICAgICAgIHNjYWxlWCA9IC0xO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAvLyBSb3RhdGUgbGVmdCA5MMKwXHJcblxyXG4gICAgICBjYXNlIDg6XHJcbiAgICAgICAgcm90YXRlID0gLTkwO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJvdGF0ZTogcm90YXRlLFxyXG4gICAgICBzY2FsZVg6IHNjYWxlWCxcclxuICAgICAgc2NhbGVZOiBzY2FsZVlcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB2YXIgcmVuZGVyID0ge1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgIHRoaXMuaW5pdENvbnRhaW5lcigpO1xyXG4gICAgICB0aGlzLmluaXRDYW52YXMoKTtcclxuICAgICAgdGhpcy5pbml0Q3JvcEJveCgpO1xyXG4gICAgICB0aGlzLnJlbmRlckNhbnZhcygpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuY3JvcHBlZCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyQ3JvcEJveCgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gaW5pdENvbnRhaW5lcigpIHtcclxuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXHJcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gICAgICAgICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXHJcbiAgICAgICAgICBjcm9wcGVyID0gdGhpcy5jcm9wcGVyO1xyXG4gICAgICB2YXIgbWluV2lkdGggPSBOdW1iZXIob3B0aW9ucy5taW5Db250YWluZXJXaWR0aCk7XHJcbiAgICAgIHZhciBtaW5IZWlnaHQgPSBOdW1iZXIob3B0aW9ucy5taW5Db250YWluZXJIZWlnaHQpO1xyXG4gICAgICBhZGRDbGFzcyhjcm9wcGVyLCBDTEFTU19ISURERU4pO1xyXG4gICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBDTEFTU19ISURERU4pO1xyXG4gICAgICB2YXIgY29udGFpbmVyRGF0YSA9IHtcclxuICAgICAgICB3aWR0aDogTWF0aC5tYXgoY29udGFpbmVyLm9mZnNldFdpZHRoLCBtaW5XaWR0aCA+PSAwID8gbWluV2lkdGggOiBNSU5fQ09OVEFJTkVSX1dJRFRIKSxcclxuICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsIG1pbkhlaWdodCA+PSAwID8gbWluSGVpZ2h0IDogTUlOX0NPTlRBSU5FUl9IRUlHSFQpXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuY29udGFpbmVyRGF0YSA9IGNvbnRhaW5lckRhdGE7XHJcbiAgICAgIHNldFN0eWxlKGNyb3BwZXIsIHtcclxuICAgICAgICB3aWR0aDogY29udGFpbmVyRGF0YS53aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGNvbnRhaW5lckRhdGEuaGVpZ2h0XHJcbiAgICAgIH0pO1xyXG4gICAgICBhZGRDbGFzcyhlbGVtZW50LCBDTEFTU19ISURERU4pO1xyXG4gICAgICByZW1vdmVDbGFzcyhjcm9wcGVyLCBDTEFTU19ISURERU4pO1xyXG4gICAgfSxcclxuICAgIC8vIENhbnZhcyAoaW1hZ2Ugd3JhcHBlcilcclxuICAgIGluaXRDYW52YXM6IGZ1bmN0aW9uIGluaXRDYW52YXMoKSB7XHJcbiAgICAgIHZhciBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhLFxyXG4gICAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XHJcbiAgICAgIHZhciB2aWV3TW9kZSA9IHRoaXMub3B0aW9ucy52aWV3TW9kZTtcclxuICAgICAgdmFyIHJvdGF0ZWQgPSBNYXRoLmFicyhpbWFnZURhdGEucm90YXRlKSAlIDE4MCA9PT0gOTA7XHJcbiAgICAgIHZhciBuYXR1cmFsV2lkdGggPSByb3RhdGVkID8gaW1hZ2VEYXRhLm5hdHVyYWxIZWlnaHQgOiBpbWFnZURhdGEubmF0dXJhbFdpZHRoO1xyXG4gICAgICB2YXIgbmF0dXJhbEhlaWdodCA9IHJvdGF0ZWQgPyBpbWFnZURhdGEubmF0dXJhbFdpZHRoIDogaW1hZ2VEYXRhLm5hdHVyYWxIZWlnaHQ7XHJcbiAgICAgIHZhciBhc3BlY3RSYXRpbyA9IG5hdHVyYWxXaWR0aCAvIG5hdHVyYWxIZWlnaHQ7XHJcbiAgICAgIHZhciBjYW52YXNXaWR0aCA9IGNvbnRhaW5lckRhdGEud2lkdGg7XHJcbiAgICAgIHZhciBjYW52YXNIZWlnaHQgPSBjb250YWluZXJEYXRhLmhlaWdodDtcclxuXHJcbiAgICAgIGlmIChjb250YWluZXJEYXRhLmhlaWdodCAqIGFzcGVjdFJhdGlvID4gY29udGFpbmVyRGF0YS53aWR0aCkge1xyXG4gICAgICAgIGlmICh2aWV3TW9kZSA9PT0gMykge1xyXG4gICAgICAgICAgY2FudmFzV2lkdGggPSBjb250YWluZXJEYXRhLmhlaWdodCAqIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjYW52YXNIZWlnaHQgPSBjb250YWluZXJEYXRhLndpZHRoIC8gYXNwZWN0UmF0aW87XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHZpZXdNb2RlID09PSAzKSB7XHJcbiAgICAgICAgY2FudmFzSGVpZ2h0ID0gY29udGFpbmVyRGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNhbnZhc1dpZHRoID0gY29udGFpbmVyRGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbztcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNhbnZhc0RhdGEgPSB7XHJcbiAgICAgICAgYXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvLFxyXG4gICAgICAgIG5hdHVyYWxXaWR0aDogbmF0dXJhbFdpZHRoLFxyXG4gICAgICAgIG5hdHVyYWxIZWlnaHQ6IG5hdHVyYWxIZWlnaHQsXHJcbiAgICAgICAgd2lkdGg6IGNhbnZhc1dpZHRoLFxyXG4gICAgICAgIGhlaWdodDogY2FudmFzSGVpZ2h0XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuY2FudmFzRGF0YSA9IGNhbnZhc0RhdGE7XHJcbiAgICAgIHRoaXMubGltaXRlZCA9IHZpZXdNb2RlID09PSAxIHx8IHZpZXdNb2RlID09PSAyO1xyXG4gICAgICB0aGlzLmxpbWl0Q2FudmFzKHRydWUsIHRydWUpO1xyXG4gICAgICBjYW52YXNEYXRhLndpZHRoID0gTWF0aC5taW4oTWF0aC5tYXgoY2FudmFzRGF0YS53aWR0aCwgY2FudmFzRGF0YS5taW5XaWR0aCksIGNhbnZhc0RhdGEubWF4V2lkdGgpO1xyXG4gICAgICBjYW52YXNEYXRhLmhlaWdodCA9IE1hdGgubWluKE1hdGgubWF4KGNhbnZhc0RhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLm1pbkhlaWdodCksIGNhbnZhc0RhdGEubWF4SGVpZ2h0KTtcclxuICAgICAgY2FudmFzRGF0YS5sZWZ0ID0gKGNvbnRhaW5lckRhdGEud2lkdGggLSBjYW52YXNEYXRhLndpZHRoKSAvIDI7XHJcbiAgICAgIGNhbnZhc0RhdGEudG9wID0gKGNvbnRhaW5lckRhdGEuaGVpZ2h0IC0gY2FudmFzRGF0YS5oZWlnaHQpIC8gMjtcclxuICAgICAgY2FudmFzRGF0YS5vbGRMZWZ0ID0gY2FudmFzRGF0YS5sZWZ0O1xyXG4gICAgICBjYW52YXNEYXRhLm9sZFRvcCA9IGNhbnZhc0RhdGEudG9wO1xyXG4gICAgICB0aGlzLmluaXRpYWxDYW52YXNEYXRhID0gYXNzaWduKHt9LCBjYW52YXNEYXRhKTtcclxuICAgIH0sXHJcbiAgICBsaW1pdENhbnZhczogZnVuY3Rpb24gbGltaXRDYW52YXMoc2l6ZUxpbWl0ZWQsIHBvc2l0aW9uTGltaXRlZCkge1xyXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuICAgICAgICAgIGNvbnRhaW5lckRhdGEgPSB0aGlzLmNvbnRhaW5lckRhdGEsXHJcbiAgICAgICAgICBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhLFxyXG4gICAgICAgICAgY3JvcEJveERhdGEgPSB0aGlzLmNyb3BCb3hEYXRhO1xyXG4gICAgICB2YXIgdmlld01vZGUgPSBvcHRpb25zLnZpZXdNb2RlO1xyXG4gICAgICB2YXIgYXNwZWN0UmF0aW8gPSBjYW52YXNEYXRhLmFzcGVjdFJhdGlvO1xyXG4gICAgICB2YXIgY3JvcHBlZCA9IHRoaXMuY3JvcHBlZCAmJiBjcm9wQm94RGF0YTtcclxuXHJcbiAgICAgIGlmIChzaXplTGltaXRlZCkge1xyXG4gICAgICAgIHZhciBtaW5DYW52YXNXaWR0aCA9IE51bWJlcihvcHRpb25zLm1pbkNhbnZhc1dpZHRoKSB8fCAwO1xyXG4gICAgICAgIHZhciBtaW5DYW52YXNIZWlnaHQgPSBOdW1iZXIob3B0aW9ucy5taW5DYW52YXNIZWlnaHQpIHx8IDA7XHJcblxyXG4gICAgICAgIGlmICh2aWV3TW9kZSA+IDEpIHtcclxuICAgICAgICAgIG1pbkNhbnZhc1dpZHRoID0gTWF0aC5tYXgobWluQ2FudmFzV2lkdGgsIGNvbnRhaW5lckRhdGEud2lkdGgpO1xyXG4gICAgICAgICAgbWluQ2FudmFzSGVpZ2h0ID0gTWF0aC5tYXgobWluQ2FudmFzSGVpZ2h0LCBjb250YWluZXJEYXRhLmhlaWdodCk7XHJcblxyXG4gICAgICAgICAgaWYgKHZpZXdNb2RlID09PSAzKSB7XHJcbiAgICAgICAgICAgIGlmIChtaW5DYW52YXNIZWlnaHQgKiBhc3BlY3RSYXRpbyA+IG1pbkNhbnZhc1dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBtaW5DYW52YXNIZWlnaHQgKiBhc3BlY3RSYXRpbztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBtaW5DYW52YXNIZWlnaHQgPSBtaW5DYW52YXNXaWR0aCAvIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh2aWV3TW9kZSA+IDApIHtcclxuICAgICAgICAgIGlmIChtaW5DYW52YXNXaWR0aCkge1xyXG4gICAgICAgICAgICBtaW5DYW52YXNXaWR0aCA9IE1hdGgubWF4KG1pbkNhbnZhc1dpZHRoLCBjcm9wcGVkID8gY3JvcEJveERhdGEud2lkdGggOiAwKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAobWluQ2FudmFzSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IE1hdGgubWF4KG1pbkNhbnZhc0hlaWdodCwgY3JvcHBlZCA/IGNyb3BCb3hEYXRhLmhlaWdodCA6IDApO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9wcGVkKSB7XHJcbiAgICAgICAgICAgIG1pbkNhbnZhc1dpZHRoID0gY3JvcEJveERhdGEud2lkdGg7XHJcbiAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IGNyb3BCb3hEYXRhLmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIGlmIChtaW5DYW52YXNIZWlnaHQgKiBhc3BlY3RSYXRpbyA+IG1pbkNhbnZhc1dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBtaW5DYW52YXNIZWlnaHQgKiBhc3BlY3RSYXRpbztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBtaW5DYW52YXNIZWlnaHQgPSBtaW5DYW52YXNXaWR0aCAvIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgX2dldEFkanVzdGVkU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcclxuICAgICAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcclxuICAgICAgICAgIHdpZHRoOiBtaW5DYW52YXNXaWR0aCxcclxuICAgICAgICAgIGhlaWdodDogbWluQ2FudmFzSGVpZ2h0XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG1pbkNhbnZhc1dpZHRoID0gX2dldEFkanVzdGVkU2l6ZXMud2lkdGg7XHJcbiAgICAgICAgbWluQ2FudmFzSGVpZ2h0ID0gX2dldEFkanVzdGVkU2l6ZXMuaGVpZ2h0O1xyXG4gICAgICAgIGNhbnZhc0RhdGEubWluV2lkdGggPSBtaW5DYW52YXNXaWR0aDtcclxuICAgICAgICBjYW52YXNEYXRhLm1pbkhlaWdodCA9IG1pbkNhbnZhc0hlaWdodDtcclxuICAgICAgICBjYW52YXNEYXRhLm1heFdpZHRoID0gSW5maW5pdHk7XHJcbiAgICAgICAgY2FudmFzRGF0YS5tYXhIZWlnaHQgPSBJbmZpbml0eTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBvc2l0aW9uTGltaXRlZCkge1xyXG4gICAgICAgIGlmICh2aWV3TW9kZSA+IChjcm9wcGVkID8gMCA6IDEpKSB7XHJcbiAgICAgICAgICB2YXIgbmV3Q2FudmFzTGVmdCA9IGNvbnRhaW5lckRhdGEud2lkdGggLSBjYW52YXNEYXRhLndpZHRoO1xyXG4gICAgICAgICAgdmFyIG5ld0NhbnZhc1RvcCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0IC0gY2FudmFzRGF0YS5oZWlnaHQ7XHJcbiAgICAgICAgICBjYW52YXNEYXRhLm1pbkxlZnQgPSBNYXRoLm1pbigwLCBuZXdDYW52YXNMZWZ0KTtcclxuICAgICAgICAgIGNhbnZhc0RhdGEubWluVG9wID0gTWF0aC5taW4oMCwgbmV3Q2FudmFzVG9wKTtcclxuICAgICAgICAgIGNhbnZhc0RhdGEubWF4TGVmdCA9IE1hdGgubWF4KDAsIG5ld0NhbnZhc0xlZnQpO1xyXG4gICAgICAgICAgY2FudmFzRGF0YS5tYXhUb3AgPSBNYXRoLm1heCgwLCBuZXdDYW52YXNUb3ApO1xyXG5cclxuICAgICAgICAgIGlmIChjcm9wcGVkICYmIHRoaXMubGltaXRlZCkge1xyXG4gICAgICAgICAgICBjYW52YXNEYXRhLm1pbkxlZnQgPSBNYXRoLm1pbihjcm9wQm94RGF0YS5sZWZ0LCBjcm9wQm94RGF0YS5sZWZ0ICsgKGNyb3BCb3hEYXRhLndpZHRoIC0gY2FudmFzRGF0YS53aWR0aCkpO1xyXG4gICAgICAgICAgICBjYW52YXNEYXRhLm1pblRvcCA9IE1hdGgubWluKGNyb3BCb3hEYXRhLnRvcCwgY3JvcEJveERhdGEudG9wICsgKGNyb3BCb3hEYXRhLmhlaWdodCAtIGNhbnZhc0RhdGEuaGVpZ2h0KSk7XHJcbiAgICAgICAgICAgIGNhbnZhc0RhdGEubWF4TGVmdCA9IGNyb3BCb3hEYXRhLmxlZnQ7XHJcbiAgICAgICAgICAgIGNhbnZhc0RhdGEubWF4VG9wID0gY3JvcEJveERhdGEudG9wO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZpZXdNb2RlID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGNhbnZhc0RhdGEud2lkdGggPj0gY29udGFpbmVyRGF0YS53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgY2FudmFzRGF0YS5taW5MZWZ0ID0gTWF0aC5taW4oMCwgbmV3Q2FudmFzTGVmdCk7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNEYXRhLm1heExlZnQgPSBNYXRoLm1heCgwLCBuZXdDYW52YXNMZWZ0KTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChjYW52YXNEYXRhLmhlaWdodCA+PSBjb250YWluZXJEYXRhLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgY2FudmFzRGF0YS5taW5Ub3AgPSBNYXRoLm1pbigwLCBuZXdDYW52YXNUb3ApO1xyXG4gICAgICAgICAgICAgICAgY2FudmFzRGF0YS5tYXhUb3AgPSBNYXRoLm1heCgwLCBuZXdDYW52YXNUb3ApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjYW52YXNEYXRhLm1pbkxlZnQgPSAtY2FudmFzRGF0YS53aWR0aDtcclxuICAgICAgICAgIGNhbnZhc0RhdGEubWluVG9wID0gLWNhbnZhc0RhdGEuaGVpZ2h0O1xyXG4gICAgICAgICAgY2FudmFzRGF0YS5tYXhMZWZ0ID0gY29udGFpbmVyRGF0YS53aWR0aDtcclxuICAgICAgICAgIGNhbnZhc0RhdGEubWF4VG9wID0gY29udGFpbmVyRGF0YS5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyQ2FudmFzOiBmdW5jdGlvbiByZW5kZXJDYW52YXMoY2hhbmdlZCwgdHJhbnNmb3JtZWQpIHtcclxuICAgICAgdmFyIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXHJcbiAgICAgICAgICBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTtcclxuXHJcbiAgICAgIGlmICh0cmFuc2Zvcm1lZCkge1xyXG4gICAgICAgIHZhciBfZ2V0Um90YXRlZFNpemVzID0gZ2V0Um90YXRlZFNpemVzKHtcclxuICAgICAgICAgIHdpZHRoOiBpbWFnZURhdGEubmF0dXJhbFdpZHRoICogTWF0aC5hYnMoaW1hZ2VEYXRhLnNjYWxlWCB8fCAxKSxcclxuICAgICAgICAgIGhlaWdodDogaW1hZ2VEYXRhLm5hdHVyYWxIZWlnaHQgKiBNYXRoLmFicyhpbWFnZURhdGEuc2NhbGVZIHx8IDEpLFxyXG4gICAgICAgICAgZGVncmVlOiBpbWFnZURhdGEucm90YXRlIHx8IDBcclxuICAgICAgICB9KSxcclxuICAgICAgICAgICAgbmF0dXJhbFdpZHRoID0gX2dldFJvdGF0ZWRTaXplcy53aWR0aCxcclxuICAgICAgICAgICAgbmF0dXJhbEhlaWdodCA9IF9nZXRSb3RhdGVkU2l6ZXMuaGVpZ2h0O1xyXG5cclxuICAgICAgICB2YXIgd2lkdGggPSBjYW52YXNEYXRhLndpZHRoICogKG5hdHVyYWxXaWR0aCAvIGNhbnZhc0RhdGEubmF0dXJhbFdpZHRoKTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gY2FudmFzRGF0YS5oZWlnaHQgKiAobmF0dXJhbEhlaWdodCAvIGNhbnZhc0RhdGEubmF0dXJhbEhlaWdodCk7XHJcbiAgICAgICAgY2FudmFzRGF0YS5sZWZ0IC09ICh3aWR0aCAtIGNhbnZhc0RhdGEud2lkdGgpIC8gMjtcclxuICAgICAgICBjYW52YXNEYXRhLnRvcCAtPSAoaGVpZ2h0IC0gY2FudmFzRGF0YS5oZWlnaHQpIC8gMjtcclxuICAgICAgICBjYW52YXNEYXRhLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgY2FudmFzRGF0YS5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgY2FudmFzRGF0YS5hc3BlY3RSYXRpbyA9IG5hdHVyYWxXaWR0aCAvIG5hdHVyYWxIZWlnaHQ7XHJcbiAgICAgICAgY2FudmFzRGF0YS5uYXR1cmFsV2lkdGggPSBuYXR1cmFsV2lkdGg7XHJcbiAgICAgICAgY2FudmFzRGF0YS5uYXR1cmFsSGVpZ2h0ID0gbmF0dXJhbEhlaWdodDtcclxuICAgICAgICB0aGlzLmxpbWl0Q2FudmFzKHRydWUsIGZhbHNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNhbnZhc0RhdGEud2lkdGggPiBjYW52YXNEYXRhLm1heFdpZHRoIHx8IGNhbnZhc0RhdGEud2lkdGggPCBjYW52YXNEYXRhLm1pbldpZHRoKSB7XHJcbiAgICAgICAgY2FudmFzRGF0YS5sZWZ0ID0gY2FudmFzRGF0YS5vbGRMZWZ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2FudmFzRGF0YS5oZWlnaHQgPiBjYW52YXNEYXRhLm1heEhlaWdodCB8fCBjYW52YXNEYXRhLmhlaWdodCA8IGNhbnZhc0RhdGEubWluSGVpZ2h0KSB7XHJcbiAgICAgICAgY2FudmFzRGF0YS50b3AgPSBjYW52YXNEYXRhLm9sZFRvcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FudmFzRGF0YS53aWR0aCA9IE1hdGgubWluKE1hdGgubWF4KGNhbnZhc0RhdGEud2lkdGgsIGNhbnZhc0RhdGEubWluV2lkdGgpLCBjYW52YXNEYXRhLm1heFdpZHRoKTtcclxuICAgICAgY2FudmFzRGF0YS5oZWlnaHQgPSBNYXRoLm1pbihNYXRoLm1heChjYW52YXNEYXRhLmhlaWdodCwgY2FudmFzRGF0YS5taW5IZWlnaHQpLCBjYW52YXNEYXRhLm1heEhlaWdodCk7XHJcbiAgICAgIHRoaXMubGltaXRDYW52YXMoZmFsc2UsIHRydWUpO1xyXG4gICAgICBjYW52YXNEYXRhLmxlZnQgPSBNYXRoLm1pbihNYXRoLm1heChjYW52YXNEYXRhLmxlZnQsIGNhbnZhc0RhdGEubWluTGVmdCksIGNhbnZhc0RhdGEubWF4TGVmdCk7XHJcbiAgICAgIGNhbnZhc0RhdGEudG9wID0gTWF0aC5taW4oTWF0aC5tYXgoY2FudmFzRGF0YS50b3AsIGNhbnZhc0RhdGEubWluVG9wKSwgY2FudmFzRGF0YS5tYXhUb3ApO1xyXG4gICAgICBjYW52YXNEYXRhLm9sZExlZnQgPSBjYW52YXNEYXRhLmxlZnQ7XHJcbiAgICAgIGNhbnZhc0RhdGEub2xkVG9wID0gY2FudmFzRGF0YS50b3A7XHJcbiAgICAgIHNldFN0eWxlKHRoaXMuY2FudmFzLCBhc3NpZ24oe1xyXG4gICAgICAgIHdpZHRoOiBjYW52YXNEYXRhLndpZHRoLFxyXG4gICAgICAgIGhlaWdodDogY2FudmFzRGF0YS5oZWlnaHRcclxuICAgICAgfSwgZ2V0VHJhbnNmb3Jtcyh7XHJcbiAgICAgICAgdHJhbnNsYXRlWDogY2FudmFzRGF0YS5sZWZ0LFxyXG4gICAgICAgIHRyYW5zbGF0ZVk6IGNhbnZhc0RhdGEudG9wXHJcbiAgICAgIH0pKSk7XHJcbiAgICAgIHRoaXMucmVuZGVySW1hZ2UoY2hhbmdlZCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5jcm9wcGVkICYmIHRoaXMubGltaXRlZCkge1xyXG4gICAgICAgIHRoaXMubGltaXRDcm9wQm94KHRydWUsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVuZGVySW1hZ2U6IGZ1bmN0aW9uIHJlbmRlckltYWdlKGNoYW5nZWQpIHtcclxuICAgICAgdmFyIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXHJcbiAgICAgICAgICBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTtcclxuICAgICAgdmFyIHdpZHRoID0gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aCAqIChjYW52YXNEYXRhLndpZHRoIC8gY2FudmFzRGF0YS5uYXR1cmFsV2lkdGgpO1xyXG4gICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2VEYXRhLm5hdHVyYWxIZWlnaHQgKiAoY2FudmFzRGF0YS5oZWlnaHQgLyBjYW52YXNEYXRhLm5hdHVyYWxIZWlnaHQpO1xyXG4gICAgICBhc3NpZ24oaW1hZ2VEYXRhLCB7XHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIGxlZnQ6IChjYW52YXNEYXRhLndpZHRoIC0gd2lkdGgpIC8gMixcclxuICAgICAgICB0b3A6IChjYW52YXNEYXRhLmhlaWdodCAtIGhlaWdodCkgLyAyXHJcbiAgICAgIH0pO1xyXG4gICAgICBzZXRTdHlsZSh0aGlzLmltYWdlLCBhc3NpZ24oe1xyXG4gICAgICAgIHdpZHRoOiBpbWFnZURhdGEud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBpbWFnZURhdGEuaGVpZ2h0XHJcbiAgICAgIH0sIGdldFRyYW5zZm9ybXMoYXNzaWduKHtcclxuICAgICAgICB0cmFuc2xhdGVYOiBpbWFnZURhdGEubGVmdCxcclxuICAgICAgICB0cmFuc2xhdGVZOiBpbWFnZURhdGEudG9wXHJcbiAgICAgIH0sIGltYWdlRGF0YSkpKSk7XHJcblxyXG4gICAgICBpZiAoY2hhbmdlZCkge1xyXG4gICAgICAgIHRoaXMub3V0cHV0KCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBpbml0Q3JvcEJveDogZnVuY3Rpb24gaW5pdENyb3BCb3goKSB7XHJcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gICAgICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcclxuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gb3B0aW9ucy5hc3BlY3RSYXRpbyB8fCBvcHRpb25zLmluaXRpYWxBc3BlY3RSYXRpbztcclxuICAgICAgdmFyIGF1dG9Dcm9wQXJlYSA9IE51bWJlcihvcHRpb25zLmF1dG9Dcm9wQXJlYSkgfHwgMC44O1xyXG4gICAgICB2YXIgY3JvcEJveERhdGEgPSB7XHJcbiAgICAgICAgd2lkdGg6IGNhbnZhc0RhdGEud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBjYW52YXNEYXRhLmhlaWdodFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XHJcbiAgICAgICAgaWYgKGNhbnZhc0RhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBjYW52YXNEYXRhLndpZHRoKSB7XHJcbiAgICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBjcm9wQm94RGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjcm9wQm94RGF0YS53aWR0aCA9IGNyb3BCb3hEYXRhLmhlaWdodCAqIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5jcm9wQm94RGF0YSA9IGNyb3BCb3hEYXRhO1xyXG4gICAgICB0aGlzLmxpbWl0Q3JvcEJveCh0cnVlLCB0cnVlKTsgLy8gSW5pdGlhbGl6ZSBhdXRvIGNyb3AgYXJlYVxyXG5cclxuICAgICAgY3JvcEJveERhdGEud2lkdGggPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS53aWR0aCwgY3JvcEJveERhdGEubWluV2lkdGgpLCBjcm9wQm94RGF0YS5tYXhXaWR0aCk7XHJcbiAgICAgIGNyb3BCb3hEYXRhLmhlaWdodCA9IE1hdGgubWluKE1hdGgubWF4KGNyb3BCb3hEYXRhLmhlaWdodCwgY3JvcEJveERhdGEubWluSGVpZ2h0KSwgY3JvcEJveERhdGEubWF4SGVpZ2h0KTsgLy8gVGhlIHdpZHRoL2hlaWdodCBvZiBhdXRvIGNyb3AgYXJlYSBtdXN0IGxhcmdlIHRoYW4gXCJtaW5XaWR0aC9IZWlnaHRcIlxyXG5cclxuICAgICAgY3JvcEJveERhdGEud2lkdGggPSBNYXRoLm1heChjcm9wQm94RGF0YS5taW5XaWR0aCwgY3JvcEJveERhdGEud2lkdGggKiBhdXRvQ3JvcEFyZWEpO1xyXG4gICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBNYXRoLm1heChjcm9wQm94RGF0YS5taW5IZWlnaHQsIGNyb3BCb3hEYXRhLmhlaWdodCAqIGF1dG9Dcm9wQXJlYSk7XHJcbiAgICAgIGNyb3BCb3hEYXRhLmxlZnQgPSBjYW52YXNEYXRhLmxlZnQgKyAoY2FudmFzRGF0YS53aWR0aCAtIGNyb3BCb3hEYXRhLndpZHRoKSAvIDI7XHJcbiAgICAgIGNyb3BCb3hEYXRhLnRvcCA9IGNhbnZhc0RhdGEudG9wICsgKGNhbnZhc0RhdGEuaGVpZ2h0IC0gY3JvcEJveERhdGEuaGVpZ2h0KSAvIDI7XHJcbiAgICAgIGNyb3BCb3hEYXRhLm9sZExlZnQgPSBjcm9wQm94RGF0YS5sZWZ0O1xyXG4gICAgICBjcm9wQm94RGF0YS5vbGRUb3AgPSBjcm9wQm94RGF0YS50b3A7XHJcbiAgICAgIHRoaXMuaW5pdGlhbENyb3BCb3hEYXRhID0gYXNzaWduKHt9LCBjcm9wQm94RGF0YSk7XHJcbiAgICB9LFxyXG4gICAgbGltaXRDcm9wQm94OiBmdW5jdGlvbiBsaW1pdENyb3BCb3goc2l6ZUxpbWl0ZWQsIHBvc2l0aW9uTGltaXRlZCkge1xyXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuICAgICAgICAgIGNvbnRhaW5lckRhdGEgPSB0aGlzLmNvbnRhaW5lckRhdGEsXHJcbiAgICAgICAgICBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhLFxyXG4gICAgICAgICAgY3JvcEJveERhdGEgPSB0aGlzLmNyb3BCb3hEYXRhLFxyXG4gICAgICAgICAgbGltaXRlZCA9IHRoaXMubGltaXRlZDtcclxuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gb3B0aW9ucy5hc3BlY3RSYXRpbztcclxuXHJcbiAgICAgIGlmIChzaXplTGltaXRlZCkge1xyXG4gICAgICAgIHZhciBtaW5Dcm9wQm94V2lkdGggPSBOdW1iZXIob3B0aW9ucy5taW5Dcm9wQm94V2lkdGgpIHx8IDA7XHJcbiAgICAgICAgdmFyIG1pbkNyb3BCb3hIZWlnaHQgPSBOdW1iZXIob3B0aW9ucy5taW5Dcm9wQm94SGVpZ2h0KSB8fCAwO1xyXG4gICAgICAgIHZhciBtYXhDcm9wQm94V2lkdGggPSBsaW1pdGVkID8gTWF0aC5taW4oY29udGFpbmVyRGF0YS53aWR0aCwgY2FudmFzRGF0YS53aWR0aCwgY2FudmFzRGF0YS53aWR0aCArIGNhbnZhc0RhdGEubGVmdCwgY29udGFpbmVyRGF0YS53aWR0aCAtIGNhbnZhc0RhdGEubGVmdCkgOiBjb250YWluZXJEYXRhLndpZHRoO1xyXG4gICAgICAgIHZhciBtYXhDcm9wQm94SGVpZ2h0ID0gbGltaXRlZCA/IE1hdGgubWluKGNvbnRhaW5lckRhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLmhlaWdodCwgY2FudmFzRGF0YS5oZWlnaHQgKyBjYW52YXNEYXRhLnRvcCwgY29udGFpbmVyRGF0YS5oZWlnaHQgLSBjYW52YXNEYXRhLnRvcCkgOiBjb250YWluZXJEYXRhLmhlaWdodDsgLy8gVGhlIG1pbi9tYXhDcm9wQm94V2lkdGgvSGVpZ2h0IG11c3QgYmUgbGVzcyB0aGFuIGNvbnRhaW5lcidzIHdpZHRoL2hlaWdodFxyXG5cclxuICAgICAgICBtaW5Dcm9wQm94V2lkdGggPSBNYXRoLm1pbihtaW5Dcm9wQm94V2lkdGgsIGNvbnRhaW5lckRhdGEud2lkdGgpO1xyXG4gICAgICAgIG1pbkNyb3BCb3hIZWlnaHQgPSBNYXRoLm1pbihtaW5Dcm9wQm94SGVpZ2h0LCBjb250YWluZXJEYXRhLmhlaWdodCk7XHJcblxyXG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xyXG4gICAgICAgICAgaWYgKG1pbkNyb3BCb3hXaWR0aCAmJiBtaW5Dcm9wQm94SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGlmIChtaW5Dcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBtaW5Dcm9wQm94V2lkdGgpIHtcclxuICAgICAgICAgICAgICBtaW5Dcm9wQm94SGVpZ2h0ID0gbWluQ3JvcEJveFdpZHRoIC8gYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbWluQ3JvcEJveFdpZHRoID0gbWluQ3JvcEJveEhlaWdodCAqIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKG1pbkNyb3BCb3hXaWR0aCkge1xyXG4gICAgICAgICAgICBtaW5Dcm9wQm94SGVpZ2h0ID0gbWluQ3JvcEJveFdpZHRoIC8gYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKG1pbkNyb3BCb3hIZWlnaHQpIHtcclxuICAgICAgICAgICAgbWluQ3JvcEJveFdpZHRoID0gbWluQ3JvcEJveEhlaWdodCAqIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChtYXhDcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBtYXhDcm9wQm94V2lkdGgpIHtcclxuICAgICAgICAgICAgbWF4Q3JvcEJveEhlaWdodCA9IG1heENyb3BCb3hXaWR0aCAvIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWF4Q3JvcEJveFdpZHRoID0gbWF4Q3JvcEJveEhlaWdodCAqIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gLy8gVGhlIG1pbldpZHRoL0hlaWdodCBtdXN0IGJlIGxlc3MgdGhhbiBtYXhXaWR0aC9IZWlnaHRcclxuXHJcblxyXG4gICAgICAgIGNyb3BCb3hEYXRhLm1pbldpZHRoID0gTWF0aC5taW4obWluQ3JvcEJveFdpZHRoLCBtYXhDcm9wQm94V2lkdGgpO1xyXG4gICAgICAgIGNyb3BCb3hEYXRhLm1pbkhlaWdodCA9IE1hdGgubWluKG1pbkNyb3BCb3hIZWlnaHQsIG1heENyb3BCb3hIZWlnaHQpO1xyXG4gICAgICAgIGNyb3BCb3hEYXRhLm1heFdpZHRoID0gbWF4Q3JvcEJveFdpZHRoO1xyXG4gICAgICAgIGNyb3BCb3hEYXRhLm1heEhlaWdodCA9IG1heENyb3BCb3hIZWlnaHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwb3NpdGlvbkxpbWl0ZWQpIHtcclxuICAgICAgICBpZiAobGltaXRlZCkge1xyXG4gICAgICAgICAgY3JvcEJveERhdGEubWluTGVmdCA9IE1hdGgubWF4KDAsIGNhbnZhc0RhdGEubGVmdCk7XHJcbiAgICAgICAgICBjcm9wQm94RGF0YS5taW5Ub3AgPSBNYXRoLm1heCgwLCBjYW52YXNEYXRhLnRvcCk7XHJcbiAgICAgICAgICBjcm9wQm94RGF0YS5tYXhMZWZ0ID0gTWF0aC5taW4oY29udGFpbmVyRGF0YS53aWR0aCwgY2FudmFzRGF0YS5sZWZ0ICsgY2FudmFzRGF0YS53aWR0aCkgLSBjcm9wQm94RGF0YS53aWR0aDtcclxuICAgICAgICAgIGNyb3BCb3hEYXRhLm1heFRvcCA9IE1hdGgubWluKGNvbnRhaW5lckRhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLnRvcCArIGNhbnZhc0RhdGEuaGVpZ2h0KSAtIGNyb3BCb3hEYXRhLmhlaWdodDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY3JvcEJveERhdGEubWluTGVmdCA9IDA7XHJcbiAgICAgICAgICBjcm9wQm94RGF0YS5taW5Ub3AgPSAwO1xyXG4gICAgICAgICAgY3JvcEJveERhdGEubWF4TGVmdCA9IGNvbnRhaW5lckRhdGEud2lkdGggLSBjcm9wQm94RGF0YS53aWR0aDtcclxuICAgICAgICAgIGNyb3BCb3hEYXRhLm1heFRvcCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0IC0gY3JvcEJveERhdGEuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbmRlckNyb3BCb3g6IGZ1bmN0aW9uIHJlbmRlckNyb3BCb3goKSB7XHJcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gICAgICAgICAgY29udGFpbmVyRGF0YSA9IHRoaXMuY29udGFpbmVyRGF0YSxcclxuICAgICAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcclxuXHJcbiAgICAgIGlmIChjcm9wQm94RGF0YS53aWR0aCA+IGNyb3BCb3hEYXRhLm1heFdpZHRoIHx8IGNyb3BCb3hEYXRhLndpZHRoIDwgY3JvcEJveERhdGEubWluV2lkdGgpIHtcclxuICAgICAgICBjcm9wQm94RGF0YS5sZWZ0ID0gY3JvcEJveERhdGEub2xkTGVmdDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNyb3BCb3hEYXRhLmhlaWdodCA+IGNyb3BCb3hEYXRhLm1heEhlaWdodCB8fCBjcm9wQm94RGF0YS5oZWlnaHQgPCBjcm9wQm94RGF0YS5taW5IZWlnaHQpIHtcclxuICAgICAgICBjcm9wQm94RGF0YS50b3AgPSBjcm9wQm94RGF0YS5vbGRUb3A7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNyb3BCb3hEYXRhLndpZHRoID0gTWF0aC5taW4oTWF0aC5tYXgoY3JvcEJveERhdGEud2lkdGgsIGNyb3BCb3hEYXRhLm1pbldpZHRoKSwgY3JvcEJveERhdGEubWF4V2lkdGgpO1xyXG4gICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS5oZWlnaHQsIGNyb3BCb3hEYXRhLm1pbkhlaWdodCksIGNyb3BCb3hEYXRhLm1heEhlaWdodCk7XHJcbiAgICAgIHRoaXMubGltaXRDcm9wQm94KGZhbHNlLCB0cnVlKTtcclxuICAgICAgY3JvcEJveERhdGEubGVmdCA9IE1hdGgubWluKE1hdGgubWF4KGNyb3BCb3hEYXRhLmxlZnQsIGNyb3BCb3hEYXRhLm1pbkxlZnQpLCBjcm9wQm94RGF0YS5tYXhMZWZ0KTtcclxuICAgICAgY3JvcEJveERhdGEudG9wID0gTWF0aC5taW4oTWF0aC5tYXgoY3JvcEJveERhdGEudG9wLCBjcm9wQm94RGF0YS5taW5Ub3ApLCBjcm9wQm94RGF0YS5tYXhUb3ApO1xyXG4gICAgICBjcm9wQm94RGF0YS5vbGRMZWZ0ID0gY3JvcEJveERhdGEubGVmdDtcclxuICAgICAgY3JvcEJveERhdGEub2xkVG9wID0gY3JvcEJveERhdGEudG9wO1xyXG5cclxuICAgICAgaWYgKG9wdGlvbnMubW92YWJsZSAmJiBvcHRpb25zLmNyb3BCb3hNb3ZhYmxlKSB7XHJcbiAgICAgICAgLy8gVHVybiB0byBtb3ZlIHRoZSBjYW52YXMgd2hlbiB0aGUgY3JvcCBib3ggaXMgZXF1YWwgdG8gdGhlIGNvbnRhaW5lclxyXG4gICAgICAgIHNldERhdGEodGhpcy5mYWNlLCBEQVRBX0FDVElPTiwgY3JvcEJveERhdGEud2lkdGggPj0gY29udGFpbmVyRGF0YS53aWR0aCAmJiBjcm9wQm94RGF0YS5oZWlnaHQgPj0gY29udGFpbmVyRGF0YS5oZWlnaHQgPyBBQ1RJT05fTU9WRSA6IEFDVElPTl9BTEwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXRTdHlsZSh0aGlzLmNyb3BCb3gsIGFzc2lnbih7XHJcbiAgICAgICAgd2lkdGg6IGNyb3BCb3hEYXRhLndpZHRoLFxyXG4gICAgICAgIGhlaWdodDogY3JvcEJveERhdGEuaGVpZ2h0XHJcbiAgICAgIH0sIGdldFRyYW5zZm9ybXMoe1xyXG4gICAgICAgIHRyYW5zbGF0ZVg6IGNyb3BCb3hEYXRhLmxlZnQsXHJcbiAgICAgICAgdHJhbnNsYXRlWTogY3JvcEJveERhdGEudG9wXHJcbiAgICAgIH0pKSk7XHJcblxyXG4gICAgICBpZiAodGhpcy5jcm9wcGVkICYmIHRoaXMubGltaXRlZCkge1xyXG4gICAgICAgIHRoaXMubGltaXRDYW52YXModHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICAgIHRoaXMub3V0cHV0KCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBvdXRwdXQ6IGZ1bmN0aW9uIG91dHB1dCgpIHtcclxuICAgICAgdGhpcy5wcmV2aWV3KCk7XHJcbiAgICAgIGRpc3BhdGNoRXZlbnQodGhpcy5lbGVtZW50LCBFVkVOVF9DUk9QLCB0aGlzLmdldERhdGEoKSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIHByZXZpZXcgPSB7XHJcbiAgICBpbml0UHJldmlldzogZnVuY3Rpb24gaW5pdFByZXZpZXcoKSB7XHJcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxyXG4gICAgICAgICAgY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG4gICAgICB2YXIgcHJldmlldyA9IHRoaXMub3B0aW9ucy5wcmV2aWV3O1xyXG4gICAgICB2YXIgdXJsID0gY3Jvc3NPcmlnaW4gPyB0aGlzLmNyb3NzT3JpZ2luVXJsIDogdGhpcy51cmw7XHJcbiAgICAgIHZhciBhbHQgPSBlbGVtZW50LmFsdCB8fCAnVGhlIGltYWdlIHRvIHByZXZpZXcnO1xyXG4gICAgICB2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHJcbiAgICAgIGlmIChjcm9zc09yaWdpbikge1xyXG4gICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGltYWdlLnNyYyA9IHVybDtcclxuICAgICAgaW1hZ2UuYWx0ID0gYWx0O1xyXG4gICAgICB0aGlzLnZpZXdCb3guYXBwZW5kQ2hpbGQoaW1hZ2UpO1xyXG4gICAgICB0aGlzLnZpZXdCb3hJbWFnZSA9IGltYWdlO1xyXG5cclxuICAgICAgaWYgKCFwcmV2aWV3KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcHJldmlld3MgPSBwcmV2aWV3O1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBwcmV2aWV3ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHByZXZpZXdzID0gZWxlbWVudC5vd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocHJldmlldyk7XHJcbiAgICAgIH0gZWxzZSBpZiAocHJldmlldy5xdWVyeVNlbGVjdG9yKSB7XHJcbiAgICAgICAgcHJldmlld3MgPSBbcHJldmlld107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucHJldmlld3MgPSBwcmV2aWV3cztcclxuICAgICAgZm9yRWFjaChwcmV2aWV3cywgZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpOyAvLyBTYXZlIHRoZSBvcmlnaW5hbCBzaXplIGZvciByZWNvdmVyXHJcblxyXG4gICAgICAgIHNldERhdGEoZWwsIERBVEFfUFJFVklFVywge1xyXG4gICAgICAgICAgd2lkdGg6IGVsLm9mZnNldFdpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0OiBlbC5vZmZzZXRIZWlnaHQsXHJcbiAgICAgICAgICBodG1sOiBlbC5pbm5lckhUTUxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGNyb3NzT3JpZ2luKSB7XHJcbiAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGltZy5zcmMgPSB1cmw7XHJcbiAgICAgICAgaW1nLmFsdCA9IGFsdDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPdmVycmlkZSBpbWcgZWxlbWVudCBzdHlsZXNcclxuICAgICAgICAgKiBBZGQgYGRpc3BsYXk6YmxvY2tgIHRvIGF2b2lkIG1hcmdpbiB0b3AgaXNzdWVcclxuICAgICAgICAgKiBBZGQgYGhlaWdodDphdXRvYCB0byBvdmVycmlkZSBgaGVpZ2h0YCBhdHRyaWJ1dGUgb24gSUU4XHJcbiAgICAgICAgICogKE9jY3VyIG9ubHkgd2hlbiBtYXJnaW4tdG9wIDw9IC1oZWlnaHQpXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIGltZy5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6YmxvY2s7JyArICd3aWR0aDoxMDAlOycgKyAnaGVpZ2h0OmF1dG87JyArICdtaW4td2lkdGg6MCFpbXBvcnRhbnQ7JyArICdtaW4taGVpZ2h0OjAhaW1wb3J0YW50OycgKyAnbWF4LXdpZHRoOm5vbmUhaW1wb3J0YW50OycgKyAnbWF4LWhlaWdodDpub25lIWltcG9ydGFudDsnICsgJ2ltYWdlLW9yaWVudGF0aW9uOjBkZWchaW1wb3J0YW50O1wiJztcclxuICAgICAgICBlbC5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICBlbC5hcHBlbmRDaGlsZChpbWcpO1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICByZXNldFByZXZpZXc6IGZ1bmN0aW9uIHJlc2V0UHJldmlldygpIHtcclxuICAgICAgZm9yRWFjaCh0aGlzLnByZXZpZXdzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtZW50LCBEQVRBX1BSRVZJRVcpO1xyXG4gICAgICAgIHNldFN0eWxlKGVsZW1lbnQsIHtcclxuICAgICAgICAgIHdpZHRoOiBkYXRhLndpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0OiBkYXRhLmhlaWdodFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gZGF0YS5odG1sO1xyXG4gICAgICAgIHJlbW92ZURhdGEoZWxlbWVudCwgREFUQV9QUkVWSUVXKTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgcHJldmlldzogZnVuY3Rpb24gcHJldmlldygpIHtcclxuICAgICAgdmFyIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhLFxyXG4gICAgICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YSxcclxuICAgICAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcclxuICAgICAgdmFyIGNyb3BCb3hXaWR0aCA9IGNyb3BCb3hEYXRhLndpZHRoLFxyXG4gICAgICAgICAgY3JvcEJveEhlaWdodCA9IGNyb3BCb3hEYXRhLmhlaWdodDtcclxuICAgICAgdmFyIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodDtcclxuICAgICAgdmFyIGxlZnQgPSBjcm9wQm94RGF0YS5sZWZ0IC0gY2FudmFzRGF0YS5sZWZ0IC0gaW1hZ2VEYXRhLmxlZnQ7XHJcbiAgICAgIHZhciB0b3AgPSBjcm9wQm94RGF0YS50b3AgLSBjYW52YXNEYXRhLnRvcCAtIGltYWdlRGF0YS50b3A7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuY3JvcHBlZCB8fCB0aGlzLmRpc2FibGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXRTdHlsZSh0aGlzLnZpZXdCb3hJbWFnZSwgYXNzaWduKHtcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcclxuICAgICAgfSwgZ2V0VHJhbnNmb3Jtcyhhc3NpZ24oe1xyXG4gICAgICAgIHRyYW5zbGF0ZVg6IC1sZWZ0LFxyXG4gICAgICAgIHRyYW5zbGF0ZVk6IC10b3BcclxuICAgICAgfSwgaW1hZ2VEYXRhKSkpKTtcclxuICAgICAgZm9yRWFjaCh0aGlzLnByZXZpZXdzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtZW50LCBEQVRBX1BSRVZJRVcpO1xyXG4gICAgICAgIHZhciBvcmlnaW5hbFdpZHRoID0gZGF0YS53aWR0aDtcclxuICAgICAgICB2YXIgb3JpZ2luYWxIZWlnaHQgPSBkYXRhLmhlaWdodDtcclxuICAgICAgICB2YXIgbmV3V2lkdGggPSBvcmlnaW5hbFdpZHRoO1xyXG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSBvcmlnaW5hbEhlaWdodDtcclxuICAgICAgICB2YXIgcmF0aW8gPSAxO1xyXG5cclxuICAgICAgICBpZiAoY3JvcEJveFdpZHRoKSB7XHJcbiAgICAgICAgICByYXRpbyA9IG9yaWdpbmFsV2lkdGggLyBjcm9wQm94V2lkdGg7XHJcbiAgICAgICAgICBuZXdIZWlnaHQgPSBjcm9wQm94SGVpZ2h0ICogcmF0aW87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY3JvcEJveEhlaWdodCAmJiBuZXdIZWlnaHQgPiBvcmlnaW5hbEhlaWdodCkge1xyXG4gICAgICAgICAgcmF0aW8gPSBvcmlnaW5hbEhlaWdodCAvIGNyb3BCb3hIZWlnaHQ7XHJcbiAgICAgICAgICBuZXdXaWR0aCA9IGNyb3BCb3hXaWR0aCAqIHJhdGlvO1xyXG4gICAgICAgICAgbmV3SGVpZ2h0ID0gb3JpZ2luYWxIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXRTdHlsZShlbGVtZW50LCB7XHJcbiAgICAgICAgICB3aWR0aDogbmV3V2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNldFN0eWxlKGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpWzBdLCBhc3NpZ24oe1xyXG4gICAgICAgICAgd2lkdGg6IHdpZHRoICogcmF0aW8sXHJcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAqIHJhdGlvXHJcbiAgICAgICAgfSwgZ2V0VHJhbnNmb3Jtcyhhc3NpZ24oe1xyXG4gICAgICAgICAgdHJhbnNsYXRlWDogLWxlZnQgKiByYXRpbyxcclxuICAgICAgICAgIHRyYW5zbGF0ZVk6IC10b3AgKiByYXRpb1xyXG4gICAgICAgIH0sIGltYWdlRGF0YSkpKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBldmVudHMgPSB7XHJcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xyXG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcclxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcbiAgICAgICAgICBjcm9wcGVyID0gdGhpcy5jcm9wcGVyO1xyXG5cclxuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wc3RhcnQpKSB7XHJcbiAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfQ1JPUF9TVEFSVCwgb3B0aW9ucy5jcm9wc3RhcnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3Btb3ZlKSkge1xyXG4gICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1BfTU9WRSwgb3B0aW9ucy5jcm9wbW92ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuY3JvcGVuZCkpIHtcclxuICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX0VORCwgb3B0aW9ucy5jcm9wZW5kKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wKSkge1xyXG4gICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1AsIG9wdGlvbnMuY3JvcCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuem9vbSkpIHtcclxuICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9aT09NLCBvcHRpb25zLnpvb20pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhZGRMaXN0ZW5lcihjcm9wcGVyLCBFVkVOVF9QT0lOVEVSX0RPV04sIHRoaXMub25Dcm9wU3RhcnQgPSB0aGlzLmNyb3BTdGFydC5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgIGlmIChvcHRpb25zLnpvb21hYmxlICYmIG9wdGlvbnMuem9vbU9uV2hlZWwpIHtcclxuICAgICAgICBhZGRMaXN0ZW5lcihjcm9wcGVyLCBFVkVOVF9XSEVFTCwgdGhpcy5vbldoZWVsID0gdGhpcy53aGVlbC5iaW5kKHRoaXMpLCB7XHJcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcclxuICAgICAgICAgIGNhcHR1cmU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG9wdGlvbnMudG9nZ2xlRHJhZ01vZGVPbkRibGNsaWNrKSB7XHJcbiAgICAgICAgYWRkTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfREJMQ0xJQ0ssIHRoaXMub25EYmxjbGljayA9IHRoaXMuZGJsY2xpY2suYmluZCh0aGlzKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQub3duZXJEb2N1bWVudCwgRVZFTlRfUE9JTlRFUl9NT1ZFLCB0aGlzLm9uQ3JvcE1vdmUgPSB0aGlzLmNyb3BNb3ZlLmJpbmQodGhpcykpO1xyXG4gICAgICBhZGRMaXN0ZW5lcihlbGVtZW50Lm93bmVyRG9jdW1lbnQsIEVWRU5UX1BPSU5URVJfVVAsIHRoaXMub25Dcm9wRW5kID0gdGhpcy5jcm9wRW5kLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZSkge1xyXG4gICAgICAgIGFkZExpc3RlbmVyKHdpbmRvdywgRVZFTlRfUkVTSVpFLCB0aGlzLm9uUmVzaXplID0gdGhpcy5yZXNpemUuYmluZCh0aGlzKSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcclxuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXHJcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gICAgICAgICAgY3JvcHBlciA9IHRoaXMuY3JvcHBlcjtcclxuXHJcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuY3JvcHN0YXJ0KSkge1xyXG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1BfU1RBUlQsIG9wdGlvbnMuY3JvcHN0YXJ0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wbW92ZSkpIHtcclxuICAgICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX01PVkUsIG9wdGlvbnMuY3JvcG1vdmUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3BlbmQpKSB7XHJcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfQ1JPUF9FTkQsIG9wdGlvbnMuY3JvcGVuZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuY3JvcCkpIHtcclxuICAgICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QLCBvcHRpb25zLmNyb3ApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnpvb20pKSB7XHJcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfWk9PTSwgb3B0aW9ucy56b29tKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVtb3ZlTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfUE9JTlRFUl9ET1dOLCB0aGlzLm9uQ3JvcFN0YXJ0KTtcclxuXHJcbiAgICAgIGlmIChvcHRpb25zLnpvb21hYmxlICYmIG9wdGlvbnMuem9vbU9uV2hlZWwpIHtcclxuICAgICAgICByZW1vdmVMaXN0ZW5lcihjcm9wcGVyLCBFVkVOVF9XSEVFTCwgdGhpcy5vbldoZWVsLCB7XHJcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcclxuICAgICAgICAgIGNhcHR1cmU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG9wdGlvbnMudG9nZ2xlRHJhZ01vZGVPbkRibGNsaWNrKSB7XHJcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfREJMQ0xJQ0ssIHRoaXMub25EYmxjbGljayk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQub3duZXJEb2N1bWVudCwgRVZFTlRfUE9JTlRFUl9NT1ZFLCB0aGlzLm9uQ3JvcE1vdmUpO1xyXG4gICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50Lm93bmVyRG9jdW1lbnQsIEVWRU5UX1BPSU5URVJfVVAsIHRoaXMub25Dcm9wRW5kKTtcclxuXHJcbiAgICAgIGlmIChvcHRpb25zLnJlc3BvbnNpdmUpIHtcclxuICAgICAgICByZW1vdmVMaXN0ZW5lcih3aW5kb3csIEVWRU5UX1JFU0laRSwgdGhpcy5vblJlc2l6ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICB2YXIgaGFuZGxlcnMgPSB7XHJcbiAgICByZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcclxuICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gICAgICAgICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXHJcbiAgICAgICAgICBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhO1xyXG4gICAgICB2YXIgcmF0aW9YID0gY29udGFpbmVyLm9mZnNldFdpZHRoIC8gY29udGFpbmVyRGF0YS53aWR0aDtcclxuICAgICAgdmFyIHJhdGlvWSA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLyBjb250YWluZXJEYXRhLmhlaWdodDtcclxuICAgICAgdmFyIHJhdGlvID0gTWF0aC5hYnMocmF0aW9YIC0gMSkgPiBNYXRoLmFicyhyYXRpb1kgLSAxKSA/IHJhdGlvWCA6IHJhdGlvWTsgLy8gUmVzaXplIHdoZW4gd2lkdGggY2hhbmdlZCBvciBoZWlnaHQgY2hhbmdlZFxyXG5cclxuICAgICAgaWYgKHJhdGlvICE9PSAxKSB7XHJcbiAgICAgICAgdmFyIGNhbnZhc0RhdGE7XHJcbiAgICAgICAgdmFyIGNyb3BCb3hEYXRhO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5yZXN0b3JlKSB7XHJcbiAgICAgICAgICBjYW52YXNEYXRhID0gdGhpcy5nZXRDYW52YXNEYXRhKCk7XHJcbiAgICAgICAgICBjcm9wQm94RGF0YSA9IHRoaXMuZ2V0Q3JvcEJveERhdGEoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnJlc3RvcmUpIHtcclxuICAgICAgICAgIHRoaXMuc2V0Q2FudmFzRGF0YShmb3JFYWNoKGNhbnZhc0RhdGEsIGZ1bmN0aW9uIChuLCBpKSB7XHJcbiAgICAgICAgICAgIGNhbnZhc0RhdGFbaV0gPSBuICogcmF0aW87XHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICB0aGlzLnNldENyb3BCb3hEYXRhKGZvckVhY2goY3JvcEJveERhdGEsIGZ1bmN0aW9uIChuLCBpKSB7XHJcbiAgICAgICAgICAgIGNyb3BCb3hEYXRhW2ldID0gbiAqIHJhdGlvO1xyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRibGNsaWNrOiBmdW5jdGlvbiBkYmxjbGljaygpIHtcclxuICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5vcHRpb25zLmRyYWdNb2RlID09PSBEUkFHX01PREVfTk9ORSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zZXREcmFnTW9kZShoYXNDbGFzcyh0aGlzLmRyYWdCb3gsIENMQVNTX0NST1ApID8gRFJBR19NT0RFX01PVkUgOiBEUkFHX01PREVfQ1JPUCk7XHJcbiAgICB9LFxyXG4gICAgd2hlZWw6IGZ1bmN0aW9uIHdoZWVsKGV2ZW50KSB7XHJcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICB2YXIgcmF0aW8gPSBOdW1iZXIodGhpcy5vcHRpb25zLndoZWVsWm9vbVJhdGlvKSB8fCAwLjE7XHJcbiAgICAgIHZhciBkZWx0YSA9IDE7XHJcblxyXG4gICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gTGltaXQgd2hlZWwgc3BlZWQgdG8gcHJldmVudCB6b29tIHRvbyBmYXN0ICgjMjEpXHJcblxyXG4gICAgICBpZiAodGhpcy53aGVlbGluZykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy53aGVlbGluZyA9IHRydWU7XHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF90aGlzLndoZWVsaW5nID0gZmFsc2U7XHJcbiAgICAgIH0sIDUwKTtcclxuXHJcbiAgICAgIGlmIChldmVudC5kZWx0YVkpIHtcclxuICAgICAgICBkZWx0YSA9IGV2ZW50LmRlbHRhWSA+IDAgPyAxIDogLTE7XHJcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQud2hlZWxEZWx0YSkge1xyXG4gICAgICAgIGRlbHRhID0gLWV2ZW50LndoZWVsRGVsdGEgLyAxMjA7XHJcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7XHJcbiAgICAgICAgZGVsdGEgPSBldmVudC5kZXRhaWwgPiAwID8gMSA6IC0xO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnpvb20oLWRlbHRhICogcmF0aW8sIGV2ZW50KTtcclxuICAgIH0sXHJcbiAgICBjcm9wU3RhcnQ6IGZ1bmN0aW9uIGNyb3BTdGFydChldmVudCkge1xyXG4gICAgICB2YXIgYnV0dG9ucyA9IGV2ZW50LmJ1dHRvbnMsXHJcbiAgICAgICAgICBidXR0b24gPSBldmVudC5idXR0b247XHJcblxyXG4gICAgICBpZiAodGhpcy5kaXNhYmxlZCAvLyBIYW5kbGUgbW91c2UgZXZlbnQgYW5kIHBvaW50ZXIgZXZlbnQgYW5kIGlnbm9yZSB0b3VjaCBldmVudFxyXG4gICAgICB8fCAoZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ3BvaW50ZXJkb3duJyAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgJiYgKCAvLyBObyBwcmltYXJ5IGJ1dHRvbiAoVXN1YWxseSB0aGUgbGVmdCBidXR0b24pXHJcbiAgICAgIGlzTnVtYmVyKGJ1dHRvbnMpICYmIGJ1dHRvbnMgIT09IDEgfHwgaXNOdW1iZXIoYnV0dG9uKSAmJiBidXR0b24gIT09IDAgLy8gT3BlbiBjb250ZXh0IG1lbnVcclxuICAgICAgfHwgZXZlbnQuY3RybEtleSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gICAgICAgICAgcG9pbnRlcnMgPSB0aGlzLnBvaW50ZXJzO1xyXG4gICAgICB2YXIgYWN0aW9uO1xyXG5cclxuICAgICAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSB7XHJcbiAgICAgICAgLy8gSGFuZGxlIHRvdWNoIGV2ZW50XHJcbiAgICAgICAgZm9yRWFjaChldmVudC5jaGFuZ2VkVG91Y2hlcywgZnVuY3Rpb24gKHRvdWNoKSB7XHJcbiAgICAgICAgICBwb2ludGVyc1t0b3VjaC5pZGVudGlmaWVyXSA9IGdldFBvaW50ZXIodG91Y2gpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEhhbmRsZSBtb3VzZSBldmVudCBhbmQgcG9pbnRlciBldmVudFxyXG4gICAgICAgIHBvaW50ZXJzW2V2ZW50LnBvaW50ZXJJZCB8fCAwXSA9IGdldFBvaW50ZXIoZXZlbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoT2JqZWN0LmtleXMocG9pbnRlcnMpLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy56b29tYWJsZSAmJiBvcHRpb25zLnpvb21PblRvdWNoKSB7XHJcbiAgICAgICAgYWN0aW9uID0gQUNUSU9OX1pPT007XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWN0aW9uID0gZ2V0RGF0YShldmVudC50YXJnZXQsIERBVEFfQUNUSU9OKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFSRUdFWFBfQUNUSU9OUy50ZXN0KGFjdGlvbikpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChkaXNwYXRjaEV2ZW50KHRoaXMuZWxlbWVudCwgRVZFTlRfQ1JPUF9TVEFSVCwge1xyXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxyXG4gICAgICAgIGFjdGlvbjogYWN0aW9uXHJcbiAgICAgIH0pID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSAvLyBUaGlzIGxpbmUgaXMgcmVxdWlyZWQgZm9yIHByZXZlbnRpbmcgcGFnZSB6b29taW5nIGluIGlPUyBicm93c2Vyc1xyXG5cclxuXHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uO1xyXG4gICAgICB0aGlzLmNyb3BwaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICBpZiAoYWN0aW9uID09PSBBQ1RJT05fQ1JPUCkge1xyXG4gICAgICAgIHRoaXMuY3JvcHBpbmcgPSB0cnVlO1xyXG4gICAgICAgIGFkZENsYXNzKHRoaXMuZHJhZ0JveCwgQ0xBU1NfTU9EQUwpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgY3JvcE1vdmU6IGZ1bmN0aW9uIGNyb3BNb3ZlKGV2ZW50KSB7XHJcbiAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmFjdGlvbjtcclxuXHJcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICFhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBwb2ludGVycyA9IHRoaXMucG9pbnRlcnM7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICBpZiAoZGlzcGF0Y2hFdmVudCh0aGlzLmVsZW1lbnQsIEVWRU5UX0NST1BfTU9WRSwge1xyXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxyXG4gICAgICAgIGFjdGlvbjogYWN0aW9uXHJcbiAgICAgIH0pID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSB7XHJcbiAgICAgICAgZm9yRWFjaChldmVudC5jaGFuZ2VkVG91Y2hlcywgZnVuY3Rpb24gKHRvdWNoKSB7XHJcbiAgICAgICAgICAvLyBUaGUgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkICgjNDMyKVxyXG4gICAgICAgICAgYXNzaWduKHBvaW50ZXJzW3RvdWNoLmlkZW50aWZpZXJdIHx8IHt9LCBnZXRQb2ludGVyKHRvdWNoLCB0cnVlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYXNzaWduKHBvaW50ZXJzW2V2ZW50LnBvaW50ZXJJZCB8fCAwXSB8fCB7fSwgZ2V0UG9pbnRlcihldmVudCwgdHJ1ZSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmNoYW5nZShldmVudCk7XHJcbiAgICB9LFxyXG4gICAgY3JvcEVuZDogZnVuY3Rpb24gY3JvcEVuZChldmVudCkge1xyXG4gICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuYWN0aW9uLFxyXG4gICAgICAgICAgcG9pbnRlcnMgPSB0aGlzLnBvaW50ZXJzO1xyXG5cclxuICAgICAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSB7XHJcbiAgICAgICAgZm9yRWFjaChldmVudC5jaGFuZ2VkVG91Y2hlcywgZnVuY3Rpb24gKHRvdWNoKSB7XHJcbiAgICAgICAgICBkZWxldGUgcG9pbnRlcnNbdG91Y2guaWRlbnRpZmllcl07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGVsZXRlIHBvaW50ZXJzW2V2ZW50LnBvaW50ZXJJZCB8fCAwXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHBvaW50ZXJzKS5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmFjdGlvbiA9ICcnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5jcm9wcGluZykge1xyXG4gICAgICAgIHRoaXMuY3JvcHBpbmcgPSBmYWxzZTtcclxuICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLmRyYWdCb3gsIENMQVNTX01PREFMLCB0aGlzLmNyb3BwZWQgJiYgdGhpcy5vcHRpb25zLm1vZGFsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGlzcGF0Y2hFdmVudCh0aGlzLmVsZW1lbnQsIEVWRU5UX0NST1BfRU5ELCB7XHJcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXHJcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIGNoYW5nZSA9IHtcclxuICAgIGNoYW5nZTogZnVuY3Rpb24gY2hhbmdlKGV2ZW50KSB7XHJcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gICAgICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YSxcclxuICAgICAgICAgIGNvbnRhaW5lckRhdGEgPSB0aGlzLmNvbnRhaW5lckRhdGEsXHJcbiAgICAgICAgICBjcm9wQm94RGF0YSA9IHRoaXMuY3JvcEJveERhdGEsXHJcbiAgICAgICAgICBwb2ludGVycyA9IHRoaXMucG9pbnRlcnM7XHJcbiAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmFjdGlvbjtcclxuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gb3B0aW9ucy5hc3BlY3RSYXRpbztcclxuICAgICAgdmFyIGxlZnQgPSBjcm9wQm94RGF0YS5sZWZ0LFxyXG4gICAgICAgICAgdG9wID0gY3JvcEJveERhdGEudG9wLFxyXG4gICAgICAgICAgd2lkdGggPSBjcm9wQm94RGF0YS53aWR0aCxcclxuICAgICAgICAgIGhlaWdodCA9IGNyb3BCb3hEYXRhLmhlaWdodDtcclxuICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xyXG4gICAgICB2YXIgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xyXG4gICAgICB2YXIgbWluTGVmdCA9IDA7XHJcbiAgICAgIHZhciBtaW5Ub3AgPSAwO1xyXG4gICAgICB2YXIgbWF4V2lkdGggPSBjb250YWluZXJEYXRhLndpZHRoO1xyXG4gICAgICB2YXIgbWF4SGVpZ2h0ID0gY29udGFpbmVyRGF0YS5oZWlnaHQ7XHJcbiAgICAgIHZhciByZW5kZXJhYmxlID0gdHJ1ZTtcclxuICAgICAgdmFyIG9mZnNldDsgLy8gTG9ja2luZyBhc3BlY3QgcmF0aW8gaW4gXCJmcmVlIG1vZGVcIiBieSBob2xkaW5nIHNoaWZ0IGtleVxyXG5cclxuICAgICAgaWYgKCFhc3BlY3RSYXRpbyAmJiBldmVudC5zaGlmdEtleSkge1xyXG4gICAgICAgIGFzcGVjdFJhdGlvID0gd2lkdGggJiYgaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5saW1pdGVkKSB7XHJcbiAgICAgICAgbWluTGVmdCA9IGNyb3BCb3hEYXRhLm1pbkxlZnQ7XHJcbiAgICAgICAgbWluVG9wID0gY3JvcEJveERhdGEubWluVG9wO1xyXG4gICAgICAgIG1heFdpZHRoID0gbWluTGVmdCArIE1hdGgubWluKGNvbnRhaW5lckRhdGEud2lkdGgsIGNhbnZhc0RhdGEud2lkdGgsIGNhbnZhc0RhdGEubGVmdCArIGNhbnZhc0RhdGEud2lkdGgpO1xyXG4gICAgICAgIG1heEhlaWdodCA9IG1pblRvcCArIE1hdGgubWluKGNvbnRhaW5lckRhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLmhlaWdodCwgY2FudmFzRGF0YS50b3AgKyBjYW52YXNEYXRhLmhlaWdodCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBwb2ludGVyID0gcG9pbnRlcnNbT2JqZWN0LmtleXMocG9pbnRlcnMpWzBdXTtcclxuICAgICAgdmFyIHJhbmdlID0ge1xyXG4gICAgICAgIHg6IHBvaW50ZXIuZW5kWCAtIHBvaW50ZXIuc3RhcnRYLFxyXG4gICAgICAgIHk6IHBvaW50ZXIuZW5kWSAtIHBvaW50ZXIuc3RhcnRZXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgY2hlY2sgPSBmdW5jdGlvbiBjaGVjayhzaWRlKSB7XHJcbiAgICAgICAgc3dpdGNoIChzaWRlKSB7XHJcbiAgICAgICAgICBjYXNlIEFDVElPTl9FQVNUOlxyXG4gICAgICAgICAgICBpZiAocmlnaHQgKyByYW5nZS54ID4gbWF4V2lkdGgpIHtcclxuICAgICAgICAgICAgICByYW5nZS54ID0gbWF4V2lkdGggLSByaWdodDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSBBQ1RJT05fV0VTVDpcclxuICAgICAgICAgICAgaWYgKGxlZnQgKyByYW5nZS54IDwgbWluTGVmdCkge1xyXG4gICAgICAgICAgICAgIHJhbmdlLnggPSBtaW5MZWZ0IC0gbGVmdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSBBQ1RJT05fTk9SVEg6XHJcbiAgICAgICAgICAgIGlmICh0b3AgKyByYW5nZS55IDwgbWluVG9wKSB7XHJcbiAgICAgICAgICAgICAgcmFuZ2UueSA9IG1pblRvcCAtIHRvcDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSBBQ1RJT05fU09VVEg6XHJcbiAgICAgICAgICAgIGlmIChib3R0b20gKyByYW5nZS55ID4gbWF4SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgcmFuZ2UueSA9IG1heEhlaWdodCAtIGJvdHRvbTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgc3dpdGNoIChhY3Rpb24pIHtcclxuICAgICAgICAvLyBNb3ZlIGNyb3AgYm94XHJcbiAgICAgICAgY2FzZSBBQ1RJT05fQUxMOlxyXG4gICAgICAgICAgbGVmdCArPSByYW5nZS54O1xyXG4gICAgICAgICAgdG9wICs9IHJhbmdlLnk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBSZXNpemUgY3JvcCBib3hcclxuXHJcbiAgICAgICAgY2FzZSBBQ1RJT05fRUFTVDpcclxuICAgICAgICAgIGlmIChyYW5nZS54ID49IDAgJiYgKHJpZ2h0ID49IG1heFdpZHRoIHx8IGFzcGVjdFJhdGlvICYmICh0b3AgPD0gbWluVG9wIHx8IGJvdHRvbSA+PSBtYXhIZWlnaHQpKSkge1xyXG4gICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNoZWNrKEFDVElPTl9FQVNUKTtcclxuICAgICAgICAgIHdpZHRoICs9IHJhbmdlLng7XHJcblxyXG4gICAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xyXG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fV0VTVDtcclxuICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XHJcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICAgIHRvcCArPSAoY3JvcEJveERhdGEuaGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgQUNUSU9OX05PUlRIOlxyXG4gICAgICAgICAgaWYgKHJhbmdlLnkgPD0gMCAmJiAodG9wIDw9IG1pblRvcCB8fCBhc3BlY3RSYXRpbyAmJiAobGVmdCA8PSBtaW5MZWZ0IHx8IHJpZ2h0ID49IG1heFdpZHRoKSkpIHtcclxuICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjaGVjayhBQ1RJT05fTk9SVEgpO1xyXG4gICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XHJcbiAgICAgICAgICB0b3AgKz0gcmFuZ2UueTtcclxuXHJcbiAgICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xyXG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fU09VVEg7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICAgIGxlZnQgKz0gKGNyb3BCb3hEYXRhLndpZHRoIC0gd2lkdGgpIC8gMjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBBQ1RJT05fV0VTVDpcclxuICAgICAgICAgIGlmIChyYW5nZS54IDw9IDAgJiYgKGxlZnQgPD0gbWluTGVmdCB8fCBhc3BlY3RSYXRpbyAmJiAodG9wIDw9IG1pblRvcCB8fCBib3R0b20gPj0gbWF4SGVpZ2h0KSkpIHtcclxuICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjaGVjayhBQ1RJT05fV0VTVCk7XHJcbiAgICAgICAgICB3aWR0aCAtPSByYW5nZS54O1xyXG4gICAgICAgICAgbGVmdCArPSByYW5nZS54O1xyXG5cclxuICAgICAgICAgIGlmICh3aWR0aCA8IDApIHtcclxuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX0VBU1Q7XHJcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xyXG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xyXG4gICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgICB0b3AgKz0gKGNyb3BCb3hEYXRhLmhlaWdodCAtIGhlaWdodCkgLyAyO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIEFDVElPTl9TT1VUSDpcclxuICAgICAgICAgIGlmIChyYW5nZS55ID49IDAgJiYgKGJvdHRvbSA+PSBtYXhIZWlnaHQgfHwgYXNwZWN0UmF0aW8gJiYgKGxlZnQgPD0gbWluTGVmdCB8fCByaWdodCA+PSBtYXhXaWR0aCkpKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY2hlY2soQUNUSU9OX1NPVVRIKTtcclxuICAgICAgICAgIGhlaWdodCArPSByYW5nZS55O1xyXG5cclxuICAgICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcclxuICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcclxuICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcclxuICAgICAgICAgICAgbGVmdCArPSAoY3JvcEJveERhdGEud2lkdGggLSB3aWR0aCkgLyAyO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIEFDVElPTl9OT1JUSF9FQVNUOlxyXG4gICAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XHJcbiAgICAgICAgICAgIGlmIChyYW5nZS55IDw9IDAgJiYgKHRvcCA8PSBtaW5Ub3AgfHwgcmlnaHQgPj0gbWF4V2lkdGgpKSB7XHJcbiAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjaGVjayhBQ1RJT05fTk9SVEgpO1xyXG4gICAgICAgICAgICBoZWlnaHQgLT0gcmFuZ2UueTtcclxuICAgICAgICAgICAgdG9wICs9IHJhbmdlLnk7XHJcbiAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaGVjayhBQ1RJT05fTk9SVEgpO1xyXG4gICAgICAgICAgICBjaGVjayhBQ1RJT05fRUFTVCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmFuZ2UueCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHJpZ2h0IDwgbWF4V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoICs9IHJhbmdlLng7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5nZS55IDw9IDAgJiYgdG9wIDw9IG1pblRvcCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB3aWR0aCArPSByYW5nZS54O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmFuZ2UueSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHRvcCA+IG1pblRvcCkge1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XHJcbiAgICAgICAgICAgICAgICB0b3AgKz0gcmFuZ2UueTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XHJcbiAgICAgICAgICAgICAgdG9wICs9IHJhbmdlLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAod2lkdGggPCAwICYmIGhlaWdodCA8IDApIHtcclxuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIX1dFU1Q7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XHJcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xyXG4gICAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xyXG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh3aWR0aCA8IDApIHtcclxuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIX1dFU1Q7XHJcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xyXG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChoZWlnaHQgPCAwKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9FQVNUO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xyXG4gICAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIEFDVElPTl9OT1JUSF9XRVNUOlxyXG4gICAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XHJcbiAgICAgICAgICAgIGlmIChyYW5nZS55IDw9IDAgJiYgKHRvcCA8PSBtaW5Ub3AgfHwgbGVmdCA8PSBtaW5MZWZ0KSkge1xyXG4gICAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2hlY2soQUNUSU9OX05PUlRIKTtcclxuICAgICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XHJcbiAgICAgICAgICAgIHRvcCArPSByYW5nZS55O1xyXG4gICAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgICBsZWZ0ICs9IGNyb3BCb3hEYXRhLndpZHRoIC0gd2lkdGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaGVjayhBQ1RJT05fTk9SVEgpO1xyXG4gICAgICAgICAgICBjaGVjayhBQ1RJT05fV0VTVCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmFuZ2UueCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGxlZnQgPiBtaW5MZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCAtPSByYW5nZS54O1xyXG4gICAgICAgICAgICAgICAgbGVmdCArPSByYW5nZS54O1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UueSA8PSAwICYmIHRvcCA8PSBtaW5Ub3ApIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgd2lkdGggLT0gcmFuZ2UueDtcclxuICAgICAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyYW5nZS55IDw9IDApIHtcclxuICAgICAgICAgICAgICBpZiAodG9wID4gbWluVG9wKSB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgLT0gcmFuZ2UueTtcclxuICAgICAgICAgICAgICAgIHRvcCArPSByYW5nZS55O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBoZWlnaHQgLT0gcmFuZ2UueTtcclxuICAgICAgICAgICAgICB0b3AgKz0gcmFuZ2UueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICh3aWR0aCA8IDAgJiYgaGVpZ2h0IDwgMCkge1xyXG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fU09VVEhfRUFTVDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcclxuICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XHJcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHdpZHRoIDwgMCkge1xyXG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fTk9SVEhfRUFTVDtcclxuICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XHJcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCA8IDApIHtcclxuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIX1dFU1Q7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgQUNUSU9OX1NPVVRIX1dFU1Q6XHJcbiAgICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcclxuICAgICAgICAgICAgaWYgKHJhbmdlLnggPD0gMCAmJiAobGVmdCA8PSBtaW5MZWZ0IHx8IGJvdHRvbSA+PSBtYXhIZWlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjaGVjayhBQ1RJT05fV0VTVCk7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XHJcbiAgICAgICAgICAgIGxlZnQgKz0gcmFuZ2UueDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpbztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9TT1VUSCk7XHJcbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9XRVNUKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyYW5nZS54IDw9IDApIHtcclxuICAgICAgICAgICAgICBpZiAobGVmdCA+IG1pbkxlZnQpIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5nZS55ID49IDAgJiYgYm90dG9tID49IG1heEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB3aWR0aCAtPSByYW5nZS54O1xyXG4gICAgICAgICAgICAgIGxlZnQgKz0gcmFuZ2UueDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJhbmdlLnkgPj0gMCkge1xyXG4gICAgICAgICAgICAgIGlmIChib3R0b20gPCBtYXhIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCArPSByYW5nZS55O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBoZWlnaHQgKz0gcmFuZ2UueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICh3aWR0aCA8IDAgJiYgaGVpZ2h0IDwgMCkge1xyXG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fTk9SVEhfRUFTVDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcclxuICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XHJcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHdpZHRoIDwgMCkge1xyXG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fU09VVEhfRUFTVDtcclxuICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XHJcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCA8IDApIHtcclxuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIX1dFU1Q7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgQUNUSU9OX1NPVVRIX0VBU1Q6XHJcbiAgICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcclxuICAgICAgICAgICAgaWYgKHJhbmdlLnggPj0gMCAmJiAocmlnaHQgPj0gbWF4V2lkdGggfHwgYm90dG9tID49IG1heEhlaWdodCkpIHtcclxuICAgICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9FQVNUKTtcclxuICAgICAgICAgICAgd2lkdGggKz0gcmFuZ2UueDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpbztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9TT1VUSCk7XHJcbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9FQVNUKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyYW5nZS54ID49IDApIHtcclxuICAgICAgICAgICAgICBpZiAocmlnaHQgPCBtYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgd2lkdGggKz0gcmFuZ2UueDtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnkgPj0gMCAmJiBib3R0b20gPj0gbWF4SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHdpZHRoICs9IHJhbmdlLng7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyYW5nZS55ID49IDApIHtcclxuICAgICAgICAgICAgICBpZiAoYm90dG9tIDwgbWF4SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgKz0gcmFuZ2UueTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaGVpZ2h0ICs9IHJhbmdlLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAod2lkdGggPCAwICYmIGhlaWdodCA8IDApIHtcclxuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIX1dFU1Q7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XHJcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xyXG4gICAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xyXG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh3aWR0aCA8IDApIHtcclxuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIX1dFU1Q7XHJcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xyXG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChoZWlnaHQgPCAwKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9FQVNUO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xyXG4gICAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIE1vdmUgY2FudmFzXHJcblxyXG4gICAgICAgIGNhc2UgQUNUSU9OX01PVkU6XHJcbiAgICAgICAgICB0aGlzLm1vdmUocmFuZ2UueCwgcmFuZ2UueSk7XHJcbiAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBab29tIGNhbnZhc1xyXG5cclxuICAgICAgICBjYXNlIEFDVElPTl9aT09NOlxyXG4gICAgICAgICAgdGhpcy56b29tKGdldE1heFpvb21SYXRpbyhwb2ludGVycyksIGV2ZW50KTtcclxuICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIENyZWF0ZSBjcm9wIGJveFxyXG5cclxuICAgICAgICBjYXNlIEFDVElPTl9DUk9QOlxyXG4gICAgICAgICAgaWYgKCFyYW5nZS54IHx8ICFyYW5nZS55KSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgb2Zmc2V0ID0gZ2V0T2Zmc2V0KHRoaXMuY3JvcHBlcik7XHJcbiAgICAgICAgICBsZWZ0ID0gcG9pbnRlci5zdGFydFggLSBvZmZzZXQubGVmdDtcclxuICAgICAgICAgIHRvcCA9IHBvaW50ZXIuc3RhcnRZIC0gb2Zmc2V0LnRvcDtcclxuICAgICAgICAgIHdpZHRoID0gY3JvcEJveERhdGEubWluV2lkdGg7XHJcbiAgICAgICAgICBoZWlnaHQgPSBjcm9wQm94RGF0YS5taW5IZWlnaHQ7XHJcblxyXG4gICAgICAgICAgaWYgKHJhbmdlLnggPiAwKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbiA9IHJhbmdlLnkgPiAwID8gQUNUSU9OX1NPVVRIX0VBU1QgOiBBQ1RJT05fTk9SVEhfRUFTVDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UueCA8IDApIHtcclxuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcclxuICAgICAgICAgICAgYWN0aW9uID0gcmFuZ2UueSA+IDAgPyBBQ1RJT05fU09VVEhfV0VTVCA6IEFDVElPTl9OT1JUSF9XRVNUO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChyYW5nZS55IDwgMCkge1xyXG4gICAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xyXG4gICAgICAgICAgfSAvLyBTaG93IHRoZSBjcm9wIGJveCBpZiBpcyBoaWRkZW5cclxuXHJcblxyXG4gICAgICAgICAgaWYgKCF0aGlzLmNyb3BwZWQpIHtcclxuICAgICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5jcm9wQm94LCBDTEFTU19ISURERU4pO1xyXG4gICAgICAgICAgICB0aGlzLmNyb3BwZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMubGltaXRlZCkge1xyXG4gICAgICAgICAgICAgIHRoaXMubGltaXRDcm9wQm94KHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZW5kZXJhYmxlKSB7XHJcbiAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSB3aWR0aDtcclxuICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgY3JvcEJveERhdGEubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgY3JvcEJveERhdGEudG9wID0gdG9wO1xyXG4gICAgICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uO1xyXG4gICAgICAgIHRoaXMucmVuZGVyQ3JvcEJveCgpO1xyXG4gICAgICB9IC8vIE92ZXJyaWRlXHJcblxyXG5cclxuICAgICAgZm9yRWFjaChwb2ludGVycywgZnVuY3Rpb24gKHApIHtcclxuICAgICAgICBwLnN0YXJ0WCA9IHAuZW5kWDtcclxuICAgICAgICBwLnN0YXJ0WSA9IHAuZW5kWTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIG1ldGhvZHMgPSB7XHJcbiAgICAvLyBTaG93IHRoZSBjcm9wIGJveCBtYW51YWxseVxyXG4gICAgY3JvcDogZnVuY3Rpb24gY3JvcCgpIHtcclxuICAgICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuY3JvcHBlZCAmJiAhdGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICAgIHRoaXMuY3JvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5saW1pdENyb3BCb3godHJ1ZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubW9kYWwpIHtcclxuICAgICAgICAgIGFkZENsYXNzKHRoaXMuZHJhZ0JveCwgQ0xBU1NfTU9EQUwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5jcm9wQm94LCBDTEFTU19ISURERU4pO1xyXG4gICAgICAgIHRoaXMuc2V0Q3JvcEJveERhdGEodGhpcy5pbml0aWFsQ3JvcEJveERhdGEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICAvLyBSZXNldCB0aGUgaW1hZ2UgYW5kIGNyb3AgYm94IHRvIHRoZWlyIGluaXRpYWwgc3RhdGVzXHJcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XHJcbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkKSB7XHJcbiAgICAgICAgdGhpcy5pbWFnZURhdGEgPSBhc3NpZ24oe30sIHRoaXMuaW5pdGlhbEltYWdlRGF0YSk7XHJcbiAgICAgICAgdGhpcy5jYW52YXNEYXRhID0gYXNzaWduKHt9LCB0aGlzLmluaXRpYWxDYW52YXNEYXRhKTtcclxuICAgICAgICB0aGlzLmNyb3BCb3hEYXRhID0gYXNzaWduKHt9LCB0aGlzLmluaXRpYWxDcm9wQm94RGF0YSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3JvcHBlZCkge1xyXG4gICAgICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICAvLyBDbGVhciB0aGUgY3JvcCBib3hcclxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcclxuICAgICAgaWYgKHRoaXMuY3JvcHBlZCAmJiAhdGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICAgIGFzc2lnbih0aGlzLmNyb3BCb3hEYXRhLCB7XHJcbiAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNyb3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlbmRlckNyb3BCb3goKTtcclxuICAgICAgICB0aGlzLmxpbWl0Q2FudmFzKHRydWUsIHRydWUpOyAvLyBSZW5kZXIgY2FudmFzIGFmdGVyIGNyb3AgYm94IHJlbmRlcmVkXHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyQ2FudmFzKCk7XHJcbiAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5kcmFnQm94LCBDTEFTU19NT0RBTCk7XHJcbiAgICAgICAgYWRkQ2xhc3ModGhpcy5jcm9wQm94LCBDTEFTU19ISURERU4pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlIHRoZSBpbWFnZSdzIHNyYyBhbmQgcmVidWlsZCB0aGUgY3JvcHBlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBuZXcgVVJMLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaGFzU2FtZVNpemVdIC0gSW5kaWNhdGUgaWYgdGhlIG5ldyBpbWFnZSBoYXMgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgb2xkIG9uZS5cclxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIHJlcGxhY2UodXJsKSB7XHJcbiAgICAgIHZhciBoYXNTYW1lU2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgdXJsKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNJbWcpIHtcclxuICAgICAgICAgIHRoaXMuZWxlbWVudC5zcmMgPSB1cmw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaGFzU2FtZVNpemUpIHtcclxuICAgICAgICAgIHRoaXMudXJsID0gdXJsO1xyXG4gICAgICAgICAgdGhpcy5pbWFnZS5zcmMgPSB1cmw7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMucmVhZHkpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3Qm94SW1hZ2Uuc3JjID0gdXJsO1xyXG4gICAgICAgICAgICBmb3JFYWNoKHRoaXMucHJldmlld3MsIGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW1nJylbMF0uc3JjID0gdXJsO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKHRoaXMuaXNJbWcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmRhdGEgPSBudWxsO1xyXG4gICAgICAgICAgdGhpcy51bmNyZWF0ZSgpO1xyXG4gICAgICAgICAgdGhpcy5sb2FkKHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICAvLyBFbmFibGUgKHVuZnJlZXplKSB0aGUgY3JvcHBlclxyXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoKSB7XHJcbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmIHRoaXMuZGlzYWJsZWQpIHtcclxuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5jcm9wcGVyLCBDTEFTU19ESVNBQkxFRCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuICAgIC8vIERpc2FibGUgKGZyZWV6ZSkgdGhlIGNyb3BwZXJcclxuICAgIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XHJcbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkKSB7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgYWRkQ2xhc3ModGhpcy5jcm9wcGVyLCBDTEFTU19ESVNBQkxFRCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kgdGhlIGNyb3BwZXIgYW5kIHJlbW92ZSB0aGUgaW5zdGFuY2UgZnJvbSB0aGUgaW1hZ2VcclxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XHJcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG5cclxuICAgICAgaWYgKCFlbGVtZW50W05BTUVTUEFDRV0pIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG5cclxuICAgICAgZWxlbWVudFtOQU1FU1BBQ0VdID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgaWYgKHRoaXMuaXNJbWcgJiYgdGhpcy5yZXBsYWNlZCkge1xyXG4gICAgICAgIGVsZW1lbnQuc3JjID0gdGhpcy5vcmlnaW5hbFVybDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy51bmNyZWF0ZSgpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlIHRoZSBjYW52YXMgd2l0aCByZWxhdGl2ZSBvZmZzZXRzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIFRoZSByZWxhdGl2ZSBvZmZzZXQgZGlzdGFuY2Ugb24gdGhlIHgtYXhpcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0WT1vZmZzZXRYXSAtIFRoZSByZWxhdGl2ZSBvZmZzZXQgZGlzdGFuY2Ugb24gdGhlIHktYXhpcy5cclxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUob2Zmc2V0WCkge1xyXG4gICAgICB2YXIgb2Zmc2V0WSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogb2Zmc2V0WDtcclxuICAgICAgdmFyIF90aGlzJGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXHJcbiAgICAgICAgICBsZWZ0ID0gX3RoaXMkY2FudmFzRGF0YS5sZWZ0LFxyXG4gICAgICAgICAgdG9wID0gX3RoaXMkY2FudmFzRGF0YS50b3A7XHJcbiAgICAgIHJldHVybiB0aGlzLm1vdmVUbyhpc1VuZGVmaW5lZChvZmZzZXRYKSA/IG9mZnNldFggOiBsZWZ0ICsgTnVtYmVyKG9mZnNldFgpLCBpc1VuZGVmaW5lZChvZmZzZXRZKSA/IG9mZnNldFkgOiB0b3AgKyBOdW1iZXIob2Zmc2V0WSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmUgdGhlIGNhbnZhcyB0byBhbiBhYnNvbHV0ZSBwb2ludFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeC1heGlzIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9eF0gLSBUaGUgeS1heGlzIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICBtb3ZlVG86IGZ1bmN0aW9uIG1vdmVUbyh4KSB7XHJcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB4O1xyXG4gICAgICB2YXIgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcclxuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgeCA9IE51bWJlcih4KTtcclxuICAgICAgeSA9IE51bWJlcih5KTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkICYmIHRoaXMub3B0aW9ucy5tb3ZhYmxlKSB7XHJcbiAgICAgICAgaWYgKGlzTnVtYmVyKHgpKSB7XHJcbiAgICAgICAgICBjYW52YXNEYXRhLmxlZnQgPSB4O1xyXG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNOdW1iZXIoeSkpIHtcclxuICAgICAgICAgIGNhbnZhc0RhdGEudG9wID0geTtcclxuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgIHRoaXMucmVuZGVyQ2FudmFzKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogWm9vbSB0aGUgY2FudmFzIHdpdGggYSByZWxhdGl2ZSByYXRpb1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIC0gVGhlIHRhcmdldCByYXRpby5cclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IF9vcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIGV2ZW50IGlmIGFueS5cclxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIHpvb206IGZ1bmN0aW9uIHpvb20ocmF0aW8sIF9vcmlnaW5hbEV2ZW50KSB7XHJcbiAgICAgIHZhciBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhO1xyXG4gICAgICByYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcblxyXG4gICAgICBpZiAocmF0aW8gPCAwKSB7XHJcbiAgICAgICAgcmF0aW8gPSAxIC8gKDEgLSByYXRpbyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmF0aW8gPSAxICsgcmF0aW87XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLnpvb21UbyhjYW52YXNEYXRhLndpZHRoICogcmF0aW8gLyBjYW52YXNEYXRhLm5hdHVyYWxXaWR0aCwgbnVsbCwgX29yaWdpbmFsRXZlbnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFpvb20gdGhlIGNhbnZhcyB0byBhbiBhYnNvbHV0ZSByYXRpb1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIC0gVGhlIHRhcmdldCByYXRpby5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwaXZvdCAtIFRoZSB6b29tIHBpdm90IHBvaW50IGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBfb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBldmVudCBpZiBhbnkuXHJcbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICB6b29tVG86IGZ1bmN0aW9uIHpvb21UbyhyYXRpbywgcGl2b3QsIF9vcmlnaW5hbEV2ZW50KSB7XHJcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gICAgICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcclxuICAgICAgdmFyIHdpZHRoID0gY2FudmFzRGF0YS53aWR0aCxcclxuICAgICAgICAgIGhlaWdodCA9IGNhbnZhc0RhdGEuaGVpZ2h0LFxyXG4gICAgICAgICAgbmF0dXJhbFdpZHRoID0gY2FudmFzRGF0YS5uYXR1cmFsV2lkdGgsXHJcbiAgICAgICAgICBuYXR1cmFsSGVpZ2h0ID0gY2FudmFzRGF0YS5uYXR1cmFsSGVpZ2h0O1xyXG4gICAgICByYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcblxyXG4gICAgICBpZiAocmF0aW8gPj0gMCAmJiB0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkICYmIG9wdGlvbnMuem9vbWFibGUpIHtcclxuICAgICAgICB2YXIgbmV3V2lkdGggPSBuYXR1cmFsV2lkdGggKiByYXRpbztcclxuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gbmF0dXJhbEhlaWdodCAqIHJhdGlvO1xyXG5cclxuICAgICAgICBpZiAoZGlzcGF0Y2hFdmVudCh0aGlzLmVsZW1lbnQsIEVWRU5UX1pPT00sIHtcclxuICAgICAgICAgIHJhdGlvOiByYXRpbyxcclxuICAgICAgICAgIG9sZFJhdGlvOiB3aWR0aCAvIG5hdHVyYWxXaWR0aCxcclxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IF9vcmlnaW5hbEV2ZW50XHJcbiAgICAgICAgfSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChfb3JpZ2luYWxFdmVudCkge1xyXG4gICAgICAgICAgdmFyIHBvaW50ZXJzID0gdGhpcy5wb2ludGVycztcclxuICAgICAgICAgIHZhciBvZmZzZXQgPSBnZXRPZmZzZXQodGhpcy5jcm9wcGVyKTtcclxuICAgICAgICAgIHZhciBjZW50ZXIgPSBwb2ludGVycyAmJiBPYmplY3Qua2V5cyhwb2ludGVycykubGVuZ3RoID8gZ2V0UG9pbnRlcnNDZW50ZXIocG9pbnRlcnMpIDoge1xyXG4gICAgICAgICAgICBwYWdlWDogX29yaWdpbmFsRXZlbnQucGFnZVgsXHJcbiAgICAgICAgICAgIHBhZ2VZOiBfb3JpZ2luYWxFdmVudC5wYWdlWVxyXG4gICAgICAgICAgfTsgLy8gWm9vbSBmcm9tIHRoZSB0cmlnZ2VyaW5nIHBvaW50IG9mIHRoZSBldmVudFxyXG5cclxuICAgICAgICAgIGNhbnZhc0RhdGEubGVmdCAtPSAobmV3V2lkdGggLSB3aWR0aCkgKiAoKGNlbnRlci5wYWdlWCAtIG9mZnNldC5sZWZ0IC0gY2FudmFzRGF0YS5sZWZ0KSAvIHdpZHRoKTtcclxuICAgICAgICAgIGNhbnZhc0RhdGEudG9wIC09IChuZXdIZWlnaHQgLSBoZWlnaHQpICogKChjZW50ZXIucGFnZVkgLSBvZmZzZXQudG9wIC0gY2FudmFzRGF0YS50b3ApIC8gaGVpZ2h0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocGl2b3QpICYmIGlzTnVtYmVyKHBpdm90LngpICYmIGlzTnVtYmVyKHBpdm90LnkpKSB7XHJcbiAgICAgICAgICBjYW52YXNEYXRhLmxlZnQgLT0gKG5ld1dpZHRoIC0gd2lkdGgpICogKChwaXZvdC54IC0gY2FudmFzRGF0YS5sZWZ0KSAvIHdpZHRoKTtcclxuICAgICAgICAgIGNhbnZhc0RhdGEudG9wIC09IChuZXdIZWlnaHQgLSBoZWlnaHQpICogKChwaXZvdC55IC0gY2FudmFzRGF0YS50b3ApIC8gaGVpZ2h0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gWm9vbSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGNhbnZhc1xyXG4gICAgICAgICAgY2FudmFzRGF0YS5sZWZ0IC09IChuZXdXaWR0aCAtIHdpZHRoKSAvIDI7XHJcbiAgICAgICAgICBjYW52YXNEYXRhLnRvcCAtPSAobmV3SGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYW52YXNEYXRhLndpZHRoID0gbmV3V2lkdGg7XHJcbiAgICAgICAgY2FudmFzRGF0YS5oZWlnaHQgPSBuZXdIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJDYW52YXModHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZSB0aGUgY2FudmFzIHdpdGggYSByZWxhdGl2ZSBkZWdyZWVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWUgLSBUaGUgcm90YXRlIGRlZ3JlZS5cclxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZTogZnVuY3Rpb24gcm90YXRlKGRlZ3JlZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5yb3RhdGVUbygodGhpcy5pbWFnZURhdGEucm90YXRlIHx8IDApICsgTnVtYmVyKGRlZ3JlZSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZSB0aGUgY2FudmFzIHRvIGFuIGFic29sdXRlIGRlZ3JlZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZSAtIFRoZSByb3RhdGUgZGVncmVlLlxyXG4gICAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgcm90YXRlVG86IGZ1bmN0aW9uIHJvdGF0ZVRvKGRlZ3JlZSkge1xyXG4gICAgICBkZWdyZWUgPSBOdW1iZXIoZGVncmVlKTtcclxuXHJcbiAgICAgIGlmIChpc051bWJlcihkZWdyZWUpICYmIHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5vcHRpb25zLnJvdGF0YWJsZSkge1xyXG4gICAgICAgIHRoaXMuaW1hZ2VEYXRhLnJvdGF0ZSA9IGRlZ3JlZSAlIDM2MDtcclxuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyh0cnVlLCB0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGUgdGhlIGltYWdlIG9uIHRoZSB4LWF4aXMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVYIC0gVGhlIHNjYWxlIHJhdGlvIG9uIHRoZSB4LWF4aXMuXHJcbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICBzY2FsZVg6IGZ1bmN0aW9uIHNjYWxlWChfc2NhbGVYKSB7XHJcbiAgICAgIHZhciBzY2FsZVkgPSB0aGlzLmltYWdlRGF0YS5zY2FsZVk7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlKF9zY2FsZVgsIGlzTnVtYmVyKHNjYWxlWSkgPyBzY2FsZVkgOiAxKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZSB0aGUgaW1hZ2Ugb24gdGhlIHktYXhpcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVkgLSBUaGUgc2NhbGUgcmF0aW8gb24gdGhlIHktYXhpcy5cclxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIHNjYWxlWTogZnVuY3Rpb24gc2NhbGVZKF9zY2FsZVkpIHtcclxuICAgICAgdmFyIHNjYWxlWCA9IHRoaXMuaW1hZ2VEYXRhLnNjYWxlWDtcclxuICAgICAgcmV0dXJuIHRoaXMuc2NhbGUoaXNOdW1iZXIoc2NhbGVYKSA/IHNjYWxlWCA6IDEsIF9zY2FsZVkpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlIHRoZSBpbWFnZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWCAtIFRoZSBzY2FsZSByYXRpbyBvbiB0aGUgeC1heGlzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZVk9c2NhbGVYXSAtIFRoZSBzY2FsZSByYXRpbyBvbiB0aGUgeS1heGlzLlxyXG4gICAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgc2NhbGU6IGZ1bmN0aW9uIHNjYWxlKHNjYWxlWCkge1xyXG4gICAgICB2YXIgc2NhbGVZID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBzY2FsZVg7XHJcbiAgICAgIHZhciBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTtcclxuICAgICAgdmFyIHRyYW5zZm9ybWVkID0gZmFsc2U7XHJcbiAgICAgIHNjYWxlWCA9IE51bWJlcihzY2FsZVgpO1xyXG4gICAgICBzY2FsZVkgPSBOdW1iZXIoc2NhbGVZKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkICYmIHRoaXMub3B0aW9ucy5zY2FsYWJsZSkge1xyXG4gICAgICAgIGlmIChpc051bWJlcihzY2FsZVgpKSB7XHJcbiAgICAgICAgICBpbWFnZURhdGEuc2NhbGVYID0gc2NhbGVYO1xyXG4gICAgICAgICAgdHJhbnNmb3JtZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjYWxlWSkpIHtcclxuICAgICAgICAgIGltYWdlRGF0YS5zY2FsZVkgPSBzY2FsZVk7XHJcbiAgICAgICAgICB0cmFuc2Zvcm1lZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHJhbnNmb3JtZWQpIHtcclxuICAgICAgICAgIHRoaXMucmVuZGVyQ2FudmFzKHRydWUsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjcm9wcGVkIGFyZWEgcG9zaXRpb24gYW5kIHNpemUgZGF0YSAoYmFzZSBvbiB0aGUgb3JpZ2luYWwgaW1hZ2UpXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyb3VuZGVkPWZhbHNlXSAtIEluZGljYXRlIGlmIHJvdW5kIHRoZSBkYXRhIHZhbHVlcyBvciBub3QuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IGNyb3BwZWQgZGF0YS5cclxuICAgICAqL1xyXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24gZ2V0RGF0YSgpIHtcclxuICAgICAgdmFyIHJvdW5kZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xyXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuICAgICAgICAgIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhLFxyXG4gICAgICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YSxcclxuICAgICAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcclxuICAgICAgdmFyIGRhdGE7XHJcblxyXG4gICAgICBpZiAodGhpcy5yZWFkeSAmJiB0aGlzLmNyb3BwZWQpIHtcclxuICAgICAgICBkYXRhID0ge1xyXG4gICAgICAgICAgeDogY3JvcEJveERhdGEubGVmdCAtIGNhbnZhc0RhdGEubGVmdCxcclxuICAgICAgICAgIHk6IGNyb3BCb3hEYXRhLnRvcCAtIGNhbnZhc0RhdGEudG9wLFxyXG4gICAgICAgICAgd2lkdGg6IGNyb3BCb3hEYXRhLndpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0OiBjcm9wQm94RGF0YS5oZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByYXRpbyA9IGltYWdlRGF0YS53aWR0aCAvIGltYWdlRGF0YS5uYXR1cmFsV2lkdGg7XHJcbiAgICAgICAgZm9yRWFjaChkYXRhLCBmdW5jdGlvbiAobiwgaSkge1xyXG4gICAgICAgICAgZGF0YVtpXSA9IG4gLyByYXRpbztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHJvdW5kZWQpIHtcclxuICAgICAgICAgIC8vIEluIGNhc2Ugcm91bmRpbmcgb2ZmIGxlYWRzIHRvIGV4dHJhIDFweCBpbiByaWdodCBvciBib3R0b20gYm9yZGVyXHJcbiAgICAgICAgICAvLyB3ZSBzaG91bGQgcm91bmQgdGhlIHRvcC1sZWZ0IGNvcm5lciBhbmQgdGhlIGRpbWVuc2lvbiAoIzM0MykuXHJcbiAgICAgICAgICB2YXIgYm90dG9tID0gTWF0aC5yb3VuZChkYXRhLnkgKyBkYXRhLmhlaWdodCk7XHJcbiAgICAgICAgICB2YXIgcmlnaHQgPSBNYXRoLnJvdW5kKGRhdGEueCArIGRhdGEud2lkdGgpO1xyXG4gICAgICAgICAgZGF0YS54ID0gTWF0aC5yb3VuZChkYXRhLngpO1xyXG4gICAgICAgICAgZGF0YS55ID0gTWF0aC5yb3VuZChkYXRhLnkpO1xyXG4gICAgICAgICAgZGF0YS53aWR0aCA9IHJpZ2h0IC0gZGF0YS54O1xyXG4gICAgICAgICAgZGF0YS5oZWlnaHQgPSBib3R0b20gLSBkYXRhLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRhdGEgPSB7XHJcbiAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgeTogMCxcclxuICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG9wdGlvbnMucm90YXRhYmxlKSB7XHJcbiAgICAgICAgZGF0YS5yb3RhdGUgPSBpbWFnZURhdGEucm90YXRlIHx8IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChvcHRpb25zLnNjYWxhYmxlKSB7XHJcbiAgICAgICAgZGF0YS5zY2FsZVggPSBpbWFnZURhdGEuc2NhbGVYIHx8IDE7XHJcbiAgICAgICAgZGF0YS5zY2FsZVkgPSBpbWFnZURhdGEuc2NhbGVZIHx8IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY3JvcHBlZCBhcmVhIHBvc2l0aW9uIGFuZCBzaXplIHdpdGggbmV3IGRhdGFcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIG5ldyBkYXRhLlxyXG4gICAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgc2V0RGF0YTogZnVuY3Rpb24gc2V0RGF0YShkYXRhKSB7XHJcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gICAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGEsXHJcbiAgICAgICAgICBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhO1xyXG4gICAgICB2YXIgY3JvcEJveERhdGEgPSB7fTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkICYmIGlzUGxhaW5PYmplY3QoZGF0YSkpIHtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMucm90YXRhYmxlKSB7XHJcbiAgICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS5yb3RhdGUpICYmIGRhdGEucm90YXRlICE9PSBpbWFnZURhdGEucm90YXRlKSB7XHJcbiAgICAgICAgICAgIGltYWdlRGF0YS5yb3RhdGUgPSBkYXRhLnJvdGF0ZTtcclxuICAgICAgICAgICAgdHJhbnNmb3JtZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGFibGUpIHtcclxuICAgICAgICAgIGlmIChpc051bWJlcihkYXRhLnNjYWxlWCkgJiYgZGF0YS5zY2FsZVggIT09IGltYWdlRGF0YS5zY2FsZVgpIHtcclxuICAgICAgICAgICAgaW1hZ2VEYXRhLnNjYWxlWCA9IGRhdGEuc2NhbGVYO1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1lZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEuc2NhbGVZKSAmJiBkYXRhLnNjYWxlWSAhPT0gaW1hZ2VEYXRhLnNjYWxlWSkge1xyXG4gICAgICAgICAgICBpbWFnZURhdGEuc2NhbGVZID0gZGF0YS5zY2FsZVk7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZCkge1xyXG4gICAgICAgICAgdGhpcy5yZW5kZXJDYW52YXModHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmF0aW8gPSBpbWFnZURhdGEud2lkdGggLyBpbWFnZURhdGEubmF0dXJhbFdpZHRoO1xyXG5cclxuICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS54KSkge1xyXG4gICAgICAgICAgY3JvcEJveERhdGEubGVmdCA9IGRhdGEueCAqIHJhdGlvICsgY2FudmFzRGF0YS5sZWZ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEueSkpIHtcclxuICAgICAgICAgIGNyb3BCb3hEYXRhLnRvcCA9IGRhdGEueSAqIHJhdGlvICsgY2FudmFzRGF0YS50b3A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS53aWR0aCkpIHtcclxuICAgICAgICAgIGNyb3BCb3hEYXRhLndpZHRoID0gZGF0YS53aWR0aCAqIHJhdGlvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSkge1xyXG4gICAgICAgICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgKiByYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0Q3JvcEJveERhdGEoY3JvcEJveERhdGEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNvbnRhaW5lciBzaXplIGRhdGEuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IGNvbnRhaW5lciBkYXRhLlxyXG4gICAgICovXHJcbiAgICBnZXRDb250YWluZXJEYXRhOiBmdW5jdGlvbiBnZXRDb250YWluZXJEYXRhKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5yZWFkeSA/IGFzc2lnbih7fSwgdGhpcy5jb250YWluZXJEYXRhKSA6IHt9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaW1hZ2UgcG9zaXRpb24gYW5kIHNpemUgZGF0YS5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgaW1hZ2UgZGF0YS5cclxuICAgICAqL1xyXG4gICAgZ2V0SW1hZ2VEYXRhOiBmdW5jdGlvbiBnZXRJbWFnZURhdGEoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNpemVkID8gYXNzaWduKHt9LCB0aGlzLmltYWdlRGF0YSkgOiB7fTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNhbnZhcyBwb3NpdGlvbiBhbmQgc2l6ZSBkYXRhLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdCBjYW52YXMgZGF0YS5cclxuICAgICAqL1xyXG4gICAgZ2V0Q2FudmFzRGF0YTogZnVuY3Rpb24gZ2V0Q2FudmFzRGF0YSgpIHtcclxuICAgICAgdmFyIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGE7XHJcbiAgICAgIHZhciBkYXRhID0ge307XHJcblxyXG4gICAgICBpZiAodGhpcy5yZWFkeSkge1xyXG4gICAgICAgIGZvckVhY2goWydsZWZ0JywgJ3RvcCcsICd3aWR0aCcsICdoZWlnaHQnLCAnbmF0dXJhbFdpZHRoJywgJ25hdHVyYWxIZWlnaHQnXSwgZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgIGRhdGFbbl0gPSBjYW52YXNEYXRhW25dO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGNhbnZhcyBwb3NpdGlvbiBhbmQgc2l6ZSB3aXRoIG5ldyBkYXRhLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgbmV3IGNhbnZhcyBkYXRhLlxyXG4gICAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgc2V0Q2FudmFzRGF0YTogZnVuY3Rpb24gc2V0Q2FudmFzRGF0YShkYXRhKSB7XHJcbiAgICAgIHZhciBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhO1xyXG4gICAgICB2YXIgYXNwZWN0UmF0aW8gPSBjYW52YXNEYXRhLmFzcGVjdFJhdGlvO1xyXG5cclxuICAgICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQgJiYgaXNQbGFpbk9iamVjdChkYXRhKSkge1xyXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLmxlZnQpKSB7XHJcbiAgICAgICAgICBjYW52YXNEYXRhLmxlZnQgPSBkYXRhLmxlZnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS50b3ApKSB7XHJcbiAgICAgICAgICBjYW52YXNEYXRhLnRvcCA9IGRhdGEudG9wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEud2lkdGgpKSB7XHJcbiAgICAgICAgICBjYW52YXNEYXRhLndpZHRoID0gZGF0YS53aWR0aDtcclxuICAgICAgICAgIGNhbnZhc0RhdGEuaGVpZ2h0ID0gZGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoZGF0YS5oZWlnaHQpKSB7XHJcbiAgICAgICAgICBjYW52YXNEYXRhLmhlaWdodCA9IGRhdGEuaGVpZ2h0O1xyXG4gICAgICAgICAgY2FudmFzRGF0YS53aWR0aCA9IGRhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyh0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjcm9wIGJveCBwb3NpdGlvbiBhbmQgc2l6ZSBkYXRhLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdCBjcm9wIGJveCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBnZXRDcm9wQm94RGF0YTogZnVuY3Rpb24gZ2V0Q3JvcEJveERhdGEoKSB7XHJcbiAgICAgIHZhciBjcm9wQm94RGF0YSA9IHRoaXMuY3JvcEJveERhdGE7XHJcbiAgICAgIHZhciBkYXRhO1xyXG5cclxuICAgICAgaWYgKHRoaXMucmVhZHkgJiYgdGhpcy5jcm9wcGVkKSB7XHJcbiAgICAgICAgZGF0YSA9IHtcclxuICAgICAgICAgIGxlZnQ6IGNyb3BCb3hEYXRhLmxlZnQsXHJcbiAgICAgICAgICB0b3A6IGNyb3BCb3hEYXRhLnRvcCxcclxuICAgICAgICAgIHdpZHRoOiBjcm9wQm94RGF0YS53aWR0aCxcclxuICAgICAgICAgIGhlaWdodDogY3JvcEJveERhdGEuaGVpZ2h0XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGRhdGEgfHwge307XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjcm9wIGJveCBwb3NpdGlvbiBhbmQgc2l6ZSB3aXRoIG5ldyBkYXRhLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgbmV3IGNyb3AgYm94IGRhdGEuXHJcbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICBzZXRDcm9wQm94RGF0YTogZnVuY3Rpb24gc2V0Q3JvcEJveERhdGEoZGF0YSkge1xyXG4gICAgICB2YXIgY3JvcEJveERhdGEgPSB0aGlzLmNyb3BCb3hEYXRhO1xyXG4gICAgICB2YXIgYXNwZWN0UmF0aW8gPSB0aGlzLm9wdGlvbnMuYXNwZWN0UmF0aW87XHJcbiAgICAgIHZhciB3aWR0aENoYW5nZWQ7XHJcbiAgICAgIHZhciBoZWlnaHRDaGFuZ2VkO1xyXG5cclxuICAgICAgaWYgKHRoaXMucmVhZHkgJiYgdGhpcy5jcm9wcGVkICYmICF0aGlzLmRpc2FibGVkICYmIGlzUGxhaW5PYmplY3QoZGF0YSkpIHtcclxuICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS5sZWZ0KSkge1xyXG4gICAgICAgICAgY3JvcEJveERhdGEubGVmdCA9IGRhdGEubGVmdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLnRvcCkpIHtcclxuICAgICAgICAgIGNyb3BCb3hEYXRhLnRvcCA9IGRhdGEudG9wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEud2lkdGgpICYmIGRhdGEud2lkdGggIT09IGNyb3BCb3hEYXRhLndpZHRoKSB7XHJcbiAgICAgICAgICB3aWR0aENoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSBkYXRhLndpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSAmJiBkYXRhLmhlaWdodCAhPT0gY3JvcEJveERhdGEuaGVpZ2h0KSB7XHJcbiAgICAgICAgICBoZWlnaHRDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgIGNyb3BCb3hEYXRhLmhlaWdodCA9IGRhdGEuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XHJcbiAgICAgICAgICBpZiAod2lkdGhDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIGNyb3BCb3hEYXRhLmhlaWdodCA9IGNyb3BCb3hEYXRhLndpZHRoIC8gYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodENoYW5nZWQpIHtcclxuICAgICAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSBjcm9wQm94RGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyQ3JvcEJveCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBjYW52YXMgZHJhd24gdGhlIGNyb3BwZWQgaW1hZ2UuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gVGhlIGNvbmZpZyBvcHRpb25zLlxyXG4gICAgICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fSAtIFRoZSByZXN1bHQgY2FudmFzLlxyXG4gICAgICovXHJcbiAgICBnZXRDcm9wcGVkQ2FudmFzOiBmdW5jdGlvbiBnZXRDcm9wcGVkQ2FudmFzKCkge1xyXG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XHJcblxyXG4gICAgICBpZiAoIXRoaXMucmVhZHkgfHwgIXdpbmRvdy5IVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcclxuICAgICAgdmFyIHNvdXJjZSA9IGdldFNvdXJjZUNhbnZhcyh0aGlzLmltYWdlLCB0aGlzLmltYWdlRGF0YSwgY2FudmFzRGF0YSwgb3B0aW9ucyk7IC8vIFJldHVybnMgdGhlIHNvdXJjZSBjYW52YXMgaWYgaXQgaXMgbm90IGNyb3BwZWQuXHJcblxyXG4gICAgICBpZiAoIXRoaXMuY3JvcHBlZCkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBfdGhpcyRnZXREYXRhID0gdGhpcy5nZXREYXRhKCksXHJcbiAgICAgICAgICBpbml0aWFsWCA9IF90aGlzJGdldERhdGEueCxcclxuICAgICAgICAgIGluaXRpYWxZID0gX3RoaXMkZ2V0RGF0YS55LFxyXG4gICAgICAgICAgaW5pdGlhbFdpZHRoID0gX3RoaXMkZ2V0RGF0YS53aWR0aCxcclxuICAgICAgICAgIGluaXRpYWxIZWlnaHQgPSBfdGhpcyRnZXREYXRhLmhlaWdodDtcclxuXHJcbiAgICAgIHZhciByYXRpbyA9IHNvdXJjZS53aWR0aCAvIE1hdGguZmxvb3IoY2FudmFzRGF0YS5uYXR1cmFsV2lkdGgpO1xyXG5cclxuICAgICAgaWYgKHJhdGlvICE9PSAxKSB7XHJcbiAgICAgICAgaW5pdGlhbFggKj0gcmF0aW87XHJcbiAgICAgICAgaW5pdGlhbFkgKj0gcmF0aW87XHJcbiAgICAgICAgaW5pdGlhbFdpZHRoICo9IHJhdGlvO1xyXG4gICAgICAgIGluaXRpYWxIZWlnaHQgKj0gcmF0aW87XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBhc3BlY3RSYXRpbyA9IGluaXRpYWxXaWR0aCAvIGluaXRpYWxIZWlnaHQ7XHJcbiAgICAgIHZhciBtYXhTaXplcyA9IGdldEFkanVzdGVkU2l6ZXMoe1xyXG4gICAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcclxuICAgICAgICB3aWR0aDogb3B0aW9ucy5tYXhXaWR0aCB8fCBJbmZpbml0eSxcclxuICAgICAgICBoZWlnaHQ6IG9wdGlvbnMubWF4SGVpZ2h0IHx8IEluZmluaXR5XHJcbiAgICAgIH0pO1xyXG4gICAgICB2YXIgbWluU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcclxuICAgICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXHJcbiAgICAgICAgd2lkdGg6IG9wdGlvbnMubWluV2lkdGggfHwgMCxcclxuICAgICAgICBoZWlnaHQ6IG9wdGlvbnMubWluSGVpZ2h0IHx8IDBcclxuICAgICAgfSwgJ2NvdmVyJyk7XHJcblxyXG4gICAgICB2YXIgX2dldEFkanVzdGVkU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcclxuICAgICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXHJcbiAgICAgICAgd2lkdGg6IG9wdGlvbnMud2lkdGggfHwgKHJhdGlvICE9PSAxID8gc291cmNlLndpZHRoIDogaW5pdGlhbFdpZHRoKSxcclxuICAgICAgICBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0IHx8IChyYXRpbyAhPT0gMSA/IHNvdXJjZS5oZWlnaHQgOiBpbml0aWFsSGVpZ2h0KVxyXG4gICAgICB9KSxcclxuICAgICAgICAgIHdpZHRoID0gX2dldEFkanVzdGVkU2l6ZXMud2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQgPSBfZ2V0QWRqdXN0ZWRTaXplcy5oZWlnaHQ7XHJcblxyXG4gICAgICB3aWR0aCA9IE1hdGgubWluKG1heFNpemVzLndpZHRoLCBNYXRoLm1heChtaW5TaXplcy53aWR0aCwgd2lkdGgpKTtcclxuICAgICAgaGVpZ2h0ID0gTWF0aC5taW4obWF4U2l6ZXMuaGVpZ2h0LCBNYXRoLm1heChtaW5TaXplcy5oZWlnaHQsIGhlaWdodCkpO1xyXG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgIGNhbnZhcy53aWR0aCA9IG5vcm1hbGl6ZURlY2ltYWxOdW1iZXIod2lkdGgpO1xyXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gbm9ybWFsaXplRGVjaW1hbE51bWJlcihoZWlnaHQpO1xyXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbENvbG9yIHx8ICd0cmFuc3BhcmVudCc7XHJcbiAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgIHZhciBfb3B0aW9ucyRpbWFnZVNtb290aGkgPSBvcHRpb25zLmltYWdlU21vb3RoaW5nRW5hYmxlZCxcclxuICAgICAgICAgIGltYWdlU21vb3RoaW5nRW5hYmxlZCA9IF9vcHRpb25zJGltYWdlU21vb3RoaSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGltYWdlU21vb3RoaSxcclxuICAgICAgICAgIGltYWdlU21vb3RoaW5nUXVhbGl0eSA9IG9wdGlvbnMuaW1hZ2VTbW9vdGhpbmdRdWFsaXR5O1xyXG4gICAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGltYWdlU21vb3RoaW5nRW5hYmxlZDtcclxuXHJcbiAgICAgIGlmIChpbWFnZVNtb290aGluZ1F1YWxpdHkpIHtcclxuICAgICAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nUXVhbGl0eSA9IGltYWdlU21vb3RoaW5nUXVhbGl0eTtcclxuICAgICAgfSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELmRyYXdJbWFnZVxyXG5cclxuXHJcbiAgICAgIHZhciBzb3VyY2VXaWR0aCA9IHNvdXJjZS53aWR0aDtcclxuICAgICAgdmFyIHNvdXJjZUhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7IC8vIFNvdXJjZSBjYW52YXMgcGFyYW1ldGVyc1xyXG5cclxuICAgICAgdmFyIHNyY1ggPSBpbml0aWFsWDtcclxuICAgICAgdmFyIHNyY1kgPSBpbml0aWFsWTtcclxuICAgICAgdmFyIHNyY1dpZHRoO1xyXG4gICAgICB2YXIgc3JjSGVpZ2h0OyAvLyBEZXN0aW5hdGlvbiBjYW52YXMgcGFyYW1ldGVyc1xyXG5cclxuICAgICAgdmFyIGRzdFg7XHJcbiAgICAgIHZhciBkc3RZO1xyXG4gICAgICB2YXIgZHN0V2lkdGg7XHJcbiAgICAgIHZhciBkc3RIZWlnaHQ7XHJcblxyXG4gICAgICBpZiAoc3JjWCA8PSAtaW5pdGlhbFdpZHRoIHx8IHNyY1ggPiBzb3VyY2VXaWR0aCkge1xyXG4gICAgICAgIHNyY1ggPSAwO1xyXG4gICAgICAgIHNyY1dpZHRoID0gMDtcclxuICAgICAgICBkc3RYID0gMDtcclxuICAgICAgICBkc3RXaWR0aCA9IDA7XHJcbiAgICAgIH0gZWxzZSBpZiAoc3JjWCA8PSAwKSB7XHJcbiAgICAgICAgZHN0WCA9IC1zcmNYO1xyXG4gICAgICAgIHNyY1ggPSAwO1xyXG4gICAgICAgIHNyY1dpZHRoID0gTWF0aC5taW4oc291cmNlV2lkdGgsIGluaXRpYWxXaWR0aCArIHNyY1gpO1xyXG4gICAgICAgIGRzdFdpZHRoID0gc3JjV2lkdGg7XHJcbiAgICAgIH0gZWxzZSBpZiAoc3JjWCA8PSBzb3VyY2VXaWR0aCkge1xyXG4gICAgICAgIGRzdFggPSAwO1xyXG4gICAgICAgIHNyY1dpZHRoID0gTWF0aC5taW4oaW5pdGlhbFdpZHRoLCBzb3VyY2VXaWR0aCAtIHNyY1gpO1xyXG4gICAgICAgIGRzdFdpZHRoID0gc3JjV2lkdGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzcmNXaWR0aCA8PSAwIHx8IHNyY1kgPD0gLWluaXRpYWxIZWlnaHQgfHwgc3JjWSA+IHNvdXJjZUhlaWdodCkge1xyXG4gICAgICAgIHNyY1kgPSAwO1xyXG4gICAgICAgIHNyY0hlaWdodCA9IDA7XHJcbiAgICAgICAgZHN0WSA9IDA7XHJcbiAgICAgICAgZHN0SGVpZ2h0ID0gMDtcclxuICAgICAgfSBlbHNlIGlmIChzcmNZIDw9IDApIHtcclxuICAgICAgICBkc3RZID0gLXNyY1k7XHJcbiAgICAgICAgc3JjWSA9IDA7XHJcbiAgICAgICAgc3JjSGVpZ2h0ID0gTWF0aC5taW4oc291cmNlSGVpZ2h0LCBpbml0aWFsSGVpZ2h0ICsgc3JjWSk7XHJcbiAgICAgICAgZHN0SGVpZ2h0ID0gc3JjSGVpZ2h0O1xyXG4gICAgICB9IGVsc2UgaWYgKHNyY1kgPD0gc291cmNlSGVpZ2h0KSB7XHJcbiAgICAgICAgZHN0WSA9IDA7XHJcbiAgICAgICAgc3JjSGVpZ2h0ID0gTWF0aC5taW4oaW5pdGlhbEhlaWdodCwgc291cmNlSGVpZ2h0IC0gc3JjWSk7XHJcbiAgICAgICAgZHN0SGVpZ2h0ID0gc3JjSGVpZ2h0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcGFyYW1zID0gW3NyY1gsIHNyY1ksIHNyY1dpZHRoLCBzcmNIZWlnaHRdOyAvLyBBdm9pZCBcIkluZGV4U2l6ZUVycm9yXCJcclxuXHJcbiAgICAgIGlmIChkc3RXaWR0aCA+IDAgJiYgZHN0SGVpZ2h0ID4gMCkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHdpZHRoIC8gaW5pdGlhbFdpZHRoO1xyXG4gICAgICAgIHBhcmFtcy5wdXNoKGRzdFggKiBzY2FsZSwgZHN0WSAqIHNjYWxlLCBkc3RXaWR0aCAqIHNjYWxlLCBkc3RIZWlnaHQgKiBzY2FsZSk7XHJcbiAgICAgIH0gLy8gQWxsIHRoZSBudW1lcmljYWwgcGFyYW1ldGVycyBzaG91bGQgYmUgaW50ZWdlciBmb3IgYGRyYXdJbWFnZWBcclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlbmd5dWFuY2hlbi9jcm9wcGVyL2lzc3Vlcy80NzZcclxuXHJcblxyXG4gICAgICBjb250ZXh0LmRyYXdJbWFnZS5hcHBseShjb250ZXh0LCBbc291cmNlXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iobm9ybWFsaXplRGVjaW1hbE51bWJlcihwYXJhbSkpO1xyXG4gICAgICB9KSkpKTtcclxuICAgICAgcmV0dXJuIGNhbnZhcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgdGhlIGFzcGVjdCByYXRpbyBvZiB0aGUgY3JvcCBib3guXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0UmF0aW8gLSBUaGUgbmV3IGFzcGVjdCByYXRpby5cclxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIHNldEFzcGVjdFJhdGlvOiBmdW5jdGlvbiBzZXRBc3BlY3RSYXRpbyhhc3BlY3RSYXRpbykge1xyXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcbiAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiAhaXNVbmRlZmluZWQoYXNwZWN0UmF0aW8pKSB7XHJcbiAgICAgICAgLy8gMCAtPiBOYU5cclxuICAgICAgICBvcHRpb25zLmFzcGVjdFJhdGlvID0gTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8pIHx8IE5hTjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucmVhZHkpIHtcclxuICAgICAgICAgIHRoaXMuaW5pdENyb3BCb3goKTtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5jcm9wcGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ3JvcEJveCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIHRoZSBkcmFnIG1vZGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIFRoZSBuZXcgZHJhZyBtb2RlLlxyXG4gICAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgc2V0RHJhZ01vZGU6IGZ1bmN0aW9uIHNldERyYWdNb2RlKG1vZGUpIHtcclxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcbiAgICAgICAgICBkcmFnQm94ID0gdGhpcy5kcmFnQm94LFxyXG4gICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkKSB7XHJcbiAgICAgICAgdmFyIGNyb3BwYWJsZSA9IG1vZGUgPT09IERSQUdfTU9ERV9DUk9QO1xyXG4gICAgICAgIHZhciBtb3ZhYmxlID0gb3B0aW9ucy5tb3ZhYmxlICYmIG1vZGUgPT09IERSQUdfTU9ERV9NT1ZFO1xyXG4gICAgICAgIG1vZGUgPSBjcm9wcGFibGUgfHwgbW92YWJsZSA/IG1vZGUgOiBEUkFHX01PREVfTk9ORTtcclxuICAgICAgICBvcHRpb25zLmRyYWdNb2RlID0gbW9kZTtcclxuICAgICAgICBzZXREYXRhKGRyYWdCb3gsIERBVEFfQUNUSU9OLCBtb2RlKTtcclxuICAgICAgICB0b2dnbGVDbGFzcyhkcmFnQm94LCBDTEFTU19DUk9QLCBjcm9wcGFibGUpO1xyXG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdCb3gsIENMQVNTX01PVkUsIG1vdmFibGUpO1xyXG5cclxuICAgICAgICBpZiAoIW9wdGlvbnMuY3JvcEJveE1vdmFibGUpIHtcclxuICAgICAgICAgIC8vIFN5bmMgZHJhZyBtb2RlIHRvIGNyb3AgYm94IHdoZW4gaXQgaXMgbm90IG1vdmFibGVcclxuICAgICAgICAgIHNldERhdGEoZmFjZSwgREFUQV9BQ1RJT04sIG1vZGUpO1xyXG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZmFjZSwgQ0xBU1NfQ1JPUCwgY3JvcHBhYmxlKTtcclxuICAgICAgICAgIHRvZ2dsZUNsYXNzKGZhY2UsIENMQVNTX01PVkUsIG1vdmFibGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIEFub3RoZXJDcm9wcGVyID0gV0lORE9XLkNyb3BwZXI7XHJcblxyXG4gIHZhciBDcm9wcGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IENyb3BwZXIuXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQgZm9yIGNyb3BwaW5nLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENyb3BwZXIoZWxlbWVudCkge1xyXG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XHJcblxyXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3JvcHBlcik7XHJcblxyXG4gICAgICBpZiAoIWVsZW1lbnQgfHwgIVJFR0VYUF9UQUdfTkFNRS50ZXN0KGVsZW1lbnQudGFnTmFtZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmaXJzdCBhcmd1bWVudCBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhbiA8aW1nPiBvciA8Y2FudmFzPiBlbGVtZW50LicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIERFRkFVTFRTLCBpc1BsYWluT2JqZWN0KG9wdGlvbnMpICYmIG9wdGlvbnMpO1xyXG4gICAgICB0aGlzLmNyb3BwZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnBvaW50ZXJzID0ge307XHJcbiAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcclxuICAgICAgdGhpcy5yZWxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy5yZXBsYWNlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnNpemVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuc2l6aW5nID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIF9jcmVhdGVDbGFzcyhDcm9wcGVyLCBbe1xyXG4gICAgICBrZXk6IFwiaW5pdFwiLFxyXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICB2YXIgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHZhciB1cmw7XHJcblxyXG4gICAgICAgIGlmIChlbGVtZW50W05BTUVTUEFDRV0pIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsZW1lbnRbTkFNRVNQQUNFXSA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnaW1nJykge1xyXG4gICAgICAgICAgdGhpcy5pc0ltZyA9IHRydWU7IC8vIGUuZy46IFwiaW1nL3BpY3R1cmUuanBnXCJcclxuXHJcbiAgICAgICAgICB1cmwgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3JjJykgfHwgJyc7XHJcbiAgICAgICAgICB0aGlzLm9yaWdpbmFsVXJsID0gdXJsOyAvLyBTdG9wIHdoZW4gaXQncyBhIGJsYW5rIGltYWdlXHJcblxyXG4gICAgICAgICAgaWYgKCF1cmwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfSAvLyBlLmcuOiBcImh0dHBzOi8vZXhhbXBsZS5jb20vaW1nL3BpY3R1cmUuanBnXCJcclxuXHJcblxyXG4gICAgICAgICAgdXJsID0gZWxlbWVudC5zcmM7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnY2FudmFzJyAmJiB3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgICAgIHVybCA9IGVsZW1lbnQudG9EYXRhVVJMKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmxvYWQodXJsKTtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICBrZXk6IFwibG9hZFwiLFxyXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgICBpZiAoIXVybCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICAgICAgdGhpcy5pbWFnZURhdGEgPSB7fTtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcbiAgICAgICAgaWYgKCFvcHRpb25zLnJvdGF0YWJsZSAmJiAhb3B0aW9ucy5zY2FsYWJsZSkge1xyXG4gICAgICAgICAgb3B0aW9ucy5jaGVja09yaWVudGF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgfSAvLyBPbmx5IElFMTArIHN1cHBvcnRzIFR5cGVkIEFycmF5c1xyXG5cclxuXHJcbiAgICAgICAgaWYgKCFvcHRpb25zLmNoZWNrT3JpZW50YXRpb24gfHwgIXdpbmRvdy5BcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gLy8gRGV0ZWN0IHRoZSBtaW1lIHR5cGUgb2YgdGhlIGltYWdlIGRpcmVjdGx5IGlmIGl0IGlzIGEgRGF0YSBVUkxcclxuXHJcblxyXG4gICAgICAgIGlmIChSRUdFWFBfREFUQV9VUkwudGVzdCh1cmwpKSB7XHJcbiAgICAgICAgICAvLyBSZWFkIEFycmF5QnVmZmVyIGZyb20gRGF0YSBVUkwgb2YgSlBFRyBpbWFnZXMgZGlyZWN0bHkgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxyXG4gICAgICAgICAgaWYgKFJFR0VYUF9EQVRBX1VSTF9KUEVHLnRlc3QodXJsKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWQoZGF0YVVSTFRvQXJyYXlCdWZmZXIodXJsKSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBPbmx5IGEgSlBFRyBpbWFnZSBtYXkgY29udGFpbnMgRXhpZiBPcmllbnRhdGlvbiBpbmZvcm1hdGlvbixcclxuICAgICAgICAgICAgLy8gdGhlIHJlc3QgdHlwZXMgb2YgRGF0YSBVUkxzIGFyZSBub3QgbmVjZXNzYXJ5IHRvIGNoZWNrIG9yaWVudGF0aW9uIGF0IGFsbC5cclxuICAgICAgICAgICAgdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IC8vIDEuIERldGVjdCB0aGUgbWltZSB0eXBlIG9mIHRoZSBpbWFnZSBieSBhIFhNTEh0dHBSZXF1ZXN0LlxyXG4gICAgICAgIC8vIDIuIExvYWQgdGhlIGltYWdlIGFzIEFycmF5QnVmZmVyIGZvciByZWFkaW5nIG9yaWVudGF0aW9uIGlmIGl0cyBhIEpQRUcgaW1hZ2UuXHJcblxyXG5cclxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgdmFyIGNsb25lID0gdGhpcy5jbG9uZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVsb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnhociA9IHhocjsgLy8gMS4gQ3Jvc3Mgb3JpZ2luIHJlcXVlc3RzIGFyZSBvbmx5IHN1cHBvcnRlZCBmb3IgcHJvdG9jb2wgc2NoZW1lczpcclxuICAgICAgICAvLyBodHRwLCBodHRwcywgZGF0YSwgY2hyb21lLCBjaHJvbWUtZXh0ZW5zaW9uLlxyXG4gICAgICAgIC8vIDIuIEFjY2VzcyB0byBYTUxIdHRwUmVxdWVzdCBmcm9tIGEgRGF0YSBVUkwgd2lsbCBiZSBibG9ja2VkIGJ5IENPUlMgcG9saWN5XHJcbiAgICAgICAgLy8gaW4gc29tZSBicm93c2VycyBhcyBJRTExIGFuZCBTYWZhcmkuXHJcblxyXG4gICAgICAgIHhoci5vbmFib3J0ID0gY2xvbmU7XHJcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBjbG9uZTtcclxuICAgICAgICB4aHIub250aW1lb3V0ID0gY2xvbmU7XHJcblxyXG4gICAgICAgIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgLy8gQWJvcnQgdGhlIHJlcXVlc3QgZGlyZWN0bHkgaWYgaXQgbm90IGEgSlBFRyBpbWFnZSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXHJcbiAgICAgICAgICBpZiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKSAhPT0gTUlNRV9UWVBFX0pQRUcpIHtcclxuICAgICAgICAgICAgeGhyLmFib3J0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIF90aGlzLnJlYWQoeGhyLnJlc3BvbnNlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB4aHIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgX3RoaXMucmVsb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICBfdGhpcy54aHIgPSBudWxsO1xyXG4gICAgICAgIH07IC8vIEJ1c3QgY2FjaGUgd2hlbiB0aGVyZSBpcyBhIFwiY3Jvc3NPcmlnaW5cIiBwcm9wZXJ0eSB0byBhdm9pZCBicm93c2VyIGNhY2hlIGVycm9yXHJcblxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5jaGVja0Nyb3NzT3JpZ2luICYmIGlzQ3Jvc3NPcmlnaW5VUkwodXJsKSAmJiBlbGVtZW50LmNyb3NzT3JpZ2luKSB7XHJcbiAgICAgICAgICB1cmwgPSBhZGRUaW1lc3RhbXAodXJsKTtcclxuICAgICAgICB9IC8vIFRoZSB0aGlyZCBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgZm9yIGF2b2lkaW5nIHNpZGUtZWZmZWN0ICgjNjgyKVxyXG5cclxuXHJcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XHJcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGVsZW1lbnQuY3Jvc3NPcmlnaW4gPT09ICd1c2UtY3JlZGVudGlhbHMnO1xyXG4gICAgICAgIHhoci5zZW5kKCk7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAga2V5OiBcInJlYWRcIixcclxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWQoYXJyYXlCdWZmZXIpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuICAgICAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7IC8vIFJlc2V0IHRoZSBvcmllbnRhdGlvbiB2YWx1ZSB0byBpdHMgZGVmYXVsdCB2YWx1ZSAxXHJcbiAgICAgICAgLy8gYXMgc29tZSBpT1MgYnJvd3NlcnMgd2lsbCByZW5kZXIgaW1hZ2Ugd2l0aCBpdHMgb3JpZW50YXRpb25cclxuXHJcbiAgICAgICAgdmFyIG9yaWVudGF0aW9uID0gcmVzZXRBbmRHZXRPcmllbnRhdGlvbihhcnJheUJ1ZmZlcik7XHJcbiAgICAgICAgdmFyIHJvdGF0ZSA9IDA7XHJcbiAgICAgICAgdmFyIHNjYWxlWCA9IDE7XHJcbiAgICAgICAgdmFyIHNjYWxlWSA9IDE7XHJcblxyXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA+IDEpIHtcclxuICAgICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IFVSTCB3aGljaCBoYXMgdGhlIGRlZmF1bHQgb3JpZW50YXRpb24gdmFsdWVcclxuICAgICAgICAgIHRoaXMudXJsID0gYXJyYXlCdWZmZXJUb0RhdGFVUkwoYXJyYXlCdWZmZXIsIE1JTUVfVFlQRV9KUEVHKTtcclxuXHJcbiAgICAgICAgICB2YXIgX3BhcnNlT3JpZW50YXRpb24gPSBwYXJzZU9yaWVudGF0aW9uKG9yaWVudGF0aW9uKTtcclxuXHJcbiAgICAgICAgICByb3RhdGUgPSBfcGFyc2VPcmllbnRhdGlvbi5yb3RhdGU7XHJcbiAgICAgICAgICBzY2FsZVggPSBfcGFyc2VPcmllbnRhdGlvbi5zY2FsZVg7XHJcbiAgICAgICAgICBzY2FsZVkgPSBfcGFyc2VPcmllbnRhdGlvbi5zY2FsZVk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5yb3RhdGFibGUpIHtcclxuICAgICAgICAgIGltYWdlRGF0YS5yb3RhdGUgPSByb3RhdGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zY2FsYWJsZSkge1xyXG4gICAgICAgICAgaW1hZ2VEYXRhLnNjYWxlWCA9IHNjYWxlWDtcclxuICAgICAgICAgIGltYWdlRGF0YS5zY2FsZVkgPSBzY2FsZVk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNsb25lKCk7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAga2V5OiBcImNsb25lXCIsXHJcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcclxuICAgICAgICAgICAgdXJsID0gdGhpcy51cmw7XHJcbiAgICAgICAgdmFyIGNyb3NzT3JpZ2luID0gZWxlbWVudC5jcm9zc09yaWdpbjtcclxuICAgICAgICB2YXIgY3Jvc3NPcmlnaW5VcmwgPSB1cmw7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2hlY2tDcm9zc09yaWdpbiAmJiBpc0Nyb3NzT3JpZ2luVVJMKHVybCkpIHtcclxuICAgICAgICAgIGlmICghY3Jvc3NPcmlnaW4pIHtcclxuICAgICAgICAgICAgY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcclxuICAgICAgICAgIH0gLy8gQnVzdCBjYWNoZSB3aGVuIHRoZXJlIGlzIG5vdCBhIFwiY3Jvc3NPcmlnaW5cIiBwcm9wZXJ0eSAoIzUxOSlcclxuXHJcblxyXG4gICAgICAgICAgY3Jvc3NPcmlnaW5VcmwgPSBhZGRUaW1lc3RhbXAodXJsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luVXJsID0gY3Jvc3NPcmlnaW5Vcmw7XHJcbiAgICAgICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblxyXG4gICAgICAgIGlmIChjcm9zc09yaWdpbikge1xyXG4gICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGltYWdlLnNyYyA9IGNyb3NzT3JpZ2luVXJsIHx8IHVybDtcclxuICAgICAgICBpbWFnZS5hbHQgPSBlbGVtZW50LmFsdCB8fCAnVGhlIGltYWdlIHRvIGNyb3AnO1xyXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcclxuICAgICAgICBpbWFnZS5vbmxvYWQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XHJcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IHRoaXMuc3RvcC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIGFkZENsYXNzKGltYWdlLCBDTEFTU19ISURFKTtcclxuICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGltYWdlLCBlbGVtZW50Lm5leHRTaWJsaW5nKTtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICBrZXk6IFwic3RhcnRcIixcclxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xyXG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xyXG4gICAgICAgIGltYWdlLm9ubG9hZCA9IG51bGw7XHJcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaXppbmcgPSB0cnVlOyAvLyBNYXRjaCBhbGwgYnJvd3NlcnMgdGhhdCB1c2UgV2ViS2l0IGFzIHRoZSBsYXlvdXQgZW5naW5lIGluIGlPUyBkZXZpY2VzLFxyXG4gICAgICAgIC8vIHN1Y2ggYXMgU2FmYXJpIGZvciBpT1MsIENocm9tZSBmb3IgaU9TLCBhbmQgaW4tYXBwIGJyb3dzZXJzLlxyXG5cclxuICAgICAgICB2YXIgaXNJT1NXZWJLaXQgPSBXSU5ET1cubmF2aWdhdG9yICYmIC8oPzppUGFkfGlQaG9uZXxpUG9kKS4qP0FwcGxlV2ViS2l0L2kudGVzdChXSU5ET1cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcblxyXG4gICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZShuYXR1cmFsV2lkdGgsIG5hdHVyYWxIZWlnaHQpIHtcclxuICAgICAgICAgIGFzc2lnbihfdGhpczIuaW1hZ2VEYXRhLCB7XHJcbiAgICAgICAgICAgIG5hdHVyYWxXaWR0aDogbmF0dXJhbFdpZHRoLFxyXG4gICAgICAgICAgICBuYXR1cmFsSGVpZ2h0OiBuYXR1cmFsSGVpZ2h0LFxyXG4gICAgICAgICAgICBhc3BlY3RSYXRpbzogbmF0dXJhbFdpZHRoIC8gbmF0dXJhbEhlaWdodFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBfdGhpczIuaW5pdGlhbEltYWdlRGF0YSA9IGFzc2lnbih7fSwgX3RoaXMyLmltYWdlRGF0YSk7XHJcbiAgICAgICAgICBfdGhpczIuc2l6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICBfdGhpczIuc2l6ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgIF90aGlzMi5idWlsZCgpO1xyXG4gICAgICAgIH07IC8vIE1vc3QgbW9kZXJuIGJyb3dzZXJzIChleGNlcHRzIGlPUyBXZWJLaXQpXHJcblxyXG5cclxuICAgICAgICBpZiAoaW1hZ2UubmF0dXJhbFdpZHRoICYmICFpc0lPU1dlYktpdCkge1xyXG4gICAgICAgICAgZG9uZShpbWFnZS5uYXR1cmFsV2lkdGgsIGltYWdlLm5hdHVyYWxIZWlnaHQpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNpemluZ0ltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgICB0aGlzLnNpemluZ0ltYWdlID0gc2l6aW5nSW1hZ2U7XHJcblxyXG4gICAgICAgIHNpemluZ0ltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGRvbmUoc2l6aW5nSW1hZ2Uud2lkdGgsIHNpemluZ0ltYWdlLmhlaWdodCk7XHJcblxyXG4gICAgICAgICAgaWYgKCFpc0lPU1dlYktpdCkge1xyXG4gICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKHNpemluZ0ltYWdlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBzaXppbmdJbWFnZS5zcmMgPSBpbWFnZS5zcmM7IC8vIGlPUyBXZWJLaXQgd2lsbCBjb252ZXJ0IHRoZSBpbWFnZSBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICAgLy8gd2l0aCBpdHMgb3JpZW50YXRpb24gb25jZSBhcHBlbmQgaXQgaW50byBET00gKCMyNzkpXHJcblxyXG4gICAgICAgIGlmICghaXNJT1NXZWJLaXQpIHtcclxuICAgICAgICAgIHNpemluZ0ltYWdlLnN0eWxlLmNzc1RleHQgPSAnbGVmdDowOycgKyAnbWF4LWhlaWdodDpub25lIWltcG9ydGFudDsnICsgJ21heC13aWR0aDpub25lIWltcG9ydGFudDsnICsgJ21pbi1oZWlnaHQ6MCFpbXBvcnRhbnQ7JyArICdtaW4td2lkdGg6MCFpbXBvcnRhbnQ7JyArICdvcGFjaXR5OjA7JyArICdwb3NpdGlvbjphYnNvbHV0ZTsnICsgJ3RvcDowOycgKyAnei1pbmRleDotMTsnO1xyXG4gICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChzaXppbmdJbWFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIGtleTogXCJzdG9wXCIsXHJcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xyXG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XHJcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gbnVsbDtcclxuICAgICAgICBpbWFnZS5vbmVycm9yID0gbnVsbDtcclxuICAgICAgICBpbWFnZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGltYWdlKTtcclxuICAgICAgICB0aGlzLmltYWdlID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICBrZXk6IFwiYnVpbGRcIixcclxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5zaXplZCB8fCB0aGlzLnJlYWR5KSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuICAgICAgICAgICAgaW1hZ2UgPSB0aGlzLmltYWdlOyAvLyBDcmVhdGUgY3JvcHBlciBlbGVtZW50c1xyXG5cclxuICAgICAgICB2YXIgY29udGFpbmVyID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IFRFTVBMQVRFO1xyXG4gICAgICAgIHZhciBjcm9wcGVyID0gdGVtcGxhdGUucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1jb250YWluZXJcIikpO1xyXG4gICAgICAgIHZhciBjYW52YXMgPSBjcm9wcGVyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItY2FudmFzXCIpKTtcclxuICAgICAgICB2YXIgZHJhZ0JveCA9IGNyb3BwZXIucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1kcmFnLWJveFwiKSk7XHJcbiAgICAgICAgdmFyIGNyb3BCb3ggPSBjcm9wcGVyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItY3JvcC1ib3hcIikpO1xyXG4gICAgICAgIHZhciBmYWNlID0gY3JvcEJveC5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWZhY2VcIikpO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY3JvcHBlciA9IGNyb3BwZXI7XHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XHJcbiAgICAgICAgdGhpcy5kcmFnQm94ID0gZHJhZ0JveDtcclxuICAgICAgICB0aGlzLmNyb3BCb3ggPSBjcm9wQm94O1xyXG4gICAgICAgIHRoaXMudmlld0JveCA9IGNyb3BwZXIucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi12aWV3LWJveFwiKSk7XHJcbiAgICAgICAgdGhpcy5mYWNlID0gZmFjZTtcclxuICAgICAgICBjYW52YXMuYXBwZW5kQ2hpbGQoaW1hZ2UpOyAvLyBIaWRlIHRoZSBvcmlnaW5hbCBpbWFnZVxyXG5cclxuICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBDTEFTU19ISURERU4pOyAvLyBJbnNlcnRzIHRoZSBjcm9wcGVyIGFmdGVyIHRvIHRoZSBjdXJyZW50IGltYWdlXHJcblxyXG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY3JvcHBlciwgZWxlbWVudC5uZXh0U2libGluZyk7IC8vIFNob3cgdGhlIGltYWdlIGlmIGlzIGhpZGRlblxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuaXNJbWcpIHtcclxuICAgICAgICAgIHJlbW92ZUNsYXNzKGltYWdlLCBDTEFTU19ISURFKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW5pdFByZXZpZXcoKTtcclxuICAgICAgICB0aGlzLmJpbmQoKTtcclxuICAgICAgICBvcHRpb25zLmluaXRpYWxBc3BlY3RSYXRpbyA9IE1hdGgubWF4KDAsIG9wdGlvbnMuaW5pdGlhbEFzcGVjdFJhdGlvKSB8fCBOYU47XHJcbiAgICAgICAgb3B0aW9ucy5hc3BlY3RSYXRpbyA9IE1hdGgubWF4KDAsIG9wdGlvbnMuYXNwZWN0UmF0aW8pIHx8IE5hTjtcclxuICAgICAgICBvcHRpb25zLnZpZXdNb2RlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMywgTWF0aC5yb3VuZChvcHRpb25zLnZpZXdNb2RlKSkpIHx8IDA7XHJcbiAgICAgICAgYWRkQ2xhc3MoY3JvcEJveCwgQ0xBU1NfSElEREVOKTtcclxuXHJcbiAgICAgICAgaWYgKCFvcHRpb25zLmd1aWRlcykge1xyXG4gICAgICAgICAgYWRkQ2xhc3MoY3JvcEJveC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItZGFzaGVkXCIpKSwgQ0xBU1NfSElEREVOKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghb3B0aW9ucy5jZW50ZXIpIHtcclxuICAgICAgICAgIGFkZENsYXNzKGNyb3BCb3guZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWNlbnRlclwiKSksIENMQVNTX0hJRERFTik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICBhZGRDbGFzcyhjcm9wcGVyLCBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWJnXCIpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghb3B0aW9ucy5oaWdobGlnaHQpIHtcclxuICAgICAgICAgIGFkZENsYXNzKGZhY2UsIENMQVNTX0lOVklTSUJMRSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5jcm9wQm94TW92YWJsZSkge1xyXG4gICAgICAgICAgYWRkQ2xhc3MoZmFjZSwgQ0xBU1NfTU9WRSk7XHJcbiAgICAgICAgICBzZXREYXRhKGZhY2UsIERBVEFfQUNUSU9OLCBBQ1RJT05fQUxMKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghb3B0aW9ucy5jcm9wQm94UmVzaXphYmxlKSB7XHJcbiAgICAgICAgICBhZGRDbGFzcyhjcm9wQm94LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1saW5lXCIpKSwgQ0xBU1NfSElEREVOKTtcclxuICAgICAgICAgIGFkZENsYXNzKGNyb3BCb3guZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLXBvaW50XCIpKSwgQ0xBU1NfSElEREVOKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZXREcmFnTW9kZShvcHRpb25zLmRyYWdNb2RlKTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0Nyb3ApIHtcclxuICAgICAgICAgIHRoaXMuY3JvcCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZXREYXRhKG9wdGlvbnMuZGF0YSk7XHJcblxyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMucmVhZHkpKSB7XHJcbiAgICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9SRUFEWSwgb3B0aW9ucy5yZWFkeSwge1xyXG4gICAgICAgICAgICBvbmNlOiB0cnVlXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfUkVBRFkpO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIGtleTogXCJ1bmJ1aWxkXCIsXHJcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJ1aWxkKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5yZWFkeSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudW5iaW5kKCk7XHJcbiAgICAgICAgdGhpcy5yZXNldFByZXZpZXcoKTtcclxuICAgICAgICB0aGlzLmNyb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNyb3BwZXIpO1xyXG4gICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfSElEREVOKTtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICBrZXk6IFwidW5jcmVhdGVcIixcclxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuY3JlYXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWR5KSB7XHJcbiAgICAgICAgICB0aGlzLnVuYnVpbGQoKTtcclxuICAgICAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcclxuICAgICAgICAgIHRoaXMuY3JvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaXppbmcpIHtcclxuICAgICAgICAgIHRoaXMuc2l6aW5nSW1hZ2Uub25sb2FkID0gbnVsbDtcclxuICAgICAgICAgIHRoaXMuc2l6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICB0aGlzLnNpemVkID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlbG9hZGluZykge1xyXG4gICAgICAgICAgdGhpcy54aHIub25hYm9ydCA9IG51bGw7XHJcbiAgICAgICAgICB0aGlzLnhoci5hYm9ydCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbWFnZSkge1xyXG4gICAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBHZXQgdGhlIG5vIGNvbmZsaWN0IGNyb3BwZXIgY2xhc3MuXHJcbiAgICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSBUaGUgY3JvcHBlciBjbGFzcy5cclxuICAgICAgICovXHJcblxyXG4gICAgfV0sIFt7XHJcbiAgICAgIGtleTogXCJub0NvbmZsaWN0XCIsXHJcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xyXG4gICAgICAgIHdpbmRvdy5Dcm9wcGVyID0gQW5vdGhlckNyb3BwZXI7XHJcbiAgICAgICAgcmV0dXJuIENyb3BwZXI7XHJcbiAgICAgIH1cclxuICAgICAgLyoqXHJcbiAgICAgICAqIENoYW5nZSB0aGUgZGVmYXVsdCBvcHRpb25zLlxyXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBuZXcgZGVmYXVsdCBvcHRpb25zLlxyXG4gICAgICAgKi9cclxuXHJcbiAgICB9LCB7XHJcbiAgICAgIGtleTogXCJzZXREZWZhdWx0c1wiLFxyXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGVmYXVsdHMob3B0aW9ucykge1xyXG4gICAgICAgIGFzc2lnbihERUZBVUxUUywgaXNQbGFpbk9iamVjdChvcHRpb25zKSAmJiBvcHRpb25zKTtcclxuICAgICAgfVxyXG4gICAgfV0pO1xyXG5cclxuICAgIHJldHVybiBDcm9wcGVyO1xyXG4gIH0oKTtcclxuXHJcbiAgYXNzaWduKENyb3BwZXIucHJvdG90eXBlLCByZW5kZXIsIHByZXZpZXcsIGV2ZW50cywgaGFuZGxlcnMsIGNoYW5nZSwgbWV0aG9kcyk7XHJcblxyXG4gIHJldHVybiBDcm9wcGVyO1xyXG5cclxufSkpKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/cropperjs/dist/cropper.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/core/plugins/custom/cropper/cropper.js");
/******/ 	
/******/ })()
;